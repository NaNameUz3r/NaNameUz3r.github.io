I"7<p>Врубаемся в Декларативную модель — Часть 6. 
<!--more--></p>

<h2 id="data-driven">Data-driven</h2>

<p>Часто на практике нужно выполнить какую то операцию над достаточно большой структурой данных, например провести итеративные вычисления, или обойти одну структуру и вычислить другую, на основе “собранных” в обходе данных.</p>

<p>Как правило, чаще всего такие вычисления проводятся над списками, массивами и деревьями. К спискам применяются операции свертки (FoldL\R), которые мы рассмотрели в прошлом посте. Но существуют и другие популярные техники.</p>

<h3 id="операция-map">Операция Map</h3>

<p>Реализация Map есть почти во всех стандартных библиотеках популярных языков программирования. Эта операция работает со списком, и вычисляет на его основании список такой же длинны, применяя переданную в Map функцию к каждому элементу исходного списка.</p>

<p>С помощью <del>заклинаний</del> программирования высшего порядка, реализовать Map можно как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def function Map(some_list, some_func)

    def function iterate_map(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list
  

        list_head = list_remaining[0]
        list_tail = list_remaining[1:] 
        return iterate_map(new_list.insert(0, some_func(list_head)), list_tail, some_func)
  

    return iterate_map([], some_list, some_func)
</code></pre></div></div>

<p>Можем передать в Map простую функцию, типа возведения в квадрат, и передать её вторым аргументов. Напоминаю что здесь, раньше и далее сниппеты описаны в “псевдопайтанокоде”. Заварите чай, прочитайте прошлые пару статей, если сходу ничего не понятно, и реализуйте рабочий вариант на своем любимом ЯП :)</p>

<h3 id="операция-filter">Операция Filter</h3>

<p>Filter это ещё одна классическая операция для обработки списков. Она так же принимает вторым аргументом некоторую функцию-предикат, и на выходе отдает список с элементами исходного списка, удовлетворяющими переданный предикат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def function Filter(some_list, some_func)

    def function iterate_filter(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list

        list_head = list_remaining[0]
        list_tail = list_remaining[1:]

        if some_func(list_head):
            return iterate_filter(new_list.insert(0, list_head), list_tail, some_func)
        else:
            return iterate_filter(new_list, list_tail, some_func)
     
   

    return iterate_filter([], some_list, some_func)
</code></pre></div></div>

<p>Снова взываю к вашей фантазии, напрягите волшебный интеллект! Предикат можно придумать, практически любой. Например, если список состоит из целых чисел, можем написать простую функцию которая возвращает true если результата делится на 2 без остатка (четный). Или вообще воткнуть предикат в вызов iterate_filter лямбдой. Если вы прожженый питонист, то я уверен что вы хотя бы раз втыкали лямбды в map или filter!!! :trollface:</p>

<h2 id="абстрактные-типы-данных">Абстрактные типы данных</h2>

<p>Абстрактный тип данных — это описание некоторой структуры данных посредством определения операций над этой структурой. И только! Только операций!
Внутренняя реализация, все атрибуты <em>полностью скрыты</em> в АТД, или лучше сказать — <strong>эта реализация вообще отсутствует</strong>.</p>

<p>В декларативной парадигме АТД, в первую очередь тип данных — множество значений, с которым связано множество <em>допустимых</em> над ними операций. Базовы набор декларативных типов перечислялся в одном <a href="/2022/02/06/hack_in_declarative_model.html">первом посте</a> из этого цикла.</p>

<p>Мало типов, скажете вы! Да, хотелось бы определять свои. АТД в нашем распоряжении.</p>

<p>И ещё раз, что такое <em>абстрактный</em> тип данных? Это такой тип, который конкретно определен <em>множеством операций</em> над собой, и при этом <strong>полностью</strong> независим от своей реализации. Мы можем всегда быстро и легко поменять эту реализацию не трогая сам абстрактный тип.</p>

<h3 id="защищаем-атд">Защищаем АТД</h3>

<p>Есть такое чувство, что легкая сменяемость чего либо в программировании может привести к проблемам. Чаще всего так и происходит. В разрезе АТД не всегда будет разумным делать реализацию типа для всех. Во-первых, программа с такой открытой реализаций, то есть <em>открытая программа</em> потенциально становится легкой мишенью для злоумышленников.</p>

<p>Под “открытой программой” тут мы понимаем не open source софт, речь вообще не об этом. Представьте программу которая запущена в прод, в ней крутится много данных, в том числе персональных данных клиентов, и в этой программе сама реализация абстрактных типов открыта, и например непосредственно доступна для взаимодействия другим программам через API.</p>

:ET