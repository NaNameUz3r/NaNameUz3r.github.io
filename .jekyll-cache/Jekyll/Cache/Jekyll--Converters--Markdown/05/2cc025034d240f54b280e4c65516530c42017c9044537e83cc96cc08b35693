I":(<p>Заметка о первом знакомстве.
<!--more--></p>

<h2 id="зачем-я-начал-учить-go">Зачем я начал учить Go</h2>

<p>Совсем недавно я начал знакомиться с базовым синтаксисом и особенностями языка программирования Go. До этого всё моё изучение программирования проходило в рамках Python, он же и был основным инструментом в написании мелких скриптов. Работу программистом я так и не нашел, но вполне реактивно перешел в DevOps из DBA осенью прошлого года. Мне очень нравится текущая работа, как позиция, так и конкретно компания, но кодить нравится — хоть убейте! Поэтому недолго поразмыслив я решил учить Go, и вот почему.</p>

<p>Начнем с того что  Go достаточно молодой язык, который разработан в Google и появился в открытом доступе в 2009, не то чтобы это плюс, просто привожу факт. На данный момент Go действительно <strong>широко</strong> используется в DevOps. Docker, Kubernetes, Prometheus, Grafana и многие другие инструменты написаны на Go. Изучение Go открывает мне потенциальные возможности разрабатывать свои инструменты, может даже принять участие в open source (хочется верить).</p>

<p>Кроме того что Go хорошо подружился с DevOps-чертовщиной, я давно поглядываю в сторону Си, и вообще си-подобных языков, строгой типизации и вот этого всего. Слышал что Go называют “Си на стероидах”, но мне почему-то это кажется не совсем корректным, по крайней мере на данный момент. Мне рано судить о плюсах и минусах Go, потому что я только начинаю свое знакомство, в частности прошел официальный <a href="https://go.dev/tour/list">тур по Go</a>, по мере свободного времени читаю документацию, и начинаю смотреть курс на coursera.</p>

<p>Ничего феноменально сложного я пока не заметил, но в разделах о поинтерах и интерфейсах пришлось напрячь мозги. Скажу честно, интерфейсы в Go, по крайней мере как они описываются в туториале, не до конца остались понятными. Хотя саму концепцию интерфейсов я вроде бы понимаю. Вероятно мои затруднения вызваны в целом малым опытом разработки, а может и тем что в Go интерфейсы в структурах данных реализуются <em>имплицитно</em> то есть <em>неявно</em>. И хотя это заявляется как сильная сторона Go, меня пока терзают смутные сомнения. Обязательно отпишусь на эту тему, как только наберусь достаточно опыта в разработке на Go и его понимания.</p>

<p>Кроме “Сишности” в Go мне нравится его простота. Это достаточно компактный язык, при этом из коробки есть практически всё что нужно. В Go <strong>нет</strong> ООП, ну точнее оно <em>как бы есть</em>, объясняю. Объектно ориентированная парадигма в некотором виде применяется в Go, но достаточно слабо. В Go можно создавать абстрактные структуры данных, вроде классов, но классом это тут не называется, это просто <em>struct</em>. Мы можем описывать интерфейсы и методы связанные с этими структурами, но в Go <strong>нет наследования</strong> (и это хорошо, потому что повторяющийся код это потенциальный источник ошибок), нет конструкторов, и нет дженериков! То есть на Go не пишут фабрики и вот это всё, код остается простым. Учитывая этот факт и достаточно выразительный синтаксис, даже не смотря на местами ужасающую неясность и корявость кода (отвратительный нейминг, например), который сообщество разработчиков Go по какой то причине не стесняется повсеместно пушить — код остается воспринимаемым. Не знаю насколько корректно оправдывать халатность комьюнити по отношению к ясности разрабатываемого кода молодостью языка, но мне эта “фишка” не нравится. Ну да ладно, главное им не подражать :) Возможно со временем Go обзаведется какими то общепринятыми правилами стилистики кода, вроде PEP8 у Python.</p>

<p>Go компилируемый язык, и говорят что компилируется он быстро! Можно поспорить на тему и сказать, что это не является особым преимуществом для доставки приложения, так как широко распространились контейнеры в которых вам и интерпретатор, и библиотеки воткнуть можно, но компилируемость позволяет не только избавиться от сторонних библиотек в составе образа (копируем бинарь и всё!), а так же и снизить его (образа\контейнера) итоговый размер — пишут, что в последних версиях Go хорошо оптимизировали размер итогового бинаря.</p>

<p>Вообще Go это достаточно амбициозная попытка взять самое лучшее у популярных языков программирования (сильные стороны применения некоторых парадигм программирования) например Java и C++, и сделать Go способным выражать то же самое, но “более простым языком”.</p>

<p>Go уверенно набирает популярность, но имхо, пока рано судить о том что ждет язык в будущем. Сообщество разработчиков очень консервативно и долго рассматривает запросы и предложения, многие из которых просто оставляя без внимания. Например погуглите как долго в Go требовали и пропихивали дженерик типы. (спойлер — их всё ещё нет, но <em>может быть</em> будут в 1.18beta).</p>

<p>Мне нравится этот микс в Go: с одной стороны есть строгая типизация, компилятор, с другой — сборщик мусора и синтаксический сахар для объявления переменных, который сам определит тип (работает только внутри функций, или вернее — <em>вложенных блоков кода</em>). Имхо, типы всё таки стоит определять явно. А ещё: поинтеры и очень крутая и простая реализация параллельного программирования — горутины и каналы. Думаю что это это темы для отдельного, более подробного поста :)</p>

<p>Я не призываю вас бежать и учить Go, но призываю учить программирование! Конкретно в моем случае Go несомненно принесет лишь пользу после долгой дружбы с Python, карьерные возможности и в целом в развитии как специалиста. И как я уже говорил на счет Си, наконец то я дорвался до Си-подобного языка! Рано или поздно я обязательно доберусь до низкоуровневого программирования и поковыряюсь в ядрышках. Если вы спросите зачем мне это нужно, то отвечу цитируя Джеффа Дантеманна из “Assembly Language Step–by–Step” — <em>because I want to know how it works</em>!</p>

<p>Увидимся в следующих постах про Go, которые наверняка ещё будут.</p>

:ET