I"@<p>Наполовину вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью.</p>

<!--more-->
<p>Оригинал статьи можете прочитать в его личном блоге по <a href="https://malisper.me/an-algorithm-for-passing-programming-interviews/">этой ссылке.</a></p>

<hr />

<p>За последние несколько лет я проходи интервью в дюжине (или около того) компаний и решил ~50 уникальных алгоритимических задач.
Мне часто давали обратную связь, в которой говорилось, что я отлично справился с предлагаемыми алгоритимическими задачами.
В этом посте я собираюсь поделиться тем, как именно я подхожу к решению этих задач.</p>

<h2 id="мыслительный-процесс">Мыслительный процесс</h2>

<p>Основной принцип, который я использую, заключается в том что каждая задача, предлагаемая к решению на собеседовании, <em>может быть решена</em>.
На интервью вас не станут просить доказать Великую теорему Ферма. Если вам дадут какую-то неразрешимую задачу, похоже что у вас не будет особых шансов её решить.</p>

<p>По моему опыту, примерно в 80% случаев алгоритмические задачи сводятся к фундаментальным структурам данных и алгоритмам. Структуры данных, которые я встречаю чаще всего:</p>
<ul>
  <li>Хэш-таблицы</li>
  <li>Связанные списки</li>
  <li>Двоичное дерево поиска</li>
</ul>

<p>Что касаемо алгоритмов:</p>
<ul>
  <li>Поиск в глубину</li>
  <li>Бинарный поиск</li>
  <li>Алгоритмы сортировки</li>
</ul>

<p>(Скорее всего от вас не будут требовать реализовать бинарный поиск или алгоритм сортировки, но вы <em>должны знать</em>, что они существуют.)</p>

<p>Кроме того, есть две дополнительные техники программирования, с которыми вы должны быть знакомы:</p>
<ul>
  <li>Динамическое программирование</li>
  <li>Рекурсия</li>
</ul>

<h2 id="алгоритм-решения">Алгоритм решения</h2>

<p>Алгоритм решения задачи выглядит так:</p>
<ol>
  <li>Как только вы получили алгоритмическую задачу, уточните в какой среде выполнения (условия) должно работать ваше решение. Скорее всего интервьвер ответит на этот вопрос.</li>
  <li>Вычеркните из списка возможных структуры данных и алгоритмы которые очевидно не имеют отношения к рассматриваемой задаче. Это избавит вас от большей части списка, и вы, как правило, останетесь с 2-3 структурами данных и алгоритмами.
    <ul>
      <li>Вы можете не рассматривать слишком медленные структуры данных. Если вам необходимо решить задачу за O(1), то невомозможно использовать бинарное дерево в своем решении, так как бинарное дерево всегда будет выполнять не менее, чем за O(log n) времени.</li>
      <li>Так же вы можете избавиться от алгоритмов, если их невозможно применить в задаче. Например, если в задаче нет графа, вы знаете, что поиск в глубину вам точно не подойдет.</li>
    </ul>
  </li>
  <li>Рассмотрите варианты использования оставшихся структур данных. Какие из них имеют отношения к поставленной задаче? Решением станет подходящая комбинация, вам остается её только собрать воедино.</li>
</ol>

<p>Давайте рассмотрим среды выполнения, основные структуры данных и алгоритмы. Затем мы разберем несколько примеров, чтобы убедиться насколько прост данных подход.</p>

<h3 id="среды-выполнения-и-варианты"><em>Среды выполнения и варианты</em></h3>

<h4 id="хэш-таблицы-за-o1-вставка-поиск-и-удаление">Хэш-таблицы за O(1) вставка, поиск и удаление</h4>
:ET