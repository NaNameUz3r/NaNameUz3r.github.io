I"J<p>Врубаемся в Декларативную модель — Часть 5. 
<!--more--></p>

<h2 id="колдуем-по-взрослому">Колдуем по взрослому</h2>

<p>Программирование высшего порядка. Что может прийти на ум сперва, если не быть знакомым с темой и термином? Ну, например:</p>

<p style="text-align: center;"><img src="/images/high_order.jpg" alt="Рекурсия" /></p>
<p><em><center>Архи-кодер владеющий программированием высшего порядка</center></em></p>

<p>А теперь серьезно. Программирование высшего порядка, это методы программирования с использованием процедур (функций) высшего порядка (или “первого” класса). Ага! А что это за порядок такой, если речь не про сакрально-волшебные сверхсилы CS просветления?</p>

<p>Сперва нужно рассмотреть такую штуку, как <em>лексическое замыкание</em>.</p>

<p>Собственно, замыкание — это такая функция, в которой есть ссылки на объекты (например переменные), объявленные вне тела этой функции. В коде это выглядит как объявление функции в другой функции. Вот эта последняя, “внутренняя” функция, фактически имеет доступ ко внешним, по отношению к ней объектам — переменным объявленным в теле “функции-обертки”, её аргументам.</p>

<p><strong>Бугурт алерт!</strong> Здесь и далее примеры на пайтонопсевдокоде! Помните, что мы сейчас изучаем Декларативную модель, <em>т е о р и ю</em>, а не прикладную практику. Это всё техники, реализация которых на одном языке будет выглядеть так, на другом иначе.</p>

<p>Пример:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># "замыкающая", внешняя функция
def mad_printer(some_new_law):

    # вложенная функция
    def actual_printer():
        print(some_new_law)

    return actual_printer

emergency_law = mad_printer("freedom is slavery")
emergency_law()
</code></pre></div></div>

<p>На выходе будет получена строка, переданная в замыкающую функцию - “freedom is slavery”.</p>

<p>Хотя функция actual_printer и не имеет в своем теле переменной some_new_law, мы видим что такой код работает без проблем. Можно сказать, что в примере выше мы привязываем определенное замыкание к переменной emergency_law. И это замыкание включает в себя <em>возвращаемую функцию actual_printer и доступное ей окружение</em>.</p>

<p class="info">Замыкание — это некоторая форма <em>записи</em> которая хранит в себе <em>функцию первого порядка</em> вместе с её окружением.</p>

<p>Ладно, ладно. А что такое функция первого порядка, не только в декларативной модели, а в программировании вообще?</p>

<p>Можно сказать, что система (язык программирования) имеет функции первого <em>класса</em>, если функции рассматриваются как <em>объекты первого класса</em>. Объект первого класса — это “элементы”, а по сути типы, которые могут передаваться как параметры, возвращаться их функций или присваиваться как значение переменным.</p>

<p>Иными словами, функция первого класса означает, что есть такой тип как функция, и любая реально объявляемая функция автоматически становится значением соответствующего типа.</p>

<p>Сам термин <em>высшего порядка</em> исходит от концепции <em>порядка процедуры</em>. Если у какой то процедуры в аргументах нет других процедур — это функция нулевого порядка. Процедура, у которой есть хотя бы один аргумент-процедура — процедура первого порядка. Порядок процедуры можно определить как n + 1, если у этой процедуры есть хотя бы один аргумент n порядка, и нет других аргументов <em>более высокого порядка</em>.</p>

<p>Получатся что функция может быть функцией первого класса, так как в системе есть вышеупомянутые критерии, но может не быть функцией первого порядка, если не имеет в аргументах других функций. В таком случае это, можно сказать, функция первого класса нулевого порядка :)</p>

<p>Короче говоря, программирование высшего порядка, по сути, это о том что процедуры могут быть любого порядка. Никакой магии, но надеюсь вы уже начали понимать, что потенциал у этой техники очень большой.</p>

<h2 id="основные-заклинания">Основные заклинания</h2>

<p>В основе всех программистских техник высшего порядка лежат следующие четыре операции:</p>

<ol>
  <li>Процедурная абстракция;</li>
  <li>Обобщение;</li>
  <li>Инстанцирование;</li>
  <li>Встраивание.</li>
</ol>

<h3 id="процедурная-абстракция">Процедурная абстракция</h3>

<p>На самом деле мы уже давно говорили о процедурных абстракциях. Настала пора четко декларировать термин.</p>

<p>Процедурная абстракция — это, по существу, определение процедуры. Мы оборачиваем программные инструкции в процедуру, внутрь заголовка процедуры, и в результате получаем блок кода (процедурное значение — замыкание), который не выполняется до тех пор, пока не будет вызван.</p>

<p>Вызов процедуры приводит к тому же результату, к которому приведет выполнение инструкций из её тела.</p>

<p>У процедурных абстракций существуют параметры, которые влияют на выполнение тела процедуры.</p>

<p>Фактически это основа основ парадигмы программирования высшего порядка, поддерживается во многих языках, а так же лежит в основе ООП.</p>

<p class="info">Процедурные абстракции позволяют представить любую программную логику как значение процедуры.</p>

<h3 id="обобщение">Обобщение</h3>

<p>Обобщить функцию — обозначает, что любая операция или значение может становиться <em>аргументом в теле функции</em>. Мы абстрагируем эту сущность от тела функции, а её (сущности) значение задается когда функция явно вызывается. Каждый раз, при вызове обобщенной функции, может задаваться другая сущность.</p>

<p>Вернемся назад к итеративным вычислениям, и разберем обобщение на примере функции, суммирующей значения элементов списка. Например, мы можем написать такую декларативную функцию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def function summary_list_values(some_list)
    if some_list == []:
        return 0
    end

    list_head = some_list[0]
    list_tail = some_list[1:]
    return list_head + summary_list_values(list_tail)
end
</code></pre></div></div>

<p>Тут есть два нейтральных элемента: 0, который мы возвращаем если some_list опустел, и операция сложения. Эти нейтральные элементы можно обобщить, сделав более универсальную функцию. Например, из примера выше можно сделать функцию FoldR. Такая функция есть во многих функциональных языках, это <em>функция-свертка</em>, схема рекурсивных вызовов которой раскручивается в цепочку, пока не будет достигнуто самое право, по сути последнее в списке, значение, после чего начнутся сами вычисления. Есть ещё FoldL, в которой вычисления начинаются СРАЗУ, то есть с “левой ассоциацией”, считаем сразу и не ждем “правого конца”.</p>

<p>Обобщим функцию, которую написали ранее следующим образом:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def FoldR(some_list, some_function, some_element)
    if some_list == []:
        return some_element
    end

    list_head = some_list[0]
    list_tail = some_list[1:]
    return some_function(list_head, FoldR(list_tail, some_function, some_element))
end
</code></pre></div></div>

<p>Обобщенная функция может получать на вход не только список, а функцию, которой будут обрабатываться вычисления среди элементов, и нейтральный элемент some_element. Эту функцию можно использовать для любых похожих ассоциативных вычислений, когда порядок аргументов some_function не важен для результата.</p>

<h3 id="инстанцирование">Инстанцирование</h3>

<p>О, это очень классная штука! Инстанцирование обозначает возможность возвращать процедуру\функцию как результата вызова другой процедуры\функции. 
Инстанцирование реализуется с помощью <em>фабрик</em> или <em>генераторов функций</em>.</p>

<p>Очень простой и грубый пример:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># генератор
def factory_function(calc_function):
    def inner_function(x,y):
        return calc_function(x,y)
    return inner_function

# какая то функция с вычислениями, которую скормим генератору
def addition(a,b):
    return a+b

# генерируем функцию
f = factory_function(addition)

# вернет 2
print(f(1, 1))
</code></pre></div></div>

<p>Очевидно что вычисления и логика внутри генератора может быть намного сложнее. Что нам это вообще дает? В первую очередь, это дает гибкость реализации каких то частей программы, которые если нужно мы можем менять на лету без особых проблем.</p>

<p>Например, у нас может быть универсальная функция-фабрика для сортировки списков. Мы можем передавать в неё конкретный алгоритм сортировки, получая на выходе функцию, реализующую этот алгоритм.</p>

<h3 id="встраивание">Встраивание</h3>

<p>Примером реализации техники встраивания являются <em>ленивые</em> вычисления. Это такие вычисления, когда вместо того, чтобы вычислять сразу всё (жадно), генерируется лишь необходимый “кусок” данных. Иными словами, техника встраивания заключается в постепенном выстраивании структуры данных, по мере запросов к элементам этой структуры. Реализуется это, собственно “встраиванием” в структуру данных некоторого кода, который генерирует соответствующие структуре и запросу данные.</p>

<h2 id="абстракция-цикла">Абстракция цикла</h2>

<p>Ранее мы разбирали рекурсии и итеративные вычисления. Грубо говоря, итеративные вычисления это и есть циклы. Но в декларативной модели описание таких вычислений выходит громоздким, так как требуются явные рекурсивные вызовы. Мы уже разобрали процедурную абстракцию и обобщение. Так почему бы не сделать циклы более лаконичными, выразительными?</p>

<p>Например, классический цикл for — это целочисленный цикл, который получает на вход четыре параметра: начальное значение, конечное значение, шак, и процедуру для вычислений в каждой итерации:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def my_for(start_value, end_value, step, procedure):

    if start_value &gt; end_value:
        return

    procedure(start_value)

    my_for(start_value + step, end_value, step, procedure)   
</code></pre></div></div>

<p>Цикл, для вычислений по элементам списка, можно выразить так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def for_list_elements(some_list, procedure):
    if some_list == []:
        return

    list_head = some_list[0]
    list_tail = some_list[1:]

    procedure(list_head)
    for_list_elements(list_tail, procedure)
</code></pre></div></div>

<p>Это всё хорошо. Но что если нам нужно сделать какие-то более прикладные вычисления, а не просто вывести данные, или применить процедуру к каждому элементу? Ну например, хотя бы снова суммировать все элементы списка, или перемножить? Помните <em>аккумуляторы</em> из <a href="/2022/02/20/hack_in_declarative_model_3.html">Части 3</a>?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def my_for_acc(start_value, end_value, step, procedure, accumulator):
    if start_value &gt; end_value:
        return accumulator

    accumulator = procedure(accumulator, start_value)
    my_for_acc(start_value + step, end_value, step, procedure, accumulator)   
</code></pre></div></div>

<p>Передадим туда, процедурой, например такой “сумматор”:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def my_sum(x,y):
    return x + y
</code></pre></div></div>

<p>И вызовем как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print(my_for_acc(1, 10, 1, my_sum, 0))
</code></pre></div></div>

<p>Обработка списков с аккумулятором может выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def for_list_elements_acc(some_list, procedure, accumulator)
    if some_list == []:
        return accumulator

    list_head = some_list[0]
    list_tail = some_list[1:]
    accumulator = procedure(accumulator, list_head)

    for_list_elements_acc(list_tail, procedure, accumulator)


def my_sum(x,y)
    return x + y


print(for_list_elements_acc([3,2,1], my_sum, 0))
</code></pre></div></div>

<p>Это будет работать как функция FoldL, о которой упоминалось ранее.</p>
:ET