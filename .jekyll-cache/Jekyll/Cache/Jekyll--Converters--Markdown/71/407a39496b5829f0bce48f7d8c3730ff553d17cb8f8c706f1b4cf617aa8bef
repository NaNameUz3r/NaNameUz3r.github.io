I"F#<p>Часть 3. Список списков, итеративные вычисления и прочие муми-тролли. 
<!--more--></p>

<h3 id="here-we-go-again">Here we go again</h3>
<p>В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.</p>

<p>Рекурсия как программистский трюк не ограничивается “самовызовом” (прочитали как самовывоз, признайтесь?) функций — <em>рекурсивными могут быть и типы данных</em>. Базовый пример рекурсивного типа данных — список.</p>

<p>Почему список на самом деле рекурсивная структура? Потому что он определяется <em>в терминах более короткой версии себя самого</em>.</p>

<p>Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и <em>“список”</em>, а лучше сказать набор или “последовательность” пар “ключ-значение”.</p>

<p>Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список.</p>

<p>Как правило этими “произвольными” значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка “впихнуть” в эти “кусочки” какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда).</p>

<p>Части списка связанны некоторым образом с другими, и всё вместе (“элементарный кусок данных” и связь-указатель на другой) называется <em>узел</em>.</p>

<p>В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.</p>

<p>Вернемся к фундаментальным материям :)</p>

<p>В декларативной модели список определяется <em>рекурсивно</em>. Считается, что либо список пустой (nil или, если хотите, None), либо <em>есть какое-то значение связанное со списком</em>.</p>

<p>Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, “узел” содержащий строку “shrek”, то тогда список X будет равен “shrek” <em>связанный со списком nil</em>!</p>

<p>Короче говоря, “последний” элемент в списке всегда будет “указывать” на “пустой список”.</p>

<p>Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.</p>

<p>В рекурсивных функциях, работающих со списками, <em>базовым случаем</em> будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов <em>более мелких списков</em>.</p>

<p>Например, “декларативная” рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list_length(list):
    if list == []
        return 0
    
    list_head = list[0]
    list_tail = list[1:]

    return 1 + list_length(list_tail)
</code></pre></div></div>

<p>Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — “Ух ты ж сколько можно то намутить с этим списком!”</p>

<p style="text-align: center;"><img src="/images/hold_on.gif" alt="Подождите!" /></p>

<p>Это всё ещё рекурсивная функция, мы в прошлый уже говорили про проблему с переполнением стека. Кроме того, рекурсивные функции со списками, при их необдуманном определении, вполне могут оказываться крайней не эффективными — O(n*n) или ещё хуже.</p>

<p>Для решения этих проблем есть техника, при которой рекурсивные функции превращаются в функции с <em>итеративной формой вычисления</em> с <strong>линейной</strong> эффективностью!</p>

<h3 id="итерируй-то">Итерируй то</h3>

<p>Ранее мы говорили про итеративные вычисления как о частном случае рекурсии. Разберемся чуть глубже.</p>

<p>Во-первых стек. Почему он вообще формируется при рекурсивном вызове? Обратите внимание на пример функции вычисления длинны списка, а именно на хвостовой return в конце. Раз за разом при рекурсивном вызове окружение экземпляра функции должно сохраняться в стеке, потому что прибавление единицы происходит <strong>после</strong> этого заключительного return.</p>

<p>В нашем примере это всё происходит лишь для того, чтобы потом в обратном порядке “размотать” стек и просуммировать единцы. Кажется избыточным.</p>

<p>Чем отличается итеративное вычисление от обычной рекурсии?</p>

<p>Схема итеративных вычислений — это <em>последовательность <strong>трансформации состояний</strong></em>. Как это работает?</p>

<p>Ну, по сути, мы добавляем некоторый счетчик в аргумент рекурсивной функции, и делаем так чтобы увеличение этого счетчика <em>происходило <strong>до</strong> рекурсивного вызова</em>.</p>

<p>Рекурсивная-итеративная функция вычисления длины списка будет выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iter_list_length(i, list):
    if list == []:
        return 0
    
    return iter_list_length(i+1, list[1:])
</code></pre></div></div>

<p>Обратите ещё раз внимание на счетчик <em>i</em>. Мы увеличиваем его в аргументах рекурсивного вызова, <strong>до</strong> самого вызова. Благодаря этому мы “замыкаем” окружение функции и состояние каждого экземпляра не требуется сохранять в отдельных записях в стеке.</p>

:ET