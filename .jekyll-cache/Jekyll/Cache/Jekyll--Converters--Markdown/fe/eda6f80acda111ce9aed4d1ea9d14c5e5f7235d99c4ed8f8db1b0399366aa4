I"F<p>Рассматриваем пару универсальных принципов разработки.
<!--more--></p>

<h3 id="лучше-сухо-чем-мокро">Лучше сухо, чем мокро!</h3>

<p>Аббревиатура принципа DRY расшифровывается как Don’t repeat yourself, что недвусмысленно переводится как “Не повторяйся”. Само сокращение является словом dry — сухой, и нарушение принципа окрестили как WET (мокрый) — Write everything twice (Пиши всё дважды) или We enjoy typing (Нам нравится печатать).</p>

<p>Разумеется уровень влажности тут вообще не при чем :)</p>

<p>Вероятно что вы уже встречали упоминание принципа DRY. Его часто упоминают в бесплатных и платных уроках программирования, но как правило речь идет только в контексте написания кода (programming-in-small).</p>

<p>На самом деле этому универсальному принципу можно, и обязательно нужно, следовать на всех уровнях проектирования системы.</p>

<h2 id="я-никогда-не-повторяюсь">Я никогда не повторяюсь</h2>
<h3 id="неповторимость-внутренностей">“Неповторимость внутренностей”</h3>

<p>Как я уже сказал, чаще всего DRY преподносят как правило, при котором мы не должны повторно использовать (копировать) код, в разных частях программы. Это лишь малая доля. В сущности DRY относится к любой сущности в системе, на любом уровне абстракции.</p>

<p>Если что-то где то определено, оно должно быть определено только в этом месте.</p>

<p>А что касаемо кода, то бывают случаи когда дублирование кода <em>оправдано</em>. Например в случае, когда есть две высокоуровневые функции-метода, которые производят <em>похожие</em> вычисления, но в разном контексте и служат разным целям (всякие проверки истинности разных данных, etc).</p>

<h3 id="неповторимость-представления">Неповторимость представления</h3>

<p>Что касаемо проектирования (programming-in-large), то DRY тут работает аналогично. Во-первых, если есть какой-то конкретный модуль, то его спецификация должна быть единообразной и находиться в одном месте.</p>

<p>Это значит, что нельзя просто копировать модуль, немного его изменять, и встраивать в систему. Тогда в будущем при доработке, в случае изменений одного такого “модуля-клона”, нам придется менять то же самое и во втором. А если копий три, четыре…? Вы точно думаете что сможете вспомнить о них всех, я не говорю уже о совершенно очевидном неудобстве такой архитектуры. Это полный зашквар, не надо так делать.</p>

<p>Во-вторых, программные интерфейсы модулей (api) тоже должны быть единообразными, следовать спецификации. Представьте что “внутри” модули используют по разному описанные вызовы. Внешние вызовы тоже накостыляли по другому. Чувствуете аромат? Так пахнет горячая точка опоры, когда система рухнет из за того что мы поменяли один интерфейс, или забыли поменять один из них.</p>

<p>Во избежание этого, можно использовать OpenAPI, или что-то в таком духе. Если мы разрабатываем собственный API, он должен быть корректно задокументирован и доступен <strong>в одном месте</strong> (например выложен на гитхаб).</p>

<h2 id="что-и-тут-тоже">Что, и тут тоже?</h2>

<p>Мы плавно подошли к документации. Многие разработчики не любят документировать проекты, и это <strong>плохо</strong>. А если и ведут документацию то относятся к этому очень халатно. Ctrl-c, Ctrl-v. Тяп ляп.</p>

<p><em>Документация тоже должна следовать принципу DRY</em>.</p>

<p>На уровне комментариев кода (это ведь тоже документация), пример WET-поведения — зачем-то описывать подробными комментариями чуть ли не каждую функцию в коде. Ясный код должен говорить сам за себя и быть понятен читающему программисту (например вам самим, через неделю), так зачем повторяться, разве что код выглядит запутанным и совершенно непонятным?  Если так, то это нужно исправлять в первую очередь.</p>

<p>На уровне документирования проекта — мы должны структурировать документы понятно, излагать информацию последовательно и, простите за тавтологию — <em>информативно</em>. Документация это не удобный случай поупражнять в графомании.</p>

<p>На самом деле писать код и писать текст по сути одно и то же, разве нет?</p>

<p>Вы можете подойти к проблеме написания документации почти так же, как к программе. Ну вот она ваша до боли скучная цель. Декомпозируйте её! Если вы хорошо понимаете документированный проект то это не вызовет проблем. Каждый модуль, согласно DRY, описывается в одном разделе документации, API в другом, etc.</p>

:ET