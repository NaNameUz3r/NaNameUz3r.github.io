I"h6<p>Врубаемся в Декларативную модель — Часть 4. 
<!--more--></p>

<p>Здравствуйте! На самом деле декларативная модель сама по себе — Джедайская техника, а именно итеративная “рекурсия”. В этом посте мы скорее разберем области применения.</p>

<h3 id="списки-различий">Списки различий</h3>

<p>Кроме списков существуют другие рекурсивные типы данных, например — Списки различий. На самом деле это особый тип данных, который состоит из <em>двух списков</em>. Эти списки связаны друг с другом таким способом, что <em>второй</em> список может быть получен из <em>первого</em>, если из этого первого списка удалить некоторое число элементов (в том числе нулевое, то есть эти списки могут быть по сути “равны”).</p>

<p>Фактически, списки различий, являются <em>одним из</em> типов данных, которые классифицируются как <strong>структуры различий</strong>. Суть таких типов мы уже разобрали — это пары значений, одно из которых “встроенно” в другое.</p>

<p>Структура различий <em>A</em>, которая, например, состоит из <em>B</em> и <em>С</em>, отражает значение равное <em>B минус C</em>.</p>

<p>В данном случае мы разбираем списки различий, потому что у них есть интересная особенность:
<em>Хвост списков различий может быть <strong>не определен</strong></em>.</p>

<p>Мы можем это легко представить. Как вы помните, список — рекурсивен, и условно всегда состоит из “Головы” и “Оставшейся части”. В списках различий, если мы итеративно добираемся до “хвоста”, то “оставшаяся часть” является не пустым списком, а <em>неопределенной декларативной переменной</em> (она “есть” но ещё не связанна со значением. См. предыдущие посты), и в первом, и во втором списке различий.</p>

<p>Что нам это дает? Самое главное преимущество, это то, что мы можем сложить оба списка за константное время O(1), вообще не зависимо от длинны списков. Это делается очень просто — неопределенную переменную в конце первого списка <em>инициализируем</em> ссылкой на второй список. Вуаля.</p>

<p>Цена такого трюка велика — мы можем провернуть это сложение списков только один раз, так как первый список просто перестает существовать.</p>

<h3 id="в-очередь">В очередь!</h3>

<p>В классической императивной модели очередь — это интуитивно понятная структура данных, которая работает на базе списка по принципу “первый вошел — первый вышел” (FIFO). У очереди есть только две операции (метода) без каких либо аргументов: добавить элемент в хвост очереди, удалить элемент из головы.</p>

<p>Прямо как в супермаркете.</p>

<p>В императивной модели очередь легко реализуется на основании другой структуры — <em>двусвязного списка</em>. Это такой список, в котором элементы связываются указателями не только со следующими за ними элементами, но и с “оставшимися” позади. Благодаря этой двусвязности, методы очереди в императивной модели работают за О(1).</p>

<p>А что в декларативной модели? Как вы помните, в декларативной модели нет указателей и нет “классических” переменных. Ну, используя “декларативный” список мы можем добавлять новые элементы в голову за О(1), но удалять из хвоста придется за линейное время О(n), так как каждый раз для этого придется рекурсивно пробегать по списку до самого хвоста, чтобы просто его найти.</p>

<p>О(n) — не надо нам, O(n). Это долго. В декларативной модели есть способ реализовать полноценную <em>О(1) очередь!</em></p>

<p>Выглядит это так. Берется два декларативных списка, которые выступают как значение полей в другом базовом типе декларативной модели — <em>записи</em>.</p>

<p>Первый список хранит одну половину очереди, второй — другую, но в <em>обратном порядке</em>. Вторую половину мы переворачиваем чтобы добавлять в “хвост” как в “голову” за О(1). А из фактической головы очереди, которая находится в первом не перевернутом списке, мы итак можем удалять за константное время.</p>

<p>Есть два нюанса. Первый ― менять значение полей <em>записи</em> в декларативной модели нельзя. Поэтому любая операция над очередью всегда будет возвращать в качестве значения очереди новую “сущность”. Это важно понимать: <strong>Нельзя использовать одну и ту же очередь в качестве аргумента для разных операций</strong></p>

<p>Второй — если в какой то момент нам понадобиться получить очередь целиком, придется взять вторую половину, перевернуть её, слепить с первой половиной (представить как один список). И при этом этот список всё ещё должен оставаться очередью (нам надо что-то добавлять, удалять), значит он будет значением первого поля записи-очереди.</p>

<p>В общем выглядит совсем не как O(1)… То есть, если у нас будет программа, в которой нам не только нужно пользоваться методами добавления/удаления элементов в очередь, но ещё и часто возвращать эту очередь как единое значение, эффективность страдает.</p>

<p>И что с этим делать? Прочитайте ещё раз про списки различий :)</p>

<p style="text-align: center;"><img src="/images/mind_blowing.gif" alt="Взрыв Мозга" /></p>

<h3 id="персистентные-структуры">Персистентные структуры</h3>

<p>В ряде случаев может возникнуть необходимость хранить историю изменений какого-либо типа данных. Очередь или иной объект, предоставляющий такую возможность называется <em>персистентной структурой</em>.</p>

<p>Как такое можно реализовать? Первое что приходит на ум, это реализация отдельной очереди или списка, в которой значениями элементов будут выступать “исторические” состояния другого типа данных, доступные только для чтения.</p>

<p>Только вот если мы захотим сохранять состояния типа данных, в котором миллион значений, да еще и состояние меняется очень динамично… Ну вы поняли  — <strong>не эффективно!</strong></p>

<p>Для реализации персистентных структур разработаны сложные алгоритмы, разбор которых выходит за рамки поста. На данный момент нам просто нужно знать что такие структуры есть.</p>

<h3 id="снова-про-эффективность">Снова про эффективность</h3>

<p>Декларативная модель — сила, математическая мощь, исток всех парадигм! Но это всё ещё программирование.
Не важно в какой парадигме мы будем программировать — всегда нужно помнить о <a href="/2022/01/22/algorithms_complexity.html">эффективности</a> разрабатываемого нами алгоритма.</p>

<p>Хорошая новость в том, что с позиции оценки сложности алгоритмов, декларативная модель проста. Самое главное — разумно учитывать <em>распространенность</em> рекурсии.</p>

<p>Кроме того, оптимизировать прожорливость по памяти проще, чем сократить время выполнение программы (оптимизировать математически).</p>

<p>Алгоритм описанный в декларативной модели проще переписать в более “экономный” вид, используя схемы рассмотренные в прошлых постах (Итеративные вычисления, аккумулятор, etc.). Для большинства задач можно подобрать подходящую рекурсивную структуру данных, а саму память можно оптимизировать сборщиком мусора или алгоритмами сжатия.</p>

<p>Но в математическом смысле оптимизированный “по памяти” код всё равно нельзя назвать “оптимальным”, простите за тавтологию. Есть определенная грань до которой мы можем улучшать программу, после достижений которой, все последующие улучшения практически не влияют на производительность и лишь усложняют программу. Это плохая практика.</p>

<p class="info">Если нет явной необходимости — не нужно пытаться оптимизировать код!</p>

<p>Фишка в том, что почти всегда <em>очень малый</em> участок кода действительно влияет на время работы программной системы. Но есть нюанс — <em>не всегда этот участок очевиден даже опытным программистам</em>.</p>

<p>Поэтому очень проектировать программы ясным способом, придерживаясь правил хорошего стиля и используя подходящие для решения конкретной задачи парадигмы.</p>

<p class="info">Правильно подобранная парадигма программирования <strong>всегда</strong> повышает выразительность кода.</p>

<hr />

<p>Спойлер к следующему посту:</p>
<ul>
  <li>Программирование высшего порядка;</li>
  <li>Опять абстракции?</li>
  <li>Как на самом деле работают циклы.</li>
</ul>

<p style="text-align: center;"><img src="/images/no_identification.gif" alt="Рекурсивные кролики" /></p>

<p>Миру — Мир!</p>
:ET