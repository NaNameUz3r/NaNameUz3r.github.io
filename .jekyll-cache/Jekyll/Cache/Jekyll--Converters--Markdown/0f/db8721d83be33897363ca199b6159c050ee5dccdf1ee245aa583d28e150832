I"<<p>Часть 2. Декларативное программирование и рекурсия.
<!--more--></p>

<p>Здравствуйте! Мы продолжаем изучать декларативную вычислительную модель. На этой неделе я добрался до более практичных тем, и начну рассказывать вам о том, как собственно устроено программирование в декларативном “стиле”.</p>

<p>В прошлый раз мы разобрали декларативную модель с теоретической точки зрения, и в общих чертах должны хорошо понимать её внутреннее устройство.</p>

<h2 id="польза-декларативной-модели">Польза декларативной модели</h2>
<h4 id="детерминированный-конструктор">Детерминированный “конструктор”</h4>
<p>Одна из главных крутостей декларативного программирования заключается в том, что декларативные программы <strong>композиционны</strong>. Это значит, что программа состоит из некоторых <em>компонентов</em>, каждый из которых, благодаря заложенным в вычислительной модели принципам, является строго и ясно ограниченной частью программы.</p>

<p>В декларативной программе каждый компонент всегда хорошо различим, у него есть определенные входы и выходы. При этом компонент не обязательно является “малым” фрагментом кода, функций или процедурой. Процедура лишь частный вид компонента, и в более “сложном” компоненте могут быть определены другие, сохраняя всю декларативную ясность и мощь.</p>

<p>Композиционность достигается благодаря свойственным декларативной модели качествам. Напоминаю, мы не используем “динамические переменные”, не храним внутренние состояния процедур\функций, не передаем их куда-то вовне. Получается что компоненты, “сущности сами в себе”, или по русски — независимые сущности. Выход из одной декларативной операции становится входом для другой, сайд-эффекты, фактически — невозможны.</p>

<p>Благодаря этому качеству в декларативной модели мы можем разрабатывать сложные и <em>надежные</em> системы.</p>

<h4 id="ясно-понятно">Ясно, понятно</h4>

<p>Вторая сила декларативного программирования вытекает и связана с первой — декларативные программы достаточно просты для понимания. Мы можем легко рассуждать о них сквозь призму, например, логического анализа. Чтобы понять программу в целом, нам нужно лишь понять все её компоненты.</p>

<hr />

<p>Исходя из этого мы можем предположить, что можно забить на все остальные вычислительные модели, хорошо разобраться в декларативной, и все программы описывать только в ней. Жаль что это невозможно. Если бы все было так просто, то другие модели бы просто не появились. Дело в том, что задачи бывают разные, и для их решения подходят разные парадигмы.</p>

<p>Но хорошая новость в том, что на уровне разработки (написания) кода отдельных функций или модулей (ещё это называется <em>programming-in-small</em>), декларативный стиль применять можно <strong>всегда!</strong>.</p>

<p>На самом деле так <strong>нужно</strong> поступать. Это залог хорошего продукта не только в виде отдельных программных модулей, но и качественной программной системы в целом (<em>programming-in-large</em>).</p>

<p>Компоненты не должны иметь лишних связей, потому что это приводит к запутыванию и усложнению системы. В такой ситуации мы не можем говорить о композиционности или понятности. Как разобраться в отдельной части, если она явным образом зависит от кучи других? А те, в свою очередь, от кучи других? А если не явным? Брррр.</p>

<p>Другие вычислительные модели, свойством которых является тесная связь многих компонентов, <em>нужно использовать изолировано и в ограниченном количестве модулей</em>. Мы пытаемся, как-бы, “компонизировать” части системы со сложными связями, чтобы сами эти части становились <strong>декларативными компонентами</strong>.</p>

<p>Вот вам новая мантра:</p>

<p class="info">Я делаю как можно больше компонентов системы декларативными.</p>

<p>Говорят, если повторять её каждый раз когда садишься программировать, и применять на практике — станешь хорошим инженером.</p>

<h2 id="рекурсия">Рекурсия</h2>

<p>Как много будоражащего ум в этом слове (пока не разобраться :) ). 
Помню в детстве я сидел в парикмахерской, и места там были напротив друг друга у противоположных стен, и зеркала соответственно. Слово рекурсия я тогда не знал, но залип <em>глубоко</em> и надолго.</p>

<p>В программировании рекурсией называют “прием”, когда в теле функции вызывается эта же функция. На самом деле рекурсия может применяться по разному, самый простой и частный случай это <em>прямая</em> или простая рекурсия, когда функцию явно вызывает “саму себя”. Ещё рекурсии бывают <em>косвенные</em> или — <em>непрямые</em>. Это более хитрый способ, когда, например, функция А, вызывает функцию В, которая в свою очередь снова вызывает функцию А, и так далее.</p>

<p>Если рекурсивный вызов в теле функции является последним оператором, то в этом случае такую рекурсию называют <em>хвостовой</em>.</p>

<p><em>Глубина</em> рекурсии определяется количеством рекурсивных вызовов. Как это работает? Ну, в общем, есть такая структура данных <strong>стек</strong>. Наивно-абстрактно мы сейчас можем представить её как некоторую “вертикальную стопку” записей. Мы можем складывать туда записи одна за другой, и извлекать в обратном порядке, то есть забирать “верхние” записи поочередно.</p>

<p>Например, возьмем рекурсивную функцию А и изначально пустой стек. В вызове А0 что-то происходит, этот вызов с его “окружением” помещается в виде записи в стек, и в процессе выполнения происходит рекурсивный вызов А1. Ситуация повторяется, А1 помещается в стек следом за А0, вызывается А2, и так далее.</p>

<p>На самом деле это может происходить бесконечно, до тех пор пока не кончится память и стек не будет переполнен (stack overflow). Во избежание подобного в рекурсивных функциях определяют конечное условие, в случае удовлетворения которого функция должна что-то вернуть, а не снова провалиться в дальнейшую рекурсию.</p>

<p>Возвращаясь к примеру выше, представим что в вызове А4 это конечное условие было удовлетворено. В результате мы имеем стек, условно, такого вида А0 -&gt; А1 -&gt; А2 - A3 -&gt; A4. Стрелки в данном случае отображаю последовательность рекурсивных вызовов. Получается, что результат работы А4 вернется в А3, оттуда в А2, А1, и наконец в изначальный вызов А0 (который в общем тоже имеет какой-то выход, в данном случае это не важно).</p>

<p>Если вы смотрели мультик Гравити Фолз, то должны помнить что там была такая бездонная яма, в которую что не упади, обязательно рано или поздно вылетит назад. Можно представить рекурсивные вызовы и стек таким образом, для запоминания.</p>

<p style="text-align: center;"><img src="/images/botomless_pit.gif" alt="Стэн в яме" /></p>
<p><em><center>Дядюшка Стен ждет конечного условия, или пока стек переполнится. </center></em></p>

<p>Очевидно что бездумное использование рекурсии может накладывать существенные расходы памяти.</p>

<h3 id="что-происходит">Что происходит?</h3>

<p>Иван, при чем тут рекурсия? Этот пост про программирование в декларативной модели был. Ага! Я не отошел от темы.</p>

<p>Сейчас мы уже знаем всё что нужно, чтобы применять “декларативщину” на практике. Подытожим.</p>

<p>Для соблюдения декларативной модели нам нужно, во-первых, использовать переменные исключительно для однократного присваивания. Во-вторых, использовать простые (арифметические) операции над исконно декларативными типами данных — списками и записями. В-третьих, комбинировать декларативные операции, получая декларативные операции в результате (компонуем по полной!).</p>

<p>Так а что с этим всем делать? Комбинировать компоненты декларативной программы по правилам <strong>программирования высшего порядка</strong>! Звучит серьезно, правда?</p>

<p>Программирование высшего порядка, это когда в модели функции могут получать в качестве аргументов другие функции (как параметры), и <em>возвращать их в качестве результата</em>.</p>

<p>Догадались, нет?</p>

<p>Технически корректной реализацией декларативной программы будет её описание как <strong>чистых рекурсивных функций</strong> организованных согласно <strong>программированию высшего порядка</strong>.</p>

<p>Помните, в самом начале первой части мы говорили о том, что декларативная модель, это когда мы описываем “что должно получиться в итоге”, а как этого результата достигать? Вот это как раз и реализуется по канону высшего порядка, рассмотрим совсем простой псевдокод.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Функция АбстракцияУправления(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо):
    если ФункцияПроверкиРезультата(ОбрабатываемыеДанные) == True:
        Возвращаем ОбрабатываемыеДанные
    конец

    ОбрабатываемыеДанные = ФункцияВычисляющаяЧтоТо(ОбрабатываемыеДанные)
    возвращаем АбстракцияУправления(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо)
конец
</code></pre></div></div>

:ET