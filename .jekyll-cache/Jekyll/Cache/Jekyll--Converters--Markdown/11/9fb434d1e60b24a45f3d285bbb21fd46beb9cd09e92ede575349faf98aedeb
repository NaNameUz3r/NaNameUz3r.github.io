I"Z9<p>Врубаемся в Декларативную модель — Часть 6. 
<!--more--></p>

<h2 id="data-driven">Data-driven</h2>

<p>Часто на практике нужно выполнить какую то операцию над достаточно большой структурой данных, например провести итеративные вычисления, или обойти одну структуру и вычислить другую, на основе “собранных” в обходе данных.</p>

<p>Как правило, чаще всего такие вычисления проводятся над списками, массивами и деревьями. К спискам применяются операции свертки (FoldL\R), которые мы рассмотрели в прошлом посте. Но существуют и другие популярные техники.</p>

<h3 id="операция-map">Операция Map</h3>

<p>Реализация Map есть почти во всех стандартных библиотеках популярных языков программирования. Эта операция работает со списком, и вычисляет на его основании список такой же длинны, применяя переданную в Map функцию к каждому элементу исходного списка.</p>

<p>С помощью <del>заклинаний</del> программирования высшего порядка, реализовать Map можно как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def function Map(some_list, some_func)

    def function iterate_map(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list
  

        list_head = list_remaining[0]
        list_tail = list_remaining[1:] 
        return iterate_map(new_list.insert(0, some_func(list_head)), list_tail, some_func)
  

    return iterate_map([], some_list, some_func)
</code></pre></div></div>

<p>Можем передать в Map простую функцию, типа возведения в квадрат, и передать её вторым аргументов. Напоминаю что здесь, раньше и далее сниппеты описаны в “псевдопайтанокоде”. Заварите чай, прочитайте прошлые пару статей, если сходу ничего не понятно, и реализуйте рабочий вариант на своем любимом ЯП :)</p>

<h3 id="операция-filter">Операция Filter</h3>

<p>Filter это ещё одна классическая операция для обработки списков. Она так же принимает вторым аргументом некоторую функцию-предикат, и на выходе отдает список с элементами исходного списка, удовлетворяющими переданный предикат:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def function Filter(some_list, some_func)

    def function iterate_filter(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list

        list_head = list_remaining[0]
        list_tail = list_remaining[1:]

        if some_func(list_head):
            return iterate_filter(new_list.insert(0, list_head), list_tail, some_func)
        else:
            return iterate_filter(new_list, list_tail, some_func)
     
   

    return iterate_filter([], some_list, some_func)
</code></pre></div></div>

<p>Снова взываю к вашей фантазии, напрягите волшебный интеллект! Предикат можно придумать, практически любой. Например, если список состоит из целых чисел, можем написать простую функцию которая возвращает true если результата делится на 2 без остатка (четный). Или вообще воткнуть предикат в вызов iterate_filter лямбдой. Если вы прожженый питонист, то я уверен что вы хотя бы раз втыкали лямбды в map или filter!!! :trollface:</p>

<h2 id="абстрактные-типы-данных">Абстрактные типы данных</h2>

<p>Абстрактный тип данных — это описание некоторой структуры данных посредством определения операций над этой структурой. И только! Только операций!
Внутренняя реализация, все атрибуты <em>полностью скрыты</em> в АТД, или лучше сказать — <strong>эта реализация вообще отсутствует</strong>.</p>

<p>В декларативной парадигме АТД, в первую очередь тип данных — множество значений, с которым связано множество <em>допустимых</em> над ними операций. Базовы набор декларативных типов перечислялся в одном <a href="/2022/02/06/hack_in_declarative_model.html">первом посте</a> из этого цикла.</p>

<p>Мало типов, скажете вы! Да, хотелось бы определять свои. АТД в нашем распоряжении.</p>

<p>И ещё раз, что такое <em>абстрактный</em> тип данных? Это такой тип, который конкретно определен <em>множеством операций</em> над собой, и при этом <strong>полностью</strong> независим от своей реализации. Мы можем всегда быстро и легко поменять эту реализацию не трогая сам абстрактный тип.</p>

<h3 id="защищаем-атд">Защищаем АТД</h3>

<p>Есть такое чувство, что легкая сменяемость чего либо в программировании может привести к проблемам. Чаще всего так и происходит. В разрезе АТД не всегда будет разумным делать реализацию типа для всех. Во-первых, программа с такой открытой реализаций, то есть <em>открытая программа</em> потенциально становится легкой мишенью для злоумышленников.</p>

<p>Под “открытой программой” тут мы понимаем не open source софт, речь вообще не об этом. Представьте программу которая запущена в прод, в ней крутится много данных, в том числе персональных данных клиентов, и в этой программе сама реализация абстрактных типов открыта, и например непосредственно доступна для взаимодействия другим программам через API. В таком случае любая другая программа может быть вредительской и “наворошить дел” в нашем рантайме.</p>

<p>Нам нужно защитить <em>конкретные</em> реализации абстрактных типов данных от <em>неавторизованного</em> вмешательства. Для этого можно ограничить внутреннюю реализацию, часть кода, которая производит вычисления.</p>

<p>Такое ограничение можно внедрить двумя способами:</p>

<ol>
  <li>
    <p>Четко определяем набор операций и их граничные значения так, чтобы вычисляемое значение вообще не могло выходить за эти границы. Сам набор операций становится ограничением, вычисляя только <em>стационарные значения</em>.</p>
  </li>
  <li>
    <p>Другой вариант — <em>мобильные значение</em>. Вычисленное значение может покидать границы, а затем вернуться обратно. Пока оно “снаружи”, с ним может как-то работать внешний код (другая программа, например, или другой модуль нашей системы). Здесь описывается четкий набор операций, которые по разрешению могут выводить значение, обрабатывать его, и возвращать результат назад.</p>
  </li>
</ol>

<p>Такое разрешение называется <em>авторизацией</em>. Для получения авторизации операция должна предоставить некоторый “ключ” (токен, называйте как хотите). В декларативной модели этот ключ-авторизацию называется просто “имя”.</p>

<p>Для реализации второго метода классическая декларативная модель должна быть расширена. Нам надо придумать как защищать значения, и как защищать <em>несвязанные</em> (со значением) декларативные переменные.</p>

<p>Например, мы можем определить операции-обертки, с ключем доступа. Доступ к внутреннему функционалу абстрактного типа становится доступным только тем операциям, которые передают в обертку <em>правильный</em> ключ.</p>

<p>Для начала нам надо определить тип для ключей, например Name, который будет хранить атомарное значение. У этого типа нет никаких операций вывода своего значения на экран, или преобразования в число, строку и тд. Всё что должно быть возможно сделать с Name, это только создавать его новые экземпляры, и сравнивать со значениями других экземпляров Name.</p>

<p>При этом, операция создания нового ключа должна гарантировать, что результирующее значение будет <em>уникальным</em>. Мы тут немного отходим от талмудов декларативности, ведь операция создания нового ключа <em>не декларативна</em> — вызывая её каждый раз, мы получаем новый результат. Но тут мы применяем этот подход только для внедрения безопасности абстрактных типов, так что это ок, ведь сами АТД остаются декларативными.</p>

<p>Далее, например у нас есть абстрактный тип данных — стек, который внутри фактически реализован как обычный список, но у нас нет прямого доступа к его (стека) содержимому в виде обычного списка.</p>

<p>Мы можем создать экземпляр стека, создать экземпляр ключа, для этого стека, назвав его как нибудь типа stack_key, и наконец — <em>реализовать функцию обертку</em> (доступную “снаружи”), которая на вход получает собственно стек, и ключ. Если ключ правильный — работаем. Если нет — чао-какао.</p>

<p>Ну вы поняли — ни Name, ни метод генерации экземпляров Name, ни сравнения с другими Name извне (другим программам) никак не доступен. Мы разделяем таким образом “внутренние” операции и “внешние”.</p>

<p>Очевидно, что такая схема обезопасивания АТД может применяться в коде часто, поэтому отчего бы её тоже не обернуть в другой слой абстракции?
А как? А с помощью АТД! :trollface:</p>

<p>Мы можем описать две функции “упаковки” и “распаковки” — wrap(), unwrap(), и ключи генерировать скрыто в “конструкторе” АТД.</p>

<p>Операция Wrap получает на вход некоторое значение, возвращает <em>функцию</em>, которая требует ключа на вызове, чтобы распаковать скрытое в себе значение.</p>

<p>Unwrap же получает эту функцию, передает ей требуемый ключ, и если ключ правильный то возвращает значение в незащищенном виде.</p>

<p>Например у нас есть:
    some_list = [“h”, “e”, “l”, “l”, “y”, “e”, “a”, “h”]</p>

<p>Мы делаем скдыщь:
    secure_list = Wrap(some_list)</p>

:ET