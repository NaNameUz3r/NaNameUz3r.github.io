I"PD<p>Как подступиться к правильному созданию программы.
<!--more--></p>

<h3 id="program-design">Program Design</h3>
<p>Проектирование программы, наверное, самый важный критерий успешности и качественности будущего программного продукта. 
На этапе проектирования нам нужно четко определить саму задачу, и то как мы будем её решать.</p>

<p>Под “решанием” имеются в виду техники программирования (прадигмы), которые будут применяться, и то как они будут связанны между собой.</p>

<p>Результатом проектирования является высокоуровневая структура, условный <em>“прототип”</em> будущей системы.</p>

<p>Очевидно, что в зависимости от задачи размер и сложность программы может существенно отличаться. Это может быть маленькая программа, написанная одним человеком или здоровенный комплекс, над которым трудится целая команда. В классическом случае первое называют programming in small, а второе — in large.</p>

<p>Более интересным с инженерной точки зрения мне кажется другое определение <em>programming in small</em> и <em>programming in large</em>, когда подразумевается не количество людей трудящихся над программой, но “фокус” разработки.</p>

<p>В этом случае, говоря о programming in small подразумевается само кодирование программы, а именно написание стилистически ясного, правильно (чистого) кода, выраженного через <a href="/2022/01/22/algorithms_complexity.html">продуктивные алгоритмы</a>.</p>

<p>Programming in large, в таком случае, является “фокусом” проектирования, когда программа уже является действительно большой (от нескольких тысяч строк кода, и более). В создании таких сложных программ критически важно подходить к проектированию осознанно и правильно, иначе всё кончится плохо: бизнес потеряет деньги, разработчики — оставшиеся нервные клетки.</p>

<h2 id="базовый-подход">Базовый подход</h2>

<p>Предлагаю вам, в качестве примера, рассмотреть следующую методику проектирования in small, когда программа разрабатывается единолично, и ожидаемый объем кода составит менее десятков тысяч строк.</p>

<h4 id="1-спецификация">1. Спецификация</h4>
<p>Сперва необходимо обозначить <strong>неформальную спецификацию</strong>. Это то, что часто называют техническим заданием. На практике же нам нужно как можно более точно записать что программа должна делать, а именно:</p>

<ul>
  <li>Что программа получает на вход?</li>
  <li>Что должна выдавать на выходе?</li>
  <li>Как входные и выходные данные соотносятся друг с другом?</li>
</ul>

<p>Такая спецификация называется неформальной, потому что мы пишем её на человеческом языке (русском, английском, или на каком вы там ещё умеете).</p>

<h4 id="2-примеры">2. Примеры</h4>
<p>Примеры служат для прояснения спецификации, полученной на первом этапе. Будет очень полезно представить что программа делает в определенных, конкретных ситуациях. Лучшего всего это делать в <em>формате тестов</em>. Да, сначала пишем тесты для кода, а потом код! Это называется TDD — Test Driven Development, и само по себе огромная тема для отдельного поста.</p>

<p>Наши примеры должны показывать, во-первых, как программа ведет себя граничных условиях. Нужно проверить её самыми неожиданными способами. Никогда не нужно думать что “чего-то может не быть”, “моя программа никогда не получит на вход отрицательное значение”, и так далее.</p>

<p><strong>Assume and check everything!</strong></p>

<p>Во-вторых, примеры должны собственно отображать базовые сценарии работы программы. Может показаться, что это важнее чем тесты. Нет, не важнее.</p>

<h4 id="3-исследование">3. Исследование</h4>

<p>На этом этапе нам необходимо написать “кирпичики” из которых мы предполагаем строить программу. Этими “кирпичиками” должны быть небольшие и по максимуму автономные операции (низкая связанность). В результате мы получим намного более четкое представление о структуре будущей программы, и сможем определить конкретные методы программирования, уместные для решения поставленных задач.</p>

<h4 id="4-структура-и-реализация">4. Структура и реализация</h4>

<p>Наконец, мы начинаем формировать саму программу — приблизительно набрасываем операции для расчета входных данных, и способы (методы), которыми эти операции между собой взаимодействуют. После этого пробелы в получившемся наброске заполняются реальным кодом. Важно то, что операции <em>должны быть простыми</em> — каждая из них должна делать <strong>одну</strong>, и только одну вещь.</p>

<p>Это один из самых важных принципов <em>ясного</em> программирования, следуя которому мы избегаем потенциально много ошибок, которые могут порождаться, например, сайд-эффектами запутанных функций, которые делают “много чего” внутри. А те ошибки, которые всё таки будут появляться (А они будут!), мы сможем намного быстрее идентифицировать и исправить.</p>

<p>Для улучшения структуры программы, связанные операции группируются в <em>модули</em>.</p>

<h4 id="5-тестирования-и-обдумывание">5. Тестирования и обдумывание</h4>

<p>Пришла пора убедиться что <del>оно живое!</del> программа вообще работает. Для этого нужно провести ряд тестов, включая те, что уже были разработаны на этапе 2. Снова и снова гоняем тесты и исправляем ошибки, до тех пор пока программа не заработает так как надо. А надо, чтобы она работала хорошо :)</p>

<p>На этом этапе важно не забывать рассуждать о структуре программы и её сложности. Находя и исправляя ошибки потенциально возможно улучшить структуру программы и переписать плохие алгоритмы (рефакторинг кода).</p>

<hr />

<p>Все эти этапы взаимодополняющи друг другу. Например, на этапе исследования, или даже написании примеров, мы можем понять что изначальная спецификация не совсем корректна, и изменить/дополнить её. Тестирование и обдумывание, имхо, вообще стоит ультимативно применять как жизненный принцип :)</p>

<p>А если по делу, то тестирование, в принципе, самый важный шаг в programming in small. Существует достаточно много методик тестирования, которые стоит изучить и применять в разработке. Например, уже упомянутое TDD и <em>модульное тестирование</em>. Это тема для отдельных постов, поэтому вкратце:</p>

<ul>
  <li>Модульное тестирование — основная идея unit-тестирования в том, чтобы писать тесты, которые проверяют <strong>наименьшую</strong> составляющую кода (один тест проверяют одну функцию, модуль или класс)</li>
  <li>TDD — Перед тем как писать код, мы пишем тесты для этого кода (например те же самые unit-тесты)! В принципе такие тесты выступают в роли спецификации того, что код <em>должен делать</em>. Мощный подход, которые позволяет понимать что мы вообще делаем, программируя части системы.</li>
</ul>

<h2 id="организация-программы">Организация программы</h2>

<p>В проектировании важно понимать как всё таки правильно организовать программу. Конечно, можно накодить всё как сплошной монолит, в котором по мере роста проекта всё в итоге запутается, и все участники разработки/сопровождения будут ультимативно страдать. Наверняка вы видели такие проекты, не буду показывать пальцами.</p>

<p>Наиболее адекватный способ борьбы с растущей сложностью системы — декомпозиция программы на так называемые <em>логические единицы</em>. Каждая такая единица должна реализовать свой набор операций, которые связанны в одно целое, например через <a href="/2022/03/13/hack_in_declarative_model_6.html">абстрактные типы данных.</a></p>

<p>Логическая единица делится на две части: <em>интерфейс</em> и <em>реализацию</em>. Снаружи логического блока доступен только интерфейс, а реализация “внутри” при этом может меняться безнаказанно.</p>

<p>Логические единицы часто называют <em>модулями</em> или <em>компонентами</em> программы.</p>

<h3 id="слово-дня---функтор">Слово дня - Функтор</h3>

<p>А теперь немного программистской “научности”, продолжая тему организации.</p>

<p>Спецификацию модуля рассматривают как <em>отдельную сущность</em> — это такой “шаблон”, который создает новый модуль, примерно так же как класс создает экземпляр объекта в объектно ориентированном программировании. Есть конкретный программистский термин, для обозначения таких спецификаций.</p>

<p><strong>Функтор</strong> — это функция, которая получает на вход набор модулей, требующихся для создания <em>нового модуля</em>, и возвращает этот новый созданный модуль. Правильно говоря, функтор получает на вход <em>интерфейсы</em> модулей, и возвращает тоже <em>интерфейс</em> нового модуля.</p>

<p>Функтор состоит из:</p>

<ul>
  <li>импорта, которым задается перечень требуемых функтору модулей;</li>
  <li>экспорта, определяющего интерфейс “изготавливаемого” модуля;</li>
  <li>реализации, включающая код инициализации самого функтора.</li>
</ul>

<p>В программной инженерии <em>программным компонентом</em> называется некоторый элемент для <em>независимого развертывания</em>. Такой компонент для своей установки ничего не требует, кроме перечня стандартных библиотек. Программный компонент не имеет фиксированного внутреннего состояния, иными словами — соответствует (декларативной модели)[/archive.html?tag=Декларативная_модель]</p>

<p>Автономное (standalone) приложение, которое не подразумевает активного взаимодействия с пользователем, например, не имеет графического интерфейса для такого взаимодействия, состоит из главного функтора, который вычисляется на старте приложения, “подтягивает” нужные себе модули, что фактически приводит к вызову других функторов.</p>

<p>Вычисление или установка главного функтора происходит в три шага:</p>
<ul>
  <li>Идентификация необходимых для работы модулей;</li>
  <li>Выполнение кода инициализации;</li>
  <li>Загрузка модулей, которые будут нужны непосредственно во время работы программы.</li>
</ul>

<p>Другие “подфункторы” могут вычисляться в разное время работы программы, как правило в те моменты, когда запрашиваются ресурсы из ещё не вычисленного функтора. Такое поведение называется <strong>динамическим связывание</strong>, которое является полной противоположность <strong>статическому связыванию</strong> — при котором все модули загружаются сразу на старте программы.</p>

<p>Множество установленных (вычисленных) модулей называется <strong>рабочим модульным окружением</strong>.</p>

<hr />

<p>Любите.</p>
:ET