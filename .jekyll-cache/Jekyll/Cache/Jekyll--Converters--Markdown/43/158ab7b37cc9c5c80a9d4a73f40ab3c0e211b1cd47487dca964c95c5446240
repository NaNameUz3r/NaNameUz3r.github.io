I"U:<p>Часть 3. Список списков, итеративные вычисления и прочие муми-тролли. 
<!--more--></p>

<h3 id="here-we-go-again">Here we go again</h3>
<p>Здравствуйте! Это очередной пост-отчёт по мотивам материала из курса <a href="https://skillsmart.ru/">школы Сергея Бобровского</a> – Как понять в программировании всё. Изучаем декларативную вычислительную модель.</p>

<p>В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.</p>

<p>Рекурсия как программистский трюк не ограничивается “самовызовом” (прочитали как самовывоз, признайтесь?) функций — <em>рекурсивными могут быть и типы данных</em>. Базовый пример рекурсивного типа данных — список.</p>

<p>Почему список на самом деле рекурсивная структура? Потому что он определяется <em>в терминах более короткой версии себя самого</em>.</p>

<p>Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и <em>“список”</em>, а лучше сказать набор или “последовательность” пар “ключ-значение”.</p>

<p>Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список.</p>

<p>Как правило этими “произвольными” значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка “впихнуть” в эти “кусочки” какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда).</p>

<p>Части списка связанны некоторым образом с другими, и всё вместе (“элементарный кусок данных” и связь-указатель на другой) называется <em>узел</em>.</p>

<p>В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.</p>

<p>Вернемся к фундаментальным материям :)</p>

<p>В декларативной модели список определяется <em>рекурсивно</em>. Считается, что либо список пустой (nil или, если хотите, None), либо <em>есть какое-то значение связанное со списком</em>.</p>

<p>Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, “узел” содержащий строку “shrek”, то тогда список X будет равен “shrek” <em>связанный со списком nil</em>!</p>

<p>Короче говоря, “последний” элемент в списке всегда будет “указывать” на “пустой список”.</p>

<p>Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.</p>

<p>В рекурсивных функциях, работающих со списками, <em>базовым случаем</em> будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов <em>более мелких списков</em>.</p>

<p>Например, “декларативная” рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list_length(some_list):
    if some_list == []
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    return 1 + list_length(some_list_tail)
</code></pre></div></div>

<p>Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — “Ух ты ж сколько можно то намутить с этим списком!”</p>

<p style="text-align: center;"><img src="/images/hold_on.gif" alt="Подождите!" /></p>

<p>Это всё ещё рекурсивная функция, мы в прошлый уже говорили про проблему с переполнением стека. Кроме того, рекурсивные функции со списками, при их необдуманном определении, вполне могут оказываться крайней не эффективными — O(n*n) или ещё хуже.</p>

<p>Для решения этих проблем есть техника, при которой рекурсивные функции превращаются в функции с <em>итеративной формой вычисления</em> с <strong>линейной</strong> эффективностью!</p>

<h3 id="итерируй-то">Итерируй то</h3>

<p>Ранее мы говорили про итеративные вычисления как о частном случае рекурсии. Разберемся чуть глубже.</p>

<p>Во-первых стек. Почему он вообще формируется при рекурсивном вызове? Обратите внимание на пример функции вычисления длинны списка, а именно на хвостовой return в конце. Раз за разом при рекурсивном вызове окружение экземпляра функции должно сохраняться в стеке, потому что прибавление единицы происходит <strong>после</strong> этого заключительного return.</p>

<p>В нашем примере это всё происходит лишь для того, чтобы потом в обратном порядке “размотать” стек и просуммировать единцы. Кажется избыточным.</p>

<p>Чем отличается итеративное вычисление от обычной рекурсии?</p>

<p>Схема итеративных вычислений — это <em>последовательность <strong>трансформации состояний</strong></em>. Как это работает?</p>

<p>Ну, по сути, мы добавляем некоторый счетчик в аргумент рекурсивной функции, и делаем так чтобы увеличение этого счетчика <em>происходило <strong>до</strong> рекурсивного вызова</em>.</p>

<p>Рекурсивная-итеративная функция вычисления длины списка будет выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
</code></pre></div></div>

<p>Обратите ещё раз внимание на счетчик <em>i</em>. Мы увеличиваем его в аргументах рекурсивного вызова, <strong>до</strong> самого вызова. Благодаря этому мы “замыкаем” окружение функции и состояние каждого экземпляра не требуется сохранять в отдельных записях в стеке.</p>

<p>Ничего не мешает скрыть такую функции за функцией-абстракцией, которая будет принимать только list, а внутри вызывать inter_list_length(0, list).</p>

<h3 id="итерируй-это">Итерируй это</h3>

<p>Видите как связана “рекурсивность функции” с “рекурсивностью типа”, который она обрабатывает?</p>

<p>Это <strong>важная фишка</strong>.</p>

<p>Мы уверенно можем сказать, что <em>рекурсивная структура функции зависит от рекурсивной структуры определения обрабатываемого типа данных</em>.</p>

<p>Мы потенциально можем нагородить какой угодно рекурсивный тип, но это не есть хорошо. Эта свобода в программировании часто приводит к написанию очень неэффективных, не грамотных алгоритмов.</p>

<p>Само по себе определение какого-то типа данных в языке программирования <em>описательно</em>. Это значит, что такое определение является всего лишь набором логических утверждений о множестве значений, который данный тип может принять. Такие определения не являются полноценными проверками допустимостей значений, а зачастую (например какой нибудь абстрактный тип) их вообще проверить нельзя.</p>

<p>В декларативной модели даже базовые типы могут быть не проверенны компилятором. Поэтому нам <strong>важно</strong> предельно осознанно понимать что мы кодим, и использовать изначально свойственные декларативной модели типы данных.</p>

<p>Список это very handy! Надо лишь включить думалку, и включить так, чтобы избежать неэффективных реализаций алгоритмов.</p>

<p>Вернемся к нашему определению взаимосвязи рекурсивности типа с рекурсивностью функции.</p>

<p>Сперва нам необходимо <em>правильно определить рекурсивный тип</em>, прежде чем писать для него функцию. Что это значит?</p>

<p>Например, у нас есть некий композитный список, элементы которого тоже могут быть списками, и нам надо посчитать количество всех значений, включая значений во вложенных списках.</p>

<p>Нам нужно понять, или <em>определить</em> тип “вложенный список”.</p>

<p>Мы помним что “список” — это либо пустой [], либо некоторый “элемент” связанный с [].</p>

<p>В таком случае “вложенный список” будет определяться как — либо пустой [], либо “вложенный список” связанный с “вложенным списком”, либо как “элемент” связанный с “вложенным списком”. Ничего не понятно?</p>

<p>Короче говоря, у нас в любом порядке и в “ширину” и в “глубину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых в любом порядке и в “глубину” и в “ширину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых…</p>

<p style="text-align: center;"><img src="/images/recursion_1.gif" alt="Рекурсия" /></p>
<p><em><center>Неотложка уже выехала.</center></em></p>

<p>Так, давайте не будем пороть горячку! Это проще чем кажется.</p>

<p>Вложенный список, с которым может быть связан вложенный список, все ещё “обычный” список, который может быть пустым (то есь может “не быть”! Ом!) Мы с этого и начали определение.</p>

<p>Тогда функция, основанная на таком типе будет иметь структуру:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lengh_1(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if type(list)
</code></pre></div></div>

:ET