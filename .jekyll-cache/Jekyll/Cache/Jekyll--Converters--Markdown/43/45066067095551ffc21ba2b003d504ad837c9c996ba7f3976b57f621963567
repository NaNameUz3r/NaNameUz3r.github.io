I"]"<p>Наполовину вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью.</p>

<!--more-->
<p>Оригинал статьи можете прочитать в его личном блоге по <a href="https://malisper.me/an-algorithm-for-passing-programming-interviews/">этой ссылке.</a></p>

<hr />

<p>За последние несколько лет я проходи интервью в дюжине (или около того) компаний и решил ~50 уникальных алгоритимических задач.
Мне часто давали обратную связь, в которой говорилось, что я отлично справился с предлагаемыми алгоритимическими задачами.
В этом посте я собираюсь поделиться тем, как именно я подхожу к решению этих задач.</p>

<h2 id="мыслительный-процесс">Мыслительный процесс</h2>

<p>Основной принцип, который я использую, заключается в том что каждая задача, предлагаемая к решению на собеседовании, <em>может быть решена</em>.
На интервью вас не станут просить доказать Великую теорему Ферма. Если вам дадут какую-то неразрешимую задачу, похоже что у вас не будет особых шансов её решить.</p>

<p>По моему опыту, примерно в 80% случаев алгоритмические задачи сводятся к фундаментальным структурам данных и алгоритмам. Структуры данных, которые я встречаю чаще всего:</p>
<ul>
  <li>Хэш-таблицы</li>
  <li>Связанные списки</li>
  <li>Двоичное дерево поиска</li>
</ul>

<p>Что касаемо алгоритмов:</p>
<ul>
  <li>Поиск в глубину</li>
  <li>Бинарный поиск</li>
  <li>Алгоритмы сортировки</li>
</ul>

<p>(Скорее всего от вас не будут требовать реализовать бинарный поиск или алгоритм сортировки, но вы <em>должны знать</em>, что они существуют.)</p>

<p>Кроме того, есть две дополнительные техники программирования, с которыми вы должны быть знакомы:</p>
<ul>
  <li>Динамическое программирование</li>
  <li>Рекурсия</li>
</ul>

<h2 id="алгоритм-решения">Алгоритм решения</h2>

<p>Алгоритм решения задачи выглядит так:</p>
<ol>
  <li>Как только вы получили алгоритмическую задачу, уточните требования реализации (условия, runtime) которым должно соответствовать ваше решение. Скорее всего интервьвер ответит на этот вопрос.</li>
  <li>Вычеркните из списка возможных структуры данных и алгоритмы которые очевидно не имеют отношения к рассматриваемой задаче. Это избавит вас от большей части списка, и вы, как правило, останетесь с 2-3 структурами данных и алгоритмами.
    <ul>
      <li>Вы можете не рассматривать слишком медленные структуры данных. Если вам необходимо решить задачу за O(1), то невомозможно использовать бинарное дерево в своем решении, так как бинарное дерево всегда будет выполнять не менее, чем за O(log n) времени.</li>
      <li>Так же вы можете избавиться от алгоритмов, если их невозможно применить в задаче. Например, если в задаче нет графа, вы знаете, что поиск в глубину вам точно не подойдет.</li>
    </ul>
  </li>
  <li>Рассмотрите варианты использования оставшихся структур данных. Какие из них имеют отношения к поставленной задаче? Решением станет подходящая комбинация, вам остается её только собрать воедино.</li>
</ol>

<p>Давайте рассмотрим среды выполнения, основные структуры данных и алгоритмы. Затем мы разберем несколько примеров, чтобы убедиться насколько прост данных подход.</p>

<h3 id="требования-реализации-и-сценарии-применения"><em>Требования реализации и сценарии применения</em></h3>

<h4 id="хэш-таблицы">Хэш-таблицы.</h4>
<p><strong>Требования реализации - поиск, вставка и удаление за O(1)</strong></p>

<p>Сценарии применения:</p>
<ul>
  <li>Когда вам нужно лишь находить и сохранять объекты.</li>
  <li>Когда вам нужно разделить список объектов на группы, по некотрому свойству (это то, что делает GROUP BY в SQL)</li>
  <li>Нужно посчитать колиечество отличных элементов из списка.</li>
</ul>

<h4 id="связанные-списки">Связанные списки.</h4>
<p><strong>Требования реализации - вставка нового узла, поиск и удаление узлов из головы, хвоста, или из узла на который уже есть указатель.</strong></p>

<p>Сценарии применения:
Основные сценарии применения связанных списков витают вокруг факта, что связанные списки поддерживают относительный порядок своих элементов. В интервью по программированию связанные списки, в основном, используются как реализация стека или очереди.</p>

<h4 id="двоичные-деревья">Двоичные деревья.</h4>
<p><strong>Требования реализации - вставка, поиск и удалние за O(log n)</strong></p>

<p>Сценарии применения:
Двоичные деревья используются, когда вам нужно хранить данные в отсортированном порядке. Позволяют быстро находить количество элементов, попадающих в конкретый диапазон, или самый <em>высокий</em> элемент в дереве.</p>

<h4 id="двоичный-поиск">Двоичный поиск.</h4>
<p><strong>Требования реализации - O(log n)</strong></p>

<p>Сценарии применения:</p>
<ul>
  <li>Вам нужно найти число в массиве, ближайшее к другому числу.</li>
  <li>Вам нужно найти наименьше число в отсортированном массиве, которое больше чем другое число.</li>
  <li>Вам нужно найти наибольшее число в отсортированном массиве, которое меньше другого числа.</li>
  <li>Если по какой-то причине в своем решении вы не можете использовать хэш-таблицу, вы можете с помощью двоичного поиска проверить, находится ли элемент в отсортированном массиве.</li>
</ul>

:ET