I""!<p>Часть 4. Рекурсивные типы данны и прочие Джедайские декларативные техники.
<!--more--></p>

<p>Здравствуйте! На самом деле декларативная модель сама по себе — Джедайская техника, а именно итеративная “рекурсия”. В этом посте мы скорее разберем области применения.</p>

<h3 id="списки-различий">Списки различий</h3>

<p>Кроме списков существуют другие рекурсивные типы данных, например — Списки различий. На самом деле это особый тип данных, который состоит из <em>двух списков</em>. Эти списки связаны друг с другом таким способом, что <em>второй</em> список может быть получен из <em>первого</em>, если из этого первого списка удалить некоторое число элементов (в том числе нулевое, то есть эти списки могут быть по сути “равны”).</p>

<p>Фактически, списки различий, являются <em>одним из</em> типов данных, которые классифицируются как <strong>структуры различий</strong>. Суть таких типов мы уже разобрали — это пары значений, одно из которых “встроенно” в другое.</p>

<p>Структура различий <em>A</em>, которая, например, состоит из <em>B</em> и <em>С</em>, отражает значение равное <em>B минус C</em>.</p>

<p>В данном случае мы разбираем списки различий, потому что у них есть интересная особенность:
<em>Хвост списков различий может быть <strong>не определен</strong></em>.</p>

<p>Мы можем это легко представить. Как вы помните, список — рекурсивен, и условно всегда состоит из “Головы” и “Оставшейся части”. В списках различий, если мы итеративно добираемся до “хвоста”, то “оставшаяся часть” является не пустым списком, а <em>неопределенной декларативной переменной</em> (она “есть” но ещё не связанна со значением. См. предыдущие посты), и в первом, и во втором списке различий.</p>

<p>Что нам это дает? Самое главное преимущество, это то, что мы можем сложить оба списка за константное время O(1), вообще не зависимо от длинны списков. Это делается очень просто — неопределенную переменную в конце первого списка <em>инициализируем</em> ссылкой на второй список. Вуаля.</p>

<p>Цена такого трюка велика — мы можем провернуть это сложение списков только один раз, так как первый список просто перестает существовать.</p>

<h3 id="в-очередь">В очередь!</h3>

<p>В классической императивной модели очередь — это интуитивно понятная структура данных, которая работает на базе списка по принципу “первый вошел — первый вышел” (FIFO). У очереди есть только две операции (метода) без каких либо аргументов: добавить элемент в хвост очереди, удалить элемент из головы.</p>

<p>Прямо как в супермаркете.</p>

<p>В императивной модели очередь легко реализуется на основании другой структуры — <em>двусвязного списка</em>. Это такой список, в котором элементы связываются указателями не только со следующими за ними элементами, но и с “оставшимися” позади. Благодаря этой двусвязности, методы очереди в императивной модели работают за О(1).</p>

<p>А что в декларативной модели? Как вы помните, в декларативной модели нет указателей и нет “классических” переменных. Ну, используя “декларативный” список мы можем добавлять новые элементы в голову за О(1), но удалять из хвоста придется за линейное время О(n), так как каждый раз для этого придется рекурсивно пробегать по списку до самого хвоста, чтобы просто его найти.</p>

<p>О(n) — не надо нам, O(n). Это долго. В декларативной модели есть способ реализовать полноценную <em>О(1) очередь!</em></p>

<p>Выглядит это так. Берется два декларативных списка, которые выступают как значение полей в другом базовом типе декларативной модели — <em>записи</em>.</p>

<p>Первый список хранит одну половину очереди, второй — другую, но в <em>обратном порядке</em>. Вторую половину мы переворачиваем чтобы добавлять в “хвост” как в “голову” за О(1). А из фактической головы очереди, которая находится в первом не перевернутом списке, мы итак можем удалять за константное время.</p>

<p>Есть два нюанса. Первый ― менять значение полей <em>записи</em> в декларативной модели нельзя. Поэтому любая операция над очередью всегда будет возвращать в качестве значения очереди новую “сущность”. Это важно понимать: <strong>Нельзя использовать одну и ту же очередь в качестве аргумента для разных операций</strong></p>

<p>Второй — если в какой то момент нам понадобиться получить очередь целиком, придется взять вторую половину, перевернуть её, слепить с первой половиной (представить как один список). И при этом этот список всё ещё должен оставаться очередью (нам надо что-то добавлять, удалять), значит он будет значением первого поля записи-очереди.</p>

<p>В общем выглядит совсем не как O(1)… То есть, если у нас будет программа, в которой нам не только нужно пользоваться методами добавления/удаления элементов в очередь, но ещё и часто возвращать эту очередь как единое значение, эффективность страдает.</p>

<p>И что с этим делать? Прочитайте ещё раз про списки различий :)</p>

:ET