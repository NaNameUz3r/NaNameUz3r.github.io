I"B:<p>Продолжаем врубаться в функциональное программирование. Пусть и туго :)
<!--more--></p>

<p>Всех и повсюду приветствую! Я продолжаю заниматься по ФП курсу, и (имхо!) пришла пора написать ещё немного про фишки F# (и, наверное, вообще ФП языков ML семейства) и порефлексировать.</p>

<h2 id="перегрузка">Перегрузка</h2>

<p>Перегрузка, это такая реализованная в языке “полиморфная” штука, когда при обращениях к функциям или операторам, которые <em>имеют несколько реализаций для разных типов данных</em> компилятор ведет себя по разному. Сами эти реализации и есть “перегрузки”.</p>

<p>В F# система типов ведет себя следующим образом:</p>
<ul>
  <li>Когда компилятору “понятно” в контексте обращения, что за тип используется — символ оператора интерпретируется как функция для этого типа;</li>
  <li>В противном случае используется <em>перегруженный</em> оператор для <em>подходящего</em> типа по умолчанию.</li>
</ul>

<p>Звучит сложно, но на самом деле тут всё просто. Если какой-то оператор можно применить к целым числам (int), ну значит int и будет считаться <em>типом по умолчанию</em>.</p>

<p>Например у функции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x,y) = x + y 
</code></pre></div></div>

<p>по умолчанию тип будет int -&gt; int. Но что если мы хотим, и заранее знаем, что будем вычислять числа с плавающей точкой? 
Явно указать тип <em>аргумента</em> в F# можно так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x: float, y: float) = x + x
</code></pre></div></div>

<p>Указать явно тип результата функции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x, y) : float = x + x
</code></pre></div></div>

<p>И, наконец, можно указать явно <em>тип выражения</em>, вычисляемого функцией:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x, y) = x + x : float
</code></pre></div></div>

<h2 id="нонфиксная-запись">Нонфиксная запись</h2>

<p>Любые инфиксные операторы можно записать нонфиксной записью. Ну, короче, не 1 + 1, а (+) 1 1.</p>

<p>Просто берем оператор в скобки, и следом перечисляем аргументы. Можно представить это как функцию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let mul3 = (*)3
</code></pre></div></div>

<p>Где вызов mul3 2 будет равняться 6. Просто? Просто!</p>

<p>Ну и по сути вызов нонфиксного оператора, который на вход получает один аргумент — функция (хотя тут вообще всё функция, но давайте сохранять трезвость рассудка).</p>

<p>Применение функции работает через <em>левую ассоциацию</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printfn "%b" ((*) 3 2 = ((*)3) 2) // будет true!
</code></pre></div></div>

<p>Ну как там, с трезвостью?</p>

<h2 id="композиция-и-каррирование">Композиция и каррирование</h2>

<p>Так, это уже серьезные спеллы, первый из которых должен быть нам уже знаком (как минимум интуитивно).</p>

<h3 id="композиция">Композиция</h3>

<p>По-простому — это подход, подразумевающий вызов одних функций в качестве аргументов других. Я уже писал про high-order и вот это всё.
По-сложному, математически — композиция двух функций x и y (x o g) будет обозначать:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x o y)(x) = x(y(x)) 
</code></pre></div></div>

<p>И есть x(a) = a + 5, и y(b) = b * 2, тогда</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x o y)(b) = x(y(b)) = x(b * 2) = b * 2 + 5
</code></pre></div></div>

<p style="text-align: center;"><img src="/images/mind_blowing.gif" alt="Взрыв Мозга" /></p>
<p><em><center>Узнали? Согласны?</center></em></p>

<p>Отставить горячку!</p>

<p>В F# вся эта магия реализуется <em>инфиксным</em> оператором « или » у которых оба параметра — функции.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = fun a -&gt; a + 5
let y = fun b -&gt; b * 2
let chtoproishodit = x &lt;&lt; y

printfn "%d" (chtoproishodit 5) // посчитает: 5 * 2 + 5 = 15

let ostanovitespojaluista = ((fun y -&gt; y * 20) &lt;&lt; (fun x -&gt; x - 1)) 2 // посчитает: 2 - 1 * 20 = 20 
</code></pre></div></div>

<p>Всё просто же? Как сказано выше, можно передавать функции в другом порядке с помощью »</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let vseyasno = x &gt;&gt; y // vseyasno 3 = y ( x(3) ) = y ( 8 ) = 16  
</code></pre></div></div>

<h3 id="каррирование">Каррирование</h3>

<p>Или — <em>частичное применение функций</em>.</p>

<p>Это когда мы передаем функции <em>неполное число аргументов</em>, и в результате получаем… что? функцию!</p>

<p>Как уже говорилось в предыдущем посте по теме, все функции в F# имеют <strong>только один аргумент</strong>, когда мы кортежем передаем несколько аргументов, это по сути (формально) работает как применение функций одного аргумента ко всем аргументам из списка поочередно.</p>

<p>Вот такая каррированая функция f a будет ждать на вход один параметр b:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let f x = fun b -&gt; b * x 
let mul5 = f 5
</code></pre></div></div>

<p>Понятно, что вызвав mul5 2 получится 10. В F# допускается ещё более краткая запись без fun:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let f x b = b * x 
</code></pre></div></div>

<p>Работать будет точно так же.</p>

<h2 id="нужно-больше-операторов">Нужно больше операторов!</h2>

<p>Тут можно делать свои операторы, а не только функции (сейчас какой-то душный человек вспомнит что оператор тоже функция и пойдет поедет. Я ― помню).</p>

<p>Для определение своих <em>инфиксных</em> операторов нам доступны следующие символы:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>! % &amp; * + - . / &lt; = &gt; ? @ ^ | ~
</code></pre></div></div>

<p>А для <em>префиксных</em> такие последовательности:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ - +. -. &amp; &amp;&amp; % %% ~ ~~ ~~~ ~~~~
</code></pre></div></div>

<p>Объявление таких операторов нужно делать через скобочную нотацию: (оператор) для инфиксных, и (~оператор), соответственно для префиксных.</p>

<h2 id="операторы-применения-функций">Операторы применения функций</h2>

<table>
  <tbody>
    <tr>
      <td>Есть два таких оператора: “</td>
      <td>&gt;” и “&lt;</td>
      <td>”, они отправляют значение вправо или влево.</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>Выражение x</td>
      <td>&gt; y и выражение y &lt;</td>
      <td>x будут означать одно и то же — “y x”.</td>
    </tr>
  </tbody>
</table>

<p>Но важный момент в том, что ассоциация этих операторов <strong>левая</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 |&gt; 2 |&gt; (+) 
</code></pre></div></div>

<p>приведет к ошибке, когда:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 |&gt; (2 |&gt; (+)) 
</code></pre></div></div>

<p>сработает.</p>

<h2 id="ещё-раз-про-кортежи">Ещё раз про кортежи</h2>

<p>Итак, мы знаем что с помощью кортежей мы можем схитрить и передать в функцию больше одного аргумента.</p>

<p>Кортежи могут объединять в себе значения разных типов, это ок. И это потенциально очень мощный инструмент. Рассмотрим несколько фишек.</p>

<h3 id="фишки-первого-уровня">Фишки первого уровня</h3>

<p>Значения типов в кортежах перевариваются в F# как объекты первого класса. Мы можем использовать их в выражениях, и получать как результат других выражений.</p>

<p>Можно использовать в качестве элемента кортежа уже связанное ранее значение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = (10, "hello")
let b = (a, 100.500)
</code></pre></div></div>

<p>Последний кортеж получится типа: ((int * string) * float)</p>

<p>Вычисляются кортежи по порядку слева-направо, и кортежи можно сравнивать, но только если совпадают значения типов их элементов (в том же порядке):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(5 = 2, "hello", 1 + 1) = (false, "hello", 2) // правда!
(5 = 2, "hello", 1 + 1) = ("friend", (10.5, 18)) // парень, не дури, типы не совпали.
</code></pre></div></div>

<p>“Легальное” сравнение (когда с типами всё ок), происходит в лексикографическом порядке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(29, 14, 100) &gt; 11, 0, 101 // не правда!
</code></pre></div></div>

<h3 id="кортеж-как-шаблон">Кортеж как шаблон</h3>

<p>Мы можем сделать кортеж состоящий только из идентификаторов:
    let (x, y) = (10, 200) // x = 10, y = 200</p>

<p>С помощью чего потенциально можем сопоставлять идентификаторы и значения.</p>

<p>Помните паттерн матчинг? Тут можно так же использовать идентификатор “_” для сопоставления с любыми значениями:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let (_, y) = (1, 2) // y = 2
</code></pre></div></div>

<h3 id="превращение-в-овцу">Превращение в овцу</h3>

<p>Это про полиморфизм, кто не понял :)</p>

<p>Пример полиморфной функции с кортежем — функция swap:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let swap (x, y) = (y, x)
</code></pre></div></div>

<p>Она меняет значения внутри кортежа местами, и типы её параметров полиморфны, то есть определяются другими типами.</p>

<p>Полиморфный тип, это такой тип, операции над которым могут нормально применяться к другим типам.</p>

<p>В F# полиморфным типом выступает базовый тип .NET System.Object, таким образом тип функции swap будет:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.Object  * System.Object -&gt; System.Object * System.Object
</code></pre></div></div>

<h2 id="рефлексия">Рефлексия</h2>
:ET