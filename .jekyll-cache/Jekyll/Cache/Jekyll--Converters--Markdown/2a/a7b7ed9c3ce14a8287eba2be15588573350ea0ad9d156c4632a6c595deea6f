I"U:<!--more-->

<h2 id="вместо-введения">Вместо введения</h2>

<p>Функциональное программирование как парадигма основывается на концепции функций первого класса, о которой вкратце я уже писал <a href="/2022/03/08/hack_in_declarative_model_5.html">здесь.</a></p>

<p>А вообще, функциональное программирование это <em>частый случай</em> декларативного подхода. В функциональном программировании тоже нет растянутых во времени состояний (переменных), значения которых хранятся и могут переопределяться когда вздумается.</p>

<p>Таким образом, функции в ФП понимаются не как какие-то подпрограммы или методы, а скорее <em>математически</em>. В программном смысле такие функции можно представить как конвейер, который преобразует входное значение в выходное. Впрочем все это уже нам знакомо из изучения декларативной модели.</p>

<p>Здесь же я хочу подчеркнуть взаимосвязь понимания времени, и именованных состояний. В разных парадигмах программирования время представляется по разному. Мы рассматриваем здесь время как некое абстрактное понятие, которое выражает последовательность именованных значений (именованных состояний, переменных).</p>

<p>Так вот, в функциональном программировании и декларативной модели время непрерывно — значения вычислений как бы перетекают в другие вычисления, до тех пор пока не будет получен итоговый результат.</p>

<h2 id="mr-gordon-freeman-alonzo-church">Mr. <del>Gordon Freeman</del> Alonzo Church</h2>

<p>Может сложится впечатление, что функциональное программирование это просто некоторая реализация декларативной парадигмы. Но это не так! Функциональное программирование фактически отдельная, самостоятельная парадигма программирования, основанная на математической теории, а точнее — на формальной системе, которую разработал Алонзо Чёрч в <del>далекой-далекой галактике</del> сороковых годах!</p>

<p>В это систему Чёрч заложил две основные операции:</p>
<ul>
  <li>Аппликация функции — это про применение (по сути вызов) функции с каким то значением. И хотя в математике итак есть обозначение подобного например как f(a), в лямбда исчислении вся фишка в том что f трактуется не просто как функция, а как <em>алгоритм</em> который вычисляет результирующее значение, где a — входное значение.</li>
  <li>Абстракция — если не вдаваться в математическую мудрость, это способ определения выражений. Ну, то есть, это определение того, что там функция f на самом деле внутри вычисляет. Если хотите — определение <em>алгоритма</em>.</li>
</ul>

<p>Кстати, Чёрч был научным руководителем Алана Тьюринга :)</p>

<p>Давайте ещё проще. Лямба-исчисление эта не меньше чем <em>полноценный</em> язык программирования, в котором нет <em>ничего</em> кроме простых функций — функций от <em>одного аргумента</em>.</p>

<p>На практике же, в функциональных языках программирования в функцию можно передавать больше одного аргумента, но делается это с помощью кортежей, то есть с точки зрения математической модели это всё ещё один аргумент, и не важно что внутри него может быть несколько значений.</p>

<p style="text-align: center;"><img src="/images/i-know-lambda-calculus.jpg" alt="Neo knows Lambda-calculus" /></p>

<h2 id="ближе-к-делу">Ближе к делу</h2>

<p>С функциональным программированием я сейчас знакомлюсь в рамках курса по изучению языка F#, который родом из семейства языков MetaLanguage (строгие языки ФП). Это синтаксически минималистичный язык (ещё бы…), но тут есть всё что нужно, чтобы писать полноценные программы: типы, функции, выражения и вычислительные выражения.</p>

<p>Типизация, разумеется, строгая статическая.  Функции же тут являются таким же базовым типом данных (функции первого класса), а вся программа является единым выражением (выше я уже говорил про “конвейер”). Получается что программа состоит не из операций присваивания и команд, а из <em>применения функций к аргументам</em> — аппликаций.</p>

<p>В F# функции как тип данных определяются типом аргумента, передаваемого этой функции, и типом результирующего значения, которые перечисляются через стрелку “-&gt;”.</p>

<p>А сами функции определяются, например, так:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  let multiply3 N = N * 3
</code></pre></div></div>
<p>Здесь <em>multyply3</em> — идентификатор (имя) функции, а N её единственный аргумент. Получается что тип этой функции будет таким: “int -&gt; int”. Имя функции можно не задавать, определив тем самым так называемую <em>анонимную</em> функцию, или <em>лямбда-функцию</em> с помощью ключевого слова <em>fun</em> (a lot of!). Та же самая функция с применением анонимной-функции может быть записана так:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  let multiply3 = fun N -&gt; N * 3
</code></pre></div></div>
<p>Видите разницу? Идентификатору multiply3 мы присваиваем результат вычисления анонимной функции, у которой N аргумент, и после стрелки -&gt; выражение, которое эта функция вычисляет.</p>

<h3 id="нужно-построить-зиккурат">Нужно построить Зиккурат</h3>

<p>Очевидно, что есть множество случаев, когда мы хотим передать в функцию более одного значения, но аргумент может быть одним. Если вы не рыба, то помните что это мы уже затронули.</p>

<p>Кортежи в F# обозначаются так же как во многих других языках — с помощью круглых скобок. Скажем нам нужна очень сложная функция, которая перемножает три целых числа между собой:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  let toughcalc (a, b, c) = 
    let firstmul = a * b
    firstmul * c 
</code></pre></div></div>
<p>Конечно можно было сразу перемножить a * b * c, но в данном примере хочется подчеркнуть то, что результирующем значением функции будет значение <em>последнего</em> выражения в её теле. Тип этой функции будет “int * int * int -&gt; int”. Да, компилятор нормально понимает когда мы передаем несколько значений через кортеж, и значения типов таких составных аргументов записываются через “*”.</p>

<p>Если мы вкорячим последним выражением какой нибудь printfn “helloworld”, тип функции станет “int * int * int -&gt; string”. Если последним выражением мы поделим результат перемножений на 0.2, тип снова изменится на “int * int * int -&gt; float”, и так далее.</p>

<h2 id="имхо--вишенка">Имхо — вишенка</h2>

<p>Pattern matching — это очень-очень круто! Что же это за колдовство? В общем, мы можем определить в функции некоторый набор вариантов выбора (clause), и жаль что такой финт есть не во всех языках программирования. В императивных языках бывают такие штуки как switch/case, но pattern matching куда круче, и идет дальше.</p>

<p>Функция, поддерживаются сопоставление с образцом начинается с ключевого слова <em>function</em>. Варианты для сопоставления аргумента (или аргументов), перечисляются через символ |, после которого задается шаблон проверки, и следом за стрелкой (“-&gt;”) соответствующий шаблону результат.</p>

<p>Например:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  let johnDoe = function
   | "age"   -&gt; "69"
   | "hobby" -&gt; "story telling"
   | "diagnosis" -&gt; "ASPD"
</code></pre></div></div>
<p>Во-первых, тип — string -&gt; string. И как видите, аргумент явно не указан, у него нет имени, нам это и не нужно. Да, так можно :)
Во-вторых, обратите внимание что 69 явно записано в кавычках, дабы быть не int, а string. В противном случае мы получим ошибку компилятора, который будет ругаться что результирующие типы шаблонов не соответствуют друг другу.</p>

<table>
  <tbody>
    <tr>
      <td>Мы можем указывать универсальный паттерн (если другие условия не сработали), или множество вариантов с помощью or-паттерна (через “</td>
      <td>” друг за другом), выглядит это так:</td>
    </tr>
  </tbody>
</table>

<p>let johnDoe = function
   | “age” | “vozrast”         -&gt; “69”
   | “hobby” | “che delart”    -&gt; “story telling”
   | “diagnosis” | “bolyachka” -&gt; “ASPD”
   | _                         -&gt; “no data”</p>

<hr />

<p>В качестве шаблона мы можем задать некоторый внутренний для функции идентификатор, который автоматически будет связан с проверяемым значением:</p>

<p>let minus1 = function
   | 0 -&gt; 0 
   | n -&gt; n - 1</p>

<p>В F# pattern matching поддерживается так-же и как отдельная операция match, которая допускает указывать дополнительные логические условия в вариантах сопоставления после ключевого слова when:</p>

<p>let tendToZero n = match n with
   | 0 -&gt; 0
   | n when n &gt; 0 -&gt; n - 1
   | n when n &lt; 0 -&gt; n + 1</p>

<h3 id="эпилог">Эпилог</h3>

<p>Пока, из того что я выучил в ФП и F#, pattern matching мне показался наиболее интересной киллер фичей. Разумеется тут можно определять рекурсивные функции (надо перед идентификатором функции добавить rec), если логические условия if\then\else\elif и так далее, но всё это привычно и, наверное, писать об этом не очень интересно.</p>

<p>Сопоставление с образцом есть не во всех языках, но его пытаются завезти. Например в прошлом году его <a href="https://habr.com/ru/company/yandex_praktikum/blog/547902/">донесли в пайтон</a>, но нужен ли он там и использовать ли — решайте сами.</p>

<p>Миру мир!</p>
:ET