I"<p>Часть 2. Декларативное программирование и рекурсия.
<!--more--></p>

<p>Здравствуйте! Мы продолжаем изучать декларативную вычислительную модель. На этой неделе я добрался до более практичных тем, и начну рассказывать вам о том, как собственно устроено программирование в декларативном “стиле”.</p>

<p>В прошлый раз мы разобрали декларативную модель с теоретической точки зрения, и в общих чертах должны хорошо понимать её внутреннее устройство.</p>

<h2 id="польза-декларативной-модели">Польза декларативной модели</h2>
<h4 id="детерминированный-конструктор">Детерминированный “конструктор”</h4>
<p>Одна из главных крутостей декларативного программирования заключается в том, что декларативные программы <strong>композиционны</strong>. Это значит, что программа состоит из некоторых <em>компонентов</em>, каждый из которых, благодаря заложенным в вычислительной модели принципам, является строго и ясно ограниченной частью программы.</p>

<p>В декларативной программе каждый компонент всегда хорошо различим, у него есть определенные входы и выходы. При этом компонент не обязательно является “малым” фрагментом кода, функций или процедурой. Процедура лишь частный вид компонента, и в более “сложном” компоненте могут быть определены другие, сохраняя всю декларативную ясность и мощь.</p>

<p>Композиционность достигается благодаря свойственным декларативной модели качествам. Напоминаю, мы не используем “динамические переменные”, не храним внутренние состояния процедур\функций, не передаем их куда-то вовне. Получается что компоненты, “сущности сами в себе”, или по русски — независимые сущности. Выход из одной декларативной операции становится входом для другой, сайд-эффекты, фактически — невозможны.</p>

<p>Благодаря этому качеству в декларативной модели мы можем разрабатывать сложные и <em>надежные</em> системы.</p>

<h4 id="ясно-понятно">Ясно, понятно</h4>

<p>Вторая сила декларативного программирования вытекает и связана с первой — декларативные программы достаточно просты для понимания. Мы можем легко рассуждать о них сквозь призму, например, логического анализа. Чтобы понять программу в целом, нам нужно лишь понять все её компоненты.</p>

<hr />

<p>Исходя из этого мы можем предположить, что можно забить на все остальные вычислительные модели, хорошо разобраться в декларативной, и все программы описывать только в ней. Жаль что это невозможно. Если бы все было так просто, то другие модели бы просто не появились. Дело в том, что задачи бывают разные, и для их решения подходят разные парадигмы.</p>

<p>Но хорошая новость в том, что на уровне разработки (написания) кода отдельных функций или модулей (ещё это называется <em>programming-in-small</em>), декларативный стиль применять можно <strong>всегда!</strong>.</p>

<p>На самом деле так <strong>нужно</strong> поступать. Это залог хорошего продукта не только в виде отдельных программных модулей, но и качественной программной системы в целом (<em>programming-in-large</em>).</p>

<p>Компоненты не должны иметь лишних связей, потому что это приводит к запутыванию и усложнению системы. В такой ситуации мы не можем говорить о композиционности или понятности. Как разобраться в отдельной части, если она явным образом зависит от кучи других? А те, в свою очередь, от кучи других? А если не явным? Брррр.</p>

<p>Другие вычислительные модели, свойством которых является тесная связь многих компонентов, <em>нужно использовать изолировано и в ограниченном количестве модулей</em>. Мы пытаемся, как-бы, “компонизировать” части системы со сложными связями, чтобы сами эти части становились <strong>декларативными компонентами</strong>.</p>

<p>Вот вам новая мантра:</p>

<p class="info">Я делаю как можно больше компонентов системы декларативными.</p>

<p>Говорят, если повторять её каждый раз когда садишься программировать, и применять на практике — станешь хорошим инженером.</p>

<h2 id="рекурсия">Рекурсия</h2>

<p>Как много будоражащего ум в этом слове (пока не разобраться :) ). 
Помню в детстве я сидел в парикмахерской, и места там были напротив друг друга у противоположных стен, и зеркала соответственно. Слово рекурсия я тогда не знал, но залип <em>глубоко</em> и надолго.</p>

<p>В программировании рекурсией называют прием, когда</p>
:ET