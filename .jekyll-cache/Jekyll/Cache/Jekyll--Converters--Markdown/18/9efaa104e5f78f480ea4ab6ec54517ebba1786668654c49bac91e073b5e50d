I"x'<p>Рассматриваем пару универсальных принципов разработки.
<!--more--></p>

<h3 id="лучше-сухо-чем-мокро">Лучше сухо, чем мокро!</h3>

<p>Аббревиатура принципа DRY расшифровывается как Don’t repeat yourself, что недвусмысленно переводится как “Не повторяйся”. Само сокращение является словом dry — сухой, и нарушение принципа окрестили как WET (мокрый) — Write everything twice (Пиши всё дважды) или We enjoy typing (Нам нравится печатать).</p>

<p>Разумеется уровень влажности тут вообще не при чем :)</p>

<p>Вероятно вы уже встречали упоминание DRY. О нем часто говорят в бесплатных и платных уроках программирования, но как правило речь только в контексте написания кода (programming-in-small).</p>

<p>На самом деле этому универсальному принципу можно, и обязательно нужно, следовать на всех уровнях проектирования системы.</p>

<h1 id="я-никогда-не-повторяюсь">Я никогда не повторяюсь</h1>
<h3 id="неповторим-внутри">Неповторим внутри</h3>

<p>Как я уже сказал, чаще всего DRY преподносят как правило, при котором мы не должны повторно использовать (копировать) код, в разные части программы. Это лишь малая доля. Фишка в том, что DRY применим к любой сущности в системе, на любом уровне абстракции.</p>

<p><em>Если что-то где-то определено, оно должно быть определено только в этом месте.</em></p>

<p>А что касаемо кода, то бывают случаи когда дублирование <em>оправдано</em>. Например есть две высокоуровневые функции (методы), которые производят <em>похожие</em> вычисления, но в разном контексте, и служат разным целям (всякие проверки истинности, etc).</p>

<h3 id="неповторим-снаружи">Неповторим снаружи</h3>

<p>В проектировании (programming-in-large) DRY работает аналогично. Во-первых, если есть какой-то конкретный модуль, то его спецификация должна быть единообразной и находиться в одном месте.</p>

<p>Это значит, что нельзя просто копировать этот модуль, немного его изменять, и встраивать в систему. Тогда в будущем при доработке, в случае изменений одного такого “модуля-клона”, нам придется менять то же самое и во втором. А если копий три, четыре…? Вы точно думаете что сможете вспомнить о них всех, я не говорю уже о совершенно очевидном неудобстве такой архитектуры. Это полный зашквар, не надо так делать.</p>

<p>Во-вторых, программные интерфейсы модулей (api) тоже должны быть единообразными, следовать спецификации. Представьте что “внутри” модули используют по разному описанные вызовы. Внешние вызовы тоже накостыляли по другому. Чувствуете аромат? Так пахнет горячая точка опоры, когда система рухнет из за того что мы поменяли один интерфейс, или забыли поменять один из них.</p>

<p>Во избежание этого, можно использовать OpenAPI, или что-то в таком духе. Если мы разрабатываем собственный API, он должен быть корректно задокументирован и доступен <strong>в одном месте</strong> (например выложен на гитхаб).</p>

<h2 id="что-и-тут-тоже">Что, и тут тоже?</h2>

<p>Мы плавно подошли к документации. Многие разработчики не любят документировать проекты, и это <strong>плохо</strong>. А если и ведут документацию то относятся к этому очень халатно. Ctrl-c, Ctrl-v. Тяп ляп.</p>

<p><em>Документация тоже должна следовать принципу DRY</em>.</p>

<p>На уровне комментариев кода (это ведь тоже документация), пример WET-поведения — зачем-то описывать подробными комментариями чуть ли не каждую функцию в коде. Ясный код должен говорить сам за себя и быть понятен читающему программисту (например вам самим, через неделю), так зачем повторяться, разве что код выглядит запутанным и совершенно непонятным?  Если так, то это нужно исправлять в первую очередь.</p>

<p>На уровне документирования проекта — мы должны структурировать документы понятно, излагать информацию последовательно и, простите за тавтологию — <em>информативно</em>. Документация это не удобный случай поупражнять в графомании.</p>

<p>На самом деле писать код и писать текст по сути одно и то же, разве нет?</p>

<p>Вы можете подойти к проблеме написания документации почти так же, как к программе. Ну вот она ваша до боли скучная цель. Декомпозируйте её! Если вы хорошо понимаете документированный проект то это не вызовет проблем. Каждый модуль, согласно DRY, описывается в одном разделе документации, API в другом, etc.</p>

<h1 id="легко-поменять">Легко поменять</h1>

<p>Ещё один очень важный принцип, залог, хорошего проектирования — <strong>ETC</strong>, или Easier to change!</p>

<p>Мы все люди, и нам свойственно ошибаться в своих решениях. Разумеется и в разработке программных систем. Поэтому очень важно создавая что-то новое, или внося изменения в уже существующие части всегда задаваться вопросом — “А будет ли в будущем это <em>легко изменить</em>?”</p>

<p>Подумайте, будет ли легко вносить изменения в проект, в котором строго следуют “сухому закону” DRY? (Я пытаюсь шутить, извините!)</p>

<p>Разумеется будет!</p>

<p>Этому принципу осознанности ETC нужно следовать даже (особенно!) в самых малых частях разработки, вплоть до написания функции из нескольких строк кода. Будет ли она легко заменимой, исправляемой? Ясно ли она описана?</p>

<hr />

<p>Верно утверждать что принцип DRY является логическим продолжением ETC. Вообще <em>любой</em> подход хорошего проектирования исходит из ETC. Например, использование понятных имен переменных и функций непосредственно упрощает дальнейшее сопровождение кода.</p>

<p>А если мы будем как можно больше компонентов делать <a href="/2022/02/12/hack_in_declarative_model_2.html">декларативными</a>, это поможет? Да! Архитектура будет менее запутанной, с меньшей <em>связностью</em>, и следственно более удобной в сопровождении.</p>

<p>Куда не глянь, если что-то сделано хорошо, это сделано осознанными в ETC инженерами!</p>

<p>Можно уйти в словоблудие и сказать, что оба эти принципа применимы не только как ценности проектирования программных систем Но я оставлю это вам как пищу для размышления.</p>

:ET