I"J\<p>Врубаемся в Декларативную модель — Часть 3. 
<!--more--></p>

<h3 id="here-we-go-again">Here we go again</h3>
<p>Здравствуйте! Это очередной пост-отчёт по мотивам материала из курса <a href="https://skillsmart.ru/">школы Сергея Бобровского</a> – Как понять в программировании всё. Изучаем декларативную вычислительную модель.</p>

<p>В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.</p>

<p>Рекурсия как программистский трюк не ограничивается “самовызовом” (прочитали как самовывоз, признайтесь?) функций — <em>рекурсивными могут быть и типы данных</em>. Базовый пример рекурсивного типа данных — список.</p>

<p>Почему список на самом деле рекурсивная структура? Потому что он определяется <em>в терминах более короткой версии себя самого</em>.</p>

<p>Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и <em>“список”</em>, а лучше сказать набор или “последовательность” пар “ключ-значение”.</p>

<p>Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список.</p>

<p>Как правило этими “произвольными” значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка “впихнуть” в эти “кусочки” какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда).</p>

<p>Части списка связанны некоторым образом с другими, и всё вместе (“элементарный кусок данных” и связь-указатель на другой) называется <em>узел</em>.</p>

<p>В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.</p>

<p>Вернемся к фундаментальным материям :)</p>

<p>В декларативной модели список определяется <em>рекурсивно</em>. Считается, что либо список пустой (nil или, если хотите, None), либо <em>есть какое-то значение связанное со списком</em>.</p>

<p>Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, “узел” содержащий строку “shrek”, то тогда список X будет равен “shrek” <em>связанный со списком nil</em>!</p>

<p>Короче говоря, “последний” элемент в списке всегда будет “указывать” на “пустой список”.</p>

<p>Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.</p>

<p>В рекурсивных функциях, работающих со списками, <em>базовым случаем</em> будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов <em>более мелких списков</em>.</p>

<p>Например, “декларативная” рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list_length(some_list):
    if some_list == []
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    return 1 + list_length(list_tail)
</code></pre></div></div>

<p>Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — “Ух ты ж сколько можно то намутить с этим списком!”</p>

<p style="text-align: center;"><img src="/images/hold_on.gif" alt="Подождите!" /></p>

<p>Это всё ещё рекурсивная функция, мы в прошлый уже говорили про проблему с переполнением стека. Кроме того, рекурсивные функции со списками, при их необдуманном определении, вполне могут оказываться крайней не эффективными — O(n*n) или ещё хуже.</p>

<p>Для решения этих проблем есть техника, при которой рекурсивные функции превращаются в функции с <em>итеративной формой вычисления</em> с <strong>линейной</strong> эффективностью!</p>

<h3 id="итерируй-то">Итерируй то</h3>

<p>Ранее мы говорили про итеративные вычисления как о частном случае рекурсии. Разберемся чуть глубже.</p>

<p>Во-первых стек. Почему он вообще формируется при рекурсивном вызове? Обратите внимание на пример функции вычисления длинны списка, а именно на хвостовой return в конце. Раз за разом при рекурсивном вызове окружение экземпляра функции должно сохраняться в стеке, потому что прибавление единицы происходит <strong>после</strong> этого заключительного return.</p>

<p>В нашем примере это всё происходит лишь для того, чтобы потом в обратном порядке “размотать” стек и просуммировать единцы. Кажется избыточным.</p>

<p>Чем отличается итеративное вычисление от обычной рекурсии?</p>

<p>Схема итеративных вычислений — это <em>последовательность <strong>трансформации состояний</strong></em>. Как это работает?</p>

<p>Ну, по сути, мы добавляем некоторый счетчик в аргумент рекурсивной функции, и делаем так чтобы увеличение этого счетчика <em>происходило <strong>до</strong> рекурсивного вызова</em>.</p>

<p>Рекурсивная-итеративная функция вычисления длины списка будет выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
</code></pre></div></div>

<p>Обратите ещё раз внимание на счетчик <em>i</em>. Мы увеличиваем его в аргументах рекурсивного вызова, <strong>до</strong> самого вызова. Благодаря этому мы “замыкаем” окружение функции и состояние каждого экземпляра не требуется сохранять в отдельных записях в стеке.</p>

<p>Ничего не мешает скрыть такую функции за функцией-абстракцией, которая будет принимать только list, а внутри вызывать inter_list_length(0, list).</p>

<h3 id="итерируй-это">Итерируй это</h3>

<p>Видите как связана “рекурсивность функции” с “рекурсивностью типа”, который она обрабатывает?</p>

<p>Это <strong>важная фишка</strong>.</p>

<p>Мы уверенно можем сказать, что <em>рекурсивная структура функции зависит от рекурсивной структуры определения обрабатываемого типа данных</em>.</p>

<p>Мы потенциально можем нагородить какой угодно рекурсивный тип, но это не есть хорошо. Эта свобода в программировании часто приводит к написанию очень неэффективных, не грамотных алгоритмов.</p>

<p>Само по себе определение какого-то типа данных в языке программирования <em>описательно</em>. Это значит, что такое определение является всего лишь набором логических утверждений о множестве значений, который данный тип может принять. Такие определения не являются полноценными проверками допустимостей значений, а зачастую (например какой нибудь абстрактный тип) их вообще проверить нельзя.</p>

<p>В декларативной модели даже базовые типы могут быть не проверенны компилятором. Поэтому нам <strong>важно</strong> предельно осознанно понимать что мы кодим, и использовать изначально свойственные декларативной модели типы данных.</p>

<p>Список это very handy! Надо лишь включить думалку, и включить так, чтобы избежать неэффективных реализаций алгоритмов.</p>

<p>Вернемся к нашему определению взаимосвязи рекурсивности типа с рекурсивностью функции.</p>

<p>Сперва нам необходимо <em>правильно определить рекурсивный тип</em>, прежде чем писать для него функцию. Что это значит?</p>

<p>Например, у нас есть некий композитный список, элементы которого тоже могут быть списками, и нам надо посчитать количество всех значений, включая значений во вложенных списках.</p>

<p>Нам нужно понять, или <em>определить</em> тип “вложенный список”.</p>

<p>Мы помним что “список” — это либо пустой [], либо некоторый “элемент” связанный с [].</p>

<p>В таком случае “вложенный список” будет определяться как — либо пустой [], либо “вложенный список” связанный с “вложенным списком”, либо как “элемент” связанный с “вложенным списком”. Ничего не понятно?</p>

<p>Короче говоря, у нас в любом порядке и в “ширину” и в “глубину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых в любом порядке и в “глубину” и в “ширину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых…</p>

<p style="text-align: center;"><img src="/images/recursion_1.gif" alt="Рекурсия" /></p>
<p><em><center>Неотложка уже выехала.</center></em></p>

<p>Так, давайте не будем пороть горячку! Это проще чем кажется.</p>

<p>Вложенный список, с которым может быть связан вложенный список, все ещё “обычный” список, который может быть пустым (то есь может “не быть”! Ом!) Мы с этого и начали определение.</p>

<p>Тогда функция, основанная на таком типе будет иметь структуру:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>length_1(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if type(some_list) is list:
        return length_1(list_head) + length_1(list_tail)
    
    return 1 + length_1(list_tail)
</code></pre></div></div>

<hr />

<p>А если структура типа будет другой? Функция будет иметь <em>другую</em> логику. К примеру у нас есть тип подобный предыдущему, но нам не важно количество элементов во вложенных списках, и мы хотим лишь посчитать элементы на “верхнем” уровне. Не важно — является этот элемент списком или нет.</p>

<p>Поймите, речь идет о <em>логическом</em> определении типа.</p>

<p>В таком случае тип “вложенный список 2” мы будем определять как — либо пустой [], либо “вложенный список 2” связанный со “вложенным списком 2”, либо как <em>элемент “верхнего” уровня</em>.</p>

<p>Ключевое отличие с прошлым примером в том, что тогда “вложенный список” всегда считался списком, а на этот раз он может считаться как простой элемент.</p>

<p>Функция:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>length_2(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if list_tail == []:
        return 1
    
    return length_2(list_head) + length_2(list_tail)
</code></pre></div></div>

<p>Ключевой момент тут это проверка list_tail == [], суть которого в том, что если рекурсия добралась до случая, когда хвост элемента является пустым списком мы возвращаем единицу, как бы “забивая” на то, что “проваливались” во вложенный список.</p>

<hr />

<p>Эти простые примеры приводятся как пример для понимания способа которым мы должны мыслить о рекурсивных вычислениях в декларативной модели. Почему нам всегда важно понимать логику алгоритма, и учитывать структуру рекурсивного типа, с которым работаем.</p>

<p>Декларативная модель дает нам мощный и изящный инструмент — <em>минималистичность</em>, которым можно и нужно пользоваться при разработке алгоритмов (если это возможно). Декларативная модель удобна и исключает множество потенциальных ошибок, если мы четко определяем типы и понимаем что делаем.</p>

<h3 id="аккумуляторы">Аккумуляторы!</h3>

<p>На этом моменте мы уже выяснили как писать рекурсивные функции, делать из них итеративные и как корректно определять и применять рекурсивные типы данных. Так а зачем тогда рекурсивные функции? <em>А не зачем</em>.</p>

<p>В боевой разработке с использованием декларативной модели функции <em>сразу пишут итеративными</em>! Мы разобрали эти тонкости сугубо в целях понимания и изучения.</p>

<p>Давайте повторим для закрепления. Вся фишка итеративных вычислений в <em>передаче значения</em> все “глубже” в рекурсию. Мы никогда не возвращаемся обратно с помощью return.</p>

<p style="text-align: center;"><img src="/images/buzz.gif" alt="Базз" /></p>
<p><em><center>Ну или пока память не кончится :D</center></em></p>

<p>Отставить шуточки! Как это работает?</p>

<p>Возьмем состояние, которое передаем в функцию как S. Возьмем это состояние и расширим двумя аргументами, S1 и Sn.</p>

<p>Такой финт называется — <em>аккумулятор</em>.</p>

<p>Мы берем этот аккумулятор и передаем его в <strong>процедуру</strong> (не функцию!). В первом посте мы говорили о том, что декларативная процедура работает в своих параметрах с указателями на ещё <em>не инициализированные</em> декларативные переменные. Иными словами, результат работы процедуры возвращается через эти параметры <em>по ссылке</em>.</p>

<p>В аккумуляторе: S1 является входным состоянием, а Sn — выходным, то есть результатом. Внутри такой процедуры происходит её рекурсивный вызов выполняющий последовательные преобразования Si в Si+1 (итеративные, тысяча чертей!!!)</p>

<p>Псевдокод:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>procedure(S, S1, Sn):
если вычисления S не требуются:
    Sn = S1
иначе:
    ## начинается блок рекурсивных вызовов
    procedure1(S1, S2)
    procedure2(S2, S3)
    ...
    procedureN(Sn-1, Sn)
</code></pre></div></div>

<p>Выход каждой procedureI является входом procedureI+1</p>

<p>Как уже объяснялось, отличие от рекурсивной функции в том, что нам не надо сохранять в стеке все промежуточные состояния-вызовы, так как значения передаются по ссылке. А “базовым случаем-ограничением” рекурсии, может быть указание границы обработанных элементов в исходной структуре S.</p>

<p>Когда мы в этом посте разбирали итеративные вычисления на примере функции iter_length:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
</code></pre></div></div>

<p>Мы практически использовали <em>схему с аккумулятором</em>, передавая текущую длину в следующий вызов <em>по ссылке</em>.</p>

<hr />

<p>Фактически в наши дни такая схема с аккумуляторами считается устаревшей, и их чрезмерное использование лишь затруднит программирование.</p>

<p>Схема с аккумуляторами имеет право на жизнь, когда получается ограничиться минимальным количеством аккумуляторов (1-2).</p>

<p>Тем не менее, пользу от знания таких фундаментальных приемов невозможно переоценить в контексте прокачки нашей аналитической и программистской машинки мозга.</p>

<p>И вот ещё повторим — хотя в итеративных вычислениях мы не проваливаемся в стек “в глубину”, память потенциально может кончиться ещё как! Мы “разматываем” состояние “в ширину”.</p>

<p>Спасибо за внимание.</p>

:ET