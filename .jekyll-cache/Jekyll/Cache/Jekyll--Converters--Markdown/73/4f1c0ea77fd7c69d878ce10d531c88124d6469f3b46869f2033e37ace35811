I"\7<p>Продолжаем знакомиться с Go. Зачем Google разработал новый язык, и чем вдохновлялись разработчики?</p>

<!--more-->

<p>В прошлой заметке о <a href="2022/01/23/go_language.html">первом знакомстве с Go</a> я очень сжато и сумбурно описал первые впечатления об этом языке программирования.</p>

<p>За минувшую неделю я в увереном темпе прошел первый курс по Go на coursera из <a href="https://www.coursera.org/specializations/google-golang">этой</a> специализации. Сложность заявлена как intermediate, и это похоже на правду. В четырех модулях были рассмотрены основные концепции языка, синтаксис, структуры данных и core features.</p>

<p>В небольших практических задачах нас знакомят с основными модулями, содержащими методы для работы со строками, вводом-выводом, и json’ами. Дается емкое объяснение того как работает сборщик мусора и указатели. Если вы не полный ноль в программировании то послее этого короткого курса довольно бегло сможете начать работать на Go. Хочу отметить что я уже отсмотрел лекции из первого модуля второго курса — <a href="https://www.coursera.org/learn/golang-functions-methods?specialization=google-golang">Functions, Methods, and Interfaces in Go</a> и тут уже начинаются более интересные и качественные вещи.</p>

<p>Например, меня отдельно порадовало то, что во тут профессор Ирвин подчеркивает важность нейминга и “чистоты” функций. В первом знакомстве я обмолвился что по неведомой причине в сообществе разработчиков Go всё ещё считается нормой однобуквенный нейминг, и прочая ересь. Это лютая жесть и полный баттхёрт.</p>

<p>Я не преследую цель пересказывать весь первый курс тут, вы можете бесплатно его посмотреть на курсере, пусть и без доступа к задачкам и тестам — не много потеряете. В целом рекомендую как отправную точку в Go, я ничуть не жалею о потраченном времени, и материал подается явно попроще, но ничуть не хуже чем в A tour of Go. Эти материалы отлично дополняют друг друга.</p>

<p>По 2 и 3 курсу я обязательно выберу какую-то тему, которую освящу отдельным постом, например интерфейсы. В этот раз я предлагаю вам чуть больше информации об истоках языка и некоторых концепциях заложенных в нем.</p>

<h3 id="люк-я-твой-отец">Люк, я твой отец</h3>

<p>Я уже упоминал фразу, что  “Go это Си на стероидах”. Называть его может кто угодно и как угодно, но по внутреннему устройству это вообще новый язык, и помимо Си на Go оказали влияние и другие “<em>родословные</em>” языков программирования.</p>

<p>Go пытается заимствовать лучшие идеи и парадигмы, при этом его создатели старались достичь максимальной семантической выразительности кода.</p>

<p>От Си язык Go унаследовал:</p>
<ul>
  <li>Синтаксис выражений;</li>
  <li>Конструкции управления потоком;</li>
  <li>Базовые типы данных (но с некоторым расширением);</li>
  <li>А так же передачу параметров <em>по значению</em> и указатели.</li>
</ul>

<p>Вторым деревом предков являются языки Никлауса Вирта, начиная с самого Паскаля. От следующего потомка паскаля - Modula-2 в Go пришла концепция <em>пакетов</em>, от Oberton - использвание одного центрального файла с определением модулей (в Go этот файл называется go.mod). Из чуть более позднего Oberton-2 взята концепция пакетов, импоторов и объявления методов.</p>

<p>Ну всё это мы видели и в других языках программирования :)</p>

<p>А вот самая вишенка, это концепция CSP (communicating sequential processes) из статьи Тони Хоара 1978 года об основах <em>параллелизма</em>, которая развивалась в научных языках компании Bell Labs, и в итоге добралась до нашего Go-суслика.</p>

<p>CSP — это скорее не концепция, а формальный язык, которым описываются модели взаимодействия процессов в параллельных программных системах <strong>не имеющих общего состояния</strong>. В этой модели процессы взаимодействуют и синхронизируются между собой с помощью <em>каналов</em>. Мне кажется это на порядок более мощная модель чем атомарность, которую я рассматривал вкратце <a href="/2022/01/30/hack_in_codding_1.html">здесь</a>. CSP до сих пор является темой для активного исследования в Computer Science.</p>

<h3 id="зачем-нам-суслик">Зачем нам суслик?</h3>

<p>Google устал от так называемого <em>взрыва сложности</em>. О какой сложности идет речь, в Гугле что, сидят дураки которым сложно программы писать на уже имеющихся языках? Вовсе нет. Здесь имеется в виду такая проблема (при чем вообще не уникальная для Google) как <em>сложность программной системы</em>.</p>

<p>Эта сложность характеризуется количеством абстрактных сущностей, которые между собой связаны и как-то взаимодействуют. Всё просто — чем сущностей больше, тем сложнее становится система. А чем сложнее система, тем затруднительнее в ней разобраться и что-то допиливать. Хороший пример сложной системы это СУБД Оракл, погуглите статью на хабре (треш алерт!).</p>

<p>Так вот, Роб Пайк (один из создатлей Go), не без оснований заметил, что сложность <em>мультипликативна</em>. Имеется в виду что если мы усложняем одну часть системы, например дорабатываем какие то фичи, etc., то обязательно будут усложняться и другие части.</p>

<p>С течением времени постоянно требуется вносить новые фичи в проект, бизнес требует <del>крови</del> денег, и требует быстро! В итоге мы получаем сложную, вообще не выразительную систему жертвуя простотой кода, хотя в долгосрочной перспективе <em>именно простота</em> является ключевым аспектом качественного софта. Простота означает ясность (выразительность), меньше шансов наплодить багов, etc.</p>

<p>Фишка в том, что такая “долгосрочная простота” требует большой работы в самом начале проекта. Необходимо четко сформулировать ключевые аспекты и поддерживать строгую дисциплину во время всего цикла разработки. Благодаря такой дисциплине становится возможным отличать плохие изменения от хороших. На практике же мы часто, и к сожалению, наблюдаем хреняк-хреняк и в продакшен.</p>

<p>Нет строгой спецификации и дисциплины — есть банальный размен <em>простоты</em> на мнимое <em>удобство</em>, которое в итоге приводит к хаосу и сплошному копанию в легаси и попытке докостылять.</p>

<p>Короче, Google устал, и разрабатывая Go одним из важных факторов стала <em>культура радикальной простоты</em>. В прошлый раз я мельком упоминал о том как медленно и неохотно в Go допиливаются новые “фичи”, и как слезно сообщество выпрашивало, например, дженерики.</p>

<p>Go выигрывает преимущство во времени в которое он появился. И преимущество это — возможность ретроспективно проанилизировать “опыт” других языков программирования, в чем разрабочики “оторвались по полной”.</p>

<p>В Go есть сборщик мусора, мы не мучаемся с памятью. Есть система пакетов, как уже было сказанно. Полноценные функции, замыкаем со спокойной душой. <em>Лексическая область видимости</em>. Интерфейс системных вызовов! И иммутабельные строки в UTF-8.</p>

<p>Но при этом, (помните про культуру радикальной простоты?): Нет конструкторов и деструкторов; Нет перегрузки операторов; Нет неявных числовых преобразований; Нет значений параметров по умолчанию. <strong>Нет наследования</strong>, обощенных типов и <strong>исключений</strong>. Нет макросов! Нет аннотаций функий и локальной памяти потока. В общем если вы до этого кодили только на Python, то сперва может будет немного больно, но не так, как на Си, или Си++ :D</p>

<p>Как вы уже могли догадаться, система типов в Go тоже своеобразна. Она боле ограниченна, чем в других языках со сторой типизацией, но при этом <em>достаточна</em> для того чтобы избежать большую часть ошибок, на которые мы можем напарываться в языках с динамической типизацией. Мы можем создавать изолированные части кода с “нетипизированным программированием”, которые в свою очередь будут включены в более широкую, более строгую схему типов.</p>

<hr />

<p>Go точно заслуживает вашего внимания, если не как основной язык программирования, то как дополнительный инструмнт точно.
Этот пост получился таким же обобщенным как и предыдующий, тут нет сниппетов кода, мы не разбирали вглубь особенности и примеры.</p>

<p>Хочу сказать что мне кажется я очень своевременно начал учить Go. Параллельно с курсом “Как понять в програмировании всё”, красота простоты Go становится ещё понятнее, как задумка, и как ценность.</p>

<hr />
<p><em>Основанно на введении из книги “The Go Programming Language”</em></p>
:ET