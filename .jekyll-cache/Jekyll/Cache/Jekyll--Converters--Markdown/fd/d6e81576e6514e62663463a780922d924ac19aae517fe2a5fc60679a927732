I"U<p><em>“Совершенство достигнуто не тогда, когда нечего добавить, а тогда, когда нечего убрать.”</em> — Антуан де Сент-Экзюпери
<!--more--></p>

<h2 id="старый-мастер">Старый мастер</h2>

<p>Помните эту затёртую человечеством до дыр притчу, про старика который поучает сына о важности единства с <del>кентами</del> братьями, давая ему ломать тростинки по одной, а потом вместе связав их в веник? Ну так то оно да, очень мудро. Но касаемо разработки программного обеспечения мейнстрим проповедует микросервисы, ортогональность, уход от высокой связности как в программировании в малом, так и в программировании в большом.</p>

<p>Справедливости ради — декомпозиция это не какое-то новомодное изобретение инженерной мысли 21 века. Напротив, декомпозиция, как и все самые лучшие идеи нашей научной отрасли уже давно изобретены мудрецами прошлого века, на заре всего того, что творится здесь и сейчас. Многие из этих идей до сих пор не воплощены полноценно, многие из них нами, молодыми разработчиками — игнорируются к глубокому изучению и осмыслению. Это печально.</p>

<p>Так что же мы будем делать если веник — это большая задача, и нам его <em>нужно</em> “сломать”? Разумеется, за неимением средств к его сожжению и иной дезинтеграции мы будем тянуть по одной тростинке на последующий излом :) 
Но ломать конечно же ничего не надо, особенно продакшен, особенно в пятницу, бугага :)</p>

<p>Ключевая идея принципа декомпозии в том, что очень обьемные задачи намного сложнее решать, чем мелкие.</p>

<p style="text-align: center;"><img src="/images/very_hard_graph.png" alt="Сложный график" /></p>
<p><em><center>Высокоточный и крайне искусно выполненный, важный график для наглядности понимания</center></em></p>

<h2 id="люк-используй-декомпозицию">Люк, используй декомпозицию!</h2>

<p>Вообще про декомпозицию как способ мышления для решения задачи сформулировал ещё Рене Декарт в своем “Рассуждении о методе”. Нас интересует применение этого инструмента, в первую очередь в своих программистских начинаниях.</p>

<h3 id="о-это-было-в-школе">О, это было в школе!</h3>

<p>Разбивка на части сложной системы, для последующей её реализации в виде подпрограмм, лежит в основе <em>структурного программирования</em>. С развитием идеи декомпозиции этот метод стали называть <em>процедурной декомпозиций</em>, потому что сформировались концепции логической, объектной и других “декомпозиций”.</p>

<p>Метод заключается, примерно в следующем:</p>
<ol>
  <li>Определяем общую структуру программы, если хотите — прототипируем, в виде одного из вариантов:
    <ul>
      <li>Последовательность подзадач (ввод данных, вычисление, вывод, ну вы поняли);</li>
      <li>Условия, или <em>альтернативные</em> подзадачи (тут нечего пояснять, правда?);</li>
      <li>Повторения подзадач (циклы).</li>
    </ul>
  </li>
  <li>Теперь, в определенной структуре нам нужно каждую подзадачу беспощадно и снова разбивать на подзадачи используя структуры из пункта 1. Разбивать до тех пор, пока на минимальном “атомарном” уровне подзадачи не будут из себя представлять простые процедуры, реализуемые несколькими операциями языка программирования.</li>
</ol>

<p>В частном случае <strong>строгой</strong> структурной декомпозиции запрещаются циклы и обратные вызовы подпрограмм. В таком случае иерархия программы становится древовидной без всяких goto петель.</p>

<p>В чем вообще плюс всей этой идеи? Ну, в первую очередь, применяя структурное программирование мы минимизируем количество ошибок в работе программы, и более детально разрабатываем алгоритм в целом. У нас просто нет выбора не разобраться что и как тут будет работать, нет выбора напороться на ужасающие и непонятные сайд-эффекты, которые лихорадочно дебажутся до поздней ночи. Хотя… :D</p>

:ET