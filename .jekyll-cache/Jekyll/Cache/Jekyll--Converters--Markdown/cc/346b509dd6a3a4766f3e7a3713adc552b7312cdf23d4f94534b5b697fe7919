I"p
<p>Врубаемся в Декларативную модель — Часть 6. 
<!--more--></p>

<h2 id="data-driven">Data-driven</h2>

<p>Часто на практике нужно выполнить какую то операцию над достаточно большой структурой данных, например провести итеративные вычисления, или обойти одну структуру и вычислить другую, на основе “собранных” в обходе данных.</p>

<p>Как правило, чаще всего такие вычисления проводятся над списками, массивами и деревьями. К спискам применяются операции свертки (FoldL\R), которые мы рассмотрели в прошлом посте. Но существуют и другие популярные техники.</p>

<h3 id="операция-map">Операция Map</h3>

<p>Реализация Map есть почти во всех стандартных библиотеках популярных языков программирования. Эта операция работает со списком, и вычисляет на его основании список такой же длинны, применяя переданную в Map функцию к каждому элементу исходного списка.</p>

<p>С помощью <del>заклинаний</del> программирования высшего порядка, реализовать Map можно как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def function Map(some_list, some_func)

    def function iterate_map(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list
  

        list_head = list_remaining[0]
        list_tail = list_remaining[1:] 
        return iterate_map(new_list.insert(0, some_func(list_head)), list_tail, some_func)
  

    return iterate_map([], some_list, some_func)
</code></pre></div></div>

<p>Можем передать в Map простую функцию, типа возведения в квадрат, и передать её вторым аргументов. Напоминаю что это псевдопайтанокод, заварите чай, прочитайте прошлые пару статей, если сходу ничего не понятно, и реализуйте рабочий вариант на своем любимом ЯП :)</p>

:ET