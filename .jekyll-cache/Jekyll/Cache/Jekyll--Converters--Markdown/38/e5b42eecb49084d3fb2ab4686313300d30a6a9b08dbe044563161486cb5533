I"!:<p>Научный взгляд на программирование. Concurrency, atomicity и кое что ещё.
<!--more--></p>

<p>В данный момент я прохожу курс Бобровского Сергея Игоревича, который называется “Как понять в программировании всё”. На самом деле это цикл курсов, направленный на освоение научного, или лучше сказать — инженерного взгляда на программироваание, от фундаментальных концепций до осмысления <em>парадигм</em> программирования.</p>

<p>Этот пост является отчетом о пройденном материале, больший фокус я хочу сделать на теме параллельного программирования и атомарности — я застрял на тесте по этой теме :), надеюсь вместе мы разберемся. В дополнение я постараюсь освятить некоторые важные концепции. Остальная и не затрагивамая в этом посте часть курса либо связана с синтаксисом и особенностями мультипарадигрмального языка программирования Julia, который изучается в рамках этого же курса, либо это отдельные и сложные концепции, которые пока мы затроули поверхностно, но обязательно вернемся позже (или я их плохо понял). Lets rock.</p>

<h3 id="что-там-научного-то">Что там научного-то?</h3>

<p>В посте про <a href="/2022/01/22/algorithms_complexity.html">сложность алгоритмов</a> я пытался развить мысль о том, что программирование — дитя математики, и подходить к анализу и понимаю алгоритмов нужно с научно-математической позиции мышления, а не с интуитивно-наивной. С программированием всё обстоит точно-так же. Чтобы разрабатывать эффективные и надежные программные системы необходимо понимать как работает “под капотом” сама система, и инструменты которые для разработки этой системы используются (языки программирования, парадигмы, подходы к программированию, etc.).</p>

<h3 id="фундаментальные-концепции">Фундаментальные концепции</h3>

<h4 id="переменная">Переменная</h4>

<p>Программе, или алгоритму, в процессе работы необходимо “пространство” в котором будут производиться вычисления. Этим пространством является оперативная память и процессорные кеши. Устройство оперативной памяти (и кешей) отдельная и сложная тема, сейчас нам нужно понимать что есть некоторый <em>ресурс</em> в который программа может быстро записывать какие-то данные, и читать их откуда.</p>

<p>Проще всего представить оперативную память как набор ячеек, у которых есть адрес. По этому адреса с ячейками можно работать. В данном случае имеются в виду <strong>физические</strong> ячейки оперативной памяти.</p>

<p>В коде программы, в частном случае, мы напрямую (явно) с этими адресами не работаем, а используем <em>переменные</em> которым присваиваем <em>значения</em>. Имя переменной — это её идентификатор, а значениями являются какие-то данные, которые мы этому имени <em>присваиваем</em>, чаще всего с помощью оператора “=”.</p>

<p>Ещё более научно это называется <em>именованным состоянием</em>, что уже чуть более сложная концепция, которая является одной из главных характеристик в <em>любой</em> парадигме программирования, и реализация (степень поддержки) зависит от конкретно рассматриваемой парадигмы.</p>

<p>В общем и целом, <em>состояние</em> — это “способность” программы запоминать данные (присвоенные значения), в будущем с этими данными работать. Если состояние имеет идентификатор, то есть, напрямую и явно доступно для операций в исходном коде, то оно называется <em>“именованное состояние”</em>. Да, состояния могут не иметь идентификаторов и быть своего рода <em>безымянными</em>.</p>

<h5 id="зачем-идентификаторы-есть-у-ячеек-есть-адреса">Зачем идентификаторы, есть у ячеек есть адреса?</h5>

<p>Во-первых, как я уже писал, мы с адресами напрямую, как правило, не работаем. Во-вторых, на самом деле значения ячейкам памяти присваиваются как “константа”, то есть “на постоянку” и однократно (в момент присваивания).</p>

<p><em>“Однократное присваивание”</em> это одна из фундаментальных концепций программирования, суть которой в том, что как только в коде определяется переменная (некоторому идентификатору присваивется его “первое” значение), эта переменная становится неизменяемой (иммутабельной).</p>

<p>Подождите, но я могу сделать в своем любимом пайтоне что-то вроде: my_special_var = “hello dear friend”, и следом my_special_var = “goodbye fella”, и расшибусь головой о стену от уверенности в том что print(my_special_var) вернёт последнюю строку — “goodbye fella”. Всё так! Просто почти во всех современных языках программирования кроме концепции однократного присваивания переменных существует дополнительный механизм — уже упомянутое “явное определение”, которое позволяет присвоить <em>новые</em> значения уже <em>существующему</em> идентификатору (переменной). Но использоваться, как правило, будет <strong>не та же самая ячейка памяти</strong>, а новая и с другим адресом. <em>Тот же самый, уже существующий идентификатор (имя переменной)</em> будет связан с другой областью (ячейкой) в памяти, в которую будет записано новое значение.</p>

<p>Не увлекайтесь “явным <em>переопределением</em>”, это удобно, но потенциально приводит к куче ошибок. Относитесь к переменным чутко и ответствено, используйте адекватный нейминг, старайтесь не переопределять уже существующие переменные (если нужно, используйте новые имена соответствующие контексту изменений). Но так же не плодить явно лишние переменные, а необходимые определяйте в непосредственной близости к коду, в котором эти переменные используются. Это короткое отступление о базовых приницпах “ясности кода” :)</p>

<h3 id="опять-математика">Опять математика?</h3>

<p>Как было сказано ранее, реализация “способности запоминать состояния” определяется поддерживаемыми языком программирования парадигмами программирования.</p>

<p style="text-align: center;"><img src="/images/mind_blowing.gif" alt="Взрыв Мозга" /></p>
<center>Поддерживаемые языком программирования парадигмы программирования — Чего-чего? </center>

<p>Не волнуйтесь, мы разберемся.</p>

<h4 id="парадигма-программирования">Парадигма программирования</h4>

<p>Парадигмой программирования, грубо говоря, называется определённый подход к программной разработке. Правильно говоря — это не менее чем <strong>настоящее</strong> научное открытие, строго выверенная математическая теории, которая на практике в том или ином образе воплащается в сложных программных системах как <em>языки программированя</em>. Это не значит что язык программирования конструируется на базе одной парадигмы, напротив — многие современные языки являются мультипарадигмальными, из чего следует вывод что это <em>ну очень сложные математические модели</em>.</p>

<p><em>Хорошая новость в том, что если что-то придумали одни люди, мы можем в этом разобраться, пусть даже приложив усилия!</em></p>

<p>Так вот, эта математическая модель выражается как <em>семантика языка программирования</em>, которая передает смысл конструкций (и инструкций) в конкретном языке программирования.</p>

<p>Подробное изучение парадигм программирования явно выходит за рамки этого поста и моих текущих знаний, но в будущем парадигмы будут подробнее изучаться на соответсвующих курсах, до которых я надеюсь добраться.</p>

<hr />

<p>Способ реализации разобранного нами ранее <em>именованного состояния</em> является одной из двух ключевых характеристик парадигм программирования. Вторая характеристика — характерность или не характерность <strong>недетерминизма</strong>.</p>

<h4 id="недетерминизм">Недетерминизм</h4>

<p>В привычном представлении новичка-программиста, особенно самоучки, привычная императивная программа выполняется последовательно и выдает от вызова к вызову с одними и теми-же аргументами один и тот-же результат. Такое поведение назвыается <strong>детерминированным</strong>. Иными словами, если программа детерминирована, мы можем по её коду однозначно определить какой результат будет на выходе. Никаких сюрпризов.</p>

<p>Недетерминизм, как несложно предположить, является противоположной ситуацией, когда вызывая программу, даже с одними и теми же входными данными, мы можем наблюдать разный результат из раза в раз. Такой недетерминизм называется <em>явным</em>.</p>

<p>Но как такое получается? Программа может выдавать неожиданные результаты, если она описана в системе (парадигме) программирования, в которой соединяются уже изученные нами “именованные состояния” и <strong><em>параллельные</em></strong> вычисления.</p>

<h3 id="параллелизм">Параллелизм</h3>

<p>Наконец мы подобрались к параллелизму! Сперва нам нужно строго определять о чем идет речь. В русском языке часто используется одно и то же слово для фактически разных концепции.</p>

:ET