I"Y<p>Часть 3. Список списков со списками списков, со списком записей…
<!--more--></p>

<h3 id="here-we-go-again">Here we go again</h3>
<p>В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.</p>

<p>Рекурсия как программистский трюк не ограничивается “самовызовом” (прочитали как самовывоз, признайтесь?) функций — <em>рекурсивными могут быть и типы данных</em>. Базовый пример рекурсивного типа данных — список.</p>

<p>Почему список на самом деле рекурсивная структура? Потому что он определяется <em>в терминах более короткой версии себя самого</em>.</p>

<p>Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и <em>“список”</em>, а лучше сказать набор или “последовательность” пар “ключ-значение”.</p>

<p>Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список.</p>

<p>Как правило этими “произвольными” значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка “впихнуть” в эти “кусочки” какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда).</p>

<p>Части списка связанны некоторым образом с другими, и всё вместе (“элементарный кусок данных” и связь-указатель на другой) называется <em>узел</em>.</p>

<p>В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.</p>

<p>Вернемся к фундаментальным материям :)</p>

<p>В декларативной модели список определяется <em>рекурсивно</em>. Считается, что либо список пустой (nil или, если хотите, None), либо <em>есть какое-то значение связанное со списком</em>.</p>

<p>Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, “узел” содержащий строку “shrek”, то тогда список X будет равен “shrek” <em>связанный со списком nil</em>!</p>

<p>Короче говоря, “последний” элемент в списке всегда будет “указывать” на “пустой список”.</p>

<p>Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.</p>

<p>В рекурсивных функциях, работающих со списками, <em>базовым случаем</em> будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов <em>более мелких списков</em>.</p>

<p>Например, “декларативная” рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>list_length(list):
    if list == []
        return 0
    
    list_head = list[0]
    list_tail = list[1:]

    return 1 + list_length(list_tail)
</code></pre></div></div>

<p>Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — “Ух ты ж сколько можно то намутить с этим списком!”</p>

:ET