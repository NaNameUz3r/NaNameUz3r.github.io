<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-01-24T00:29:21+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Лупоглазый суслик Go.</title><link href="http://localhost:4000/2022/01/23/go_language.html" rel="alternate" type="text/html" title="Лупоглазый суслик Go." /><published>2022-01-23T00:00:00+03:00</published><updated>2022-01-23T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/23/go_language</id><content type="html" xml:base="http://localhost:4000/2022/01/23/go_language.html">&lt;p&gt;Заметка о первом знакомстве.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;зачем-я-начал-учить-go&quot;&gt;Зачем я начал учить Go&lt;/h2&gt;

&lt;p&gt;Совсем недавно я начал знакомиться с базовым синтаксисом и особенностями языка программирования Go. До этого всё моё изучение программирования проходило в рамках Python, он же и был основным инструментом в написании мелких скриптов. Работу программистом я так и не нашел, но вполне реактивно перешел в DevOps из DBA осенью прошлого года. Мне очень нравится текущая работа, как позиция, так и конкретно компания, но кодить нравится — хоть убейте! Поэтому недолго поразмыслив я решил учить Go, и вот почему.&lt;/p&gt;

&lt;p&gt;Go действительно &lt;strong&gt;широко&lt;/strong&gt; используется в DevOps. Docker, Kubernetes, Prometheus, Grafana и многие другие инструменты написаны на Go. Это открывает мне потенциальные возможности в будущем по нобходимости быстрее разбираться в Go коде, разрабатывать свои приложение, и, простите за веру в себя — потенциальную возможность принять участие в open source разработке.&lt;/p&gt;

&lt;p&gt;Кроме того что Go хорошо подружился с DevOps чертовщиной, я давно поглядываю в сторону Си, и сиподобных языков в целом, строгой типизации и вот этого всего. Слышал что Go называют “Си на стероидах”, но мне почему-то это кажется не совсем корректным, по крайней мере на данный момент. Мне рано судить о плюсах и минусах Go, так как только начинаю свое знакомство, в частности прошел официальный &lt;a href=&quot;https://go.dev/tour/list&quot;&gt;тур по Go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ничего феноменально сложного я не заметил, но в разделах о поинтерах и интерфейсах пришлось напрячь мозги. Скажу честно, интерфейсы в Go, по крайней мере как они описываются в туториале не до конца остались понятными. Хотя саму концепцию интерфейсов я вроде бы понимаю. Вероятно мои затруднения вызваны в целом малым опытом разработки, а может и тем что в Go интерфейсы в структурах данных реализуются &lt;em&gt;имплицитно&lt;/em&gt; то есть &lt;em&gt;неявно&lt;/em&gt;. И хотя это заявляется как сильная сторона Go, меня пока терзают смутные сомнения. Обязательно отпишусь на эту тему, как только наберусь достаточно опыта в разработке на Go.&lt;/p&gt;

&lt;p&gt;Кроме “Сишности” в Go мне нравится его простота. Это достаточно компактный язык, при это из коробки есть практически всё что нужно. В Go &lt;strong&gt;нет&lt;/strong&gt; ООП, на нем не пишут фабрики, и код остатется простым. Даже не смотря на местами ужасающую неясность и корявость исходного кода (отвратительный нейминг, например), который сообщество по какой то причине не стесняется выкладывать, код остается воспринимаемым. Go достаточно молодой язык, который разработан в Google и появился в открытом доступе в 2009. Не знаю насклько корректно оправдывать халатность комьюнити по отношению к ясности разрабатываемого кода молодостью языка. Ну да ладно, главное им не подражать :)&lt;/p&gt;

&lt;p&gt;Go компилируемый язык, и говорят что компилируется он быстро! Можно поспорить на тему, что это не является особым преимуществом для доставки приложения, так как широко распространились контейнеры, но компилируемость позволяет не только избавиться от сторонних библиотек в составе образа (копируем бинарь и всё!), а так же и снизить его (образа\контейнера) итоговый размер.&lt;/p&gt;

&lt;p&gt;Вообще Go это достаточно амбициозная попытка взять самое лучшее у популярных языков программирования (сильные стороны применения некоторых парадигм программирования) например Java и C++, и сделать Go способным выражать то же самое, но “более простым языком”.&lt;/p&gt;

&lt;p&gt;Go уверенно набирает популярность, но имхо, пока рано судить о том что ждет язык в будущем. Сообщество разработчиков очень консервативно и долго рассматривает реквесты и предложния, многие из которых просто оставляя без внимания. Например погуглите как долго в Go требовали и пропихивали дженерик типы. (спойлер — их всё ещё нет, но &lt;em&gt;может быть&lt;/em&gt; будут в 1.18beta).&lt;/p&gt;

&lt;p&gt;Мне нравится этот микс в Go: с одной стороны есть стогая типизация, с другой — сборщик мусора. Есть поинтеры и очень крутая и простая реализация парралельного программирования — горутины и каналы.&lt;/p&gt;

&lt;p&gt;Я не призываю вас бежать и учить Go, но призываю учить программирование! Конкретно в моем случае Go несомненно принесет лишь пользу после долгой дружбы с Python, карьерные возможности и в целом в развитии как специалиста. И как я уже говорил на счет Си, наконец то я дорвался до Си-подобного языка! Рано или поздно я обязательно доберусь до низкоуровнего программирования и поковыряюсь в ядрышках. Если вы спросите зачем мне это нужно, то отвечу цитируя Джеффа Дантеманна из “Assembly Language Step–by–Step” — &lt;em&gt;because I want to know how it works&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Увидимся в следующих постах про Go, которые наверняка ещё будут.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Go" /><summary type="html">Заметка о первом знакомстве.</summary></entry><entry xml:lang="ru"><title type="html">Давай я погуглю за тебя</title><link href="http://localhost:4000/2022/01/23/how_to_google.html" rel="alternate" type="text/html" title="Давай я погуглю за тебя" /><published>2022-01-23T00:00:00+03:00</published><updated>2022-01-23T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/23/how_to_google</id><content type="html" xml:base="http://localhost:4000/2022/01/23/how_to_google.html">&lt;p&gt;Да пребудет с вами сила поиска в Google! Или как избавить своего тимлида от 80% глупых вопросов. Слышали что нибудь о так называемых google dorks? Нет? Добро пожаловать под кат!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Один из самых главных инструментов любого айтишника, разумеется, после мозга — это правильное использование поисковых систем интернета.
Воспользусь правом автора и буду рассматривать только Google.&lt;/p&gt;

&lt;h3 id=&quot;элементарные-запросы&quot;&gt;Элементарные запросы&lt;/h3&gt;

&lt;p&gt;Начнем с азов. Современный гугл достаточно умный, вы можете задать даже коряво сформированный запрос и плюс-минус получите удовлетворительный ответ на первой странице. Если вы хотите найти фразу &lt;em&gt;именно в том виде&lt;/em&gt; в котором задаете её в поисковик — просто заключите её в двойные кавычки. Кроме того можно включить “обязательность” присутствия одного или нескольких слов в поиске, для этого, как и в прошлый раз, заключите требуемую часть запроса в кавычки.&lt;/p&gt;

&lt;p&gt;Исключить одно или несколько слов из выдачи можно просто используя знак минуса перед ними без пробела.&lt;/p&gt;

&lt;p&gt;В поисковых запросах Гугла можно использовать стандартные логические операции: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;.&lt;br /&gt;
Можно указать в любом месте запрос символ &lt;strong&gt;*&lt;/strong&gt;, Гугл будет интерпетировать это точно так же как в обычном регулярном выражении — подставлять любое количество недостающих слов, удовлетворяющих оставшиеся части запроса на место символа звездочки. Ограничить удаленность двух слов, или частей запроса друг от друга можно с помощью оператора &lt;strong&gt;AROUND()&lt;/strong&gt;, передав ему в качестве аргумента колличество слов допустимых в промежутке. Например:&lt;/p&gt;

&lt;h3 id=&quot;level-up&quot;&gt;Level Up&lt;/h3&gt;

&lt;p&gt;Есть список специальных операторов поиска. К примеру, чтобы искать информацию исключительно на конкретном сайте вы можете определить его используя оператор &lt;strong&gt;site:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/site_google_operator.png&quot; alt=&quot;search medium for postgres replication&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Оператор &lt;strong&gt;related:&lt;/strong&gt; служит для поиска &lt;em&gt;других&lt;/em&gt; сайтов, похожих на указанный.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/related_google_operator.png&quot; alt=&quot;search other social networks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Более того, в Гугле можно сразу искать файлы конкретного расширения. Скажем, вы в поисках новых знаний о программировани. Примените оператор &lt;strong&gt;file:&lt;/strong&gt; с указанием расширения, например, pdf.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/file_google_operator.png&quot; alt=&quot;search for pdf books&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Дай человеку рыбу и он будет сыт один день… Оставшийся список оператор вы можете найти сами.&lt;/p&gt;

&lt;h3 id=&quot;google-dorks&quot;&gt;Google dorks&lt;/h3&gt;

&lt;p&gt;Фишка в том что поисковые операторы можно группировать практически в любом порядке и количестве. А теперь проявите фантазию. Допустим вам нужно найти что-то весьма специфическое. Например случайно утекшие в сеть пароли, забытые документы и прочее. А чё, так можно? Можно.&lt;/p&gt;

&lt;p&gt;Google Dorks или Google Dork Queries — это специально сформированный запрос для выявления дыр в безопасности. Такими запросами пользуются как нетсталкеры, так и настоящие злоумышленники. Они могут искать, например, потенциально уязвимые паттерны url ссылок с помощью оператора &lt;strong&gt;inurl:&lt;/strong&gt;, которые при должной сноровке могут, и часто являются, векторами атак.&lt;/p&gt;

&lt;p&gt;Для общего развития и формирования понимания потенциальной мощности поиска в Google, рекомендую ознакомиться с базой дорков собирамой исследователями информационной безопасности на сайте сообщества Offensive Security &lt;a href=&quot;https://www.exploit-db.com/google-hacking-database&quot;&gt;exploit-db.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Помните слова Дяди Бена, имейте совесть, уважайте свои и чужие персональные данные. Если что, карма вас обязательно настигнет!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><category term="Информационная_безопасность" /><summary type="html">Да пребудет с вами сила поиска в Google! Или как избавить своего тимлида от 80% глупых вопросов. Слышали что нибудь о так называемых google dorks? Нет? Добро пожаловать под кат!</summary></entry><entry xml:lang="ru"><title type="html">Сложность и эффективность алгоритмов.</title><link href="http://localhost:4000/2022/01/22/algorithms_complexity.html" rel="alternate" type="text/html" title="Сложность и эффективность алгоритмов." /><published>2022-01-22T00:00:00+03:00</published><updated>2022-01-22T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/22/algorithms_complexity</id><content type="html" xml:base="http://localhost:4000/2022/01/22/algorithms_complexity.html">&lt;p&gt;Как правильно думать о программе, что такое временная сложность и это самое “О большое”. Давайте разбираться.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Недавно я сделал перевод важной статьи про &lt;a href=&quot;/2022/01/15/programming_interview_algorithm.html&quot;&gt;Алгоритм прохождения интервью по программированию&lt;/a&gt;. Это сложная тема, особенно если вы никогда до этого не изучали структуры данных, ничего не слышали про временную сложность и не занимались оценкой эффективности или не эффективности программного кода.&lt;/p&gt;

&lt;h2 id=&quot;а-как-думать&quot;&gt;А как думать?&lt;/h2&gt;

&lt;p&gt;Начну с того что не зависимо от особенностей каждого человека, если мы физически и психически здоровы то “понимание” какой-то темы у нас складывается примерно одинково. Возьмем, например, телевизор. Человек растет и развивается, видит как его родители нажимают на кнопки, из телевизора показывают картинки, в его мозгу формируются некоторые связи приводящие к пониманию зависимости действий над объектом, и к каким результатам эти действия приведут. Но если человек никогда не интересовался как работает телевизор, из каких компонентов он состоит то он не сможет объяснить что это на самом деле такое, как работе, как это создать с нуля или починить. Это нормально. Инженер или работник завода на котором собирают телевизоры или его компоненты знают порядком больше, в виду обладания &lt;em&gt;большим опытом&lt;/em&gt; в непосредственной области, соответствующим обучением, etc. Надо ли говорить как телевизор будет воспринимать пещерный человек, или коренной житель глубокой тропической деревни, где иногда до сих пор практикуют каннибализм?&lt;/p&gt;

&lt;p&gt;С программированием всё обстоит так-же. Информационные технологии и программирование — дети науки и математики, развивашихся лучшими умами человечества за последние столетия.
Само собой это сложная тема, и нахрапом её не взять.&lt;/p&gt;

&lt;p&gt;Когда мы программисты-самоучки, мы можем достаточно быстро выучить современный высокоуровневый и выразительный язык программирования, например Python, методы его стандартной библиотеки, и интуитивно начать собирать в голове образ того чего мы хотим добиться от программы, смутно представлять как она работает. Мы, ещё раз, &lt;em&gt;интуитивно&lt;/em&gt; понимаем что такое переменная, что такое лист или массив. Ну есть там какие-то данные, мы их туда записали, можем сделать клац-клац &lt;strong&gt;sorted(my_very_spetial_list)&lt;/strong&gt; и знаем чего ожидать. Несмотря на то, что таким же образом можно изучить ряд технологий, фреймворков и довольно успешно выполнять простые прикладные задачи, это представление неверно, контрпродуктивно и ничем хорошим не заканчивается, например как только мы попытаемся разработать хоть сколько нибудь сложную систему.&lt;/p&gt;

&lt;p&gt;Поэтому единственный правильный способ думать о программе — это думать научно, и так же подходить к изучению программирования. Напрягаем извилины и идём дальше.&lt;/p&gt;

&lt;h2 id=&quot;алгоритм&quot;&gt;Алгоритм&lt;/h2&gt;

&lt;p&gt;Что такое программирование вообще? Ну, в первую очередь, скажете вы — это написание какой-то программы, которая что-то внутри делает и выдает интересующий нас результат, и будете в общем-то правы. Приемлемо. А что такое программа? Ни больше ни меньше, программа, в самом простом её представлении и правильном понимании — это &lt;em&gt;Алгоритм&lt;/em&gt; достижения требуемого результата. Утрированный пример алгоритма, который я неоднократно встречал во всевозможных книжках начального уровня, это список ваших последовательных дел на завтра:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Проснуться&lt;/li&gt;
  &lt;li&gt;Потянуться&lt;/li&gt;
  &lt;li&gt;Надеть носки&lt;/li&gt;
  &lt;li&gt;Поехать на работу (или дойти до компьютра и начать рабоать :) )&lt;/li&gt;
  &lt;li&gt;Прерваться на обед&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При том каждый из пунктов тоже на самом деле является алгоритмом некоторых последовательных (а может и параллельных) действий, так что в примере выше я скоре описываю &lt;em&gt;список алгоритмов&lt;/em&gt;.
Так и есть. В любой даже маленькой программе практически всегда есть &lt;em&gt;n&lt;/em&gt; число алгоритмов — вызовы разных функций, каждая из которых что-то вычисляет.
А если вычисляет — значит алгоритм. Кажется я вас начинаю запутывать, но думаю идея ясна.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Алгоритмом мы называем пошаговое руководство “компьютеру” что-то нам посчитать (вычислить). Вычисления могут быть очень простыми, а могут быть и крайне сложными. Правильный способ думать о программе не как о волшебном коде, а как о вполне строгом, &lt;strong&gt;математическом&lt;/strong&gt; описании решения задачи.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Вычислительное железо, как и любой другой объект физического мира подчиняется строгим законам. Сила притяжения (по крайней мере на нашей планете) не даст вам прыгнуть кузнечиком в окно второго этажа. Вычислительные ресурсы (центральный процессор, оперативная память, etc) просто так не обработают по щелчку пальцев огромное количество данных — на это потребуется &lt;strong&gt;время&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;К какому бы крутому суперкомпьютеру у вас вдруг не оказался доступ, его мощность играет &lt;em&gt;намного меньшее значение&lt;/em&gt; для производительности программы, чем &lt;em&gt;правильно подобранный алгоритм&lt;/em&gt;. Именно о правильном подборе алгоритма и идет речь в переведенной мною статье, со ссылки на которую начинается этот пост.&lt;/p&gt;

&lt;p&gt;Итак, алгоритм — это вычисление или преобразование &lt;em&gt;входных&lt;/em&gt; данных в интересующие нас &lt;em&gt;выходные&lt;/em&gt; данные. Вы любите ждать? Маловероятно. Проще всего эффективность алгоритма понять как отношение времени, за которое мы получим результат. Чем быстрее — тем лучше.&lt;/p&gt;

&lt;h2 id=&quot;асимптотическая-сложность&quot;&gt;Асимптотическая сложность&lt;/h2&gt;

&lt;p&gt;Так что же влияет на скорость работы алгоритма? Как сказанно выше, в первую очередь это правильность самого алгоритма. А точнее — оправданность его использования в &lt;em&gt;конкретных обстоятельствах&lt;/em&gt;. Под конкретным обстоятельствами я имею в виду контекст решаемой нами задачи. В контексте задачи скорость, с которой алгоритм будет вычислять решение, зависит от &lt;em&gt;объема (количества) входных данных&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Научно (математически) сложность алгоритмов оценивается с помощью так называемого &lt;em&gt;асимптотического анализа&lt;/em&gt;. Итак, мы рассматриваем сложность алгоритма посредством анализа &lt;em&gt;зависимости времени и вычислительных ресурсов&lt;/em&gt;, которые потребуются алгоритму в процессе его работы.&lt;/p&gt;

&lt;p&gt;На практике всё это выражается как математическая функция, которая позволяет понять &lt;em&gt;насколько быстро&lt;/em&gt; будет увеличиваться время работы алгоритма, в зависимости от увеличения обрабатываемого объема данных. Иными словами, под &lt;em&gt;асимптотикой&lt;/em&gt; мы понимаем &lt;em&gt;характер&lt;/em&gt; с которым изменяется функция в течении &lt;em&gt;времени&lt;/em&gt;, когда её аргумент (количество обрабатываемых данных) &lt;em&gt;стремится&lt;/em&gt; к какой-то точке. Только в асимптотическом анализе сложности &lt;em&gt;компьютерых алгоритмов&lt;/em&gt; за эту точку принимается бесконечность. Простите меня за то что я несколько раз повторяю одно и то же, но это важно понять:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Мы оцениваем скорость работы алгоритма в сравнительном &lt;strong&gt;количестве операций&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;так-что-там-за-о&quot;&gt;Так что там за О?&lt;/h3&gt;

&lt;p&gt;Наиболее часто для оценки роста используются следующие &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_notation&quot;&gt;нотации&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ο (О-большое) – верхняя или “наихудшая” оценка сложности. Входные данные подаются самым “неудобным” для алгоритма способом;&lt;/li&gt;
  &lt;li&gt;o (o-малое) – средняя оценка, данные подаются случайным образом;&lt;/li&gt;
  &lt;li&gt;Ω (Омега) – нижняя оценка, идеальная ситуация для достижения максимальной скорости алгоритма;&lt;/li&gt;
  &lt;li&gt;Θ (Тета) – нижняя и верхняя, точная оценка роста временной функции.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Все эти нотации используются мощными человеческими умами в теоретической Computer Science, нам же полезнее всего будет рассмотреть фундаментальные меры сложности, использумые повсеместно, которые выражаются через O-большое.&lt;/p&gt;

&lt;h4 id=&quot;разбираемся-подробнее&quot;&gt;Разбираемся подробнее&lt;/h4&gt;

&lt;p&gt;Возьмем &lt;em&gt;n&lt;/em&gt; за величину подаваемого объема данных. Тогда верхнюю оценку сложности алгоритма можно записать как &lt;strong&gt;O(f(n))&lt;/strong&gt;. Почему нас интересует именно верхняя или “наихудшая” оценка? Потому что с практической точки зрения нам важно понять этот &lt;em&gt;наихудший вариант развития событий&lt;/em&gt; при котором алгоритму будет скормлено &lt;em&gt;большое количество данных&lt;/em&gt;. Если он будет эффективен в этих условиях, то разумеется будет эффективен и в более “благоприятных”.&lt;/p&gt;

&lt;p&gt;Самые простые для понимания обозначения сложности это &lt;strong&gt;O(1)&lt;/strong&gt; и &lt;strong&gt;O(n)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(1)&lt;/strong&gt; выражает сложность, при которой для выполнения алгоритму потребуется &lt;em&gt;константа&lt;/em&gt; времени. Например взятие элемента из массива по его индексу. Мы точно знаем где элемент находится и просто идём туда. &lt;em&gt;Такие операции не зависят от количества обрабатываемых данных.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n)&lt;/strong&gt; линейно зависит от количества входных данных. В худшем случае такому линейному алгоритму придется проводить какие-то операции с каждым элементом данных. Это, например, обход массива, обход связанного списка или расчет его длинны. Чтобы понять лучше приведу утрированный пример. Представим что задача состоит в том, чтобы определенному сущетву (алгоритм) нужно выпить некоторое (n) количество воды. Смоделируем ситуацию, в которой воду пьёт не человек, а волшебный троглодит, у которого не желудок, а бездонная черная дыра (n стремится к бесконечности). Пить воду он может только последовательно, глоток за глотком, поэтому алгоритм выпивания воды будет иметь линейную сложность O(n) — чем больше воды мы дадим троглодиту на испитие, тем дольше он будет её хлебать.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Классическим вариантом логарифимической сложности &lt;strong&gt;O(log n)&lt;/strong&gt;, где за основание логарифма обычно берется 2, является бинарный (двоичный поиск). Чем больше входных данных — тем медленнее растет время выполнения алгоритма (тем меньше его сложность). Самый простой и затертый до дыр пример для представления работы двоичного поиска — попытка найти номер телефона нужного вам человека по индексированному справочнику (Аббоненты упорядочены по алфавиту). Вы можете искать по порядку, запись за записью, страница за страницей. Согласитесь, очевидно что это может занять много времени. Сложность такого поиска можно выразить предыдущей формулой O(n). Представьте что вы в ищите человека не в своей записной книжке, а в справочнике всех аббоненов Москвы, например. Похоже что листать его последовательно (линейно) плохая идея.&lt;/p&gt;

&lt;p&gt;Намного быстрее, зная что справочник упорядочен, открыть его примерно в том месте, где мы ожидаем найти аббонента. Например мы ищем Фёдора Корнельчука (все совпадения случайны!). Зная алфавит русского языка может показаться что буква К обязательно будет находиться в первой половине справочника, но это не так, мы не знаем сколько фамилий на А, Б, и так далее. Может случиться так, что фамилии на К находится во второй половине сравочника. Алгоритм Двоичный поиска работает так — мы открываем справочник (массив) посередине и смотрим куда попали, если нам нужно в левую половину (на откртой странице фамилии на букву, следующую за К в алфавитом порядке), мы отбрасываем правую часть и открываем оставшуюся часть &lt;em&gt;снова посередине&lt;/em&gt;. И так до тех пор пока не найдем Корнельчука.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Сложность алгоритмов сортировки часто выражается как &lt;strong&gt;O(n log n)&lt;/strong&gt;. Время выполнения таких алгоритмов растет быстрее, чем O(n). Можно представить как комбинацию O(log n) и O(n).&lt;/p&gt;

&lt;p&gt;Далее по интенсивности роста идут квадратичные зависимости, например &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;. Время выполнения таких алгоритмов растет очень быстро при увеличении объема входных данных (экспоненциально!). Например, два цикла, когда один вложен в другой, каждый из которых работает за O(n). Практически в любом случае это &lt;strong&gt;очень плохая мера&lt;/strong&gt;, которую вообще не стоит определять в своих алгоритмах.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Разбор алгоритмов сортировки и разных структур данных выходит за рамки этого поста. В будущем я планирую несколько постов в которых мы разберем базовые структуры данных и попытаемся оценить их сложность. Надеюсь что теперь стало понятнее о чем шла речь в статье-алгоритме Майкла.&lt;/p&gt;

&lt;p&gt;До новых встреч!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Алгоритмы" /><category term="ComputerScience" /><summary type="html">Как правильно думать о программе, что такое временная сложность и это самое “О большое”. Давайте разбираться.</summary></entry><entry xml:lang="ru"><title type="html">Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!</title><link href="http://localhost:4000/2022/01/16/why_zettelkasen.html" rel="alternate" type="text/html" title="Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!" /><published>2022-01-16T00:00:00+03:00</published><updated>2022-01-16T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/16/why_zettelkasen</id><content type="html" xml:base="http://localhost:4000/2022/01/16/why_zettelkasen.html">&lt;p&gt;Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. 
Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;при-чём-тут-комод&quot;&gt;При чём тут комод?&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9B%D1%83%D0%BC%D0%B0%D0%BD,_%D0%9D%D0%B8%D0%BA%D0%BB%D0%B0%D1%81&quot;&gt;Никлас Луман&lt;/a&gt; — &lt;em&gt;чрезвычайно&lt;/em&gt; продуктивный немецкий социолог. За 40 лет труда он написал более 70 книг и 400 статей на &lt;strong&gt;разные&lt;/strong&gt; темы: социология, биология, математика и др. При этом, книги Лумана совсем не водянистые романы в мягком переплете. Его работы стали настоящей классикой, а сам Луман считается чуть ли не самым важным социологом прошлого века.&lt;/p&gt;

&lt;p&gt;Секрет его продуктивности — тот самый &lt;em&gt;комод&lt;/em&gt;. Никлас создал и постоянно поддерживал свой Zettelkasten как огромную картотеку заметок и идей, а сам же он говорил, что &lt;em&gt;ничего сам не придумывает&lt;/em&gt;, и большая часть работы происходит в Zettelksaten.&lt;/p&gt;

&lt;h4 id=&quot;дело-не-в-мебели&quot;&gt;Дело не в мебели.&lt;/h4&gt;

&lt;p&gt;На самом деле комод с ящиками не при чём. Просто в то время не было более удобного способа ведения картотеки. Zettelkasten — это метод ведения записей. И в своей сути он предельно прост:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Каждая заметка, в идеальном случае, должна быть &lt;em&gt;атомарна&lt;/em&gt;, то есть освещать какую то конкретную мысль и объект “сам в себе”. Заметка не должна превращаться в подробное эссе или статью.&lt;/li&gt;
  &lt;li&gt;Заметки могут иметь тэги, объединяться в “папки” или условные группы, но это &lt;strong&gt;не главное&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Самое главное, и гениально простое — заметка &lt;em&gt;должна ссылаться&lt;/em&gt; на другую заметку, или на несколько заметок.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Таким образом Zettelkasten — это метод организации &lt;em&gt;сети идей&lt;/em&gt;, связанных друг с другом по смыслу. Новые заметки не нарушают структуру, а лишь укрепляют и развивают её. Примерно так же работет человеческий мозг — чем больше нейронных связий вы наращиваете, тем умнее становитесь.&lt;/p&gt;

&lt;p&gt;Метод ведения записей Лумана опередил появление гиперссылок интерата, а работает, по сути именно так.&lt;/p&gt;

&lt;h3 id=&quot;и-зачем-мне-это&quot;&gt;И зачем мне это?&lt;/h3&gt;
&lt;h4 id=&quot;помощник-в-учебе&quot;&gt;Помощник в учебе&lt;/h4&gt;
&lt;p&gt;Zetellkasten отличный инструмент, который может помочь вам в широком спектре задач. Например в учебе. Мы можем читать книги или статьи с целью изучения, и даже перечитывая их несколько раз вдумчево, материал попадет лишь в нашу краткосрочную память. Другое дело, нелюбимое многими — конспектирование. Ведя конспект вы напрягаете заметно больше отделов мозга, в этом процессе учавствует моторика, вы как то жонглируете информацией, сокращаете, etc. Можно пойти ещё дальше (внимание, лайфхак!). Если английский язык не ваш родной, вы не говорите и не пишите на нем, но способны читать и понимать, пусть даже с помощью переводчика — &lt;em&gt;пишите конспекты на русском.&lt;/em&gt; Я так учил документацию Oracle DB, что в конечном итоге привело к лучшему пониманию этой СУБД, и СУБД технологий вообще, чем у других ребят со стажировки, которые пытались учиться по книгам переведенным на русский, и\или не так усердно вели конспекты. Но большую часть материала &lt;em&gt;я всё равно забыл&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ведение сети заметок в Zettelkasten &lt;em&gt;намного&lt;/em&gt; выигрывает у обычного конспектирования. Если бы я тогда знал про этот метод, вел конспект и строил Zettelkasten из ключевых смыслов по всем изучаемым темам, в нем бы сейчас была вся архитектура СУБД, к которой я мог бы вернуться в любой момент, “пробежаться” по ссылкам и очень быстро освежить материал в памяти.&lt;/p&gt;

&lt;h4 id=&quot;отстойник-и-лучший-собеседник-запасные-мозги&quot;&gt;Отстойник и лучший собеседник, запасные мозги&lt;/h4&gt;

&lt;p&gt;Луман часто называл свою картотеку собеседником, второй памятью, жвачкой, и иногда отстойником.&lt;/p&gt;

&lt;p&gt;Со второй памятью всё понятно, фиксирование информации — это главная цель любых записей которые мы ведем.
Zettelkasten как отостойник идей — отличное описание. Во-первых, при внесении новых заметок вы не обязательно должны сразу их линковать с другими, если такая связь естественно не приходит на ум сразу. Главное позже возвращаться к этим “сиротам” и вплетать их в общую сеть созданием связей. Во-вторых, сам по себе Zettelkasten, как уже было сказано, со временем растет и становится умнее, свое содержимое он как бы “настаивает”. Это особенно актуально если вы напоняете Zettelkasten не только как банк изучаемых данных, но и активно вносите туда &lt;strong&gt;свои&lt;/strong&gt; мысли, идеи.&lt;/p&gt;

&lt;p&gt;Каждый раз возвращаясь к Zettelkasten и погуляв по ссылкам вы не только освежите топики в памяти, но и с большой вероятностью ваш мозг сгенерирует новые, “настоявшиеся” идеи. Чем не собеседник?&lt;/p&gt;

&lt;h4 id=&quot;современный-комод&quot;&gt;Современный комод&lt;/h4&gt;

&lt;p&gt;Хорошая новость в том, что нам не надо покупать комод с ящиками, хотя если вам очень хочется, я не стану вас переубеждать :)
Вы можете вполне успешно вести классический Zettelkasten, но нужно ли?
Гораздо проще и продуктивнее воспользоваться современными технологиями. Zettelkasten можно завести используя любой текстовый редактор, собрать себе в докере собственную wiki на локалхосте, или скачать какой-нибудь Zettelkasten софт. Вариантов навалом.&lt;/p&gt;

&lt;p&gt;Я пользуюсь &lt;a href=&quot;https://obsidian.md/&quot;&gt;obsidian&lt;/a&gt; — он мультиплатформерный, имеет вполне отзывчивое комьюнити и бесплатную версию, которой более чем достаточно. Платная подписка позволяет вам завести некий аккаунт и синхронизировать заметки между устройствами, я с трудом понимаю зачем это нужно, кроме способа оказать финаносвую поддержку и выразить благодарность разработчикам. Или можно решить вопрос синхронизации своего кибер-комода банальным репозиторием на гитхабе.&lt;/p&gt;

&lt;p&gt;Преимущество obsidan в том, что заметки в нем полностью поддерживают markdown, есть множество плагинов, как официальных так и от сообщества, а вишинка на торте - граф вашего Zettelkasten. Это очень удобно и наглядно. В данный момент мой выглядит так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zettelkasten.png&quot; alt=&quot;&amp;lt;img class=&amp;quot;image image--xl&amp;quot; src=&amp;quot;/images/zettelkasten.png&amp;quot;/&amp;gt;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Всегда можно зайти в граф, поблуждать по нему, дописать новое в заметки, добавить новые ссылки, укрепив сеть смысловых связей, etc.&lt;/p&gt;

&lt;p&gt;При том что я заполняю его чуть менее месяца. А теперь представьте что будет через пол года? Через год? Даже если вносить в день как минимум одну новую заметку.
Часто, используя Zettelkasten в процессе обучения одну запись добавить просто невозможно, ведь нам нужно следовать правилу атомарности, а изучаемая тема редко когда содержить лишь одну концепцию. Я так-же использую два плагина для obsidian: быстрая кнопка для создания новой заметки с префиксом из текущей даты, и вторая — открыть рандомную заметку.&lt;/p&gt;

&lt;h4 id=&quot;резюме&quot;&gt;Резюме&lt;/h4&gt;

&lt;p&gt;В данный момент мой процесс обучения стал намного устойчивее и яснее. Ведение конспектов по изучаемому материалу, блога и формирование Zettelkasten сильно дополняют и укрепляют друг друга. Смотрите что происходит у вас в голове, и если зацепилась действительно стоящая мысль (вам хотя бы на секунду показалось что она интересна) — незамедлительно запишите куда угодно! Я испольую ежедневник, который всегда под рукой, или личные сообщения самому себе в мессенджерах. Потом вы всегда сможете перенести эти заметки либо в полноценную статью блога (я так написал, например &lt;a href=&quot;/2022/01/15/my_interviews_experience.html&quot;&gt;эту&lt;/a&gt;), или во временную заметку-сиротку в Zettelkasten, которая рано или поздно обязательно обзаведется родственными связями.&lt;/p&gt;

&lt;p&gt;Во всей этой затее главное выработать привычку и достичь постоянства. Такой Zettelkasten — натуральное продолжение вашего мозга. Киберпанк уже давно тут.&lt;/p&gt;

&lt;p&gt;Начните прямо сейчас!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><summary type="html">Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.</summary></entry><entry xml:lang="ru"><title type="html">Мой лайфхак для прохождения интервью.</title><link href="http://localhost:4000/2022/01/15/my_interviews_experience.html" rel="alternate" type="text/html" title="Мой лайфхак для прохождения интервью." /><published>2022-01-15T00:00:00+03:00</published><updated>2022-01-15T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/15/my_interviews_experience</id><content type="html" xml:base="http://localhost:4000/2022/01/15/my_interviews_experience.html">&lt;p&gt;Поговорим о том как подговиться к собеседованию и что нужно держать в голове :)
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;В сети часто пишут и говорят о так называмых hard и coft скилах. Если кто не в курсе, hard - это вполне конкретные компетенции какндидата как специалиста: знание языков программирования, технологических стеков, etc. В общем это всё то, что вы обычно видите в разделе вакансий &lt;em&gt;требумые навыки&lt;/em&gt;. С soft скилами всё ещё проще.
По большому счёту софт скилы - &lt;em&gt;это просто ваши социальные навыки&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;С первым всё понятно - мы должны изучать компетенции и совершенствоваться в своем поле. Касаемо hard скилов, лучшей практой подготовки к любому собеседованию или аттестации будет ведение некоторой документации, подтверждающей ваш опыт как технического специалиста – тематический блог, правильно оформленный гитхаб с проектами и трекером изучаемых тем. Это тема для отдельного разговора.&lt;/p&gt;

&lt;p&gt;Я же хочу поговорить, скорее, о soft скиллах. На основании своего опыта я осознал почти беспройгрышный вариант как вести себя на техническом собеседовании (или аттестации).&lt;/p&gt;

&lt;p&gt;Во-первых, не нужно бояться, никто вас убивать не будет. Самое худшее что может случиться - вам деликатно откажут или не перезвонят, пообещав это сделать. В хорошем случае - вам скажут в чем вы ошибаетесь и что нужно подтянуть. По хорошему это именно то что вам нужно самим &lt;strong&gt;всегда&lt;/strong&gt; уточнять. Любое собесдование не казнь, а крайне полезный опыт.&lt;/p&gt;

&lt;h3 id=&quot;микро-инсайт&quot;&gt;Микро-инсайт&lt;/h3&gt;
&lt;p&gt;А теперь о том, что мне действительно каждый раз помогало:
Перехватывайте инициативу на вашем техническом собеседовании!&lt;/p&gt;

&lt;p&gt;Я не говорю о том, что вам нужно отклоняться от темы вопроса, или вдаваться в рассуждения на абстрактные темами. Не надо умничать! Это  приведет к лишним вопросам и вы сами себя зароете. Будьте бдительны, и задавайте ВСТРЕЧНЫЕ вопросы в &lt;em&gt;обсуждамом контексте&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Ваше собеседование должно быть беседой. Каздый раз делая так я чувствовал позитивную реакцию, получался увлеченный диалог технических специалистов. Если вы действительно имеете какой-то опыт и показываете что “горите глазами” - вам врядли смогут отказать. По крайней мере вы получите отличный фидбэк.&lt;/p&gt;

&lt;p&gt;Если вы уверены что не просто забыли, а вообще не знаете о чем вас спрашивают - не теряйтесь и не стесняйтесь об этом прямо сказать.&lt;/p&gt;

&lt;p&gt;Главное сохранять баланс. Не забывайте что собеседуют всё таки вас.
Когда мне отвечают на встречные вопросы, и я слышу что-то новое и интересное, я никогда не стесняюсь и прошу интервьювера подождать 5 секунд, беру ручку и записываю пометку в блокнот максимально кратко - концепцию, название технологии, etc. Будьте искренни. В противно случае что вы тут вообще делаете? Это же касается вопросов, ответы на которые вы не знаете. Я всегда в таких случая прошу вкратце пояснить о чем речь, и запысываю ответ.&lt;/p&gt;

&lt;p&gt;Хорошо, если вы потом вернетесь к этим записям и изучите список :)
Если нет, то как минимум интервьювер увидит что вы по настояему увлечены процесом изучения новых технологий.&lt;/p&gt;

&lt;p&gt;Правда если вы попали на максимально консервативное, “бирюкратическое” собеседование, то всё выше упомянутое скорее всего не сработает. Тем не менее это тоже является хорошим опытом. Вообще проходить технические собеседования полезно, даже если вам нравится текущее место работы и не планируете его менять. Часто принимая участие этих мероприятиях вы остаетесь в курсе требований рынка, проверяете свои знания и актуализируете их.
В общем одни плюсы.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html">Поговорим о том как подговиться к собеседованию и что нужно держать в голове :)</summary></entry><entry xml:lang="ru"><title type="html">Алгоритм прохождения интервью по программированию.</title><link href="http://localhost:4000/2022/01/15/programming_interview_algorithm.html" rel="alternate" type="text/html" title="Алгоритм прохождения интервью по программированию." /><published>2022-01-15T00:00:00+03:00</published><updated>2022-01-15T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/15/programming_interview_algorithm</id><content type="html" xml:base="http://localhost:4000/2022/01/15/programming_interview_algorithm.html">&lt;p&gt;Достаточно вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью по программированию.&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;Оригинал статьи можете прочитать в его личном блоге по &lt;a href=&quot;https://malisper.me/an-algorithm-for-passing-programming-interviews/&quot;&gt;этой ссылке.&lt;/a&gt;
Приступим.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;За последние несколько лет я проходи интервью в дюжине (или около того) компаний и решил ~50 уникальных алгоритимических задач.
Мне часто давали обратную связь, в которой говорилось, что я отлично справился с предлагаемыми алгоритимическими задачами.
В этом посте я собираюсь поделиться тем, как именно я подхожу к решению этих задач.&lt;/p&gt;

&lt;h2 id=&quot;мыслительный-процесс&quot;&gt;Мыслительный процесс&lt;/h2&gt;

&lt;p&gt;Основной принцип, который я использую, заключается в том что каждая задача, предлагаемая к решению на собеседовании, &lt;em&gt;может быть решена&lt;/em&gt;.
На интервью вас не станут просить доказать Великую теорему Ферма. Если вам дадут какую-то неразрешимую задачу, похоже что у вас не будет особых шансов её решить.&lt;/p&gt;

&lt;p&gt;По моему опыту, примерно в 80% случаев алгоритмические задачи сводятся к фундаментальным структурам данных и алгоритмам. Структуры данных, которые я встречаю чаще всего:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево поиска&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Что касаемо алгоритмов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Скорее всего от вас не будут требовать реализовать бинарный поиск или алгоритм сортировки, но вы &lt;em&gt;должны знать&lt;/em&gt;, что они существуют.)&lt;/p&gt;

&lt;p&gt;Кроме того, есть две дополнительные техники программирования, с которыми вы должны быть знакомы:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;алгоритм-решения&quot;&gt;Алгоритм решения&lt;/h2&gt;

&lt;p&gt;Алгоритм решения задачи выглядит так:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Как только вы получили алгоритмическую задачу, уточните требования к реализации (условия, runtime) которым должно соответствовать ваше решение. Скорее всего интервьвер ответит на этот вопрос.&lt;/li&gt;
  &lt;li&gt;Вычеркните из списка возможных структуры данных и алгоритмы которые очевидно не имеют отношения к рассматриваемой задаче. Это избавит вас от большей части списка, и вы, как правило, останетесь с 2-3 структурами данных и алгоритмами.
    &lt;ul&gt;
      &lt;li&gt;Вы можете не рассматривать слишком медленные структуры данных. Если вам необходимо решить задачу за O(1), то невомозможно использовать бинарное дерево в своем решении, так как бинарное дерево всегда будет выполнять не менее, чем за O(log n) времени.&lt;/li&gt;
      &lt;li&gt;Так же вы можете избавиться от алгоритмов, если их невозможно применить в задаче. Например, если в задаче нет графа, вы знаете, что поиск в глубину вам точно не подойдет.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Рассмотрите варианты использования оставшихся структур данных. Какие из них имеют отношения к поставленной задаче? Решением станет подходящая комбинация, вам остается её только собрать воедино.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте рассмотрим среды выполнения, основные структуры данных и алгоритмы. Затем мы разберем несколько примеров, чтобы убедиться насколько прост данных подход.&lt;/p&gt;

&lt;h3 id=&quot;требования-и-сценарии&quot;&gt;&lt;em&gt;Требования и сценарии&lt;/em&gt;&lt;/h3&gt;

&lt;h4 id=&quot;хэш-таблицы&quot;&gt;Хэш-таблицы.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - поиск, вставка и удаление за O(1)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Когда вам нужно лишь находить и сохранять объекты.&lt;/li&gt;
  &lt;li&gt;Когда вам нужно разделить список объектов на группы, по некотрому свойству (это то, что делает GROUP BY в SQL)&lt;/li&gt;
  &lt;li&gt;Нужно посчитать колиечество отличных элементов из списка.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;связанные-списки&quot;&gt;Связанные списки.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - вставка нового узла, поиск и удаление узлов из головы, хвоста, или из узла на который уже есть указатель.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:
Основные сценарии применения связанных списков витают вокруг факта, что связанные списки поддерживают относительный порядок своих элементов. В интервью по программированию связанные списки, в основном, используются как реализация стека или очереди.&lt;/p&gt;

&lt;h4 id=&quot;двоичные-деревья&quot;&gt;Двоичные деревья.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - вставка, поиск и удалние за O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:
Двоичные деревья используются, когда вам нужно хранить данные в отсортированном порядке. Позволяют быстро находить количество элементов, попадающих в конкретый диапазон, или самый &lt;em&gt;высокий&lt;/em&gt; элемент в дереве.&lt;/p&gt;

&lt;h4 id=&quot;двоичный-поиск&quot;&gt;Двоичный поиск.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Вам нужно найти число в массиве, ближайшее к другому числу.&lt;/li&gt;
  &lt;li&gt;Вам нужно найти наименьше число в отсортированном массиве, которое больше чем другое число.&lt;/li&gt;
  &lt;li&gt;Вам нужно найти наибольшее число в отсортированном массиве, которое меньше другого числа.&lt;/li&gt;
  &lt;li&gt;Если по какой-то причине в своем решении вы не можете использовать хэш-таблицу, вы можете с помощью двоичного поиска проверить, находится ли элемент в отсортированном массиве.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;поиск-в-глубину&quot;&gt;Поиск в глубину.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Требуется обойти весь граф.&lt;/li&gt;
  &lt;li&gt;Требуется найти конкретный элемент в графе.&lt;/li&gt;
  &lt;li&gt;Нужно найти &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B3%D1%80%D0%B0%D1%84%D0%B0&quot;&gt;компоненту графа&lt;/a&gt; (состоящий из наибольшего количества узлов подграф)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;сортировка&quot;&gt;Сортировка.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(n log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Может использоваться в случае, когда вам нужно обработать элементы в требуемом порядке. Сначала сортируем в этом порядке, затем итерируемся по элементам.&lt;/li&gt;
  &lt;li&gt;Может использоваться для соритровки массива, к которому потом будет применяться двоичный поиск.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;динамическое-прогрммирование-и-рекурсии&quot;&gt;Динамическое прогрммирование и рекурсии.&lt;/h4&gt;

&lt;p&gt;Динамическое программирование и рекурсия отличаются тем, что являются общими методами решения алгоритмических задач, а не конкретными алгоритмами.
Это означает что у них нет конкретных сценариев применения или требуемого &lt;a href=&quot;https://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5&quot;&gt;асимптотического поведения&lt;/a&gt;. 
Хорошая новость в том, что после небольшой практики становится достаточно просто распознавать задачи, которые можно решить с помощью динамического программирования или рекурсии. Я рекомендую попрактиковаться в подобных задачах, чтобы вы &lt;em&gt;могли почувствовать&lt;/em&gt; эти методы. Полное объяснение динамического программирования и рекурсии выходит за рамки данного поста.&lt;/p&gt;

&lt;h3 id=&quot;примеры&quot;&gt;Примеры&lt;/h3&gt;

&lt;p&gt;Теперь давайте посмотрим на несколько разных алгоритмических задач с интервью, и как они могут быть решены с помощью алгоритма решения.&lt;/p&gt;

&lt;h4 id=&quot;задача-1-написать-рейт-лимитер&quot;&gt;Задача #1: Написать рейт-лимитер&lt;/h4&gt;

&lt;p&gt;Эту задачу я встречал несколько раз на интервью в разных компаниях.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Вам нужно написать функцию, которая может быть вызвана не более N раз за одну минуту. Например, она может быть вызвана лишь 10 раз в минуту.
Если функция вызывается более N раз, она должна генерировать исключение. Ожидается что функция будет работать за O(1).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Посмотрите на список алгоритмов и структур данных, которые мы можем использовать, и попытайтесь понять какие из них помогут в решении данной задачи. Затем попробуйте понять как вы можете их применить в решении. Попробуйте самостоятельно, прежде чем смотреть ответ.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Сперва исключим алгоритмы и структуры данных, которые явно не подходят.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Двоичное дерево&lt;/del&gt; — слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; — слишком медленно, и в задаче нет графа для использования этого алгоритма.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — тоже слишком медленно, в задаче нет отсортированного массива.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — снова слишком медленно. В задаче нет элементов для сортировки.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — нет способов применить динамическое программирование в решении.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — нет сособов применить рекурсию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Не вычеркнули только хэш-таблицы и связанные списки. Если мы вернемся и рассмотрим сценарии использования хэш-таблиц, то не найдем способа применить эту структуру данных в решении задачи. Нам не нужно быстро искать разные объекты, и не нужно разбивать на подгруппы списки объектов. Значит хэш-таблицы тоже можно вычеркнуть из списка.&lt;/p&gt;

&lt;p&gt;Таким образом, осталась только одна структура данных v связанные списки. Глядя на сценарии применения видим реализацию стека или очереди. Можем ли мы использовать какой то из этих вариантов для отслеживания колличества вызовов функции за последюю минуту? Да! Мы можем создать очередь, в которую будет входить одна запись за каждый вызов функции в течении последней минуты. Каждый раз, когда функция вызывается, мы удаляем из очереди все записи, которые были сделанны более минуты назад. Если очередь по прежнему имеет длинну больше N — генерируется исключение. В противном случае мы добавляем новую запись в очередь с меткой текущего времени (время вызова). Отслеживая длинну очереди с помощью переменной счётчика, которую мы можем определять за O(1), функция так же будет иметь ожидаемую производительность O(1).&lt;/p&gt;

&lt;h4 id=&quot;задача-2-анаграммы&quot;&gt;Задача #2: Анаграммы&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;На вход поаается список слов, из которого нужно составить список слов, которые являются анаграммами как минимум одного другого слова во входном списке. Два слова являются анаграммами друг друга, в случае если буквы в одном слове можно поменять местами так, чтобы получилось второе. Программа должна выполняться за O(n), если все слова одной длинны&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Снова попытатейтсь обдумать задачу самостоятельно, прежде чем читать решение. Вот уже знакомый нам список структур данных и алгоритмов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение-1&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Начнем отбрасывать элементы из списка, которые не помогут в решении проблемы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Двоичное дерево&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; —Тут нет графа.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — Тут нет отсортированного массива.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — Нет способа применить динамическое программирование.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — Нет способа применить рекурсию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;У нас остались хэш-таблицы и связанные списки. Связанные списки, похоже, не пригодятся в решении этой задачи, так как стэк или очередь не выглядят эффективно. Получается что остается использовать хэш-таблицу.&lt;/p&gt;

&lt;p&gt;Единственный вариант использования хэш-таблицы, который кажется здесь уместным, — это возможность разделить список объектов на группы по некоторому признаку. В этом случае, если бы у нас был способ разделить список на отдельные группы, в которые бы входили слова анаграммы друг друга, это помогло бы решить задачу. Выглядит как план:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Разделим входной список слов на группы по признаку “анаграммности” друг друга.&lt;/li&gt;
  &lt;li&gt;Соединим вместе группы, в которых больше одного слова. В результате мы получим требуемый список слов, в котором каждое слово будет являться анаграммой как минимум одного другого слова из входного списка.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Единственное, что нам осталось решить. это найти какое-то свойство, которое мы можем использовать для группирования анаграмм. Нам нужно определить функцию &lt;em&gt;f&lt;/em&gt;, результат выполнения которой как &lt;em&gt;f(x)&lt;/em&gt; и  &lt;em&gt;f(y)&lt;/em&gt; будет одинаков, если x и y являются анаграммами друг друга.&lt;/p&gt;

&lt;p&gt;Для этой цели мы можем использовать две разные функции:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Отсортируем символы в словах по алфавиту. Мы знаем, что все анаграммы состоят из одних и тех же буква. Таким образом мы получим одну и ту же строку для любой пары слов-анаграмм.&lt;/li&gt;
  &lt;li&gt;Составим словарь из количества вхождений каждой буквы в каждом слове. Это решенее сложнее, так как придётся каким то образом использовать в качестве ключа в хэш-таблице. В некоторых языках программирования есть способ это сделать, в других нет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Теперь, когда мы нашли способ сгруппировать слова анаграммы друг друга, мы можем собрать все размышления вместе и решить задачу.&lt;/p&gt;

&lt;p&gt;Давайте попробуем рассмотреть ещё одну задачу.&lt;/p&gt;

&lt;h4 id=&quot;задача-3-k-sorted-частичная-сортировка&quot;&gt;Задача #3: K-sorted (частичная сортировка)&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Есть массив объектов, который частично отсортирован, и его нужно “досортировать”. Каждый элемент массива находится на расстоянии, не более чем k от своего фактического места. Требования к сложности реализации алгоритма отсутствуют.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Как и ранее, вот список алгоритмов и структур данных:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение-2&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Сначала, давайте подумаем, можем ли мы что то предположить о сложности и времени выполнения алгоритма. В самом лучшем случае мы можем достичь O(n), посколько именно столько времени потребуется на итерирование по списку. Мы также можем выполнить обычную сортировку за O(n log n). Давайте определим, можно ли сделать лучше, чем O(n log n).&lt;/p&gt;

&lt;p&gt;Как нам достичь скорости в O(n)? Ну, если k=n, то сложность задачи становится такой же, как сортировка списка, поэтому невозможно постоянно попадать в O(n). Но может быть всё ещё можно решить задачу быстрее, чем за O(n log n). Теперь давайте посмотрим, какие структуры данных и алгоритмы из нашего перечня помогут в решении:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; — Нет графа.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — Массив не отсортирован.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — Не подходит для решения задачи.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — Не подходит для решения задачи.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Из оставшихся структур данных, единственная, которая имеет отношение к возможному решению — это двоичное дерево. К такому выводу мы приходим потому что только двоичное дерево единственная структура данных из списка, имееющая отношение к сортировке элементов. Если немного подумать о том, как можно применить двоичное дерево для решения, ответ станет ясен. Мы можем построить двоичное дерево из &lt;em&gt;последних k элементов&lt;/em&gt;. Мы раз за разом удаляем наименьший элемент из бинарного дерева, и добавляем в него следующий из входного массива. Полный алгоритм решения выглядит следующим образом:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Построить двоичное дерево из первых k элементов входного массива.&lt;/li&gt;
  &lt;li&gt;Перебрать оставшуюся часть массива. На каждой итерации удаляем наименьший элемент из двоичного дерева и добавляем его в результирующий массив. Затем добавляем &lt;em&gt;текущий&lt;/em&gt; элемент из входного массива в двоичное дерево.&lt;/li&gt;
  &lt;li&gt;Как только мы дойдем до конца входного массива, один за одним удаляем наименьший элемент из двоичного дерева, пока дерево не опустеет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Анализируя сложность этого решения делаем вывод, что время выполнения составит O(n log k). Возможно ли сделать лучше? Интуитивно кажется, что тут добиться более быстрого алгоритма не получится. 
Какой алгоритм может быть эффективнее, между O(n) и O(n log k), особенно из тех, что вам удастся придумать во время интервьюирования? Дале приводится неформальное доказательство того, что вы не можете решить задачу быстре, чем O(n log k). Учитывая то, что придумать алгоритм быстрее задача не из лёгких, от вас не будут ожидать этого на интервью. Если доказательство вам не интересно, можете его пропустить.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Предположим, у вас уже есть алгоритм, который работает быстрее, чем O(n log k). Мы можем использовать его, чтобы пытаться придумать алгоритм сортировки, который быстрее O(n log n), что невозможно. Допустим, у вас есть n/k различных списков, кажрый длинной в k, причем элементы каждого списка строго больше, чем элементы предыдущего. Если вы объедините все списки вместе, запустите для них k-сортировку, а затем разделите каждые k элементов на отдельные списки, вы отсортируете n/k списков менее, чем за время O(n log k). В свою очередь это означает, что в среднем вы сортируете каждый список менее чем за O(n/(n/k) log k) = O(k log k), что невозможно. Поэтому ни один алгоритм k-сортировки не будет работать быстрее, чем O(n log k).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Это озачает что выше мы нашли оптимальное решение поставленной задачи.&lt;/p&gt;

&lt;p&gt;Надеюсь, на данный момент я убедил вас, что алгоритм решения алгоритмических задач, описываемый в этом посте — эффективный метод. Обратите внимание, что он эффективен не только при решении задач на собеседованиях, но и для решения алгоритмических задач, с которыми вы можете столкнуться в реальном мире. Вы можете использовать его, чтобы проверить, есть ли у задачи решение, состоящие из основных структур данных из нашего списка.&lt;/p&gt;

&lt;p&gt;Если вы хотите узнать о других способах решения задач, я настоятельно рекомендую книгу &lt;a href=&quot;https://www.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069111966X&quot;&gt;How to solve it&lt;/a&gt;. Эта книга охватывает множество различных подходов к решению любой задачи. How to solve it оказала огромное влияние на то, как я подхожу к любой задаче в настоящее время.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;На этом текст оригинальной статьи подходит к концу. По мере вычитывания и укрепления собственного понимания, с большой долей вероятности, в мой перевод будут вноситься улучшающие изменения.
Это статья достаточно сложная. Если вам не понятно что такое O(n) и так далее, и вы не знакомы с алгоритмами и структурами данных, о которых идет речь — не беспокойтесь! Я планирую написать цикл небольших постов на эти темы. Благодарю за уделённое время и надеюсь что превод окажется вам полезным!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Перевод" /><category term="Программирование" /><category term="Алгоритмы" /><category term="ComputerScience" /><summary type="html">Достаточно вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью по программированию.</summary></entry><entry xml:lang="ru"><title type="html">О чём этот блог?</title><link href="http://localhost:4000/2022/01/10/about_blog.html" rel="alternate" type="text/html" title="О чём этот блог?" /><published>2022-01-10T00:00:00+03:00</published><updated>2022-01-10T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/10/about_blog</id><content type="html" xml:base="http://localhost:4000/2022/01/10/about_blog.html">&lt;p&gt;Приветствую. Мысль начать вести свой блог я развивал около полугода. Сперва, идея заключалась в написании статей ради систематизирования своих знаний и мыслей. Я пробовал собрать нечто на Django и Vue, что-то получилось, но в итоге так и не ушло в &lt;em&gt;production&lt;/em&gt;. Я не был доволен результатом, так как это была всего лишь копипаста с какой то статьи “для чайников”. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Впрочем не хватало и мотивации, зато работы и бытовых трудностей - навалом. Сейчас быт стало ещё гуще и напряжённее, но счасливее, благодаря унарному инкременту счётчика кол-ва членов моей семьи. А мотивации вести блог насыпали знатно. За сына я благодарю свою любимую супругу, а за мотивацию - Сергея Игоревича Бобровского, у которого я учусь программированию уже чуть более года. В виду этих обстоятельств - я более чем доволен GitHub Pages на Jekyll.&lt;/p&gt;

&lt;p&gt;Обо мне вы можете прочитать &lt;a href=&quot;/about.html&quot;&gt;здесь&lt;/a&gt;. Вернёмся к блогу.&lt;/p&gt;

&lt;p&gt;Планируется, что основной контент статей будет заключаться в описании изучаемых мной технологий, нюансов программирования и инсайтов, на которые я надеюсь. Трек обучения и лог вы можете найти в моём &lt;a href=&quot;https://github.com/NaNameUz3r/My-Learning-Tracker&quot;&gt;гитхабе&lt;/a&gt;. Оставляю за собой право на глупость и ламерство, за что прошу отнестись с пониманием. Я открыт для любой конструктивной &lt;del&gt;и не очень&lt;/del&gt; критике, всегда рад обратной связи.&lt;/p&gt;

&lt;h3 id=&quot;почему-такое-название&quot;&gt;Почему такое название?&lt;/h3&gt;

&lt;p&gt;А почему топор? Потому что &lt;em&gt;врубаемся&lt;/em&gt;. Если вы на волне хайпа стереотипизируете Хакер == Кибер-преступник, право ваше, “рыночек” &lt;del&gt;вас&lt;/del&gt; порешал. Я исповедую другое понимание, Хакерство как вдохновенный настрой ума разобраться в той или иной теме, ведущее к мастерству в исследуемой области. Сантехник, который с закрытыми глазами и оторванной рукой починит вам трубы с помощью подручных материалов, которые вам бы и в голову не пришло использовать, да ещё быстро и качественно это сделает - Хакер.&lt;/p&gt;

&lt;p&gt;Скрипт кидди, который не может отсортировать массив без стандартных библиотек ЯП, но при этом успешно разводит народ, эксплуатируя когнитивные баги человеческого мозга - банальный мошенник и преступник, какие были всегда испокон веков.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Я не хакер&lt;/strong&gt;, но wannabe. Мне нравятся информационные технологии. Я вообще плох в математике, и в контексте данного блога преследую лишь две следующие, взаимодополняемые в бесконечном цикле, цели:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Врубиться в программирование&lt;/li&gt;
  &lt;li&gt;Поделиться нарубленным&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Надеюсь вы, как говорится, get the point.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html">Приветствую. Мысль начать вести свой блог я развивал около полугода. Сперва, идея заключалась в написании статей ради систематизирования своих знаний и мыслей. Я пробовал собрать нечто на Django и Vue, что-то получилось, но в итоге так и не ушло в production. Я не был доволен результатом, так как это была всего лишь копипаста с какой то статьи “для чайников”.</summary></entry></feed>