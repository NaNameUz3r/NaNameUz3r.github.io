<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-02-20T23:38:21+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Врубаемся в Декларативную модель</title><link href="http://localhost:4000/2022/02/20/hack_in_declarative_model_3.html" rel="alternate" type="text/html" title="Врубаемся в Декларативную модель" /><published>2022-02-20T00:00:00+03:00</published><updated>2022-02-20T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/20/hack_in_declarative_model_3</id><content type="html" xml:base="http://localhost:4000/2022/02/20/hack_in_declarative_model_3.html">&lt;p&gt;Часть 3. Список списков, итеративные вычисления и прочие муми-тролли. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;here-we-go-again&quot;&gt;Here we go again&lt;/h3&gt;
&lt;p&gt;Здравствуйте! Это очередной пост-отчёт по мотивам материала из курса &lt;a href=&quot;https://skillsmart.ru/&quot;&gt;школы Сергея Бобровского&lt;/a&gt; – Как понять в программировании всё. Изучаем декларативную вычислительную модель.&lt;/p&gt;

&lt;p&gt;В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.&lt;/p&gt;

&lt;p&gt;Рекурсия как программистский трюк не ограничивается “самовызовом” (прочитали как самовывоз, признайтесь?) функций — &lt;em&gt;рекурсивными могут быть и типы данных&lt;/em&gt;. Базовый пример рекурсивного типа данных — список.&lt;/p&gt;

&lt;p&gt;Почему список на самом деле рекурсивная структура? Потому что он определяется &lt;em&gt;в терминах более короткой версии себя самого&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и &lt;em&gt;“список”&lt;/em&gt;, а лучше сказать набор или “последовательность” пар “ключ-значение”.&lt;/p&gt;

&lt;p&gt;Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список.&lt;/p&gt;

&lt;p&gt;Как правило этими “произвольными” значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка “впихнуть” в эти “кусочки” какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда).&lt;/p&gt;

&lt;p&gt;Части списка связанны некоторым образом с другими, и всё вместе (“элементарный кусок данных” и связь-указатель на другой) называется &lt;em&gt;узел&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.&lt;/p&gt;

&lt;p&gt;Вернемся к фундаментальным материям :)&lt;/p&gt;

&lt;p&gt;В декларативной модели список определяется &lt;em&gt;рекурсивно&lt;/em&gt;. Считается, что либо список пустой (nil или, если хотите, None), либо &lt;em&gt;есть какое-то значение связанное со списком&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, “узел” содержащий строку “shrek”, то тогда список X будет равен “shrek” &lt;em&gt;связанный со списком nil&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Короче говоря, “последний” элемент в списке всегда будет “указывать” на “пустой список”.&lt;/p&gt;

&lt;p&gt;Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.&lt;/p&gt;

&lt;p&gt;В рекурсивных функциях, работающих со списками, &lt;em&gt;базовым случаем&lt;/em&gt; будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов &lt;em&gt;более мелких списков&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Например, “декларативная” рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list_length(some_list):
    if some_list == []
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    return 1 + list_length(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — “Ух ты ж сколько можно то намутить с этим списком!”&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/hold_on.gif&quot; alt=&quot;Подождите!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Это всё ещё рекурсивная функция, мы в прошлый уже говорили про проблему с переполнением стека. Кроме того, рекурсивные функции со списками, при их необдуманном определении, вполне могут оказываться крайней не эффективными — O(n*n) или ещё хуже.&lt;/p&gt;

&lt;p&gt;Для решения этих проблем есть техника, при которой рекурсивные функции превращаются в функции с &lt;em&gt;итеративной формой вычисления&lt;/em&gt; с &lt;strong&gt;линейной&lt;/strong&gt; эффективностью!&lt;/p&gt;

&lt;h3 id=&quot;итерируй-то&quot;&gt;Итерируй то&lt;/h3&gt;

&lt;p&gt;Ранее мы говорили про итеративные вычисления как о частном случае рекурсии. Разберемся чуть глубже.&lt;/p&gt;

&lt;p&gt;Во-первых стек. Почему он вообще формируется при рекурсивном вызове? Обратите внимание на пример функции вычисления длинны списка, а именно на хвостовой return в конце. Раз за разом при рекурсивном вызове окружение экземпляра функции должно сохраняться в стеке, потому что прибавление единицы происходит &lt;strong&gt;после&lt;/strong&gt; этого заключительного return.&lt;/p&gt;

&lt;p&gt;В нашем примере это всё происходит лишь для того, чтобы потом в обратном порядке “размотать” стек и просуммировать единцы. Кажется избыточным.&lt;/p&gt;

&lt;p&gt;Чем отличается итеративное вычисление от обычной рекурсии?&lt;/p&gt;

&lt;p&gt;Схема итеративных вычислений — это &lt;em&gt;последовательность &lt;strong&gt;трансформации состояний&lt;/strong&gt;&lt;/em&gt;. Как это работает?&lt;/p&gt;

&lt;p&gt;Ну, по сути, мы добавляем некоторый счетчик в аргумент рекурсивной функции, и делаем так чтобы увеличение этого счетчика &lt;em&gt;происходило &lt;strong&gt;до&lt;/strong&gt; рекурсивного вызова&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Рекурсивная-итеративная функция вычисления длины списка будет выглядеть так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обратите ещё раз внимание на счетчик &lt;em&gt;i&lt;/em&gt;. Мы увеличиваем его в аргументах рекурсивного вызова, &lt;strong&gt;до&lt;/strong&gt; самого вызова. Благодаря этому мы “замыкаем” окружение функции и состояние каждого экземпляра не требуется сохранять в отдельных записях в стеке.&lt;/p&gt;

&lt;p&gt;Ничего не мешает скрыть такую функции за функцией-абстракцией, которая будет принимать только list, а внутри вызывать inter_list_length(0, list).&lt;/p&gt;

&lt;h3 id=&quot;итерируй-это&quot;&gt;Итерируй это&lt;/h3&gt;

&lt;p&gt;Видите как связана “рекурсивность функции” с “рекурсивностью типа”, который она обрабатывает?&lt;/p&gt;

&lt;p&gt;Это &lt;strong&gt;важная фишка&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Мы уверенно можем сказать, что &lt;em&gt;рекурсивная структура функции зависит от рекурсивной структуры определения обрабатываемого типа данных&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы потенциально можем нагородить какой угодно рекурсивный тип, но это не есть хорошо. Эта свобода в программировании часто приводит к написанию очень неэффективных, не грамотных алгоритмов.&lt;/p&gt;

&lt;p&gt;Само по себе определение какого-то типа данных в языке программирования &lt;em&gt;описательно&lt;/em&gt;. Это значит, что такое определение является всего лишь набором логических утверждений о множестве значений, который данный тип может принять. Такие определения не являются полноценными проверками допустимостей значений, а зачастую (например какой нибудь абстрактный тип) их вообще проверить нельзя.&lt;/p&gt;

&lt;p&gt;В декларативной модели даже базовые типы могут быть не проверенны компилятором. Поэтому нам &lt;strong&gt;важно&lt;/strong&gt; предельно осознанно понимать что мы кодим, и использовать изначально свойственные декларативной модели типы данных.&lt;/p&gt;

&lt;p&gt;Список это very handy! Надо лишь включить думалку, и включить так, чтобы избежать неэффективных реализаций алгоритмов.&lt;/p&gt;

&lt;p&gt;Вернемся к нашему определению взаимосвязи рекурсивности типа с рекурсивностью функции.&lt;/p&gt;

&lt;p&gt;Сперва нам необходимо &lt;em&gt;правильно определить рекурсивный тип&lt;/em&gt;, прежде чем писать для него функцию. Что это значит?&lt;/p&gt;

&lt;p&gt;Например, у нас есть некий композитный список, элементы которого тоже могут быть списками, и нам надо посчитать количество всех значений, включая значений во вложенных списках.&lt;/p&gt;

&lt;p&gt;Нам нужно понять, или &lt;em&gt;определить&lt;/em&gt; тип “вложенный список”.&lt;/p&gt;

&lt;p&gt;Мы помним что “список” — это либо пустой [], либо некоторый “элемент” связанный с [].&lt;/p&gt;

&lt;p&gt;В таком случае “вложенный список” будет определяться как — либо пустой [], либо “вложенный список” связанный с “вложенным списком”, либо как “элемент” связанный с “вложенным списком”. Ничего не понятно?&lt;/p&gt;

&lt;p&gt;Короче говоря, у нас в любом порядке и в “ширину” и в “глубину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых в любом порядке и в “глубину” и в “ширину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых…&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/recursion_1.gif&quot; alt=&quot;Рекурсия&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Неотложка уже выехала.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Так, давайте не будем пороть горячку! Это проще чем кажется.&lt;/p&gt;

&lt;p&gt;Вложенный список, с которым может быть связан вложенный список, все ещё “обычный” список, который может быть пустым (то есь может “не быть”! Ом!) Мы с этого и начали определение.&lt;/p&gt;

&lt;p&gt;Тогда функция, основанная на таком типе будет иметь структуру:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;length_1(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if type(some_list) is list:
        return length_1(list_head) + length_1(list_tail)
    
    return 1 + length_1(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;А если структура типа будет другой? Функция будет иметь &lt;em&gt;другую&lt;/em&gt; логику. К примеру у нас есть тип подобный предыдущему, но нам не важно количество элементов во вложенных списках, и мы хотим лишь посчитать элементы на “верхнем” уровне. Не важно — является этот элемент списком или нет.&lt;/p&gt;

&lt;p&gt;Поймите, речь идет о &lt;em&gt;логическом&lt;/em&gt; определении типа.&lt;/p&gt;

&lt;p&gt;В таком случае тип “вложенный список 2” мы будем определять как — либо пустой [], либо “вложенный список 2” связанный со “вложенным списком 2”, либо как &lt;em&gt;элемент “верхнего” уровня&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ключевое отличие с прошлым примером в том, что тогда “вложенный список” всегда считался списком, а на этот раз он может считаться как простой элемент.&lt;/p&gt;

&lt;p&gt;Функция:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;length_2(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if list_tail == []:
        return 1
    
    return length_2(list_head) + length_2(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ключевой момент тут это проверка list_tail == [], суть которого в том, что если рекурсия добралась до случая, когда хвост элемента является пустым списком мы возвращаем единицу, как бы “забивая” на то, что “проваливались” во вложенный список.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Эти простые примеры приводятся как пример для понимания способа которым мы должны мыслить о рекурсивных вычислениях в декларативной модели. Почему нам всегда важно понимать логику алгоритма, и учитывать структуру рекурсивного типа, с которым работаем.&lt;/p&gt;

&lt;p&gt;Декларативная модель дает нам мощный и изящный инструмент — &lt;em&gt;минималистичность&lt;/em&gt;, которым можно и нужно пользоваться при разработке алгоритмов (если это возможно). Декларативная модель удобна и исключает множество потенциальных ошибок, если мы четко определяем типы и понимаем что делаем.&lt;/p&gt;

&lt;h3 id=&quot;аккумуляторы&quot;&gt;Аккумуляторы!&lt;/h3&gt;

&lt;p&gt;На этом моменте мы уже выяснили как писать рекурсивные функции, делать из них итеративные и как корректно определять и применять рекурсивные типы данных. Так а зачем тогда рекурсивные функции? &lt;em&gt;А не зачем&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В боевой разработке с использованием декларативной модели функции &lt;em&gt;сразу пишут итеративными&lt;/em&gt;! Мы разобрали эти тонкости сугубо в целях понимания и изучения.&lt;/p&gt;

&lt;p&gt;Давайте повторим для закрепления. Вся фишка итеративных вычислений в &lt;em&gt;передаче значения&lt;/em&gt; все “глубже” в рекурсию. Мы никогда не возвращаемся обратно с помощью return.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/buzz.gif&quot; alt=&quot;Базз&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Ну или пока память не кончится :D&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Отставить шуточки! Как это работает?&lt;/p&gt;

&lt;p&gt;Возьмем состояние, которое передаем в функцию как S. Возьмем это состояние и расширим двумя аргументами, S1 и Sn.&lt;/p&gt;

&lt;p&gt;Такой финт называется — &lt;em&gt;аккумулятор&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы берем этот аккумулятор и передаем его в &lt;strong&gt;процедуру&lt;/strong&gt; (не функцию!). В первом посте мы говорили о том, что декларативная процедура работает в своих параметрах с указателями на ещё &lt;em&gt;не инициализированные&lt;/em&gt; декларативные переменные. Иными словами, результат работы процедуры возвращается через эти параметры &lt;em&gt;по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В аккумуляторе: S1 является входным состоянием, а Sn — выходным, то есть результатом. Внутри такой процедуры происходит её рекурсивный вызов выполняющий последовательные преобразования Si в Si+1 (итеративные, тысяча чертей!!!)&lt;/p&gt;

&lt;p&gt;Псевдокод:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;procedure(S, S1, Sn):
если вычисления S не требуются:
    Sn = S1
иначе:
    ## начинается блок рекурсивных вызовов
    procedure1(S1, S2)
    procedure2(S2, S3)
    ...
    procedureN(Sn-1, Sn)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Выход каждой procedureI является входом procedureI+1&lt;/p&gt;

&lt;p&gt;Как уже объяснялось, отличие от рекурсивной функции в том, что нам не надо сохранять в стеке все промежуточные состояния-вызовы, так как значения передаются по ссылке. А “базовым случаем-ограничением” рекурсии, может быть указание границы обработанных элементов в исходной структуре S.&lt;/p&gt;

&lt;p&gt;Когда мы в этом посте разбирали итеративные вычисления на примере функции iter_length:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы практически использовали &lt;em&gt;схему с аккумулятором&lt;/em&gt;, передавая текущую длину в следующий вызов &lt;em&gt;по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Фактически в наши дни такая схема с аккумуляторами считается устаревшей, и их чрезмерное использование лишь затруднит программирование.&lt;/p&gt;

&lt;p&gt;Схема с аккумуляторами имеет право на жизнь, когда получается ограничиться минимальным количеством аккумуляторов (1-2).&lt;/p&gt;

&lt;p&gt;Тем не менее, пользу от знания таких фундаментальных приемов невозможно переоценить в контексте прокачки нашей аналитической и программистской машинки мозга.&lt;/p&gt;

&lt;p&gt;И вот ещё повторим — хотя в итеративных вычислениях мы не проваливаемся в стек “в глубину”, память потенциально может кончиться ещё как! Мы “разматываем” состояние “в ширину”.&lt;/p&gt;

&lt;p&gt;Спасибо за внимание.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><summary type="html">Часть 3. Список списков, итеративные вычисления и прочие муми-тролли.</summary></entry><entry xml:lang="ru"><title type="html">Бери и DRY, и так далее</title><link href="http://localhost:4000/2022/02/13/dry_etc.html" rel="alternate" type="text/html" title="Бери и DRY, и так далее" /><published>2022-02-13T00:00:00+03:00</published><updated>2022-02-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/13/dry_etc</id><content type="html" xml:base="http://localhost:4000/2022/02/13/dry_etc.html">&lt;p&gt;Рассматриваем пару универсальных принципов разработки.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;лучше-сухо-чем-мокро&quot;&gt;Лучше сухо, чем мокро!&lt;/h3&gt;

&lt;p&gt;Аббревиатура принципа DRY расшифровывается как Don’t repeat yourself, что недвусмысленно переводится как “Не повторяйся”. Само сокращение является словом dry — сухой, и нарушение принципа окрестили как WET (мокрый) — Write everything twice (Пиши всё дважды) или We enjoy typing (Нам нравится печатать).&lt;/p&gt;

&lt;p&gt;Разумеется уровень влажности тут вообще не при чем :)&lt;/p&gt;

&lt;p&gt;Вероятно вы уже встречали упоминание DRY. О нем часто говорят в бесплатных и платных уроках программирования, но как правило речь только в контексте написания кода (programming-in-small).&lt;/p&gt;

&lt;p&gt;На самом деле этому универсальному принципу можно, и обязательно нужно, следовать на всех уровнях проектирования системы.&lt;/p&gt;

&lt;h1 id=&quot;я-никогда-не-повторяюсь&quot;&gt;Я никогда не повторяюсь&lt;/h1&gt;
&lt;h3 id=&quot;неповторим-внутри&quot;&gt;Неповторим внутри&lt;/h3&gt;

&lt;p&gt;Как я уже сказал, чаще всего DRY преподносят как правило, при котором мы не должны повторно использовать (копировать) код, в разные части программы. Это лишь малая доля. Фишка в том, что DRY применим к любой сущности в системе, на любом уровне абстракции.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Если что-то где-то определено, оно должно быть определено только в этом месте.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;А что касаемо кода, то бывают случаи когда дублирование &lt;em&gt;оправдано&lt;/em&gt;. Например есть две высокоуровневые функции (методы), которые производят &lt;em&gt;похожие&lt;/em&gt; вычисления, но в разном контексте, и служат разным целям (всякие проверки истинности, etc).&lt;/p&gt;

&lt;h3 id=&quot;неповторим-снаружи&quot;&gt;Неповторим снаружи&lt;/h3&gt;

&lt;p&gt;В проектировании (programming-in-large) DRY работает аналогично. Во-первых, если есть какой-то конкретный модуль, то его спецификация должна быть единообразной и находиться в одном месте.&lt;/p&gt;

&lt;p&gt;Это значит, что нельзя просто копировать этот модуль, немного его изменять и встраивать в систему. Тогда в будущем при доработке, в случае изменений одного такого “модуля-клона”, нам придется менять то же самое и во втором. А если копий три, четыре…? Вы точно думаете что сможете вспомнить о них всех, я не говорю уже о совершенно очевидном неудобстве такой архитектуры. Это полный зашквар, не надо так делать.&lt;/p&gt;

&lt;p&gt;Во-вторых, программные интерфейсы (api) тоже должны быть единообразными, следовать спецификации. Представьте что “внутри” модули используют по разному описанные вызовы. Внешние вызовы тоже накостыляли по другому. Чувствуете аромат? Так пахнет горящая точка опоры, когда система рухнет из за того что мы поменяли один интерфейс, или &lt;em&gt;забыли&lt;/em&gt; поменять один из них, в соответствии с новыми требованиями.&lt;/p&gt;

&lt;p&gt;Во избежание этого можно использовать, например OpenAPI, или что-то в таком духе. Если мы разрабатываем собственный API, он должен быть корректно задокументирован и доступен &lt;strong&gt;в одном месте&lt;/strong&gt; (например в конкретном репозитории команды разработки).&lt;/p&gt;

&lt;h2 id=&quot;что-и-тут-тоже&quot;&gt;Что, и тут тоже?&lt;/h2&gt;

&lt;p&gt;Мы плавно подошли к документации. Многие разработчики не любят документировать проекты, и это &lt;strong&gt;плохо&lt;/strong&gt;. А если и ведут документацию то относятся очень халатно. Ctrl-c, Ctrl-v, Тяп ляп, и так сойдет!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Документация тоже должна следовать принципу DRY&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;На уровне комментариев кода (это ведь тоже документация), пример WET-поведения — зачем-то описывать подробными комментариями чуть ли не каждую функцию в коде. Ясный код должен говорить сам за себя и быть понятен читающему его программисту (например вам самим завтра или через неделю).&lt;/p&gt;

&lt;p&gt;Так зачем повторяться? Разве что код выглядит запутанным и совершенно непонятным? Если так, то это отдельная проблема и нужно решать её в первую очередь.&lt;/p&gt;

&lt;p&gt;На уровне документирования проекта — мы должны структурировать документы понятно, излагать информацию последовательно и, простите за тавтологию — &lt;em&gt;информативно&lt;/em&gt;. Документация это не удобный случай поупражняться в графомании.&lt;/p&gt;

&lt;p&gt;На самом деле писать код и писать текст по сути одно и то же, разве нет?&lt;/p&gt;

&lt;p&gt;Мы можем подойти к этой задаче почти так же, как к разработке программы. Декомпозируйте её! Если вы хорошо понимаете документируемый проект то это не вызовет проблем. Каждый модуль, согласно DRY, описывается в одном разделе документации, API в другом, и так далее.&lt;/p&gt;

&lt;h1 id=&quot;легко-поменять&quot;&gt;Легко поменять&lt;/h1&gt;

&lt;p&gt;Ещё один очень важный принцип, залог, хорошего проектирования — &lt;strong&gt;ETC&lt;/strong&gt;, или Easier to change!&lt;/p&gt;

&lt;p&gt;Мы все люди, и нам свойственно ошибаться в своих решениях. Разумеется и в разработке программных систем. Поэтому очень важно создавая что-то новое, или внося изменения в уже существующие части, всегда задаваться вопросом — “А будет ли в будущем это &lt;em&gt;легко изменить&lt;/em&gt;?”&lt;/p&gt;

&lt;p&gt;Подумайте, будет ли легко вносить изменения в проект, в котором строго следуют “сухому закону” DRY? (Я пытаюсь шутить, извините!)&lt;/p&gt;

&lt;p&gt;Разумеется будет!&lt;/p&gt;

&lt;p&gt;Этому принципу осознанности ETC нужно следовать даже (особенно!) в самых малых частях разработки, вплоть до написания функции из нескольких строк кода. Будет ли она легко заменимой, исправляемой? Ясно ли она описана?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Верно утверждать что принцип DRY является логическим продолжением ETC. Вообще &lt;em&gt;любой&lt;/em&gt; подход хорошего проектирования исходит из ETC. Например, использование понятных имен переменных и функций непосредственно упрощает дальнейшее сопровождение кода.&lt;/p&gt;

&lt;p&gt;А если мы будем как можно больше компонентов делать &lt;a href=&quot;/2022/02/12/hack_in_declarative_model_2.html&quot;&gt;декларативными&lt;/a&gt;, это поможет? Да! Архитектура будет менее запутанной, с меньшей &lt;em&gt;связностью&lt;/em&gt;, и следственно более удобной в сопровождении.&lt;/p&gt;

&lt;p&gt;Куда не глянь, если что-то сделано хорошо, это сделано осознанными в ETC инженерами!&lt;/p&gt;

&lt;p&gt;Можно уйти в словоблудие и сказать, что оба эти принципа применимы не только как ценности проектирования программных систем, и исходят из более “фундаментальных” личностных качеств.&lt;/p&gt;

&lt;p&gt;Но я оставлю это вам как пищу для размышления.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Инструменты" /><category term="Размышления" /><summary type="html">Рассматриваем пару универсальных принципов разработки.</summary></entry><entry xml:lang="ru"><title type="html">Врубаемся в Декларативную модель</title><link href="http://localhost:4000/2022/02/12/hack_in_declarative_model_2.html" rel="alternate" type="text/html" title="Врубаемся в Декларативную модель" /><published>2022-02-12T00:00:00+03:00</published><updated>2022-02-12T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/12/hack_in_declarative_model_2</id><content type="html" xml:base="http://localhost:4000/2022/02/12/hack_in_declarative_model_2.html">&lt;p&gt;Часть 2. Декларативное программирование и рекурсия.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Здравствуйте! Мы продолжаем изучать декларативную вычислительную модель. На этой неделе я добрался до более практичных тем, и начну рассказывать вам о том, как собственно устроено программирование в декларативном “стиле”.&lt;/p&gt;

&lt;p&gt;В прошлый раз мы разобрали декларативную модель с теоретической точки зрения, и в общих чертах должны хорошо понимать её внутреннее устройство.&lt;/p&gt;

&lt;h2 id=&quot;польза-декларативной-модели&quot;&gt;Польза декларативной модели&lt;/h2&gt;
&lt;h4 id=&quot;детерминированный-конструктор&quot;&gt;Детерминированный “конструктор”&lt;/h4&gt;
&lt;p&gt;Одна из главных крутостей декларативного программирования заключается в том, что декларативные программы &lt;strong&gt;композиционны&lt;/strong&gt;. Это значит, что программа состоит из некоторых &lt;em&gt;компонентов&lt;/em&gt;, каждый из которых, благодаря заложенным в вычислительной модели принципам, является строго и ясно ограниченной частью программы.&lt;/p&gt;

&lt;p&gt;В декларативной программе каждый компонент всегда хорошо различим, у него есть определенные входы и выходы. При этом компонент не обязательно является “малым” фрагментом кода, функций или процедурой. Процедура лишь частный вид компонента, и в более “сложном” компоненте могут быть определены другие, сохраняя всю декларативную ясность и мощь.&lt;/p&gt;

&lt;p&gt;Композиционность достигается благодаря свойственным декларативной модели качествам. Напоминаю, мы не используем “динамические переменные”, не храним внутренние состояния процедур\функций, не передаем их куда-то вовне. Получается что компоненты, “сущности сами в себе”, или по русски — независимые сущности. Выход из одной декларативной операции становится входом для другой, сайд-эффекты, фактически — невозможны.&lt;/p&gt;

&lt;p&gt;Благодаря этому качеству в декларативной модели мы можем разрабатывать сложные и &lt;em&gt;надежные&lt;/em&gt; системы.&lt;/p&gt;

&lt;h4 id=&quot;ясно-понятно&quot;&gt;Ясно, понятно&lt;/h4&gt;

&lt;p&gt;Вторая сила декларативного программирования вытекает и связана с первой — декларативные программы достаточно просты для понимания. Мы можем легко рассуждать о них сквозь призму, например, логического анализа. Чтобы понять программу в целом, нам нужно лишь понять все её компоненты.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Исходя из этого мы можем предположить, что можно забить на все остальные вычислительные модели, хорошо разобраться в декларативной, и все программы описывать только в ней. Жаль что это невозможно. Если бы все было так просто, то другие модели бы просто не появились. Дело в том, что задачи бывают разные, и для их решения подходят разные парадигмы.&lt;/p&gt;

&lt;p&gt;Но хорошая новость в том, что на уровне разработки (написания) кода отдельных функций или модулей (ещё это называется &lt;em&gt;programming-in-small&lt;/em&gt;), декларативный стиль применять можно &lt;strong&gt;всегда!&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;На самом деле так &lt;strong&gt;нужно&lt;/strong&gt; поступать. Это залог хорошего продукта не только в виде отдельных программных модулей, но и качественной программной системы в целом (&lt;em&gt;programming-in-large&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Компоненты не должны иметь лишних связей, потому что это приводит к запутыванию и усложнению системы. В такой ситуации мы не можем говорить о композиционности или понятности. Как разобраться в отдельной части, если она явным образом зависит от кучи других? А те, в свою очередь, от кучи других? А если не явным? Брррр.&lt;/p&gt;

&lt;p&gt;Другие вычислительные модели, свойством которых является тесная связь многих компонентов, &lt;em&gt;нужно использовать изолировано и в ограниченном количестве модулей&lt;/em&gt;. Мы пытаемся, как-бы, “компонизировать” части системы со сложными связями, чтобы сами эти части становились &lt;strong&gt;декларативными компонентами&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Вот вам новая мантра:&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Я делаю как можно больше компонентов системы декларативными.&lt;/p&gt;

&lt;p&gt;Говорят, если повторять её каждый раз когда садишься программировать, и применять на практике — станешь хорошим инженером.&lt;/p&gt;

&lt;h2 id=&quot;рекурсия&quot;&gt;Рекурсия&lt;/h2&gt;

&lt;p&gt;Как много будоражащего ум в этом слове (пока не разобраться :) ). 
Помню в детстве я сидел в парикмахерской, и места там были напротив друг друга у противоположных стен, и зеркала соответственно. Слово рекурсия я тогда не знал, но залип &lt;em&gt;глубоко&lt;/em&gt; и надолго.&lt;/p&gt;

&lt;p&gt;В программировании рекурсией называют “прием”, когда в теле функции вызывается эта же функция. На самом деле рекурсия может применяться по разному, самый простой и частный случай это &lt;em&gt;прямая&lt;/em&gt; или простая рекурсия, когда функцию явно вызывает “саму себя”. Ещё рекурсии бывают &lt;em&gt;косвенные&lt;/em&gt; или — &lt;em&gt;непрямые&lt;/em&gt;. Это более хитрый способ, когда, например, функция А, вызывает функцию В, которая в свою очередь снова вызывает функцию А, и так далее.&lt;/p&gt;

&lt;p&gt;Если рекурсивный вызов в теле функции является последним оператором, то в этом случае такую рекурсию называют &lt;em&gt;хвостовой&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Глубина&lt;/em&gt; рекурсии определяется количеством рекурсивных вызовов. Как это работает? Ну, в общем, есть такая структура данных &lt;strong&gt;стек&lt;/strong&gt;. Наивно-абстрактно мы сейчас можем представить её как некоторую “вертикальную стопку” записей. Мы можем складывать туда записи одна за другой, и извлекать в обратном порядке, то есть забирать “верхние” записи поочередно.&lt;/p&gt;

&lt;p&gt;Например, возьмем рекурсивную функцию А и изначально пустой стек. В вызове А0 что-то происходит, этот вызов с его “окружением” помещается в виде записи в стек, и в процессе выполнения происходит рекурсивный вызов А1. Ситуация повторяется, А1 помещается в стек следом за А0, вызывается А2, и так далее.&lt;/p&gt;

&lt;p&gt;На самом деле это может происходить бесконечно, до тех пор пока не кончится память и стек не будет переполнен (stack overflow). Во избежание подобного в рекурсивных функциях определяют конечное условие, в случае удовлетворения которого функция должна что-то вернуть, а не снова провалиться в дальнейшую рекурсию.&lt;/p&gt;

&lt;p&gt;Это ещё называется “базовым случаем” — условие в рекурсивной функции, при котором не происходит рекурсивный вызов и функция завершая, как правило вернув какое-то значение. Соответственно, если проверка базового случая не проходит, функция выполняется дальше в “рекурсивный случай”.&lt;/p&gt;

&lt;p&gt;Возвращаясь к примеру выше, представим что в вызове А4 это конечное условие было удовлетворено. В результате мы имеем стек, условно, такого вида А0 -&amp;gt; А1 -&amp;gt; А2 - A3 -&amp;gt; A4. Стрелки в данном случае отображают последовательность рекурсивных вызовов. Получается, что результат работы А4 вернется в А3, оттуда в А2, А1, и наконец в изначальный вызов А0 (который в общем тоже имеет какой-то выход, в данном случае это не важно).&lt;/p&gt;

&lt;p&gt;Если вы смотрели мультик Гравити Фолз, то должны помнить что там была такая бездонная яма, в которую что не упади, обязательно рано или поздно вылетит назад. Можно представить рекурсивные вызовы и стек таким образом, для запоминания.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/botomless_pit.gif&quot; alt=&quot;Стэн в яме&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Дядюшка Стен ждет конечного условия, или пока стек переполнится. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Очевидно что бездумное использование рекурсии может накладывать существенные расходы памяти.&lt;/p&gt;

&lt;h3 id=&quot;что-происходит&quot;&gt;Что происходит?&lt;/h3&gt;

&lt;p&gt;Иван, при чем тут рекурсия? Этот пост про программирование в декларативной модели был. Ага! Я не отошел от темы.&lt;/p&gt;

&lt;p&gt;Сейчас мы уже знаем всё что нужно, чтобы применять “декларативщину” на практике. Подытожим.&lt;/p&gt;

&lt;p&gt;Для соблюдения декларативной модели нам нужно, во-первых, использовать переменные исключительно для однократного присваивания. Во-вторых, использовать простые (арифметические) операции над исконно декларативными типами данных — списками и записями. В-третьих, комбинировать декларативные операции, получая декларативные операции в результате (компонуем по полной!).&lt;/p&gt;

&lt;p&gt;Так а что с этим всем делать? Комбинировать компоненты декларативной программы по правилам &lt;strong&gt;программирования высшего порядка&lt;/strong&gt;! Звучит серьезно, правда?&lt;/p&gt;

&lt;p&gt;Программирование высшего порядка, это когда в модели функции могут получать в качестве аргументов другие функции (как параметры), и &lt;em&gt;возвращать их в качестве результата&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Догадались, нет?&lt;/p&gt;

&lt;p&gt;Технически корректной реализацией декларативной программы будет её описание как &lt;strong&gt;чистых рекурсивных функций&lt;/strong&gt; организованных согласно &lt;strong&gt;программированию высшего порядка&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Помните, в самом начале первой части мы говорили о том, что декларативная модель, это когда мы описываем “что должно получиться в итоге”, а как этого результата достигать? Вот это как раз и реализуется по канону высшего порядка, рассмотрим совсем простой псевдокод.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ИтерацияВычислений(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо):
    if ФункцияПроверкиРезультата(ОбрабатываемыеДанные) == True:
        Возвращаем ОбрабатываемыеДанные
    env

    ОбрабатываемыеДанные = ФункцияВычисляющаяЧтоТо(ОбрабатываемыеДанные)
    return ИтерацияВычислений(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо)
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Разберем по порядку. Всё вместе называется &lt;strong&gt;абстракцией управления&lt;/strong&gt;. Это как раз пример программирования высшего порядка.
У нас есть функция которая вызывается рекурсивно — &lt;em&gt;ИтерацияВычислений&lt;/em&gt;. В данном примере я назвал её так, потому что &lt;strong&gt;итеративные вычисления&lt;/strong&gt; это &lt;em&gt;частный случай рекурсии.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ФункцияПроверкиРезультата&lt;/em&gt;, в данном случае, это как раз то, с помощью чего определяется то самое условие “что должно получиться в итоге”.&lt;/p&gt;

&lt;p&gt;Ну а &lt;em&gt;ФункцияВычисляющаяЧтоТо&lt;/em&gt;, это рабочая лошадка, производящая фактические преобразования исходного значения “&lt;em&gt;ОбрабатываемыеДанные&lt;/em&gt;”&lt;/p&gt;

&lt;p&gt;Всё это мы можем обернуть в ещё одну функцию, в которую аргументом будут передавать лишь ОбрабатываемыеДанные, которые нужно преобразовать способом, скрытым внутри реализации. В результате мы получаем компонент, который может использоваться в проекте. В прошлой части я писал о &lt;em&gt;лингвистических абстракциях&lt;/em&gt;. Подобный компонент, если он должен часто использоваться в проекте, может быть представлен как раз в виде такой абстракции.&lt;/p&gt;

&lt;p&gt;Учитывая правило, о котором мы уже говорили — использование простых арифметических операций, глубокий стек рекурсивных вызовов формироваться не будет. Во-первых, потому что мы имеем четко определенное конечное состояние, которое проверяется “ФункциейПроверкиРезультатов”. Во-вторых, такие простые вычисления хорошо оптимизируются компиляторами.&lt;/p&gt;

&lt;h2 id=&quot;резюме&quot;&gt;Резюме&lt;/h2&gt;

&lt;p&gt;Если декларативная модель — это исток всех остальных моделей, их сердцевина. То сердцевина самой декларативной модели — рекурсивные вычисления! Это чрезвычайно мощный инструмент с огромным потенциалом. Кроличья нора &lt;em&gt;очень глубока&lt;/em&gt;, но ослепительно проста и прекрасна.&lt;/p&gt;

&lt;p&gt;В следующий раз мы разберемся в том, что списки, на самом деле &lt;strong&gt;рекурсивный тип данных!&lt;/strong&gt; и продолжим гнаться за декларативным белым кроликом.&lt;/p&gt;

&lt;p&gt;Будьте здоровы.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/white_rabbits.gif&quot; alt=&quot;Рекурсивные кролики&quot; /&gt;&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><summary type="html">Часть 2. Декларативное программирование и рекурсия.</summary></entry><entry xml:lang="ru"><title type="html">Врубаемся в Декларативную модель</title><link href="http://localhost:4000/2022/02/06/hack_in_declarative_model.html" rel="alternate" type="text/html" title="Врубаемся в Декларативную модель" /><published>2022-02-06T00:00:00+03:00</published><updated>2022-02-06T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/06/hack_in_declarative_model</id><content type="html" xml:base="http://localhost:4000/2022/02/06/hack_in_declarative_model.html">&lt;p&gt;Часть 1. Средоточие и исток любой парадигмы программирования.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Не без помощи ментора мне удалось пройти последний тест по предыдущему курсу. Спойлерить вопросы из теста не стану, но поверьте, 2 и них были почти Дзен коанами, ну или Concurrency коанами.&lt;/p&gt;

&lt;p&gt;На этой неделе я приступил ко второму курсу, главная тема которого — &lt;em&gt;Декларативная модель программирования&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Без изучения декларативной модели глубоко понять программирование в принципе невозможно, потому что эта модель является &lt;strong&gt;фундаментальной&lt;/strong&gt; — корнем, из которого возникли все остальные парадигмы. Хорошее понимание декларативной модели автоматически дает возможность быстрее разобраться в других технологиях программирования.&lt;/p&gt;

&lt;h2 id=&quot;декларативная-парадигма&quot;&gt;Декларативная парадигма&lt;/h2&gt;

&lt;p&gt;Напоминаю, что парадигма — это в первую очередь по сути математическая теория, но в более прикладном понимании это &lt;em&gt;подход программирования&lt;/em&gt; (воплощающий эту мат. теорию). Или ещё вернее — набор программно-инженерных техник для решения задач, или класса задач, с помощью которых мы проектируем программу в соответствии с определенной &lt;strong&gt;вычислительной моделью&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Глубокое понимание, знание разных парадигм программирования воспитывает наше мышление и дает возможность разрабатывать качественно эффективный код, применяя различные парадигмы для решения подходящего класса задач.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/cat_hammer.gif&quot; alt=&quot;Котик с молотком&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Ну вы знаете эту популярную присказку, про забивание гвоздя микроскопом? Не надо так, надо как котик. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Соответственно поэтому мы и начинаем свое изучение с логического начала — с Декларативной парадигмы.&lt;/p&gt;

&lt;h3 id=&quot;в-чем-суть&quot;&gt;В чем суть?&lt;/h3&gt;

&lt;p&gt;Декларативную парадигму часто противопоставляют императивной. В императивной парадигме всё крутится вокруг &lt;em&gt;состояний&lt;/em&gt; (переменных), и мы последовательно описываем шаги, которые исполнитель (компуктер), должен выполнить для решения поставленной задачи. Короче говоря мы придумываем и подробно описываем алгоритм.&lt;/p&gt;

&lt;p&gt;В декларативной парадигме мы описываем сам &lt;em&gt;результат&lt;/em&gt; который хотим достичь, а не то как его достигать. Ого, скайнет?! Машины такие умные стали что мы можем сказать “хочу печеньку” и они напекут? Нет, по крайней мере пока :)&lt;/p&gt;

&lt;p&gt;Точнее мы описываем соотношение &lt;em&gt;входных данных&lt;/em&gt; и результата, и по необходимости уточняем некоторые детали выполнения, пока интерпретатор не “поймет” что ему делать. Мы всё ещё не говорим исполнителю как именно решать задачу, а просто точнее описываем как “вход” соотносится с “выходом”.&lt;/p&gt;

&lt;p&gt;Продолжая проповедовать научность программирования, предлагаю погрузиться глубже.&lt;/p&gt;

&lt;h2 id=&quot;diving-deeper-&quot;&gt;Diving deeper 👨‍🚀&lt;/h2&gt;

&lt;p&gt;Я тут уже сказал про вычислительную модель. В общем это та самая научно-математическая штука (формальная система), которая определяет язык программирования и то как инструкции на этом языке будут обрабатываться исполнителем (абстрактной вычислительной машиной).&lt;/p&gt;

&lt;p&gt;Вообще есть набор разных математических концепций, из которых не всегда получается полезная нам вычислительная модель. Поэтому существующие и применяемые на практике парадигмы (модели) программирования основаны на &lt;strong&gt;целесообразных&lt;/strong&gt; вычислительных моделях. Это такие модели, которые не ставят нам палки в колеса, и предлагают ясные и толковые техники которые можно применять на практике.&lt;/p&gt;

&lt;p&gt;Так вот, декларативное программирование это первая и самая простая целесообразная вычислительная модель, где основной идеей является вычисление функций без использования переменных.&lt;/p&gt;

&lt;h3 id=&quot;внутреннее-устройство&quot;&gt;Внутреннее устройство&lt;/h3&gt;

&lt;p&gt;Сейчас может быть будет сложно, но я постараюсь написать проще. В общем, переменные в декларативной модели используются, но не используются. А?&lt;/p&gt;

&lt;p&gt;Переменные в &lt;em&gt;классическом&lt;/em&gt; программистском понимании не используются. Но с памятью и значениями же как-то надо работать, вычислять там…&lt;/p&gt;

&lt;p&gt;В декларативной модели есть такая штука как &lt;strong&gt;хранилище однократных присваиваний&lt;/strong&gt;. Это множество уникальных идентификаторов-переменных, которые &lt;em&gt;изначально не определены&lt;/em&gt;. Они могут быть связаны с каким-то значением (инициализированы), но &lt;strong&gt;только один раз&lt;/strong&gt;, и называются &lt;em&gt;декларативными переменными&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В хранилище однократных присваиваний могут одновременно находиться как уже инициализированные переменные, так и ещё “свободные”. Если в хранилище все переменные связаны со значениями, то оно так и называется — хранилище значений.&lt;/p&gt;

&lt;p&gt;В принципе всё что с хранилищем можно сделать — это связать значение с декларативной переменной внутри него. 
Если в хранилище уже есть инициализированная переменная (идентификатор связан со значением), и мы попытаемся связать её же с другим, отличным от инициализированного значения — операция связывания свалится с ошибкой.&lt;/p&gt;

&lt;p&gt;Переменные как “привычные” переменные в коде в этой модели тоже есть, и называются &lt;em&gt;идентификаторы переменных&lt;/em&gt;. Эти идентификаторы &lt;strong&gt;существуют вне хранилища&lt;/strong&gt;, которые каким-то образом указывают на декларативные переменные в хранилище.&lt;/p&gt;

&lt;p&gt;Эта система внешних “переменных” называется &lt;em&gt;окружение&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Возможно вы запутались. Сначала я говорю в декларативной модели фишка в вычислении без использования переменных, потом пишу что переменные есть, и ещё “ссылки” из окружения на них есть. Ну есть, есть, только это не “переменные”, это &lt;strong&gt;постоянные&lt;/strong&gt; (перечитайте ещё раз про хранилище, если не поняли).&lt;/p&gt;

&lt;h3 id=&quot;переменные-которые-постоянные&quot;&gt;Переменные, которые постоянные&lt;/h3&gt;

&lt;p&gt;Чувствуете красоту строгости этих декларативных переменных? Их фишка в том, что создание переменной не есть та же операция, что и связывание этой переменной со значением. Мы &lt;strong&gt;не можем&lt;/strong&gt; использовать переменную пока у неё нет значения. Попытка это сделать приведет к ошибке!&lt;/p&gt;

&lt;p&gt;Сперва это может быть не просто понять, потому что в большинстве языков программирования для большей выразительности и удобства операции создания и связывания со значением переменной происходят одновременно. Хотя в некоторых языках эти механизмы могут быть реализованы иначе.&lt;/p&gt;

&lt;p&gt;В С++ указатель &lt;em&gt;может указывать на неинициализированную область памяти&lt;/em&gt;, представляете к чему может привести? Я никогда не трогал С++, но начинаю понимать критику, по мере углубления в программирования. В целом это самая плохая ситуация которая может возникнуть в рассматриваемом вопросе о переменных.&lt;/p&gt;

&lt;p&gt;Есть ещё сценарий, когда переменная определена, не связана со значением, но ошибки использования переменной при обращении к ней не возникает. Это обеспечивается благодаря присваиванию переменной дефолтного значения (по умолчанию) при создании. Например так происходит в Go — мы можем создать переменную какого типа, и не присвоить ей значение. По умолчанию у каждого типа будет свое значение, например 0 у integer, nil (он же None) у слайсов (аналог динамического массива, но не совсем). В целом, этот вариант лучше чем предыдущий, но далек от “идеала”. Хотя в том же Go есть дополнительное ограничение — хотя мы и можем создать переменную без связывания значения, если эта переменная нигде н будет использована наша программа вообще не скомпилируется (это так же касается не используемых импортированных модулей.) То есть это своеобразная реализация следующего варианта, когда &lt;em&gt;исполнение программы завершается с ошибкой&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Самый крутой вариант это &lt;strong&gt;&lt;em&gt;dataflow-переменные&lt;/em&gt;&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Dataflow-переменные, это декларативные переменные, у которых ещё не привязано значение. Но фишка в том, что система не падает с ошибкой, а &lt;em&gt;ожидает&lt;/em&gt; когда переменная получит свое значение, и продолжает работать дальше. Благодаря наличию такого механизма мы “из коробки” получаем &lt;em&gt;декларативный параллелизм!&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы уже рассматривали параллелизм и недетерминизм в прошлом &lt;a href=&quot;/2022/01/30/hack_in_codding_1.html&quot;&gt;посте-отчете&lt;/a&gt;, так что название говорит само за себя. Декларативный параллелизм &lt;em&gt;великолепен&lt;/em&gt;, нет никаких race condition. Как мы помним, “формула” недетерминизма = использование именованных состояний (переменных) + параллельные вычисления, так что реализация декларативного параллелизма, по сути, заключена в самой декларативной модели.&lt;/p&gt;

&lt;h2 id=&quot;типы-данных-и-вычисления&quot;&gt;Типы данных и вычисления&lt;/h2&gt;

&lt;p&gt;Тип, или тип данных — это такая “сущность”, которая определяет возможные значения и их &lt;em&gt;смысл&lt;/em&gt;, а так же возможные над этими значениями операции. В языках программирования всегда есть какие-то базовые наборы типов данных: целые числа, числа с плавающей точкой, строки, etc.&lt;/p&gt;

&lt;p&gt;В декларативной модели проверяется каждая операция над всеми значениями, учитывая типы данных этих значений. Если встречается какая-то “не законная” операция (над значениями несовместимых типов) — в программе возникает ошибка. Изначально в модели нет обработчиков ошибок, любая ошибка сразу обрушает выполнение программы. Ещё могут возникать &lt;em&gt;исключительные ситуации&lt;/em&gt;, например — попытка деления на ноль.&lt;/p&gt;

&lt;h4 id=&quot;базовые-типы-данных-декларативной-модели&quot;&gt;Базовые типы данных декларативной модели&lt;/h4&gt;

&lt;p&gt;Разумеется тут есть стандартные булевы величины true-false, останавливаться тут не на чем.&lt;/p&gt;

&lt;p&gt;Тип данных &lt;strong&gt;Атом&lt;/strong&gt;! Прикиньте, тут есть Атомы! По крайней мере такая у меня была первая реакция. Ну на самом деле это просто символическая константа которую можно использовать в выражениях. По факту просто строка или идентификатор. Но название что надо :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Запись&lt;/strong&gt; — это композитная структура у которой есть идентификатор-название и список пар ключ-значение. Самый простой пример для понимания — словари в Python. Записи поддерживают стандартные операции над ними, вроде обращения к полям по имени записи, получение их списка, etc.
Вообще, запись это &lt;em&gt;фундаментальная&lt;/em&gt; программистская концепция структурирования данных. Этот тип можно найти практически в любой реализации более сложных структур, от связанных списков до деревьев и графов.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кортеж&lt;/strong&gt; — это &lt;em&gt;запись&lt;/em&gt;, у которой имена полей являются последовательно увеличивающимися числами, начиная с единицы. Получается что массивы тоже наследники записей :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Список&lt;/strong&gt; — а это тоже наследник записей :D В списке есть некоторое количество произвольных значений, и они между с собой связаны определенным способом, например последовательно.&lt;/p&gt;

&lt;p&gt;И наконец &lt;strong&gt;Процедуры&lt;/strong&gt; — проще всего понять процедуру как определение функции в обычном её понимании. Значение процедурного типа может иметь идентификатор (имя функции) или быть безымянным (анонимным).&lt;/p&gt;

&lt;p&gt;Но на самом деле процедуры это не привычные нам функции. Процедуры проще функций, так как не требуют строгого определения. Иными словами, процедуры не ограничены так как функции!&lt;/p&gt;

&lt;p&gt;Например у функций обязательно должен быть &lt;em&gt;один&lt;/em&gt; выход, а у процедур может быть много выходов — любое количество. Как и входов. Или не быть их вообще!&lt;/p&gt;

&lt;p&gt;А ещё &lt;em&gt;любую&lt;/em&gt; инструкцию декларативной программы можно переместить внутрь определения процедуры. Такой финт называется &lt;strong&gt;процедурная абстракция&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Записи и процедуры это &lt;em&gt;фундаментальные&lt;/em&gt; и очень мощные строительные блоки из которых, грубо говоря, &lt;em&gt;в программировании собирают всё остальное&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;организация-вычислений&quot;&gt;Организация вычислений&lt;/h4&gt;

&lt;p&gt;Не смотря на то что переменные в декларативной модели строго определяются один раз и навсегда, допускается определение локальных видимостей &lt;strong&gt;идентификаторов&lt;/strong&gt; декларативных переменных. Это работает так, что при каждом новом &lt;em&gt;локальном&lt;/em&gt; определении создается новая инстанция необходимой декларативной переменной. Физически этот инстанс отличается от переменных в хранилище, но имя и значение остаются теми же.&lt;/p&gt;

&lt;p&gt;У процедур есть ряд интересных особенностей. Во-первых, для того чтобы получить результат работы процедуры в её аргументах нужно передать указатель на ещё не инициализированную переменную. Результат работы процедуры будет связан с этим идентификатором, т.е. проинициализирует переменную. Это называется &lt;em&gt;передача по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Во-вторых, в процедурах могут быть &lt;strong&gt;свободные идентификаторы&lt;/strong&gt;. Это такие переменные, которые не входят в число параметров процедуры, и не определены в ее теле (из внешнего скоупа).&lt;/p&gt;

&lt;p&gt;Фишка в том, что значениями этих свободных идентификаторов будут определены как значения соответствующих переменных (согласно областям видимости) &lt;strong&gt;на момент определения&lt;/strong&gt; процедуры, а не на момент её вызова! Это называется &lt;strong&gt;статическая видимости&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Дело в том что определение процедуры в декларативной модели — &lt;em&gt;обычная&lt;/em&gt; операция (инструкция), и выполняется наравне с другими.&lt;/p&gt;

&lt;p&gt;В привычных языках определение функций работают по другому. Операция определения функции не является “обычной”, и выполняется как бы отделено от остального кода, а сама функция вообще ничего не делает без явного вызова. Это называется &lt;strong&gt;динамическая видимость&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;То есть, если в такой функции со статической видимостью есть какие-то указатели на переменные из внешнего скоупа, значениями этих “локальных” переменных станут значения внешних переменных &lt;strong&gt;на момент вызова&lt;/strong&gt; такой функции.&lt;/p&gt;

&lt;p&gt;Это вообще плохо, так как чревато ошибками. По этой причине в языках с использованием функций доступ к внешним переменным обычно запрещается.&lt;/p&gt;

&lt;p&gt;Сочетание статической видимости с процедурными абстракциями дает мощный инструмент для проектирования надежных программ без побочных эффектов. При этом реализация остается простой. Вот что значит целесообразная вычислительная модель! Песня!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Справедливости ради хочется упомянуть о том, что декларативная модель в принципе “поддерживает” функции с помощью &lt;em&gt;лингвистической абстракции&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Лингвистическая абстракция — это создание новой конструкции в некотором языке программирования, с целью расширения синтаксиса этого языка. В целом это повсеместный прием, который служит как для улучшения выразительности кода, так и для повышения качества языка программирования в целом, благодаря улучшению безопасности и эффективности языковых конструкций.&lt;/p&gt;

&lt;p&gt;Так вот в декларативной модели лингвистическая абстракция функции, как не сложно догадаться — это процедура с одним выходом, которая возвращает некоторое выражение, значением которой является результат &lt;em&gt;вычисляемый&lt;/em&gt; в ходе вызова функции с конкретными аргументами.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;На сегодня это всё. Как видите, декларативная модель настоящая “всему голова” программирования. Вероятно этот пост-отчет будет дополнен.
Всех благ!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><summary type="html">Часть 1. Средоточие и исток любой парадигмы программирования.</summary></entry><entry xml:lang="ru"><title type="html">Предки суслика</title><link href="http://localhost:4000/2022/01/31/go_closely.html" rel="alternate" type="text/html" title="Предки суслика" /><published>2022-01-31T00:00:00+03:00</published><updated>2022-01-31T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/31/go_closely</id><content type="html" xml:base="http://localhost:4000/2022/01/31/go_closely.html">&lt;p&gt;Продолжаем знакомиться с Go. Зачем Google разработал новый язык, и чем вдохновлялись разработчики?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;В прошлой заметке о &lt;a href=&quot;2022/01/23/go_language.html&quot;&gt;первом знакомстве с Go&lt;/a&gt; я очень сжато и сумбурно описал первые впечатления об этом языке программирования.&lt;/p&gt;

&lt;p&gt;За минувшую неделю я в увереном темпе прошел первый курс по Go на coursera из &lt;a href=&quot;https://www.coursera.org/specializations/google-golang&quot;&gt;этой&lt;/a&gt; специализации. Сложность заявлена как intermediate, и это похоже на правду. В четырех модулях были рассмотрены основные концепции языка, синтаксис, структуры данных и core features.&lt;/p&gt;

&lt;p&gt;В небольших практических задачах нас знакомят с основными модулями, содержащими методы для работы со строками, вводом-выводом, и json’ами. Дается емкое объяснение того как работает сборщик мусора и указатели. Если вы не полный ноль в программировании то послее этого короткого курса довольно бегло сможете начать работать на Go. Хочу отметить что я уже отсмотрел лекции из первого модуля второго курса — &lt;a href=&quot;https://www.coursera.org/learn/golang-functions-methods?specialization=google-golang&quot;&gt;Functions, Methods, and Interfaces in Go&lt;/a&gt; и тут уже начинаются более интересные и качественные вещи.&lt;/p&gt;

&lt;p&gt;Например, меня отдельно порадовало то, что во тут профессор Ирвин подчеркивает важность нейминга и “чистоты” функций. В первом знакомстве я обмолвился что по неведомой причине в сообществе разработчиков Go всё ещё считается нормой однобуквенный нейминг, и прочая ересь. Это лютая жесть и полный баттхёрт.&lt;/p&gt;

&lt;p&gt;Я не преследую цель пересказывать весь первый курс тут, вы можете бесплатно его посмотреть на курсере, пусть и без доступа к задачкам и тестам — не много потеряете. В целом рекомендую как отправную точку в Go, я ничуть не жалею о потраченном времени, и материал подается явно попроще, но ничуть не хуже чем в A tour of Go. Эти материалы отлично дополняют друг друга.&lt;/p&gt;

&lt;p&gt;По 2 и 3 курсу я обязательно выберу какую-то тему, которую освящу отдельным постом, например интерфейсы. В этот раз я предлагаю вам чуть больше информации об истоках языка и некоторых концепциях заложенных в нем.&lt;/p&gt;

&lt;h3 id=&quot;люк-я-твой-отец&quot;&gt;Люк, я твой отец&lt;/h3&gt;

&lt;p&gt;Я уже упоминал фразу, что  “Go это Си на стероидах”. Называть его может кто угодно и как угодно, но по внутреннему устройству это вообще новый язык, и помимо Си на Go оказали влияние и другие “&lt;em&gt;родословные&lt;/em&gt;” языков программирования.&lt;/p&gt;

&lt;p&gt;Go пытается заимствовать лучшие идеи и парадигмы, при этом его создатели старались достичь максимальной семантической выразительности кода.&lt;/p&gt;

&lt;p&gt;От Си язык Go унаследовал:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Синтаксис выражений;&lt;/li&gt;
  &lt;li&gt;Конструкции управления потоком;&lt;/li&gt;
  &lt;li&gt;Базовые типы данных (но с некоторым расширением);&lt;/li&gt;
  &lt;li&gt;А так же передачу параметров &lt;em&gt;по значению&lt;/em&gt; и указатели.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вторым деревом предков являются языки Никлауса Вирта, начиная с самого Паскаля. От следующего потомка паскаля - Modula-2 в Go пришла концепция &lt;em&gt;пакетов&lt;/em&gt;, от Oberton - использвание одного центрального файла с определением модулей (в Go этот файл называется go.mod). Из чуть более позднего Oberton-2 взята концепция пакетов, импоторов и объявления методов.&lt;/p&gt;

&lt;p&gt;Ну всё это мы видели и в других языках программирования :)&lt;/p&gt;

&lt;p&gt;А вот самая вишенка, это концепция CSP (communicating sequential processes) из статьи Тони Хоара 1978 года об основах &lt;em&gt;параллелизма&lt;/em&gt;, которая развивалась в научных языках компании Bell Labs, и в итоге добралась до нашего Go-суслика.&lt;/p&gt;

&lt;p&gt;CSP — это скорее не концепция, а формальный язык, которым описываются модели взаимодействия процессов в параллельных программных системах &lt;strong&gt;не имеющих общего состояния&lt;/strong&gt;. В этой модели процессы взаимодействуют и синхронизируются между собой с помощью &lt;em&gt;каналов&lt;/em&gt;. Мне кажется это на порядок более мощная модель чем атомарность, которую я рассматривал вкратце &lt;a href=&quot;/2022/01/30/hack_in_codding_1.html&quot;&gt;здесь&lt;/a&gt;. CSP до сих пор является темой для активного исследования в Computer Science.&lt;/p&gt;

&lt;h3 id=&quot;зачем-нам-суслик&quot;&gt;Зачем нам суслик?&lt;/h3&gt;

&lt;p&gt;Google устал от так называемого &lt;em&gt;взрыва сложности&lt;/em&gt;. О какой сложности идет речь, в Гугле что, сидят дураки которым сложно программы писать на уже имеющихся языках? Вовсе нет. Здесь имеется в виду такая проблема (при чем вообще не уникальная для Google) как &lt;em&gt;сложность программной системы&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Эта сложность характеризуется количеством абстрактных сущностей, которые между собой связаны и как-то взаимодействуют. Всё просто — чем сущностей больше, тем сложнее становится система. А чем сложнее система, тем затруднительнее в ней разобраться и что-то допиливать. Хороший пример сложной системы это СУБД Оракл, погуглите статью на хабре (треш алерт!).&lt;/p&gt;

&lt;p&gt;Так вот, Роб Пайк (один из создатлей Go), не без оснований заметил, что сложность &lt;em&gt;мультипликативна&lt;/em&gt;. Имеется в виду что если мы усложняем одну часть системы, например дорабатываем какие то фичи, etc., то обязательно будут усложняться и другие части.&lt;/p&gt;

&lt;p&gt;С течением времени постоянно требуется вносить новые фичи в проект, бизнес требует &lt;del&gt;крови&lt;/del&gt; денег, и требует быстро! В итоге мы получаем сложную, вообще не выразительную систему жертвуя простотой кода, хотя в долгосрочной перспективе &lt;em&gt;именно простота&lt;/em&gt; является ключевым аспектом качественного софта. Простота означает ясность (выразительность), меньше шансов наплодить багов, etc.&lt;/p&gt;

&lt;p&gt;Фишка в том, что такая “долгосрочная простота” требует большой работы в самом начале проекта. Необходимо четко сформулировать ключевые аспекты и поддерживать строгую дисциплину во время всего цикла разработки. Благодаря такой дисциплине становится возможным отличать плохие изменения от хороших. На практике же мы часто, и к сожалению, наблюдаем хреняк-хреняк и в продакшен.&lt;/p&gt;

&lt;p&gt;Нет строгой спецификации и дисциплины — есть банальный размен &lt;em&gt;простоты&lt;/em&gt; на мнимое &lt;em&gt;удобство&lt;/em&gt;, которое в итоге приводит к хаосу и сплошному копанию в легаси и попытке докостылять.&lt;/p&gt;

&lt;p&gt;Короче, Google устал, и разрабатывая Go одним из важных факторов стала &lt;em&gt;культура радикальной простоты&lt;/em&gt;. В прошлый раз я мельком упоминал о том как медленно и неохотно в Go допиливаются новые “фичи”, и как слезно сообщество выпрашивало, например, дженерики.&lt;/p&gt;

&lt;p&gt;Go выигрывает преимущство во времени в которое он появился. И преимущество это — возможность ретроспективно проанилизировать “опыт” других языков программирования, в чем разрабочики “оторвались по полной”.&lt;/p&gt;

&lt;p&gt;В Go есть сборщик мусора, мы не мучаемся с памятью. Есть система пакетов, как уже было сказанно. Полноценные функции, замыкаем со спокойной душой. &lt;em&gt;Лексическая область видимости&lt;/em&gt;. Интерфейс системных вызовов! И иммутабельные строки в UTF-8.&lt;/p&gt;

&lt;p&gt;Но при этом, (помните про культуру радикальной простоты?): Нет конструкторов и деструкторов; Нет перегрузки операторов; Нет неявных числовых преобразований; Нет значений параметров по умолчанию. &lt;strong&gt;Нет наследования&lt;/strong&gt;, обощенных типов и &lt;strong&gt;исключений&lt;/strong&gt;. Нет макросов! Нет аннотаций функий и локальной памяти потока. В общем если вы до этого кодили только на Python, то сперва может будет немного больно, но не так, как на Си, или Си++ :D&lt;/p&gt;

&lt;p&gt;Как вы уже могли догадаться, система типов в Go тоже своеобразна. Она боле ограниченна, чем в других языках со сторой типизацией, но при этом &lt;em&gt;достаточна&lt;/em&gt; для того чтобы избежать большую часть ошибок, на которые мы можем напарываться в языках с динамической типизацией. Мы можем создавать изолированные части кода с “нетипизированным программированием”, которые в свою очередь будут включены в более широкую, и более строгую схему типов.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Go точно заслуживает вашего внимания, даже если не как основной язык программирования, то как дополнительный инструмент точно.
Совсем не похоже что этот проект отправится на знаменитое кладбище Google.&lt;/p&gt;

&lt;p&gt;Этот пост получился таким же обобщенным как и предыдующий, тут нет сниппетов кода, мы не разбирали вглубь особенности и примеры.&lt;/p&gt;

&lt;p&gt;Хочу сказать что мне кажется я очень своевременно начал учить Go. Параллельно с курсом “Как понять в програмировании всё”, красота простоты Go становится ещё понятнее, как задумка, и как ценность.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Основанно на введении из книги “The Go Programming Language”&lt;/em&gt;&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Go" /><summary type="html">Продолжаем знакомиться с Go. Зачем Google разработал новый язык, и чем вдохновлялись разработчики?</summary></entry><entry xml:lang="ru"><title type="html">Врубаемся в программирование</title><link href="http://localhost:4000/2022/01/30/hack_in_codding_1.html" rel="alternate" type="text/html" title="Врубаемся в программирование" /><published>2022-01-30T00:00:00+03:00</published><updated>2022-01-30T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/30/hack_in_codding_1</id><content type="html" xml:base="http://localhost:4000/2022/01/30/hack_in_codding_1.html">&lt;p&gt;Научный взгляд на программирование. Concurrency, atomicity и кое что ещё.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Сейчас я прохожу курс Бобровского Сергея Игоревича, который называется “Как понять в программировании всё”. На самом деле это цикл курсов, направленный на освоение научного, или лучше сказать — инженерного взгляда на программирование, от фундаментальных концепций до осмысления &lt;em&gt;парадигм&lt;/em&gt; программирования.&lt;/p&gt;

&lt;p&gt;Этот пост является своего рода отчетом о пройденном материале. Хочу сфокусироваться на теме параллельного программирования и атомарности — я застрял на тесте по этой теме :), надеюсь вместе мы разберемся. В дополнение я постараюсь освятить некоторые важные концепции. Остальная часть курса, которая в этом после не затрагивается, либо связана с синтаксисом и особенностями мультипарадигмального языка программирования Julia, либо это отдельные и сложные концепции, которые мы затроули пока лишь поверхностно, но обязательно вернемся к их углубленному изучению позже (или я их плохо понял). Lets rock.&lt;/p&gt;

&lt;h3 id=&quot;что-там-научного-то&quot;&gt;Что там научного-то?&lt;/h3&gt;

&lt;p&gt;В посте про &lt;a href=&quot;/2022/01/22/algorithms_complexity.html&quot;&gt;сложность алгоритмов&lt;/a&gt; я пытался развить мысль о том, что программирование — дитя математики, и подходить к анализу и понимаю алгоритмов нужно с научно-математической позиции мышления, а не с интуитивно-наивной. Чтобы разрабатывать эффективные и надежные программные системы необходимо понимать как работает “под капотом” сама система, и инструменты которые для разработки этой системы используются (языки программирования, парадигмы или подходы к программированию, etc.).&lt;/p&gt;

&lt;h3 id=&quot;фундаментальные-концепции&quot;&gt;Фундаментальные концепции&lt;/h3&gt;

&lt;h4 id=&quot;переменная&quot;&gt;Переменная&lt;/h4&gt;

&lt;p&gt;Программе, или алгоритму, в процессе работы необходимо “пространство” в котором будут “производиться вычисления”. Этим пространством является оперативная память и процессорные кеши. Их устройство это отдельная и сложная тема, сейчас нам нужно понимать что есть некоторый &lt;em&gt;ресурс&lt;/em&gt; в который программа может быстро записывать какие-то данные, и читать их откуда.&lt;/p&gt;

&lt;p&gt;Проще всего представить оперативную память как набор ячеек у каждой из которых есть адрес. По этому адресу к ячейками можно &lt;em&gt;получить доступ&lt;/em&gt;. В данном случае имеются в виду &lt;strong&gt;физические&lt;/strong&gt; ячейки оперативной памяти.&lt;/p&gt;

&lt;p&gt;В коде программы, в частном случае, мы напрямую (явно) с этими адресами не работаем, а используем &lt;em&gt;переменные&lt;/em&gt;, к которым привязываем &lt;em&gt;значения&lt;/em&gt;. Имя переменной — это её идентификатор, а значениями являются какие-то данные, которые мы этому имени &lt;em&gt;присваиваем&lt;/em&gt;, чаще всего с помощью оператора “=”.&lt;/p&gt;

&lt;p&gt;Ещё более научно это называется &lt;em&gt;именованным состоянием&lt;/em&gt;, что уже чуть более сложная концепция, которая является одной из главных характеристик в &lt;em&gt;любой&lt;/em&gt; парадигме программирования, а её реализация (степень поддержки) зависит от конкретно рассматриваемой парадигмы.&lt;/p&gt;

&lt;p&gt;В общем и целом, &lt;em&gt;состояние&lt;/em&gt; — это “способность” программы запоминать данные (присвоенные значения), и в будущем с ними как-то работать. Если состояние имеет идентификатор, то есть, напрямую и явно доступно для операций в ходе программирования, то оно называется &lt;em&gt;“именованным состояним”&lt;/em&gt;. Да, состояния могут не иметь идентификаторов и быть своего рода &lt;em&gt;безымянными&lt;/em&gt;.&lt;/p&gt;

&lt;h5 id=&quot;зачем-идентификаторы-есть-у-ячеек-есть-адреса&quot;&gt;Зачем идентификаторы, есть у ячеек есть адреса?&lt;/h5&gt;

&lt;p&gt;Во-первых, как я уже писал, мы с адресами напрямую не работаем. Во-вторых, на самом деле значения ячейкам памяти присваиваются как “константа”, то есть “на постоянку”, или однократно.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Однократное присваивание”&lt;/em&gt; это одна из фундаментальных концепций программирования, суть которой заключается в том, что как только в коде определяется новая переменная (некоторому идентификатору присваивется его “первое” значение), эта переменная становится неизменяемой (иммутабельной).&lt;/p&gt;

&lt;p&gt;Подождите, но я могу сделать в своем любимом пайтоне что-то вроде: my_special_var = “hello dear friend”, и следом my_special_var = “goodbye fella”, и расшибусь головой о стену от уверенности в том что print(my_special_var) вернёт последнюю строку — “goodbye fella”. Всё так! Просто почти во всех современных языках программирования кроме концепции однократного присваивания переменных существует дополнительный механизм — “явное определение”, которое позволяет присвоить &lt;em&gt;новые&lt;/em&gt; значения уже &lt;em&gt;существующему&lt;/em&gt; идентификатору. Но для записи данных использоваться, как правило, будет &lt;strong&gt;не та же самая ячейка памяти&lt;/strong&gt;, а новая и с другим адресом. &lt;em&gt;Тот же самый, уже существующий идентификатор (имя переменной)&lt;/em&gt; будет связан с другой областью памяти, в которую будет записано новое значение.&lt;/p&gt;

&lt;p&gt;Не увлекайтесь “явным &lt;em&gt;переопределением&lt;/em&gt;”, это удобно, но есть один &lt;strong&gt;серьезный минус&lt;/strong&gt; — потенциально эта возможность легкого переопределения приводит к куче ошибок. Относитесь к переменным чутко и ответствено, используйте адекватный нейминг. Старайтесь не переопределять уже существующие переменные (если нужно, используйте новые имена, соответствующие контексту изменений и “смыслу кода”). Но так же не стоит плодить явно лишние переменные, а необходимые определяйте в непосредственной близости к коду, в котором эти переменные используются. Это короткое отступление о базовых приницпах “ясного стиля” программирования :)&lt;/p&gt;

&lt;h3 id=&quot;опять-математика&quot;&gt;Опять математика?&lt;/h3&gt;

&lt;p&gt;Как было сказано ранее, реализация “способности запоминать состояния” определяется поддерживаемыми языком программирования парадигмами программирования.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/mind_blowing.gif&quot; alt=&quot;Взрыв Мозга&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Поддерживаемые языком программирования парадигмы программирования — Чего-чего? &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Не волнуйтесь, мы разберемся.&lt;/p&gt;

&lt;h4 id=&quot;парадигма-программирования&quot;&gt;Парадигма программирования&lt;/h4&gt;

&lt;p&gt;Парадигмой программирования, грубо говоря, называется определённый подход к программной разработке. Правильно говоря — это не менее чем &lt;strong&gt;настоящее&lt;/strong&gt; научное открытие, строго выверенная математическая теории, которая на практике воплощается в таких сложных программных системах как &lt;em&gt;языки программирования&lt;/em&gt;. Это не значит что язык программирования конструируется на базе одной парадигмы, напротив — многие современные языки являются мультипарадигмальными, из чего следует вывод что это &lt;em&gt;ну очень сложные математические модели&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Хорошая новость в том, что если что-то придумали одни люди, мы можем в этом разобраться, пусть даже приложив N усилия!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Подробное изучение парадигм программирования явно выходит за рамки этого поста и моих текущих знаний, но в будущем эти темы будут подробнее изучаться на соответствующих курсах, до которых я надеюсь добраться, а значит о них будут написаны подобные посты-отчеты.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Способ реализации &lt;em&gt;именованного состояния&lt;/em&gt; является одной из двух ключевых характеристик парадигм программирования. Вторая характеристика — характерность или не характерность &lt;strong&gt;недетерминизма&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;недетерминизм&quot;&gt;Недетерминизм&lt;/h4&gt;

&lt;p&gt;В привычном представлении новичка-программиста, особенно самоучки, обычная императивная программа выполняется последовательно и выдает от вызова к вызову, с одними и теми-же аргументами, один и тот-же результат. Такое поведение называется &lt;strong&gt;детерминированным&lt;/strong&gt;. Иными словами, если программа детерминирована, мы можем по её коду однозначно определить какой результат будет получен на выходе. Никаких сюрпризов.&lt;/p&gt;

&lt;p&gt;Недетерминизм, как несложно предположить, является противоположной ситуацией, когда вызывая программу, даже с одними и теми же входными данными, мы можем наблюдать разный результат из раза в раз. Такой недетерминизм называется &lt;em&gt;явным&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Но как такое получается? Программа может выдавать неожиданные результаты, если она описана в системе (парадигме) программирования, в которой соединяются уже изученные нами “именованные состояния” и &lt;strong&gt;&lt;em&gt;параллельные&lt;/em&gt;&lt;/strong&gt; вычисления.&lt;/p&gt;

&lt;h3 id=&quot;параллелизм&quot;&gt;Параллелизм&lt;/h3&gt;

&lt;p&gt;Наконец мы подобрались к параллелизму! Сперва нам нужно строго определить о чем идет речь. В русском языке часто используется одно и то же слово для фактически разных концепции.&lt;/p&gt;

&lt;p&gt;Во-первых, есть parallelism — аппаратная концепция. Это про “одновременное” выполнение процессорных инструкций на нескольких ядрах, etc.&lt;/p&gt;

&lt;p&gt;Во-вторых, concurrency — чисто программная концепция, которая нас интересует в первую очередь в рамках этой темы.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Вернемся к связи недетерминизма с параллельными вычислениями и именованными состояниями. В теме программного параллелизма есть две разные штуки:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Процесс&lt;/li&gt;
  &lt;li&gt;и Thread (нить).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вспоминая свое начальное обучение на администратора баз данных, одно из самых ярких впечатлений на тот момент у меня вызвало простое, но чертовски понятное определение разницы этих двух терминов, которое я услышал в одой из лекций Дмитрия Кетова на тему устройства Линукса. Дословно не помню, но суть такая:&lt;/p&gt;

&lt;p&gt;“Процесс — вычисления работающие в &lt;strong&gt;изолированной&lt;/strong&gt; модели памяти. Нити — работают в модели &lt;strong&gt;общей&lt;/strong&gt; памяти.”&lt;/p&gt;

&lt;p&gt;Иными словами, Нити — это параллельные “процессы” которые могу иметь\имеют доступ к одним и тем же &lt;em&gt;именованным состояниям&lt;/em&gt; (модель “общей” памяти).&lt;/p&gt;

&lt;p&gt;Теперь должно стать понятно откуда могут взяться “неожиданные”, недетерминированные результаты работы кода. Если в программе используются параллельные потоки (нити), которые работают с одними и теми-же переменными, мы &lt;strong&gt;вообще&lt;/strong&gt; не можем знать в каком порядке эти нити буду запущены, как изменят значения переменной и завершатся. В таких условиях работы возникает &lt;em&gt;race condition&lt;/em&gt;, по русски — “состояние гонки”. Смысл этого термина в том, что “победителем” гонки будет нить, которая последней запишет в переменную результат своей работы. Отсюда и возникает &lt;em&gt;явный недетерминизим&lt;/em&gt;, мы видим его в непосредственном результате работы программы.&lt;/p&gt;

&lt;p&gt;Хотя существуют ситуации, в которых недетерминизм приемлем или даже необходим (является целевым, ожидаемым поведением), чаще всего мы хотим чтобы наши программы были детерминированы (надежны и стабильны), даже если мы применяем параллельные вычисления, например, используя их для ускорения работы программы.&lt;/p&gt;

&lt;p&gt;Такой результат может быть достигнут только благодаря правильному проектированию программного кода, &lt;strong&gt;нельзя&lt;/strong&gt; бездумно использовать параллельные вычисления и именованные состояния вместе, это приведет уже не просто к недетерминированному результату, а к настоящему хаосу.&lt;/p&gt;

&lt;p&gt;В случае когда нам всё таки нужно совмещать эти концепции, &lt;strong&gt;мы должны&lt;/strong&gt; делать это в строго ограниченной, изолированной части системы, где код должен быть “грамотным” и выразительным.&lt;/p&gt;

&lt;p&gt;Разумеется, в программной инженерии разработаны подходы к реализации совмещения переменных и concurrency.&lt;/p&gt;

&lt;h3 id=&quot;атомарность&quot;&gt;Атомарность&lt;/h3&gt;

&lt;p&gt;Один из способов решить проблему race condition — использовать атомарных операций.&lt;/p&gt;

&lt;p&gt;Сначала вернемся к “состоянию гонки”, и разберем его чуть подробнее. Представьте толкучку. Именно это и происходит когда параллельные нити пытаются работать с одними и теми же участками памяти. Кто успел — тот и съел. Потоки вычислений пытаются выполнить похожие действия и мешают друг другу.&lt;/p&gt;

&lt;p&gt;Способ борьбы с этой ситуаций — построение thread-safe, или организация “&lt;em&gt;безопасности потока&lt;/em&gt;”. В язык программирования внедряются специальные инструкции, доступные разработчику для использования, которые позволяют объявить некоторые операции &lt;em&gt;атомарными&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;На практике это выглядит как &lt;em&gt;блокирование доступа к общей ячейке памяти&lt;/em&gt; для других нитей, во время работы &lt;em&gt;“активной”&lt;/em&gt; нити (та, которая “повесила” блокировку). Блокировка снимается когда активная нить завершила все необходимые ей операции с заблокированной ячейкой памяти.&lt;/p&gt;

&lt;p&gt;Повторюсь — важный момент заключается в том, что хотя благодаря атомарности мы и изолируем ресурсы на время работы одной нити от других, сами они всё ещё могут, и запускаются в &lt;strong&gt;непредсказуемом&lt;/strong&gt; порядке.&lt;/p&gt;

&lt;p&gt;То есть получается, что хотя thread-safe и является мощным инструментом-концепцией для устранения race condition, он не &lt;em&gt;избавляет нас от недетерминизма&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Избавиться от недетерминизма при параллельных вычислениях можно, опять же, только правильным проектированием программы. Мы можем разделить атомарные операции по нитям таким образом, когда они, пусть и работают параллельно — результат становится детерминированным.&lt;/p&gt;

&lt;h3 id=&quot;железная-параллельность&quot;&gt;Железная параллельность&lt;/h3&gt;

&lt;p&gt;Хочется вкратце рассмотреть параллельность на уровне железа, работу многороцессорных систем.&lt;/p&gt;

&lt;p&gt;Нам нужно понимать, что сначала именованные состояния попадают в ячейки оперативной памяти, и следом копируются по системной шине в &lt;em&gt;процессорные кэши&lt;/em&gt;. Так как процессорных ядер у нас может быть несколько, параллельно работающие инструкции на разных ядрах могут стягивать в свой &lt;em&gt;локальный&lt;/em&gt; кэш значения из памяти и по своему обрабатывать. В результате может получиться такая ситуация, когда в оперативной памяти у нас “изначальное” значение, а в локальных процессорных кэшах свои копии данных, да ещё и разные.&lt;/p&gt;

&lt;p&gt;Разумеется, на практике существует решений этой проблемы, иначе как бы эта параллельность вообще работала? Мы точно не хотим иметь такой “race condition” на уровне железа, когда в оперативную память будут возвращаться разные результаты работы из независимых (параллельно работающих) ядер.&lt;/p&gt;

&lt;p&gt;Единство значений в локальных процессорных кэшах, для обеспечения корректной работы системы в целом, достигается благодаря так называемым &lt;em&gt;протоколам когерентности&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Когерентность кэша (cache coherence) — &lt;em&gt;это свойство кэшей, подразумевающее консистентность (целостность) значений, которые записываются в локальные кэши каждого из процессорных ядер.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Обеспечивается эта консистентность наличием у &lt;strong&gt;каждой&lt;/strong&gt; ячейки кэша специальных флагов, от значений которых зависит то, как состояние хранимое в этой ячейке будет соотноситься с состояниями в ячейка кэша других ядер &lt;strong&gt;имеющих такой же адрес&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Например, когда состояние определенной ячейки меняется каким-либо образом, по внутренней сети процессорной системы происходит рассылка специальных сообщений (очень-очень быстро!).&lt;/p&gt;

&lt;p&gt;На данный момент разработано много &lt;em&gt;протоколов когерентности&lt;/em&gt;, которые отличаются алгоритмами работы и количеством состояний ячеек (флажков). Большая часть протоколов основаны на протоколе MESI (футболист тут не при чем!).&lt;/p&gt;

&lt;h4 id=&quot;протокол-когерентности-mesi&quot;&gt;Протокол когерентности MESI&lt;/h4&gt;

&lt;p&gt;Важно подчеркнуть то, что данные между ячейками оперативной памяти и ячейками процессорного кэша передаются блоками фиксированных размеров, которые называют &lt;strong&gt;линиями кэша&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;В схеме работы протокола MESI каждая линия кэша может находиться в одном из четырех состояний (те самые флаги):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Модифицированная линия (modified). Этим флагом одновременно может быть помечена только &lt;em&gt;одна&lt;/em&gt; линия в &lt;em&gt;одном&lt;/em&gt; локальном кэше. Очевидно из названия — флаг обозначает, что линия была как-то изменена, &lt;strong&gt;но до оперативной памяти изменения ещё не доехали&lt;/strong&gt;. Ядро, к которому непосредственно относится эта линия может &lt;em&gt;без рассылки&lt;/em&gt; уведомлений по внутреннй сети продолжать читать из ячейки и записывать в неё.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Эксклюзивная линия (exclusive). Так же как и модифицированная линия, эксклюзивная может находиться одновременно только в одном локальном кэше. Отличие в том, что данные в этой линии &lt;em&gt;идентичны&lt;/em&gt; данным в соответствующей ячейке оперативной памяти. Чтение и запись в этой линии происходит без уведомлений, но после изменения данных линия помечается как &lt;em&gt;модифицированная&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Разделяемая линия (shared). Такая линия &lt;em&gt;может&lt;/em&gt; содержаться одновременно в разных локальных кэшах, но запросы на изменение &lt;strong&gt;всегда&lt;/strong&gt; отправляются в общую процессорную шину. Это приводит к тому, что все кэши других линий с таким же адресом отмечаются специальным флагом как &lt;em&gt;недействительные&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Недействительная линия (invalid). Попытка чтения из кэша недействительной линии всегда проваливается (cache miss). Chace miss приводит к тому, что “свежие” данные должны быть прочитаны из оперативной памяти. Этим флагом помечаются либо пустые линии, либо содержащие устаревшие значения.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;На практике работа процессорных кэшей, их внутреннее взаимодействие и работа с оперативной памятью выглядит намного сложнее. Тему “железного” параллелизма мне захотелось затронуть, так как она является частью одного из вопросов в заключительном тесте по текущему курсу, и в качестве дополнительного акцента на разнице между concurrency и parallelism. Хочется верить что пост получился читаемым. Всех благ!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><summary type="html">Научный взгляд на программирование. Concurrency, atomicity и кое что ещё.</summary></entry><entry xml:lang="ru"><title type="html">Лупоглазый суслик Go.</title><link href="http://localhost:4000/2022/01/23/go_language.html" rel="alternate" type="text/html" title="Лупоглазый суслик Go." /><published>2022-01-23T00:00:00+03:00</published><updated>2022-01-23T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/23/go_language</id><content type="html" xml:base="http://localhost:4000/2022/01/23/go_language.html">&lt;p&gt;Заметка о первом знакомстве.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;зачем-я-начал-учить-go&quot;&gt;Зачем я начал учить Go&lt;/h2&gt;

&lt;p&gt;Совсем недавно я начал знакомиться с базовым синтаксисом и особенностями языка программирования Go. До этого всё моё изучение программирования проходило в рамках Python, он же и был основным инструментом в написании мелких скриптов. Работу программистом я так и не нашел, но вполне реактивно перешел в DevOps из DBA осенью прошлого года. Мне очень нравится текущая работа, как позиция, так и конкретно компания, но кодить нравится — хоть убейте! Поэтому недолго поразмыслив я решил учить Go, и вот почему.&lt;/p&gt;

&lt;p&gt;Начнем с того что  Go достаточно молодой язык, который разработан в Google и появился в открытом доступе в 2009, не то чтобы это плюс, просто привожу факт. На данный момент Go действительно &lt;strong&gt;широко&lt;/strong&gt; используется в DevOps. Docker, Kubernetes, Prometheus, Grafana и многие другие инструменты написаны на Go. Изучение Go открывает мне потенциальные возможности разрабатывать свои инструменты, может даже принять участие в open source (хочется верить).&lt;/p&gt;

&lt;p&gt;Кроме того что Go хорошо подружился с DevOps-чертовщиной, я давно поглядываю в сторону Си, и вообще си-подобных языков, строгой типизации и вот этого всего. Слышал что Go называют “Си на стероидах”, но мне почему-то это кажется не совсем корректным, по крайней мере на данный момент. Мне рано судить о плюсах и минусах Go, потому что я только начинаю свое знакомство, в частности прошел официальный &lt;a href=&quot;https://go.dev/tour/list&quot;&gt;тур по Go&lt;/a&gt;, по мере свободного времени читаю документацию, и начинаю смотреть курс на coursera.&lt;/p&gt;

&lt;p&gt;Ничего феноменально сложного я пока не заметил, но в разделах о поинтерах и интерфейсах пришлось напрячь мозги. Скажу честно, интерфейсы в Go, по крайней мере как они описываются в туториале, не до конца остались понятными. Хотя саму концепцию интерфейсов я вроде бы понимаю. Вероятно мои затруднения вызваны в целом малым опытом разработки, а может и тем что в Go интерфейсы в структурах данных реализуются &lt;em&gt;имплицитно&lt;/em&gt; то есть &lt;em&gt;неявно&lt;/em&gt;. И хотя это заявляется как сильная сторона Go, меня пока терзают смутные сомнения. Обязательно отпишусь на эту тему, как только наберусь достаточно опыта в разработке на Go и его понимания.&lt;/p&gt;

&lt;p&gt;Кроме “Сишности” в Go мне нравится его простота. Это достаточно компактный язык, при этом из коробки есть практически всё что нужно. В Go &lt;strong&gt;нет&lt;/strong&gt; ООП, ну точнее оно &lt;em&gt;как бы есть&lt;/em&gt;, объясняю. Объектно ориентированная парадигма в некотором виде применяется в Go, но достаточно слабо. В Go можно создавать абстрактные структуры данных, вроде классов, но классом это тут не называется, это просто &lt;em&gt;struct&lt;/em&gt;. Мы можем описывать интерфейсы и методы связанные с этими структурами, но в Go &lt;strong&gt;нет наследования&lt;/strong&gt; (и это хорошо, потому что повторяющийся код это потенциальный источник ошибок), нет конструкторов, и нет дженериков! То есть на Go не пишут фабрики и вот это всё, код остается простым. Учитывая этот факт и достаточно выразительный синтаксис, даже не смотря на местами ужасающую неясность и корявость кода (отвратительный нейминг, например), который сообщество разработчиков Go по какой то причине не стесняется повсеместно пушить — код остается воспринимаемым. Не знаю насколько корректно оправдывать халатность комьюнити по отношению к ясности разрабатываемого кода молодостью языка, но мне эта “фишка” не нравится. Ну да ладно, главное им не подражать :) Возможно со временем Go обзаведется какими то общепринятыми правилами стилистики кода, вроде PEP8 у Python.&lt;/p&gt;

&lt;p&gt;Go компилируемый язык, и говорят что компилируется он быстро! Можно поспорить на тему и сказать, что это не является особым преимуществом для доставки приложения, так как широко распространились контейнеры в которых вам и интерпретатор, и библиотеки воткнуть можно, но компилируемость позволяет не только избавиться от сторонних библиотек в составе образа (копируем бинарь и всё!), а так же и снизить его (образа\контейнера) итоговый размер — пишут, что в последних версиях Go хорошо оптимизировали размер итогового бинаря.&lt;/p&gt;

&lt;p&gt;Вообще Go это достаточно амбициозная попытка взять самое лучшее у популярных языков программирования (сильные стороны применения некоторых парадигм программирования) например Java и C++, и сделать Go способным выражать то же самое, но “более простым языком”.&lt;/p&gt;

&lt;p&gt;Go уверенно набирает популярность, но имхо, пока рано судить о том что ждет язык в будущем. Сообщество разработчиков очень консервативно и долго рассматривает запросы и предложения, многие из которых просто оставляя без внимания. Например погуглите как долго в Go требовали и пропихивали дженерик типы. (спойлер — их всё ещё нет, но &lt;em&gt;может быть&lt;/em&gt; будут в 1.18beta).&lt;/p&gt;

&lt;p&gt;Мне нравится этот микс в Go: с одной стороны есть строгая типизация, компилятор, с другой — сборщик мусора и синтаксический сахар для объявления переменных, который сам определит тип (работает только внутри функций, или вернее — &lt;em&gt;вложенных блоков кода&lt;/em&gt;). Имхо, типы всё таки стоит определять явно. А ещё: поинтеры и очень крутая и простая реализация параллельного программирования — горутины и каналы. Думаю что это это темы для отдельного, более подробного поста :)&lt;/p&gt;

&lt;p&gt;Я не призываю вас бежать и учить Go, но призываю учить программирование! Конкретно в моем случае Go несомненно принесет лишь пользу после долгой дружбы с Python, карьерные возможности и в целом в развитии как специалиста. И как я уже говорил на счет Си, наконец то я дорвался до Си-подобного языка! Рано или поздно я обязательно доберусь до низкоуровневого программирования и поковыряюсь в ядрышках. Если вы спросите зачем мне это нужно, то отвечу цитируя Джеффа Дантеманна из “Assembly Language Step–by–Step” — &lt;em&gt;because I want to know how it works&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Увидимся в следующих постах про Go, которые наверняка ещё будут.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Go" /><summary type="html">Заметка о первом знакомстве.</summary></entry><entry xml:lang="ru"><title type="html">Давай я погуглю за тебя</title><link href="http://localhost:4000/2022/01/23/how_to_google.html" rel="alternate" type="text/html" title="Давай я погуглю за тебя" /><published>2022-01-23T00:00:00+03:00</published><updated>2022-01-23T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/23/how_to_google</id><content type="html" xml:base="http://localhost:4000/2022/01/23/how_to_google.html">&lt;p&gt;Да пребудет с вами сила поиска в Google! Или как избавить своего тимлида от 80% глупых вопросов. Слышали что нибудь о так называемых google dorks? Нет? Добро пожаловать под кат!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Один из самых главных инструментов любого айтишника, разумеется, после мозга — это правильное использование поисковых систем интернета.
Воспользусь правом автора и буду рассматривать только Google.&lt;/p&gt;

&lt;h3 id=&quot;элементарные-запросы&quot;&gt;Элементарные запросы&lt;/h3&gt;

&lt;p&gt;Начнем с азов. Современный гугл достаточно умный, вы можете задать даже коряво сформированный запрос и плюс-минус получите удовлетворительный ответ на первой странице. Если вы хотите найти фразу &lt;em&gt;именно в том виде&lt;/em&gt; в котором задаете её в поисковик — просто заключите её в двойные кавычки. Кроме того можно включить “обязательность” присутствия одного или нескольких слов в поиске, для этого, как и в прошлый раз, заключите требуемую часть запроса в кавычки.&lt;/p&gt;

&lt;p&gt;Исключить одно или несколько слов из выдачи можно просто используя знак минуса перед ними без пробела.&lt;/p&gt;

&lt;p&gt;В поисковых запросах Гугла можно использовать стандартные логические операции: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;.&lt;br /&gt;
Можно указать в любом месте запрос символ &lt;strong&gt;*&lt;/strong&gt;, Гугл будет интерпетировать это точно так же как в обычном регулярном выражении — подставлять любое количество недостающих слов, удовлетворяющих оставшиеся части запроса на место символа звездочки. Ограничить удаленность двух слов, или частей запроса друг от друга можно с помощью оператора &lt;strong&gt;AROUND()&lt;/strong&gt;, передав ему в качестве аргумента колличество слов допустимых в промежутке. Например:&lt;/p&gt;

&lt;h3 id=&quot;level-up&quot;&gt;Level Up&lt;/h3&gt;

&lt;p&gt;Есть список специальных операторов поиска. К примеру, чтобы искать информацию исключительно на конкретном сайте вы можете определить его используя оператор &lt;strong&gt;site:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/site_google_operator.png&quot; alt=&quot;search medium for postgres replication&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Оператор &lt;strong&gt;related:&lt;/strong&gt; служит для поиска &lt;em&gt;других&lt;/em&gt; сайтов, похожих на указанный.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/related_google_operator.png&quot; alt=&quot;search other social networks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Более того, в Гугле можно сразу искать файлы конкретного расширения. Скажем, вы в поисках новых знаний о программировани. Примените оператор &lt;strong&gt;file:&lt;/strong&gt; с указанием расширения, например, pdf.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/file_google_operator.png&quot; alt=&quot;search for pdf books&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Дай человеку рыбу и он будет сыт один день… Оставшийся список оператор вы можете найти сами.&lt;/p&gt;

&lt;h3 id=&quot;google-dorks&quot;&gt;Google dorks&lt;/h3&gt;

&lt;p&gt;Фишка в том что поисковые операторы можно группировать практически в любом порядке и количестве. А теперь проявите фантазию. Допустим вам нужно найти что-то весьма специфическое. Например случайно утекшие в сеть пароли, забытые документы и прочее. А чё, так можно? Можно.&lt;/p&gt;

&lt;p&gt;Google Dorks или Google Dork Queries — это специально сформированный запрос для выявления дыр в безопасности. Такими запросами пользуются как нетсталкеры, так и настоящие злоумышленники. Они могут искать, например, потенциально уязвимые паттерны url ссылок с помощью оператора &lt;strong&gt;inurl:&lt;/strong&gt;, которые при должной сноровке могут, и часто являются, векторами атак.&lt;/p&gt;

&lt;p&gt;Для общего развития и формирования понимания потенциальной мощности поиска в Google, рекомендую ознакомиться с базой дорков собирамой исследователями информационной безопасности на сайте сообщества Offensive Security &lt;a href=&quot;https://www.exploit-db.com/google-hacking-database&quot;&gt;exploit-db.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Помните слова Дяди Бена, имейте совесть, уважайте свои и чужие персональные данные. Если что, карма вас обязательно настигнет!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><category term="Информационная_безопасность" /><summary type="html">Да пребудет с вами сила поиска в Google! Или как избавить своего тимлида от 80% глупых вопросов. Слышали что нибудь о так называемых google dorks? Нет? Добро пожаловать под кат!</summary></entry><entry xml:lang="ru"><title type="html">Сложность и эффективность алгоритмов.</title><link href="http://localhost:4000/2022/01/22/algorithms_complexity.html" rel="alternate" type="text/html" title="Сложность и эффективность алгоритмов." /><published>2022-01-22T00:00:00+03:00</published><updated>2022-01-22T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/22/algorithms_complexity</id><content type="html" xml:base="http://localhost:4000/2022/01/22/algorithms_complexity.html">&lt;p&gt;Как правильно думать о программе, что такое временная сложность и это самое “О большое”. Давайте разбираться.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Недавно я сделал перевод важной статьи — &lt;a href=&quot;/2022/01/15/programming_interview_algorithm.html&quot;&gt;Алгоритм прохождения интервью по программированию&lt;/a&gt;. Это сложная тема, особенно если вы никогда до этого не изучали структуры данных, ничего не слышали про временную сложность и не занимались оценкой эффективности или не эффективности программного кода.&lt;/p&gt;

&lt;h2 id=&quot;а-как-думать&quot;&gt;А как думать?&lt;/h2&gt;

&lt;p&gt;Начну с того, что не зависимо от особенностей каждого человека, если мы физически и психически здоровы то “понимание” какой-то темы у нас складывается примерно одинаково. Возьмем, например, телевизор. Человек растет и развивается, видит как его родители нажимают на кнопки, из телевизора показывают картинки, в его мозгу формируются некоторые связи приводящие к пониманию зависимости действий над объектом, и к каким результатам эти действия приводят. Но если человек никогда не интересовался как работает телевизор, из каких компонентов он состоит, то он не сможет объяснить что это на самом деле такое, как работает, как это создать с нуля или починить. Это нормально. Инженер или работник завода на котором собирают телевизоры или его компоненты знают порядком больше, в виду обладания &lt;em&gt;большим опытом&lt;/em&gt; в непосредственной области, соответствующим обучением, etc. Надо ли говорить как телевизор будет воспринимать пещерный человек, или коренной житель глубокой тропической деревни, где иногда до сих пор практикуют каннибализм?&lt;/p&gt;

&lt;p&gt;С программированием всё обстоит так-же. Информационные технологии и программирование — дети науки и математики, развивающиеся лучшими умами человечества последние столетия.
Само собой это сложная тема, и нахрапом её не взять.&lt;/p&gt;

&lt;p&gt;Когда мы программисты-самоучки, мы можем достаточно быстро выучить современный высокоуровневый и выразительный язык программирования, например Python, методы его стандартной библиотеки. Мы интуитивно начинаем собирать в голове образ того что мы хотим добиться от программы, смутно представляем как она работает. Мы, ещё раз, &lt;em&gt;интуитивно&lt;/em&gt; понимаем что такое переменная, что такое лист или массив. Ну есть там какие-то данные, мы их туда записали, можем сделать клац-клац &lt;strong&gt;sorted(my_very_spetial_list)&lt;/strong&gt; и знаем чего ожидать. Несмотря на то что таким образом можно изучить ряд технологий, фреймворков, и довольно успешно выполнять простые прикладные задачи, это представление &lt;strong&gt;неверно&lt;/strong&gt;, контрпродуктивно и ничем хорошим не заканчивается, например мы это очень хорошо прочувствуем как только попытаемся разработать хоть сколько нибудь сложную систему.&lt;/p&gt;

&lt;p&gt;Поэтому единственный правильный способ думать о программе — это думать научно, и так же подходить к изучению программирования. Напрягаем извилины и идём дальше.&lt;/p&gt;

&lt;h2 id=&quot;алгоритм&quot;&gt;Алгоритм&lt;/h2&gt;

&lt;h4 id=&quot;идем-от-интуитивного-к-научному&quot;&gt;Идем от интуитивного к научному.&lt;/h4&gt;

&lt;p&gt;Что такое программирование вообще? Ну, в первую очередь, скажете вы — это написание какой-то программы (текста), которая что-то внутри делает и выдает интересующий нас результат, и будете в общем-то правы. Приемлемо. А что такое программа? Ни больше ни меньше, программа, в самом простом её представлении и правильном понимании — это &lt;em&gt;Алгоритм&lt;/em&gt; достижения требуемого результата. Утрированный пример алгоритма, который я неоднократно встречал во всевозможных книжках начального уровня, это список ваших последовательных дел на завтра:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Проснуться&lt;/li&gt;
  &lt;li&gt;Потянуться&lt;/li&gt;
  &lt;li&gt;Надеть носки&lt;/li&gt;
  &lt;li&gt;Поехать на работу (или дойти до десктопа и начать работать :) )&lt;/li&gt;
  &lt;li&gt;Прерваться на обед&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При том каждый из пунктов тоже на самом деле является алгоритмом некоторых последовательных (а может и параллельных) действий, так что в примере выше я скоре описываю &lt;em&gt;список алгоритмов&lt;/em&gt;.
Так и есть. В любой даже маленькой программе практически всегда есть &lt;em&gt;n&lt;/em&gt; число алгоритмов — вызовы разных функций, каждая из которых что-то вычисляет.
А если вычисляет — значит алгоритм. Кажется я вас начинаю запутывать, но думаю идея ясна.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Алгоритмом мы называем пошаговое руководство “компьютеру” (исполнителю) что-то нам посчитать. Вычисления могут быть очень простыми, а могут быть и крайне сложными. Правильный способ думать о программе не как о волшебном коде, а как о вполне строгом, &lt;strong&gt;математическом&lt;/strong&gt; описании решения задачи.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Вычислительное железо, как и любой другой объект физического мира подчиняется законам физики. Сила притяжения (по крайней мере на нашей планете) не даст вам прыгнуть кузнечиком в окно второго этажа. Вычислительные ресурсы (центральный процессор, оперативная память, etc) просто так не обработают по щелчку пальцев огромное количество данных — на это потребуется &lt;strong&gt;время&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;К какому бы крутому суперкомпьютеру у вас вдруг не оказался доступ, его мощность играет &lt;em&gt;намного меньшее значение&lt;/em&gt; для производительности программы, чем &lt;em&gt;правильно подобранный алгоритм&lt;/em&gt;. Именно о правильном подборе алгоритма и идет речь в переведенной мною статье, со ссылки на которую начинается этот пост.&lt;/p&gt;

&lt;p&gt;Итак, алгоритм — это вычисление или преобразование &lt;em&gt;входных&lt;/em&gt; данных в интересующие нас &lt;em&gt;выходные&lt;/em&gt; данные. Вы любите ждать? Маловероятно. Проще всего эффективность алгоритма понять как отношение времени, за которое мы получим результат. Чем быстрее — тем лучше.&lt;/p&gt;

&lt;h2 id=&quot;асимптотическая-сложность&quot;&gt;Асимптотическая сложность&lt;/h2&gt;

&lt;p&gt;Так что же влияет на скорость работы алгоритма? Как сказано выше, в первую очередь это правильность самого алгоритма. А точнее — оправданность его использования в &lt;em&gt;конкретных обстоятельствах&lt;/em&gt;. Под конкретным обстоятельствами я имею в виду контекст решаемой нами задачи. В контексте задачи скорость, с которой алгоритм будет вычислять решение, зависит от &lt;em&gt;объема (количества) входных данных&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Научно (математически) сложность алгоритмов оценивается с помощью так называемого &lt;em&gt;асимптотического анализа&lt;/em&gt;. Мы рассматриваем сложность алгоритма посредством анализа &lt;em&gt;зависимости времени и вычислительных ресурсов&lt;/em&gt;, которые потребуются алгоритму в процессе его работы поставленной задачей.&lt;/p&gt;

&lt;p&gt;На практике всё это выражается как математическая функция, которая позволяет понять &lt;em&gt;насколько быстро&lt;/em&gt; будет увеличиваться время работы алгоритма, в зависимости от увеличения обрабатываемого объема данных.&lt;/p&gt;

&lt;p&gt;Иными словами, под &lt;em&gt;асимптотикой&lt;/em&gt; мы понимаем &lt;em&gt;характер&lt;/em&gt; с которым изменяется функция в течении &lt;em&gt;времени&lt;/em&gt; (хуже или лучше она начинает работать), когда её аргумент (количество обрабатываемых данных) &lt;em&gt;стремится&lt;/em&gt; к какой-то точке.&lt;/p&gt;

&lt;p&gt;Только в асимптотическом анализе сложности &lt;em&gt;компьютерных алгоритмов&lt;/em&gt; за эту точку принимается бесконечность, потому что нас интересует не фактическое время выполнения конкретного алгоритма (секунды,etc), а то как будет меняться эффективность работы, если мы будем постоянно и бесконечно повышать размер входных данных.&lt;/p&gt;

&lt;p&gt;Простите меня за то что я несколько раз повторяю одно и то же, но это важно понять:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Мы оцениваем скорость работы алгоритма в сравнительном &lt;strong&gt;количестве операций&lt;/strong&gt;&lt;/em&gt;. Этим количеством мы и меряем “время”.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;так-что-там-за-о&quot;&gt;Так что там за О?&lt;/h3&gt;

&lt;p&gt;Наиболее часто для оценки роста используются следующие &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_notation&quot;&gt;нотации&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ο (О-большое) – верхняя или “наихудшая” оценка сложности. Входные данные подаются самым “неудобным” для алгоритма способом;&lt;/li&gt;
  &lt;li&gt;o (o-малое) – средняя оценка, данные подаются случайным образом;&lt;/li&gt;
  &lt;li&gt;Ω (Омега) – нижняя оценка, идеальная ситуация для достижения максимальной скорости алгоритма;&lt;/li&gt;
  &lt;li&gt;Θ (Тета) – нижняя и верхняя, точная оценка роста временной функции.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Пока мы рассмотрим фундаментальные меры сложности, используемые повсеместно, которые выражаются через O-большое.&lt;/p&gt;

&lt;h4 id=&quot;разбираемся-подробнее&quot;&gt;Разбираемся подробнее&lt;/h4&gt;

&lt;p&gt;Возьмем &lt;em&gt;n&lt;/em&gt; за величину подаваемого объема данных. Тогда верхнюю оценку сложности алгоритма можно записать как &lt;strong&gt;O(f(n))&lt;/strong&gt;. Почему нас интересует именно верхняя или “наихудшая” оценка? Потому что с практической точки зрения нам важно понять этот &lt;em&gt;наихудший вариант развития событий&lt;/em&gt; при котором алгоритму будет скормлено &lt;em&gt;большое количество данных&lt;/em&gt;. Если он будет эффективен в этих условиях, то разумеется будет эффективен и в более “благоприятных”.&lt;/p&gt;

&lt;p&gt;Самые простые для понимания обозначения сложности это &lt;strong&gt;O(1)&lt;/strong&gt; и &lt;strong&gt;O(n)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(1)&lt;/strong&gt; выражает сложность, при которой для выполнения алгоритму потребуется &lt;em&gt;константа&lt;/em&gt; времени. Например взятие элемента из массива по его индексу. Мы точно знаем где элемент находится и просто идём туда. &lt;em&gt;Такие операции не зависят от количества обрабатываемых данных.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n)&lt;/strong&gt; линейно зависит от количества входных данных. В худшем случае такому алгоритму придется проводить какие-то операции с каждым элементом данных. Это, например, обход массива, обход связанного списка или расчет его длинны. Чтобы понять лучше приведу утрированный пример. Представим что задача состоит в том, чтобы определенному существу (алгоритм) нужно выпить некоторое (n) количество воды. Смоделируем ситуацию, в которой воду пьёт не человек, а волшебный троглодит, у которого не желудок, а бездонная черная дыра (n стремится к бесконечности). Пить воду он может только последовательно (ограничения реализации), глоток за глотком, поэтому алгоритм выпивания воды будет иметь линейную сложность O(n) — чем больше воды мы дадим троглодиту на испитие, тем дольше он будет её хлебать.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Классическим вариантом логарифмической сложности &lt;strong&gt;O(log n)&lt;/strong&gt;, где за основание логарифма обычно берется 2, является бинарный (двоичный) поиск. Чем больше входных данных — тем медленнее растет время выполнения алгоритма (тем меньше его сложность). Самый простой и затертый до дыр пример для описания работы двоичного поиска — попытка найти номер телефона нужного вам человека по индексированному справочнику (Отсортирован по фамилиям). Вы можете искать по порядку, запись за записью, страница за страницей. Очевидно что это может занять много времени. Сложность такого глупого поиска можно выразить предыдущей формулой O(n). Представьте что вы в ищите телефон человека не в своей записной книжке, а в справочнике всех абоненов Москвы. Похоже что листать его последовательно (линейно) плохая идея.&lt;/p&gt;

&lt;p&gt;Намного быстрее, зная что справочник упорядочен, открыть его примерно в том месте, где мы ожидаем найти нужного человека. Например мы ищем Фёдора Корнельчука (все совпадения случайны!). Зная алфавит русского языка может показаться что буква К обязательно будет находиться в первой половине справочника, но это не точно. Мы не знаем сколько фамилий на А, Б, и так далее. Может случиться так, что фамилии на К находится во второй половине справочника. Алгоритм Двоичный поиска работает так — мы открываем справочник (массив) посередине и смотрим куда попали, если нам нужно в левую половину (на открытой странице фамилии, например, на букву П), мы отбрасываем правую половину и открываем оставшуюся левую &lt;em&gt;снова посередине&lt;/em&gt;. И так до тех пор пока не найдем Корнельчука.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Сложность алгоритмов сортировки часто выражается как &lt;strong&gt;O(n log n)&lt;/strong&gt;. Время выполнения таких алгоритмов растет быстрее, чем O(n). Можно представить как комбинацию O(log n) и O(n).&lt;/p&gt;

&lt;p&gt;Далее по интенсивности роста идут квадратичные зависимости, например &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;. Время выполнения таких алгоритмов растет очень быстро при увеличении объема входных данных (экспоненциально!). Например, два цикла, когда один вложен в другой, каждый из которых работает за O(n). Практически в любом случае это &lt;strong&gt;очень плохая мера&lt;/strong&gt;, которую вообще не стоит определять в своих алгоритмах.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Разбор алгоритмов сортировки и разных структур данных выходит за рамки этого поста. В будущем мы разберем базовые структуры данных и попытаемся оценить их сложность. Надеюсь что теперь стало понятнее о чем шла речь в статье-алгоритме Майкла.&lt;/p&gt;

&lt;p&gt;До новых встреч!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Алгоритмы" /><category term="ComputerScience" /><summary type="html">Как правильно думать о программе, что такое временная сложность и это самое “О большое”. Давайте разбираться.</summary></entry><entry xml:lang="ru"><title type="html">Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!</title><link href="http://localhost:4000/2022/01/16/why_zettelkasen.html" rel="alternate" type="text/html" title="Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!" /><published>2022-01-16T00:00:00+03:00</published><updated>2022-01-16T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/16/why_zettelkasen</id><content type="html" xml:base="http://localhost:4000/2022/01/16/why_zettelkasen.html">&lt;p&gt;Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. 
Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;при-чём-тут-комод&quot;&gt;При чём тут комод?&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9B%D1%83%D0%BC%D0%B0%D0%BD,_%D0%9D%D0%B8%D0%BA%D0%BB%D0%B0%D1%81&quot;&gt;Никлас Луман&lt;/a&gt; — &lt;em&gt;чрезвычайно&lt;/em&gt; продуктивный немецкий социолог. За 40 лет труда он написал более 70 книг и 400 статей на &lt;strong&gt;разные&lt;/strong&gt; темы: социология, биология, математика и др. При этом, книги Лумана совсем не водянистые романы в мягком переплете. Его работы стали настоящей классикой, а сам Луман считается чуть ли не самым важным социологом прошлого века.&lt;/p&gt;

&lt;p&gt;Секрет его продуктивности — тот самый &lt;em&gt;комод&lt;/em&gt;. Никлас создал и постоянно поддерживал свой Zettelkasten как огромную картотеку заметок и идей, а сам же он говорил, что &lt;em&gt;ничего сам не придумывает&lt;/em&gt;, и большая часть работы происходит в Zettelksaten.&lt;/p&gt;

&lt;h4 id=&quot;дело-не-в-мебели&quot;&gt;Дело не в мебели.&lt;/h4&gt;

&lt;p&gt;На самом деле комод с ящиками не при чём. Просто в то время не было более удобного способа ведения картотеки. Zettelkasten — это метод ведения записей. И в своей сути он предельно прост:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Каждая заметка, в идеальном случае, должна быть &lt;em&gt;атомарна&lt;/em&gt;, то есть освещать какую то конкретную мысль и объект “сам в себе”. Заметка не должна превращаться в подробное эссе или статью.&lt;/li&gt;
  &lt;li&gt;Заметки могут иметь тэги, объединяться в “папки” или условные группы, но это &lt;strong&gt;не главное&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Самое главное, и гениально простое — заметка &lt;em&gt;должна ссылаться&lt;/em&gt; на другую заметку, или на несколько заметок.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Таким образом Zettelkasten — это метод организации &lt;em&gt;сети идей&lt;/em&gt;, связанных друг с другом по смыслу. Новые заметки не нарушают структуру, а лишь укрепляют и развивают её. Примерно так же работет человеческий мозг — чем больше нейронных связий вы наращиваете, тем умнее становитесь.&lt;/p&gt;

&lt;p&gt;Метод ведения записей Лумана опередил появление гиперссылок интерата, а работает, по сути именно так.&lt;/p&gt;

&lt;h3 id=&quot;и-зачем-мне-это&quot;&gt;И зачем мне это?&lt;/h3&gt;
&lt;h4 id=&quot;помощник-в-учебе&quot;&gt;Помощник в учебе&lt;/h4&gt;
&lt;p&gt;Zetellkasten отличный инструмент, который может помочь вам в широком спектре задач. Например в учебе. Мы можем читать книги или статьи с целью изучения, и даже перечитывая их несколько раз вдумчево, материал попадет лишь в нашу краткосрочную память. Другое дело, нелюбимое многими — конспектирование. Ведя конспект вы напрягаете заметно больше отделов мозга, в этом процессе учавствует моторика, вы как то жонглируете информацией, сокращаете, etc. Можно пойти ещё дальше (внимание, лайфхак!). Если английский язык не ваш родной, вы не говорите и не пишите на нем, но способны читать и понимать, пусть даже с помощью переводчика — &lt;em&gt;пишите конспекты на русском.&lt;/em&gt; Я так учил документацию Oracle DB, что в конечном итоге привело к лучшему пониманию этой СУБД, и СУБД технологий вообще, чем у других ребят со стажировки, которые пытались учиться по книгам переведенным на русский, и\или не так усердно вели конспекты. Но большую часть материала &lt;em&gt;я всё равно забыл&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ведение сети заметок в Zettelkasten &lt;em&gt;намного&lt;/em&gt; выигрывает у обычного конспектирования. Если бы я тогда знал про этот метод, вел конспект и строил Zettelkasten из ключевых смыслов по всем изучаемым темам, в нем бы сейчас была вся архитектура СУБД, к которой я мог бы вернуться в любой момент, “пробежаться” по ссылкам и очень быстро освежить материал в памяти.&lt;/p&gt;

&lt;h4 id=&quot;отстойник-и-лучший-собеседник-запасные-мозги&quot;&gt;Отстойник и лучший собеседник, запасные мозги&lt;/h4&gt;

&lt;p&gt;Луман часто называл свою картотеку собеседником, второй памятью, жвачкой, и иногда отстойником.&lt;/p&gt;

&lt;p&gt;Со второй памятью всё понятно, фиксирование информации — это главная цель любых записей которые мы ведем.
Zettelkasten как отостойник идей — отличное описание. Во-первых, при внесении новых заметок вы не обязательно должны сразу их линковать с другими, если такая связь естественно не приходит на ум сразу. Главное позже возвращаться к этим “сиротам” и вплетать их в общую сеть созданием связей. Во-вторых, сам по себе Zettelkasten, как уже было сказано, со временем растет и становится умнее, свое содержимое он как бы “настаивает”. Это особенно актуально если вы напоняете Zettelkasten не только как банк изучаемых данных, но и активно вносите туда &lt;strong&gt;свои&lt;/strong&gt; мысли, идеи.&lt;/p&gt;

&lt;p&gt;Каждый раз возвращаясь к Zettelkasten и погуляв по ссылкам вы не только освежите топики в памяти, но и с большой вероятностью ваш мозг сгенерирует новые, “настоявшиеся” идеи. Чем не собеседник?&lt;/p&gt;

&lt;h4 id=&quot;современный-комод&quot;&gt;Современный комод&lt;/h4&gt;

&lt;p&gt;Хорошая новость в том, что нам не надо покупать комод с ящиками, хотя если вам очень хочется, я не стану вас переубеждать :)
Вы можете вполне успешно вести классический Zettelkasten, но нужно ли?
Гораздо проще и продуктивнее воспользоваться современными технологиями. Zettelkasten можно завести используя любой текстовый редактор, собрать себе в докере собственную wiki на локалхосте, или скачать какой-нибудь Zettelkasten софт. Вариантов навалом.&lt;/p&gt;

&lt;p&gt;Я пользуюсь &lt;a href=&quot;https://obsidian.md/&quot;&gt;obsidian&lt;/a&gt; — он мультиплатформерный, имеет вполне отзывчивое комьюнити и бесплатную версию, которой более чем достаточно. Платная подписка позволяет вам завести некий аккаунт и синхронизировать заметки между устройствами, я с трудом понимаю зачем это нужно, кроме способа оказать финаносвую поддержку и выразить благодарность разработчикам. Или можно решить вопрос синхронизации своего кибер-комода банальным репозиторием на гитхабе.&lt;/p&gt;

&lt;p&gt;Преимущество obsidan в том, что заметки в нем полностью поддерживают markdown, есть множество плагинов, как официальных так и от сообщества, а вишинка на торте - граф вашего Zettelkasten. Это очень удобно и наглядно. В данный момент мой выглядит так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zettelkasten.png&quot; alt=&quot;&amp;lt;img class=&amp;quot;image image--xl&amp;quot; src=&amp;quot;/images/zettelkasten.png&amp;quot;/&amp;gt;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Всегда можно зайти в граф, поблуждать по нему, дописать новое в заметки, добавить новые ссылки, укрепив сеть смысловых связей, etc.&lt;/p&gt;

&lt;p&gt;При том что я заполняю его чуть менее месяца. А теперь представьте что будет через пол года? Через год? Даже если вносить в день как минимум одну новую заметку.
Часто, используя Zettelkasten в процессе обучения одну запись добавить просто невозможно, ведь нам нужно следовать правилу атомарности, а изучаемая тема редко когда содержить лишь одну концепцию. Я так-же использую два плагина для obsidian: быстрая кнопка для создания новой заметки с префиксом из текущей даты, и вторая — открыть рандомную заметку.&lt;/p&gt;

&lt;h4 id=&quot;резюме&quot;&gt;Резюме&lt;/h4&gt;

&lt;p&gt;В данный момент мой процесс обучения стал намного устойчивее и яснее. Ведение конспектов по изучаемому материалу, блога и формирование Zettelkasten сильно дополняют и укрепляют друг друга. Смотрите что происходит у вас в голове, и если зацепилась действительно стоящая мысль (вам хотя бы на секунду показалось что она интересна) — незамедлительно запишите куда угодно! Я испольую ежедневник, который всегда под рукой, или личные сообщения самому себе в мессенджерах. Потом вы всегда сможете перенести эти заметки либо в полноценную статью блога (я так написал, например &lt;a href=&quot;/2022/01/15/my_interviews_experience.html&quot;&gt;эту&lt;/a&gt;), или во временную заметку-сиротку в Zettelkasten, которая рано или поздно обязательно обзаведется родственными связями.&lt;/p&gt;

&lt;p&gt;Во всей этой затее главное выработать привычку и достичь постоянства. Такой Zettelkasten — натуральное продолжение вашего мозга. Киберпанк уже давно тут.&lt;/p&gt;

&lt;p&gt;Начните прямо сейчас!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><summary type="html">Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.</summary></entry></feed>