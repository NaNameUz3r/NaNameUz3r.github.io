<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-01-16T20:54:17+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!</title><link href="http://localhost:4000/2022/01/16/why_zettelkasen.html" rel="alternate" type="text/html" title="Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!" /><published>2022-01-16T00:00:00+03:00</published><updated>2022-01-16T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/16/why_zettelkasen</id><content type="html" xml:base="http://localhost:4000/2022/01/16/why_zettelkasen.html">&lt;p&gt;Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. 
Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;при-чём-тут-комод&quot;&gt;При чём тут комод?&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9B%D1%83%D0%BC%D0%B0%D0%BD,_%D0%9D%D0%B8%D0%BA%D0%BB%D0%B0%D1%81&quot;&gt;Никлас Луман&lt;/a&gt; — &lt;em&gt;чрезвычайно&lt;/em&gt; продуктивный немецкий социолог. За 40 лет труда он написал более 70 книг и 400 статей на &lt;strong&gt;разные&lt;/strong&gt; темы: социология, биология, математика и др. При этом, книги Лумана совсем не водянистые романы в мягком переплете. Его работы стали настоящей классикой, а сам Луман считается чуть ли не самым важным социологом прошлого века.&lt;/p&gt;

&lt;p&gt;Секрет его продуктивности — тот самый &lt;em&gt;комод&lt;/em&gt;. Никлас создал и постоянно поддерживал свой Zettelkasten как огромную картотеку заметок и идей, а сам же он говорил, что &lt;em&gt;ничего сам не придумывает&lt;/em&gt;, и большая часть работы происходит в Zettelksaten.&lt;/p&gt;

&lt;h4 id=&quot;дело-не-в-мебели&quot;&gt;Дело не в мебели.&lt;/h4&gt;

&lt;p&gt;На самом деле комод с ящиками не при чём. Просто в то время не было более удобного способа ведения картотеки. Zettelkasten — это метод ведения записей. И в своей сути он предельно прост:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Каждая заметка, в идеальном случае, должна быть &lt;em&gt;атомарна&lt;/em&gt;, то есть освещать какую то конкретную мысль и объект “сам в себе”. Заметка не должна превращаться в подробное эссе или статью.&lt;/li&gt;
  &lt;li&gt;Заметки могут иметь тэги, объединяться в “папки” или условные группы, но это &lt;strong&gt;не главное&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Самое главное, и гениально простое — заметка &lt;em&gt;должна ссылаться&lt;/em&gt; на другую заметку, или на несколько заметок.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Таким образом Zettelkasten — это метод организации &lt;em&gt;сети идей&lt;/em&gt;, связанных друг с другом по смыслу. Новые заметки не нарушают структуру, а лишь укрепляют и развивают её. Примерно так же работет человеческий мозг — чем больше нейронных связий вы наращиваете, тем умнее становитесь.&lt;/p&gt;

&lt;p&gt;Метод ведения записей Лумана опередил появление гиперссылок интерата, а работает, по сути именно так.&lt;/p&gt;

&lt;h3 id=&quot;и-зачем-мне-это&quot;&gt;И зачем мне это?&lt;/h3&gt;
&lt;h4 id=&quot;помощник-в-учебе&quot;&gt;Помощник в учебе&lt;/h4&gt;
&lt;p&gt;Zetellkasten отличный инструмент, который может помочь вам в широком спектре задач. Например в учебе. Мы можем читать книги или статьи с целью изучения, и даже перечитывая их несколько раз вдумчево, материал попадет лишь в нашу краткосрочную память. Другое дело, нелюбимое многими — конспектирование. Ведя конспект вы напрягаете заметно больше отделов мозга, в этом процессе учавствует моторика, вы как то жонглируете информацией, сокращаете, etc. Можно пойти ещё дальше (внимание, лайфхак!). Если английский язык не ваш родной, вы не говорите и не пишите на нем, но способны читать и понимать, пусть даже с помощью переводчика — &lt;em&gt;пишите конспекты на русском.&lt;/em&gt; Я так учил документацию Oracle DB, что в конечном итоге привело к лучшему пониманию этой СУБД, и СУБД технологий вообще, чем у других ребят со стажировки, которые пытались учиться по книгам переведенным на русский, и\или не так усердно вели конспекты. Но большую часть материала &lt;em&gt;я всё равно забыл&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ведение сети заметок в Zettelkasten &lt;em&gt;намного&lt;/em&gt; выигрывает у обычного конспектирования. Если бы я тогда знал про этот метод, вел конспект и строил Zettelkasten из ключевых смыслов по всем изучаемым темам, в нем бы сейчас была вся архитектура СУБД, к которой я мог бы вернуться в любой момент, “пробежаться” по ссылкам и очень быстро освежить материал в памяти.&lt;/p&gt;

&lt;h4 id=&quot;отстойник-и-лучший-собеседник-запасные-мозги&quot;&gt;Отстойник и лучший собеседник, запасные мозги&lt;/h4&gt;

&lt;p&gt;Луман часто называл свою картотеку собеседником, второй памятью, жвачкой, и иногда отстойником.&lt;/p&gt;

&lt;p&gt;Со второй памятью всё понятно, фиксирование информации — это главная цель любых записей которые мы ведем.
Zettelkasten как отостойник идей — отличное описание. Во-первых, при внесении новых заметок вы не обязательно должны сразу их линковать с другими, если такая связь естественно не приходит на ум сразу. Главное позже возвращаться к этим “сиротам” и вплетать их в общую сеть созданием связей. Во-вторых, сам по себе Zettelkasten, как уже было сказано, со временем растет и становится умнее, свое содержимое он как бы “настаивает”. Это особенно актуально если вы напоняете Zettelkasten не только как банк изучаемых данных, но и активно вносите туда &lt;strong&gt;свои&lt;/strong&gt; мысли, идеи.&lt;/p&gt;

&lt;p&gt;Каждый раз возвращаясь к Zettelkasten и погуляв по ссылкам вы не только освежите топики в памяти, но и с большой вероятностью ваш мозг сгенерирует новые, “настоявшиеся” идеи. Чем не собеседник?&lt;/p&gt;

&lt;h4 id=&quot;современный-комод&quot;&gt;Современный комод&lt;/h4&gt;

&lt;p&gt;Хорошая новость в том, что нам не надо покупать комод с ящиками, хотя если вам очень хочется, я не стану вас переубеждать :)
Вы можете вполне успешно вести классический Zettelkasten, но нужно ли?
Гораздо проще и продуктивнее воспользоваться современными технологиями. Zettelkasten можно завести используя любой текстовый редактор, собрать себе в докере собственную wiki на локалхосте, или скачать какой-нибудь Zettelkasten софт. Вариантов навалом.&lt;/p&gt;

&lt;p&gt;Я пользуюсь &lt;a href=&quot;https://obsidian.md/&quot;&gt;obsidian&lt;/a&gt; — он мультиплатформерный, имеет вполне отзывчивое комьюнити и бесплатную версию, которой более чем достаточно. Платная подписка позволяет вам завести некий аккаунт и синхронизировать заметки между устройствами, я с трудом понимаю зачем это нужно, кроме способа оказать финаносвую поддержку и выразить благодарность разработчикам. Или можно решить вопрос синхронизации своего кибер-комода банальным репозиторием на гитхабе.&lt;/p&gt;

&lt;p&gt;Преимущество obsidan в том, что заметки в нем полностью поддерживают markdown, есть множество плагинов, как официальных так и от сообщества, а вишинка на торте - граф вашего Zettelkasten. Это очень удобно и наглядно. В данный момент мой выглядит так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zettelkasten.png&quot; alt=&quot;&amp;lt;img class=&amp;quot;image image--xl&amp;quot; src=&amp;quot;/images/zettelkasten.png&amp;quot;/&amp;gt;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Всегда можно зайти в граф, поблуждать по нему, дописать новое в заметки, добавить новые ссылки, укрепив сеть смысловых связей, etc.&lt;/p&gt;

&lt;p&gt;При том что я заполняю его чуть менее месяца. А теперь представьте что будет через пол года? Через год? Даже если вносить в день как минимум одну новую заметку.
Часто, используя Zettelkasten в процессе обучения одну запись добавить просто невозможно, ведь нам нужно следовать правилу атомарности, а изучаемая тема редко когда содержить лишь одну концепцию. Я так-же использую два плагина для obsidian: быстрая кнопка для создания новой заметки с префиксом из текущей даты, и вторая — открыть рандомную заметку.&lt;/p&gt;

&lt;h4 id=&quot;резюме&quot;&gt;Резюме&lt;/h4&gt;

&lt;p&gt;В данный момент мой процесс обучения стал намного устойчивее и яснее. Ведение конспектов по изучаемому материалу, блога и формирование Zettelkasten сильно дополняют и укрепляют друг друга. Смотрите что происходит у вас в голове, и если зацепилась действительно стоящая мысль (вам хотя бы на секунду показалось что она интересна) — незамедлительно запишите куда угодно! Я испольую ежедневник, который всегда под рукой, или личные сообщения самому себе в мессенджерах. Потом вы всегда сможете перенести эти заметки либо в полноценную статью блога (я так написал, например &lt;a href=&quot;2022/01/15/my_interviews_experience.html&quot;&gt;эту&lt;/a&gt;), или во временную заметку-сироту в Zettelkasten, которая рано или поздно обязательно обзаведется родственными связями.&lt;/p&gt;

&lt;p&gt;Во всей этой затее главное выработать привычку и достичь постоянства. Такой Zettelkasten — натуральное продолжение вашего мозга. Киберпанк уже давно тут.&lt;/p&gt;

&lt;p&gt;Начните прямо сейчас!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><summary type="html">Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.</summary></entry><entry xml:lang="ru"><title type="html">Мой лайфхак для прохождения интервью</title><link href="http://localhost:4000/2022/01/15/my_interviews_experience.html" rel="alternate" type="text/html" title="Мой лайфхак для прохождения интервью" /><published>2022-01-15T00:00:00+03:00</published><updated>2022-01-15T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/15/my_interviews_experience</id><content type="html" xml:base="http://localhost:4000/2022/01/15/my_interviews_experience.html">&lt;p&gt;Поговорим о том как подговиться к собеседованию и что нужно держать в голове :)
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;В сети часто пишут и говорят о так называмых hard и coft скилах. Если кто не в курсе, hard - это вполне конкретные компетенции какндидата как специалиста: знание языков программирования, технологических стеков, etc. В общем это всё то, что вы обычно видите в разделе вакансий &lt;em&gt;требумые навыки&lt;/em&gt;. С soft скилами всё ещё проще.
По большому счёту софт скилы - &lt;em&gt;это просто ваши социальные навыки&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;С первым всё понятно - мы должны изучать компетенции и совершенствоваться в своем поле. Касаемо hard скилов, лучшей практой подготовки к любому собеседованию или аттестации будет ведение некоторой документации, подтверждающей ваш опыт как технического специалиста – тематический блог, правильно оформленный гитхаб с проектами и трекером изучаемых тем. Это тема для отдельного разговора.&lt;/p&gt;

&lt;p&gt;Я же хочу поговорить, скорее, о soft скиллах. На основании своего опыта я осознал почти беспройгрышный вариант как вести себя на техническом собеседовании (или аттестации).&lt;/p&gt;

&lt;p&gt;Во-первых, не нужно бояться, никто вас убивать не будет. Самое худшее что может случиться - вам деликатно откажут или не перезвонят, пообещав это сделать. В хорошем случае - вам скажут в чем вы ошибаетесь и что нужно подтянуть. По хорошему это именно то что вам нужно самим &lt;strong&gt;всегда&lt;/strong&gt; уточнять. Любое собесдование не казнь, а крайне полезный опыт.&lt;/p&gt;

&lt;h3 id=&quot;микро-инсайт&quot;&gt;Микро-инсайт&lt;/h3&gt;
&lt;p&gt;А теперь о том, что мне действительно каждый раз помогало:
Перехватывайте инициативу на вашем техническом собеседовании!&lt;/p&gt;

&lt;p&gt;Я не говорю о том, что вам нужно отклоняться от темы вопроса, или вдаваться в рассуждения на абстрактные темами. Не надо умничать! Это  приведет к лишним вопросам и вы сами себя зароете. Будьте бдительны, и задавайте ВСТРЕЧНЫЕ вопросы в &lt;em&gt;обсуждамом контексте&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Ваше собеседование должно быть беседой. Каздый раз делая так я чувствовал позитивную реакцию, получался увлеченный диалог технических специалистов. Если вы действительно имеете какой-то опыт и показываете что “горите глазами” - вам врядли смогут отказать. По крайней мере вы получите отличный фидбэк.&lt;/p&gt;

&lt;p&gt;Если вы уверены что не просто забыли, а вообще не знаете о чем вас спрашивают - не теряйтесь и не стесняйтесь об этом прямо сказать.&lt;/p&gt;

&lt;p&gt;Главное сохранять баланс. Не забывайте что собеседуют всё таки вас.
Когда мне отвечают на встречные вопросы, и я слышу что-то новое и интересное, я никогда не стесняюсь и прошу интервьювера подождать 5 секунд, беру ручку и записываю пометку в блокнот максимально кратко - концепцию, название технологии, etc. Будьте искренни. В противно случае что вы тут вообще делаете? Это же касается вопросов, ответы на которые вы не знаете. Я всегда в таких случая прошу вкратце пояснить о чем речь, и запысываю ответ.&lt;/p&gt;

&lt;p&gt;Хорошо, если вы потом вернетесь к этим записям и изучите список :)
Если нет, то как минимум интервьювер увидит что вы по настояему увлечены процесом изучения новых технологий.&lt;/p&gt;

&lt;p&gt;Правда если вы попали на максимально консервативное, “бирюкратическое” собеседование, то всё выше упомянутое скорее всего не сработает. Тем не менее это тоже является хорошим опытом. Вообще проходить технические собеседования полезно, даже если вам нравится текущее место работы и не планируете его менять. Часто принимая участие этих мероприятиях вы остаетесь в курсе требований рынка, проверяете свои знания и актуализируете их.
В общем одни плюсы.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html">Поговорим о том как подговиться к собеседованию и что нужно держать в голове :)</summary></entry><entry xml:lang="ru"><title type="html">Алгоритм прохождения интервью по программированию</title><link href="http://localhost:4000/2022/01/15/programming_interview_algorithm.html" rel="alternate" type="text/html" title="Алгоритм прохождения интервью по программированию" /><published>2022-01-15T00:00:00+03:00</published><updated>2022-01-15T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/15/programming_interview_algorithm</id><content type="html" xml:base="http://localhost:4000/2022/01/15/programming_interview_algorithm.html">&lt;p&gt;Достаточно вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью по программированию.&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;Оригинал статьи можете прочитать в его личном блоге по &lt;a href=&quot;https://malisper.me/an-algorithm-for-passing-programming-interviews/&quot;&gt;этой ссылке.&lt;/a&gt;
Приступим.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;За последние несколько лет я проходи интервью в дюжине (или около того) компаний и решил ~50 уникальных алгоритимических задач.
Мне часто давали обратную связь, в которой говорилось, что я отлично справился с предлагаемыми алгоритимическими задачами.
В этом посте я собираюсь поделиться тем, как именно я подхожу к решению этих задач.&lt;/p&gt;

&lt;h2 id=&quot;мыслительный-процесс&quot;&gt;Мыслительный процесс&lt;/h2&gt;

&lt;p&gt;Основной принцип, который я использую, заключается в том что каждая задача, предлагаемая к решению на собеседовании, &lt;em&gt;может быть решена&lt;/em&gt;.
На интервью вас не станут просить доказать Великую теорему Ферма. Если вам дадут какую-то неразрешимую задачу, похоже что у вас не будет особых шансов её решить.&lt;/p&gt;

&lt;p&gt;По моему опыту, примерно в 80% случаев алгоритмические задачи сводятся к фундаментальным структурам данных и алгоритмам. Структуры данных, которые я встречаю чаще всего:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево поиска&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Что касаемо алгоритмов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Скорее всего от вас не будут требовать реализовать бинарный поиск или алгоритм сортировки, но вы &lt;em&gt;должны знать&lt;/em&gt;, что они существуют.)&lt;/p&gt;

&lt;p&gt;Кроме того, есть две дополнительные техники программирования, с которыми вы должны быть знакомы:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;алгоритм-решения&quot;&gt;Алгоритм решения&lt;/h2&gt;

&lt;p&gt;Алгоритм решения задачи выглядит так:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Как только вы получили алгоритмическую задачу, уточните требования к реализации (условия, runtime) которым должно соответствовать ваше решение. Скорее всего интервьвер ответит на этот вопрос.&lt;/li&gt;
  &lt;li&gt;Вычеркните из списка возможных структуры данных и алгоритмы которые очевидно не имеют отношения к рассматриваемой задаче. Это избавит вас от большей части списка, и вы, как правило, останетесь с 2-3 структурами данных и алгоритмами.
    &lt;ul&gt;
      &lt;li&gt;Вы можете не рассматривать слишком медленные структуры данных. Если вам необходимо решить задачу за O(1), то невомозможно использовать бинарное дерево в своем решении, так как бинарное дерево всегда будет выполнять не менее, чем за O(log n) времени.&lt;/li&gt;
      &lt;li&gt;Так же вы можете избавиться от алгоритмов, если их невозможно применить в задаче. Например, если в задаче нет графа, вы знаете, что поиск в глубину вам точно не подойдет.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Рассмотрите варианты использования оставшихся структур данных. Какие из них имеют отношения к поставленной задаче? Решением станет подходящая комбинация, вам остается её только собрать воедино.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте рассмотрим среды выполнения, основные структуры данных и алгоритмы. Затем мы разберем несколько примеров, чтобы убедиться насколько прост данных подход.&lt;/p&gt;

&lt;h3 id=&quot;требования-и-сценарии&quot;&gt;&lt;em&gt;Требования и сценарии&lt;/em&gt;&lt;/h3&gt;

&lt;h4 id=&quot;хэш-таблицы&quot;&gt;Хэш-таблицы.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - поиск, вставка и удаление за O(1)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Когда вам нужно лишь находить и сохранять объекты.&lt;/li&gt;
  &lt;li&gt;Когда вам нужно разделить список объектов на группы, по некотрому свойству (это то, что делает GROUP BY в SQL)&lt;/li&gt;
  &lt;li&gt;Нужно посчитать колиечество отличных элементов из списка.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;связанные-списки&quot;&gt;Связанные списки.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - вставка нового узла, поиск и удаление узлов из головы, хвоста, или из узла на который уже есть указатель.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:
Основные сценарии применения связанных списков витают вокруг факта, что связанные списки поддерживают относительный порядок своих элементов. В интервью по программированию связанные списки, в основном, используются как реализация стека или очереди.&lt;/p&gt;

&lt;h4 id=&quot;двоичные-деревья&quot;&gt;Двоичные деревья.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - вставка, поиск и удалние за O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:
Двоичные деревья используются, когда вам нужно хранить данные в отсортированном порядке. Позволяют быстро находить количество элементов, попадающих в конкретый диапазон, или самый &lt;em&gt;высокий&lt;/em&gt; элемент в дереве.&lt;/p&gt;

&lt;h4 id=&quot;двоичный-поиск&quot;&gt;Двоичный поиск.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Вам нужно найти число в массиве, ближайшее к другому числу.&lt;/li&gt;
  &lt;li&gt;Вам нужно найти наименьше число в отсортированном массиве, которое больше чем другое число.&lt;/li&gt;
  &lt;li&gt;Вам нужно найти наибольшее число в отсортированном массиве, которое меньше другого числа.&lt;/li&gt;
  &lt;li&gt;Если по какой-то причине в своем решении вы не можете использовать хэш-таблицу, вы можете с помощью двоичного поиска проверить, находится ли элемент в отсортированном массиве.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;поиск-в-глубину&quot;&gt;Поиск в глубину.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Требуется обойти весь граф.&lt;/li&gt;
  &lt;li&gt;Требуется найти конкретный элемент в графе.&lt;/li&gt;
  &lt;li&gt;Нужно найти &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B3%D1%80%D0%B0%D1%84%D0%B0&quot;&gt;компоненту графа&lt;/a&gt; (состоящий из наибольшего количества узлов подграф)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;сортировка&quot;&gt;Сортировка.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(n log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Может использоваться в случае, когда вам нужно обработать элементы в требуемом порядке. Сначала сортируем в этом порядке, затем итерируемся по элементам.&lt;/li&gt;
  &lt;li&gt;Может использоваться для соритровки массива, к которому потом будет применяться двоичный поиск.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;динамическое-прогрммирование-и-рекурсии&quot;&gt;Динамическое прогрммирование и рекурсии.&lt;/h4&gt;

&lt;p&gt;Динамическое программирование и рекурсия отличаются тем, что являются общими методами решения алгоритмических задач, а не конкретными алгоритмами.
Это означает что у них нет конкретных сценариев применения или требуемого &lt;a href=&quot;https://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5&quot;&gt;асимптотического поведения&lt;/a&gt;. 
Хорошая новость в том, что после небольшой практики становится достаточно просто распознавать задачи, которые можно решить с помощью динамического программирования или рекурсии. Я рекомендую попрактиковаться в подобных задачах, чтобы вы &lt;em&gt;могли почувствовать&lt;/em&gt; эти методы. Полное объяснение динамического программирования и рекурсии выходит за рамки данного поста.&lt;/p&gt;

&lt;h3 id=&quot;примеры&quot;&gt;Примеры&lt;/h3&gt;

&lt;p&gt;Теперь давайте посмотрим на несколько разных алгоритмических задач с интервью, и как они могут быть решены с помощью алгоритма решения.&lt;/p&gt;

&lt;h4 id=&quot;задача-1-написать-рейт-лимитер&quot;&gt;Задача #1: Написать рейт-лимитер&lt;/h4&gt;

&lt;p&gt;Эту задачу я встречал несколько раз на интервью в разных компаниях.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Вам нужно написать функцию, которая может быть вызвана не более N раз за одну минуту. Например, она может быть вызвана лишь 10 раз в минуту.
Если функция вызывается более N раз, она должна генерировать исключение. Ожидается что функция будет работать за O(1).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Посмотрите на список алгоритмов и структур данных, которые мы можем использовать, и попытайтесь понять какие из них помогут в решении данной задачи. Затем попробуйте понять как вы можете их применить в решении. Попробуйте самостоятельно, прежде чем смотреть ответ.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Сперва исключим алгоритмы и структуры данных, которые явно не подходят.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Двоичное дерево&lt;/del&gt; — слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; — слишком медленно, и в задаче нет графа для использования этого алгоритма.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — тоже слишком медленно, в задаче нет отсортированного массива.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — снова слишком медленно. В задаче нет элементов для сортировки.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — нет способов применить динамическое программирование в решении.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — нет сособов применить рекурсию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Не вычеркнули только хэш-таблицы и связанные списки. Если мы вернемся и рассмотрим сценарии использования хэш-таблиц, то не найдем способа применить эту структуру данных в решении задачи. Нам не нужно быстро искать разные объекты, и не нужно разбивать на подгруппы списки объектов. Значит хэш-таблицы тоже можно вычеркнуть из списка.&lt;/p&gt;

&lt;p&gt;Таким образом, осталась только одна структура данных v связанные списки. Глядя на сценарии применения видим реализацию стека или очереди. Можем ли мы использовать какой то из этих вариантов для отслеживания колличества вызовов функции за последюю минуту? Да! Мы можем создать очередь, в которую будет входить одна запись за каждый вызов функции в течении последней минуты. Каждый раз, когда функция вызывается, мы удаляем из очереди все записи, которые были сделанны более минуты назад. Если очередь по прежнему имеет длинну больше N — генерируется исключение. В противном случае мы добавляем новую запись в очередь с меткой текущего времени (время вызова). Отслеживая длинну очереди с помощью переменной счётчика, которую мы можем определять за O(1), функция так же будет иметь ожидаемую производительность O(1).&lt;/p&gt;

&lt;h4 id=&quot;задача-2-анаграммы&quot;&gt;Задача #2: Анаграммы&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;На вход поаается список слов, из которого нужно составить список слов, которые являются анаграммами как минимум одного другого слова во входном списке. Два слова являются анаграммами друг друга, в случае если буквы в одном слове можно поменять местами так, чтобы получилось второе. Программа должна выполняться за O(n), если все слова одной длинны&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Снова попытатейтсь обдумать задачу самостоятельно, прежде чем читать решение. Вот уже знакомый нам список структур данных и алгоритмов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение-1&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Начнем отбрасывать элементы из списка, которые не помогут в решении проблемы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Двоичное дерево&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; —Тут нет графа.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — Тут нет отсортированного массива.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — Нет способа применить динамическое программирование.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — Нет способа применить рекурсию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;У нас остались хэш-таблицы и связанные списки. Связанные списки, похоже, не пригодятся в решении этой задачи, так как стэк или очередь не выглядят эффективно. Получается что остается использовать хэш-таблицу.&lt;/p&gt;

&lt;p&gt;Единственный вариант использования хэш-таблицы, который кажется здесь уместным, — это возможность разделить список объектов на группы по некоторому признаку. В этом случае, если бы у нас был способ разделить список на отдельные группы, в которые бы входили слова анаграммы друг друга, это помогло бы решить задачу. Выглядит как план:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Разделим входной список слов на группы по признаку “анаграммности” друг друга.&lt;/li&gt;
  &lt;li&gt;Соединим вместе группы, в которых больше одного слова. В результате мы получим требуемый список слов, в котором каждое слово будет являться анаграммой как минимум одного другого слова из входного списка.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Единственное, что нам осталось решить. это найти какое-то свойство, которое мы можем использовать для группирования анаграмм. Нам нужно определить функцию &lt;em&gt;f&lt;/em&gt;, результат выполнения которой как &lt;em&gt;f(x)&lt;/em&gt; и  &lt;em&gt;f(y)&lt;/em&gt; будет одинаков, если x и y являются анаграммами друг друга.&lt;/p&gt;

&lt;p&gt;Для этой цели мы можем использовать две разные функции:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Отсортируем символы в словах по алфавиту. Мы знаем, что все анаграммы состоят из одних и тех же буква. Таким образом мы получим одну и ту же строку для любой пары слов-анаграмм.&lt;/li&gt;
  &lt;li&gt;Составим словарь из количества вхождений каждой буквы в каждом слове. Это решенее сложнее, так как придётся каким то образом использовать в качестве ключа в хэш-таблице. В некоторых языках программирования есть способ это сделать, в других нет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Теперь, когда мы нашли способ сгруппировать слова анаграммы друг друга, мы можем собрать все размышления вместе и решить задачу.&lt;/p&gt;

&lt;p&gt;Давайте попробуем рассмотреть ещё одну задачу.&lt;/p&gt;

&lt;h4 id=&quot;задача-3-k-sorted-частичная-сортировка&quot;&gt;Задача #3: K-sorted (частичная сортировка)&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Есть массив объектов, который частично отсортирован, и его нужно “досортировать”. Каждый элемент массива находится на расстоянии, не более чем k от своего фактического места. Требования к сложности реализации алгоритма отсутствуют.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Как и ранее, вот список алгоритмов и структур данных:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение-2&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Сначала, давайте подумаем, можем ли мы что то предположить о сложности и времени выполнения алгоритма. В самом лучшем случае мы можем достичь O(n), посколько именно столько времени потребуется на итерирование по списку. Мы также можем выполнить обычную сортировку за O(n log n). Давайте определим, можно ли сделать лучше, чем O(n log n).&lt;/p&gt;

&lt;p&gt;Как нам достичь скорости в O(n)? Ну, если k=n, то сложность задачи становится такой же, как сортировка списка, поэтому невозможно постоянно попадать в O(n). Но может быть всё ещё можно решить задачу быстрее, чем за O(n log n). Теперь давайте посмотрим, какие структуры данных и алгоритмы из нашего перечня помогут в решении:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; — Нет графа.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — Массив не отсортирован.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — Не подходит для решения задачи.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — Не подходит для решения задачи.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Из оставшихся структур данных, единственная, которая имеет отношение к возможному решению — это двоичное дерево. К такому выводу мы приходим потому что только двоичное дерево единственная структура данных из списка, имееющая отношение к сортировке элементов. Если немного подумать о том, как можно применить двоичное дерево для решения, ответ станет ясен. Мы можем построить двоичное дерево из &lt;em&gt;последних k элементов&lt;/em&gt;. Мы раз за разом удаляем наименьший элемент из бинарного дерева, и добавляем в него следующий из входного массива. Полный алгоритм решения выглядит следующим образом:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Построить двоичное дерево из первых k элементов входного массива.&lt;/li&gt;
  &lt;li&gt;Перебрать оставшуюся часть массива. На каждой итерации удаляем наименьший элемент из двоичного дерева и добавляем его в результирующий массив. Затем добавляем &lt;em&gt;текущий&lt;/em&gt; элемент из входного массива в двоичное дерево.&lt;/li&gt;
  &lt;li&gt;Как только мы дойдем до конца входного массива, один за одним удаляем наименьший элемент из двоичного дерева, пока дерево не опустеет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Анализируя сложность этого решения делаем вывод, что время выполнения составит O(n log k). Возможно ли сделать лучше? Интуитивно кажется, что тут добиться более быстрого алгоритма не получится. 
Какой алгоритм может быть эффективнее, между O(n) и O(n log k), особенно из тех, что вам удастся придумать во время интервьюирования? Дале приводится неформальное доказательство того, что вы не можете решить задачу быстре, чем O(n log k). Учитывая то, что придумать алгоритм быстрее задача не из лёгких, от вас не будут ожидать этого на интервью. Если доказательство вам не интересно, можете его пропустить.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Предположим, у вас уже есть алгоритм, который работает быстрее, чем O(n log k). Мы можем использовать его, чтобы пытаться придумать алгоритм сортировки, который быстрее O(n log n), что невозможно. Допустим, у вас есть n/k различных списков, кажрый длинной в k, причем элементы каждого списка строго больше, чем элементы предыдущего. Если вы объедините все списки вместе, запустите для них k-сортировку, а затем разделите каждые k элементов на отдельные списки, вы отсортируете n/k списков менее, чем за время O(n log k). В свою очередь это означает, что в среднем вы сортируете каждый список менее чем за O(n/(n/k) log k) = O(k log k), что невозможно. Поэтому ни один алгоритм k-сортировки не будет работать быстрее, чем O(n log k).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Это озачает что выше мы нашли оптимальное решение поставленной задачи.&lt;/p&gt;

&lt;p&gt;Надеюсь, на данный момент я убедил вас, что алгоритм решения алгоритмических задач, описываемый в этом посте — эффективный метод. Обратите внимание, что он эффективен не только при решении задач на собеседованиях, но и для решения алгоритмических задач, с которыми вы можете столкнуться в реальном мире. Вы можете использовать его, чтобы проверить, есть ли у задачи решение, состоящие из основных структур данных из нашего списка.&lt;/p&gt;

&lt;p&gt;Если вы хотите узнать о других способах решения задач, я настоятельно рекомендую книгу &lt;a href=&quot;https://www.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069111966X&quot;&gt;How to solve it&lt;/a&gt;. Эта книга охватывает множество различных подходов к решению любой задачи. How to solve it оказала огромное влияние на то, как я подхожу к любой задаче в настоящее время.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;На этом текст оригинальной статьи подходит к концу. По мере вычитывания и укрепления собственного понимания, с большой долей вероятности, в мой перевод будут вноситься улучшающие изменения.
Это статья достаточно сложная. Если вам не понятно что такое O(n) и так далее, и вы не знакомы с алгоритмами и структурами данных, о которых идет речь — не беспокойтесь! Я планирую написать цикл небольших постов на эти темы. Благодарю за уделённое время и надеюсь что превод окажется вам полезным!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Перевод" /><category term="Программирование" /><category term="Алгоритмы" /><summary type="html">Достаточно вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью по программированию.</summary></entry><entry xml:lang="ru"><title type="html">О чём этот блог</title><link href="http://localhost:4000/2022/01/10/about_blog.html" rel="alternate" type="text/html" title="О чём этот блог" /><published>2022-01-10T00:00:00+03:00</published><updated>2022-01-10T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/10/about_blog</id><content type="html" xml:base="http://localhost:4000/2022/01/10/about_blog.html">&lt;p&gt;Приветствую. Мысль начать вести свой блог я развивал около полугода. Сперва, идея заключалась в написании статей ради систематизирования своих знаний и мыслей. Я пробовал собрать нечто на Django и Vue, что-то получилось, но в итоге так и не ушло в &lt;em&gt;production&lt;/em&gt;. Я не был доволен результатом, так как это была всего лишь копипаста с какой то статьи “для чайников”. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Впрочем не хватало и мотивации, зато работы и бытовых трудностей - навалом. Сейчас быт стало ещё гуще и напряжённее, но счасливее, благодаря унарному инкременту счётчика кол-ва членов моей семьи. А мотивации вести блог насыпали знатно. За сына я благодарю свою любимую супругу, а за мотивацию - Сергея Игоревича Бобровского, у которого я учусь программированию уже чуть более года. В виду этих обстоятельств - я более чем доволен GitHub Pages на Jekyll.&lt;/p&gt;

&lt;p&gt;Обо мне вы можете прочитать &lt;a href=&quot;/about.html&quot;&gt;здесь&lt;/a&gt;. Вернёмся к блогу.&lt;/p&gt;

&lt;p&gt;Планируется, что основной контент статей будет заключаться в описании изучаемых мной технологий, нюансов программирования и инсайтов, на которые я надеюсь. Трек обучения и лог вы можете найти в моём &lt;a href=&quot;https://github.com/NaNameUz3r/My-Learning-Tracker&quot;&gt;гитхабе&lt;/a&gt;. Оставляю за собой право на глупость и ламерство, за что прошу отнестись с пониманием. Я открыт для любой конструктивной &lt;del&gt;и не очень&lt;/del&gt; критике, всегда рад обратной связи.&lt;/p&gt;

&lt;h3 id=&quot;почему-такое-название&quot;&gt;Почему такое название?&lt;/h3&gt;

&lt;p&gt;А почему топор? Потому что &lt;em&gt;врубаемся&lt;/em&gt;. Если вы на волне хайпа стереотипизируете Хакер == Кибер-преступник, право ваше, “рыночек” &lt;del&gt;вас&lt;/del&gt; порешал. Я исповедую другое понимание, Хакерство как вдохновенный настрой ума разобраться в той или иной теме, ведущее к мастерству в исследуемой области. Сантехник, который с закрытыми глазами и оторванной рукой починит вам трубы с помощью подручных материалов, которые вам бы и в голову не пришло использовать, да ещё быстро и качественно это сделает - Хакер.&lt;/p&gt;

&lt;p&gt;Скрипт кидди, который не может отсортировать массив без стандартных библиотек ЯП, но при этом успешно разводит народ, эксплуатируя когнитивные баги человеческого мозга - банальный мошенник и преступник, какие были всегда испокон веков.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Я не хакер&lt;/strong&gt;, но wannabe. Мне нравятся информационные технологии. Я вообще плох в математике, и в контексте данного блога преследую лишь две следующие, взаимодополняемые в бесконечном цикле, цели:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Врубиться в программирование&lt;/li&gt;
  &lt;li&gt;Поделиться нарубленным&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Надеюсь вы, как говорится, get the point.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html">Приветствую. Мысль начать вести свой блог я развивал около полугода. Сперва, идея заключалась в написании статей ради систематизирования своих знаний и мыслей. Я пробовал собрать нечто на Django и Vue, что-то получилось, но в итоге так и не ушло в production. Я не был доволен результатом, так как это была всего лишь копипаста с какой то статьи “для чайников”.</summary></entry></feed>