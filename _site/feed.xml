<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-04-19T01:47:01+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Ещё немного про F#</title><link href="http://localhost:4000/2022/04/17/more_about_f.html" rel="alternate" type="text/html" title="Ещё немного про F#" /><published>2022-04-17T00:00:00+03:00</published><updated>2022-04-17T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/17/more_about_f</id><content type="html" xml:base="http://localhost:4000/2022/04/17/more_about_f.html">&lt;p&gt;Продолжаем врубаться в функциональное программирование. Пусть и туго :)
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Всех и повсюду приветствую! Я продолжаю заниматься по ФП курсу, и (имхо!) пришла пора написать ещё немного про фишки F# (и, наверное, вообще ФП языков ML семейства) и порефлексировать.&lt;/p&gt;

&lt;h2 id=&quot;перегрузка&quot;&gt;Перегрузка&lt;/h2&gt;

&lt;p&gt;Перегрузка, это такая реализованная в языке “полиморфная” штука, когда при обращениях к функциям или операторам, которые &lt;em&gt;имеют несколько реализаций для разных типов данных&lt;/em&gt; компилятор ведет себя по разному. Сами эти реализации и есть “перегрузки”.&lt;/p&gt;

&lt;p&gt;В F# система типов ведет себя следующим образом:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Когда компилятору “понятно” в контексте обращения, что за тип используется — символ оператора интерпретируется как функция для этого типа;&lt;/li&gt;
  &lt;li&gt;В противном случае используется &lt;em&gt;перегруженный&lt;/em&gt; оператор для &lt;em&gt;подходящего&lt;/em&gt; типа по умолчанию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Звучит сложно, но на самом деле тут всё просто. Если какой-то оператор можно применить к целым числам (int), ну значит int и будет считаться &lt;em&gt;типом по умолчанию&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Например у функции:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let addition (x,y) = x + y 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;по умолчанию тип будет int -&amp;gt; int. Но что если мы хотим, и заранее знаем, что будем вычислять числа с плавающей точкой? 
Явно указать тип &lt;em&gt;аргумента&lt;/em&gt; в F# можно так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let addition (x: float, y: float) = x + x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Указать явно тип результата функции:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let addition (x, y) : float = x + x
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;И, наконец, можно указать явно &lt;em&gt;тип выражения&lt;/em&gt;, вычисляемого функцией:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let addition (x, y) = x + x : float
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;нонфиксная-запись&quot;&gt;Нонфиксная запись&lt;/h2&gt;

&lt;p&gt;Любые инфиксные операторы можно записать нонфиксной записью. Ну, короче, не 1 + 1, а (+) 1 1.&lt;/p&gt;

&lt;p&gt;Просто берем оператор в скобки, и следом перечисляем аргументы. Можно представить это как функцию:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let mul3 = (*)3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Где вызов mul3 2 будет равняться 6. Просто? Просто!&lt;/p&gt;

&lt;p&gt;Ну и по сути вызов нонфиксного оператора, который на вход получает один аргумент — функция (хотя тут вообще всё функция, но давайте сохранять трезвость рассудка).&lt;/p&gt;

&lt;p&gt;Применение функции работает через &lt;em&gt;левую ассоциацию&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;printfn &quot;%b&quot; ((*) 3 2 = ((*)3) 2) // будет true!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ну как там, с трезвостью?&lt;/p&gt;

&lt;h2 id=&quot;композиция-и-каррирование&quot;&gt;Композиция и каррирование&lt;/h2&gt;

&lt;p&gt;Так, это уже серьезные спеллы, первый из которых должен быть нам уже знаком (как минимум интуитивно).&lt;/p&gt;

&lt;h3 id=&quot;композиция&quot;&gt;Композиция&lt;/h3&gt;

&lt;p&gt;По-простому — это подход, подразумевающий вызов одних функций в качестве аргументов других. Я уже писал про high-order и вот это всё.
По-сложному, математически — композиция двух функций x и y (x o g) будет обозначать:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(x o y)(x) = x(y(x)) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;И есть x(a) = a + 5, и y(b) = b * 2, тогда&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(x o y)(b) = x(y(b)) = x(b * 2) = b * 2 + 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/mind_blowing.gif&quot; alt=&quot;Взрыв Мозга&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Узнали? Согласны?&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Отставить горячку!&lt;/p&gt;

&lt;p&gt;В F# вся эта магия реализуется &lt;em&gt;инфиксным&lt;/em&gt; оператором « или » у которых оба параметра — функции.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let x = fun a -&amp;gt; a + 5
let y = fun b -&amp;gt; b * 2
let chtoproishodit = x &amp;lt;&amp;lt; y

printfn &quot;%d&quot; (chtoproishodit 5) // посчитает: 5 * 2 + 5 = 15

let ostanovitespojaluista = ((fun y -&amp;gt; y * 20) &amp;lt;&amp;lt; (fun x -&amp;gt; x - 1)) 2 // посчитает: 2 - 1 * 20 = 20 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Всё просто же? Как сказано выше, можно передавать функции в другом порядке с помощью »&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let vseyasno = x &amp;gt;&amp;gt; y // vseyasno 3 = y ( x(3) ) = y ( 8 ) = 16  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;каррирование&quot;&gt;Каррирование&lt;/h3&gt;

&lt;p&gt;Или — &lt;em&gt;частичное применение функций&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Это когда мы передаем функции &lt;em&gt;неполное число аргументов&lt;/em&gt;, и в результате получаем… что? функцию!&lt;/p&gt;

&lt;p&gt;Как уже говорилось в предыдущем посте по теме, все функции в F# имеют &lt;strong&gt;только один аргумент&lt;/strong&gt;, когда мы кортежем передаем несколько аргументов, это по сути (формально) работает как применение функций одного аргумента ко всем аргументам из списка поочередно.&lt;/p&gt;

&lt;p&gt;Вот такая каррированая функция f a будет ждать на вход один параметр b:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let f x = fun b -&amp;gt; b * x 
let mul5 = f 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Понятно, что вызвав mul5 2 получится 10. В F# допускается ещё более краткая запись без fun:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let f x b = b * x 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Работать будет точно так же.&lt;/p&gt;

&lt;h2 id=&quot;нужно-больше-операторов&quot;&gt;Нужно больше операторов!&lt;/h2&gt;

&lt;p&gt;Тут можно делать свои операторы, а не только функции (сейчас какой-то душный человек вспомнит что оператор тоже функция и пойдет поедет. Я ― помню).&lt;/p&gt;

&lt;p&gt;Для определение своих &lt;em&gt;инфиксных&lt;/em&gt; операторов нам доступны следующие символы:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;! % &amp;amp; * + - . / &amp;lt; = &amp;gt; ? @ ^ | ~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;А для &lt;em&gt;префиксных&lt;/em&gt; такие последовательности:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ - +. -. &amp;amp; &amp;amp;&amp;amp; % %% ~ ~~ ~~~ ~~~~
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Объявление таких операторов нужно делать через скобочную нотацию: (оператор) для инфиксных, и (~оператор), соответственно для префиксных.&lt;/p&gt;

&lt;h2 id=&quot;операторы-применения-функций&quot;&gt;Операторы применения функций&lt;/h2&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Есть два таких оператора: “&lt;/td&gt;
      &lt;td&gt;&amp;gt;” и “&amp;lt;&lt;/td&gt;
      &lt;td&gt;”, они отправляют значение вправо или влево.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Выражение x&lt;/td&gt;
      &lt;td&gt;&amp;gt; y и выражение y &amp;lt;&lt;/td&gt;
      &lt;td&gt;x будут означать одно и то же — “y x”.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Но важный момент в том, что ассоциация этих операторов &lt;strong&gt;левая&lt;/strong&gt;:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10 |&amp;gt; 2 |&amp;gt; (+) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;приведет к ошибке, когда:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;10 |&amp;gt; (2 |&amp;gt; (+)) 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;сработает.&lt;/p&gt;

&lt;h2 id=&quot;ещё-раз-про-кортежи&quot;&gt;Ещё раз про кортежи&lt;/h2&gt;

&lt;p&gt;Итак, мы знаем что с помощью кортежей мы можем схитрить и передать в функцию больше одного аргумента.&lt;/p&gt;

&lt;p&gt;Кортежи могут объединять в себе значения разных типов, это ок. И это потенциально очень мощный инструмент. Рассмотрим несколько фишек.&lt;/p&gt;

&lt;h3 id=&quot;фишки-первого-уровня&quot;&gt;Фишки первого уровня&lt;/h3&gt;

&lt;p&gt;Значения типов в кортежах перевариваются в F# как объекты первого класса. Мы можем использовать их в выражениях, и получать как результат других выражений.&lt;/p&gt;

&lt;p&gt;Можно использовать в качестве элемента кортежа уже связанное ранее значение:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let a = (10, &quot;hello&quot;)
let b = (a, 100.500)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Последний кортеж получится типа: ((int * string) * float)&lt;/p&gt;

&lt;p&gt;Вычисляются кортежи по порядку слева-направо, и кортежи можно сравнивать, но только если совпадают значения типов их элементов (в том же порядке):&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(5 = 2, &quot;hello&quot;, 1 + 1) = (false, &quot;hello&quot;, 2) // правда!
(5 = 2, &quot;hello&quot;, 1 + 1) = (&quot;friend&quot;, (10.5, 18)) // парень, не дури, типы не совпали.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;“Легальное” сравнение (когда с типами всё ок), происходит в лексикографическом порядке:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(29, 14, 100) &amp;gt; 11, 0, 101 // не правда!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;кортеж-как-шаблон&quot;&gt;Кортеж как шаблон&lt;/h3&gt;

&lt;p&gt;Мы можем сделать кортеж состоящий только из идентификаторов:
    let (x, y) = (10, 200) // x = 10, y = 200&lt;/p&gt;

&lt;p&gt;С помощью чего потенциально можем сопоставлять идентификаторы и значения.&lt;/p&gt;

&lt;p&gt;Помните паттерн матчинг? Тут можно так же использовать идентификатор “_” для сопоставления с любыми значениями:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let (_, y) = (1, 2) // y = 2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;превращение-в-овцу&quot;&gt;Превращение в овцу&lt;/h3&gt;

&lt;p&gt;Это про полиморфизм, кто не понял :)&lt;/p&gt;

&lt;p&gt;Пример полиморфной функции с кортежем — функция swap:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let swap (x, y) = (y, x)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Она меняет значения внутри кортежа местами, и типы её параметров полиморфны, то есть определяются другими типами.&lt;/p&gt;

&lt;p&gt;Полиморфный тип, это такой тип, операции над которым могут нормально применяться к другим типам.&lt;/p&gt;

&lt;p&gt;В F# полиморфным типом выступает базовый тип .NET System.Object, таким образом тип функции swap будет:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.Object  * System.Object -&amp;gt; System.Object * System.Object
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;рефлексия&quot;&gt;Рефлексия&lt;/h2&gt;

&lt;p class=&quot;error&quot;&gt;Спойлер Алерт!!! Если вы занимаетесь по курсам Сергея Игоревича Бобровского, и не прошли ещё курс по F# — имейте совесть и смелость решить задачки сами. В частности далее будет спойлер к задаче по кастомным операторам 23.4.1.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/serious_cat.jpg&quot; alt=&quot;Котямба&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Я серьезно.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Задачка следующая:&lt;/p&gt;

&lt;p&gt;В фэнтези-РПГ принята следующая денежная система: в одном золотом 20 серебряных, а в одном серебряном 12 медяков. Суммы в такой системе задаются тройками целых чисел (золотые, серебряные, медяки), например (1, 0, 128) или (32, 23, 5).&lt;/p&gt;

&lt;p&gt;Реализуйте инфиксный оператор .+. , который складывает деньги, представленные в виде троек, и инфиксный оператор .-. , который вычитает деньги. Результат приводите к формату, когда количество медяков не превышает 11, а количество серебряных не превышает 19.&lt;/p&gt;

&lt;p&gt;Посмотрите какую хрень я накодил в первый (ладно, во второй) раз:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let (.+.) x y =
    let (g1, s1, c1) = x
    let (g2, s2, c2) = y
    
    let total_wallet = (g1 + g2, s1 + s2, c1 + c2)
    
    let rec count_coppers = function
    | (g, s, c) when c &amp;lt;= 11 -&amp;gt; (g, s, c)
    | (g, s, c) -&amp;gt; count_coppers (g, s + 1, c - 12)

    let rec count_silvers = function
    | (g, s, c) when s &amp;lt;= 19 -&amp;gt; (g, s, c)
    | (g, s, c) -&amp;gt; count_silvers (g + 1, s - 20, c)

    let copper_converted = count_coppers total_wallet
    let converted_wallet = count_silvers copper_converted
    converted_wallet


let (.-.) x y = 

    let (more, less) = 
        if x &amp;lt; y then
            (y, x)
        else
            (x, y)

    let (g1, s1, c1) = more
    let (g2, s2, c2) = less

    let rec count_coppers = function
    | (g, s, c) when c &amp;lt;= 11 -&amp;gt; (g, s, c)
    | (g, s, c) -&amp;gt; count_coppers (g, s + 1, c - 12)

    let rec count_silvers = function
    | (g, s, c) when s &amp;lt;= 19 -&amp;gt; (g, s, c)
    | (g, s, c) -&amp;gt; count_silvers (g + 1, s - 20, c)

    let bigger_copper_converted = count_coppers more
    let bigger_converted_wallet = count_silvers bigger_copper_converted
    
    let smaller_copper_converted = count_coppers less
    let smaller_converted_wallet = count_silvers smaller_copper_converted

    let (bigger_g, bigger_s, bigger_c) = bigger_converted_wallet
    let (smaller_g, smaller_s, smaller_c) = smaller_converted_wallet
    (bigger_g - smaller_g, bigger_s - smaller_s, bigger_c - smaller_c)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ну, справедливости ради, оно работает и прошло тесты. Но это какая то жесть. Пусть я и попытался применять рекурсию, здесь налицо недопонимание принципов хорошего, ясного программирования. И вообще халатность. Например в реализации оператора .-. не кажется ли вам что DRY не пахнет?&lt;/p&gt;

&lt;p&gt;Эталонное решение выглядит следующим образом:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let rec iter = function
| (a, b, c) when c &amp;gt; 11 -&amp;gt; iter (a, b + (c / 12), c % 12)
| (a, b, c) when b &amp;gt; 19 -&amp;gt; iter (a + (b / 20), b % 20, c)
| (a, b, c) when c &amp;lt; 0 &amp;amp;&amp;amp; b &amp;gt; 0 -&amp;gt; iter (a, b - 1, c + 12)
| (a, b, c) when b &amp;lt; 0 &amp;amp;&amp;amp; a &amp;gt; 0 -&amp;gt; iter (a - 1, b + 20, c)
| (a, b, c) when c &amp;lt; 0 &amp;amp;&amp;amp; a &amp;gt; 0 -&amp;gt; iter (a - 1, b + 19, c + 12)
| (a, b, c) -&amp;gt; (a, b, c)

let (.+.) (a, b, c) (x, y, z) = iter (a + x, b + y, c + z)
let (.-.) (a, b, c) (x, y, z) = iter (a - x, b - y, c - z)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ради той же справедливости попытаюсь оправдаться, что в первом своем нерабочем решении я использовал деление с остатком, но там была какая то императивная дичь с условными операторами, и компилятор ругался матом. Почему я не додумался забабахать рекурсивный паттерн матчинг… Хороший вопрос. Просто посмотрите на эту красоту, насколько это более ясно и коротко может быть выражено в коде. Паттерн матчинг воистину крутая штука!&lt;/p&gt;

&lt;p&gt;Век живи — век учись. А дурнем и помрешь!&lt;/p&gt;

&lt;p&gt;Слава Алонзо Черчу! Миру Мир! Я пошел.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html">Продолжаем врубаться в функциональное программирование. Пусть и туго :)</summary></entry><entry xml:lang="ru"><title type="html">Декомпозиция</title><link href="http://localhost:4000/2022/04/10/decomposition.html" rel="alternate" type="text/html" title="Декомпозиция" /><published>2022-04-10T00:00:00+03:00</published><updated>2022-04-10T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/10/decomposition</id><content type="html" xml:base="http://localhost:4000/2022/04/10/decomposition.html">&lt;p&gt;&lt;em&gt;“Совершенство достигнуто не тогда, когда нечего добавить, а тогда, когда нечего убрать.”&lt;/em&gt; — Антуан де Сент-Экзюпери
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;старый-мастер&quot;&gt;Старый мастер&lt;/h2&gt;

&lt;p&gt;Помните эту затёртую человечеством до дыр притчу, про старика который поучает сына о важности единства с &lt;del&gt;кентами&lt;/del&gt; братьями, давая ему ломать тростинки по одной, а потом вместе связав их в веник? Ну так то оно да, очень мудро. Но касаемо разработки программного обеспечения мейнстрим проповедует микросервисы, ортогональность, уход от высокой связности как в программировании в малом, так и в программировании в большом.&lt;/p&gt;

&lt;p&gt;Справедливости ради — декомпозиция это не какое-то новомодное изобретение инженерной мысли 21 века. Напротив, декомпозиция, как и все самые лучшие идеи нашей научной отрасли уже давно изобретены мудрецами прошлого века, на заре всего того, что творится здесь и сейчас. Многие из этих идей до сих пор не воплощены полноценно, многие из них нами, молодыми разработчиками — игнорируются к глубокому изучению и осмыслению. Это печально.&lt;/p&gt;

&lt;p&gt;Так что же мы будем делать если веник — это большая задача, и нам его &lt;em&gt;нужно&lt;/em&gt; “сломать”? Разумеется, за неимением средств к его сожжению и иной дезинтеграции мы будем тянуть по одной тростинке на последующий излом :) 
Но ломать конечно же ничего не надо, особенно продакшен, особенно в пятницу, бугага :)&lt;/p&gt;

&lt;p&gt;Ключевая идея принципа декомпозии в том, что очень обьемные задачи намного сложнее решать, чем мелкие.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/very_hard_graph.png&quot; alt=&quot;Сложный график&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Высокоточный и крайне искусно выполненный, важный график для наглядности понимания&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;люк-используй-декомпозицию&quot;&gt;Люк, используй декомпозицию!&lt;/h2&gt;

&lt;p&gt;Вообще про декомпозицию как способ мышления для решения задачи сформулировал ещё Рене Декарт в своем “Рассуждении о методе”. Нас интересует применение этого инструмента, в первую очередь в своих программистских начинаниях.&lt;/p&gt;

&lt;h3 id=&quot;о-это-было-в-школе&quot;&gt;О, это было в школе!&lt;/h3&gt;

&lt;p&gt;Разбивка на части сложной системы, для последующей её реализации в виде подпрограмм, лежит в основе &lt;em&gt;структурного программирования&lt;/em&gt;. С развитием идеи декомпозиции этот метод стали называть &lt;em&gt;процедурной декомпозиций&lt;/em&gt;, потому что сформировались концепции логической, объектной и других “декомпозиций”.&lt;/p&gt;

&lt;p&gt;Метод заключается, примерно в следующем:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Определяем общую структуру программы, если хотите — прототипируем, в виде одного из вариантов:
    &lt;ul&gt;
      &lt;li&gt;Последовательность подзадач (ввод данных, вычисление, вывод, ну вы поняли);&lt;/li&gt;
      &lt;li&gt;Условия, или &lt;em&gt;альтернативные&lt;/em&gt; подзадачи (тут нечего пояснять, правда?);&lt;/li&gt;
      &lt;li&gt;Повторения подзадач (циклы).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Теперь, в определенной структуре нам нужно каждую подзадачу беспощадно и снова разбивать на подзадачи используя структуры из пункта 1. Разбивать до тех пор, пока на минимальном “атомарном” уровне подзадачи не будут из себя представлять простые процедуры, реализуемые несколькими операциями языка программирования.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;В частном случае &lt;strong&gt;строгой&lt;/strong&gt; структурной декомпозиции запрещаются циклы и обратные вызовы подпрограмм. В таком случае иерархия программы становится древовидной без всяких goto петель.&lt;/p&gt;

&lt;p&gt;В чем вообще плюс всей этой идеи? Ну, в первую очередь, применяя структурное программирование мы минимизируем количество ошибок в работе программы, и более детально разрабатываем алгоритм в целом. У нас просто нет выбора не разобраться что и как тут будет работать, нет выбора напороться на ужасающие и непонятные сайд-эффекты, которые лихорадочно дебажутся до поздней ночи. Хотя… :D&lt;/p&gt;

&lt;p&gt;Если школьный курс информатики у вас был такой же как у меня, то вероятно подобные блок схемы это всё, что вы оттуда запомнили:&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/very_hard_sсheme.png&quot; alt=&quot;Сложная схема&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Подарите мне графический планшет 😢 &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;врубаемся-в-декомпозицию&quot;&gt;Врубаемся в декомпозицию&lt;/h3&gt;

&lt;p&gt;В низкоуровневых процедурных языках “декомпозиционной единицей” является &lt;em&gt;функция&lt;/em&gt; (или процедура) и &lt;em&gt;абстрактные типы данных&lt;/em&gt; (ADT). В высокоуровневых языках поддерживаюзих объектно ориентированную парадигму такой единицей является &lt;em&gt;класс&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Чтобы декомпозиция “работала” и вообще имела смысл, подпрограммы выделенные из общей системы должны быть независимы (ортогональны) друг от друга настолько, насколько это возможно. Разумеется, это не значит (в принципе, скорее всего и невозможно) что подпрограммы должны быть полностью независимы. Имеется в виду что они не должны иметь бесмысленных, избыточных связей друг с другом.&lt;/p&gt;

&lt;p&gt;Такая независимость особенно важна в проектах, над которым трудится несколько разработчиков. Каждый из нас может работать намного более продуктивно, если сосредоточится в один момент времени на одной задаче полностью, не беспокоясь обо всей остальной части системы.&lt;/p&gt;

&lt;p&gt;Конечно, разработчик &lt;em&gt;должен&lt;/em&gt; понимать систему и учитывать все ключевые моменты разработки! Тут имеется в виду работа над конкретно решаемой задачей. Если части системы максимально независимы друг от друга, перерабатывая какую-то из существующих частей, или разрабатывая новый модуль программист может сосредоточиться на решении своей задачи, если интерфейс взаимодействия с другими модулями понятен, унифицирован, и нет никаких подводных камней, сайд-эффектов.&lt;/p&gt;

&lt;p&gt;Может показаться что декомпозиция не имеет особого смысла в программе из тысячи или менее строк кода. Но на самом деле это не так. Намного продуктивнее развить в себе привычку декомпозировать код даже в таких маленьких системках, потому что этот навык невозможно переоценить и он обязательно даст плоды при разработке систем на 100 тысяч и более строк кода.&lt;/p&gt;

&lt;h2 id=&quot;сектор-приз-на-барабане&quot;&gt;Сектор приз на барабане&lt;/h2&gt;

&lt;p&gt;Правильно декомпозированную процедуру или класс часто сравнивают с “черным ящиком”. Что это значит?&lt;/p&gt;

&lt;p&gt;Имеется в виду то, что внутрнее устройство, работа этого черного ящика &lt;em&gt;неочевидна&lt;/em&gt;. Такой ящик &lt;em&gt;определяется тем что он делает&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Флешбек:&lt;/strong&gt;
Если вы читали предыдущии мои посты, а именно цикл по изучению Декларативной модели, мы там разбирали абстрактные типы данных. Напомню — абстрактный тип, это такая струтура данных, которая описана исключительно посредством операций над этой структурой. Смекаете?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Внутренняя реализация АТД неочевидна, она может меняться на лету, в любой момент времени, без влияния на остальную систему, если изменения полностью соответствуют определению типа!&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Так вот, черный ящик имеет четко определенное поведение с точки зрения ввода данных в него, представляет собой максимально простую абстракцию (в контексте задачи) для описания того, &lt;em&gt;что будет получено на выходе&lt;/em&gt;, а реализация… реализация &lt;em&gt;безопасно&lt;/em&gt; скрыта внутри!&lt;/p&gt;

&lt;p&gt;Черный ящик можно обозвать &lt;em&gt;“единицей делигировани”&lt;/em&gt;, мы просто говорим ему &lt;em&gt;чего мы хотим&lt;/em&gt; (продолжаем лоавить декларативные флешбеки). Например — я хочу воткнуть запись в стек, я хочу узнать что наверху стека, я хочу вытолкнуть запись из стека, и так далее.&lt;/p&gt;

&lt;p&gt;Как уже было сказано, ключевая цель декомпозиции — разделение задачи на независимые подзадачи. И идея черных ящиков это естественное, логическое продолжение этой цели. Большинство таких ящиком могут быть описаны как независимые, или полностью независимые струкруты.&lt;/p&gt;

&lt;p&gt;Любые взаимодействия между черными ящиками при необходимости могут быть описаны четко определенными и простыми программистскими механизмами.&lt;/p&gt;

&lt;h2 id=&quot;абстракция&quot;&gt;Абстракция&lt;/h2&gt;

&lt;p&gt;На самом деле декомпозиция, это не что иное как пример применения стратегии &lt;em&gt;“разделяй и влавствуй”&lt;/em&gt;. 
Самое главное преимущество, повторюсь, заключается в том что работать с модулями (ящиками) можно независимо друг от друга.&lt;/p&gt;

&lt;p&gt;Снаружи все модули просты и понятны, поэтому мы можем легко понять как и где их использовать, как их сочетать.&lt;/p&gt;

&lt;p&gt;Но это хорошо работает только в том случае, если &lt;em&gt;асбтракция&lt;/em&gt;, которую представляет собой черный ящик &lt;em&gt;имет какой то фундаментальный смысл&lt;/em&gt;. Между входными и выходными данными должна быть понятная, четкая связь.&lt;/p&gt;

&lt;p&gt;Как правило, почти всегда есть ряд сложностей и тонкостей в реализации программы, &lt;em&gt;которые &lt;strong&gt;не должны&lt;/strong&gt; быть частью реализации асбтракции&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Фишка в том, что “ящик” должен в качестве входны данных требовать &lt;em&gt;только то что ему нужно для вычисления этих данных&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Понять правильно ли описана абстракция на самом деле достаточно просто. Первый, и самый главный критерий:&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Легко ли описать своими словами то, что данный компонент делает?&lt;/p&gt;

&lt;p&gt;Для функции хорошим признаком будет ситуация, в которой в формируемом описании её поведения имя функции будет глаголом, а параметры (аргументы) — существительными.&lt;/p&gt;

&lt;h2 id=&quot;хорошие-функции&quot;&gt;Хорошие функции&lt;/h2&gt;

&lt;p&gt;Так что же все таки должно быть параметрами функции? Как понять, что подзадача достаточно сложна и независима для того, чтобы быть “достойной” выделния её в отдельную функцию?&lt;/p&gt;

&lt;p&gt;Зарубим себе на носу:&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Функция должна решать &lt;strong&gt;одну конкретную задачу&lt;/strong&gt;. Её аргументы должны включать в себя &lt;strong&gt;только то, что необходимо&lt;/strong&gt;. Абстракция того, что функция выполняет со своими аргументами, &lt;strong&gt;должна иметь смысл&lt;/strong&gt;.&lt;/p&gt;

&lt;h3 id=&quot;одна-задача&quot;&gt;Одна задача!&lt;/h3&gt;

&lt;p&gt;Это не значит что функция должна состоять из одной строки кода с несколькими операторами. Код в функции должен решать эту одну задачу. Занимаясь рефакторингом, просматривая код снова и снова, в какой-то момент мы обязательно сможем выделить часть кода, которая достойна стать подпрограммой.&lt;/p&gt;

&lt;h3 id=&quot;длинна-функции&quot;&gt;Длинна функции&lt;/h3&gt;

&lt;p&gt;Длинна функции это хрень. Это очень упрощенная мера, которая не выдерживает критики с точки зрения анализа структуры задачи. Конечно функция может оказаться длинной из за того что она решает несколько задач. Части такой функции можно и нужно декомпозировать.&lt;/p&gt;

&lt;p&gt;Но функция может всё ещё решать одну задачу и быть “вынужденно” длинной, просто потому что вычисления для задачи, решаемой функций, могут быть достаточно объемны. Эти вычисления не могут выполняться независимо друг от друга, части этих вычислений не могут или “не заслуживаю” быть выделенными в отдельную функцию.&lt;/p&gt;

&lt;p&gt;Или могут и заслуживают?… Это очень важный момент. Здоровенная функция &lt;strong&gt;автоматически должна вызывать подозрения&lt;/strong&gt; о качестве её декомозиции. Перечитайте её, действительно ли алгоритм написан грамотно и ничего нельзя разложить?&lt;/p&gt;

&lt;p&gt;Это очень условно, но в идеале функция должна иметь от 5 до 25 строк.&lt;/p&gt;

&lt;h3 id=&quot;короткие-процедуры&quot;&gt;Короткие процедуры&lt;/h3&gt;

&lt;p&gt;Может показаться, что 2 строчки кода не имеет смысла выделять в отдельную функцию. А вот и нет, ещё как имеет. 
Например у вас может быть какая-то сложная строка, которая явно “шумит” в коде и лишь отвлекает внимание.&lt;/p&gt;

&lt;p&gt;Может статься так, что эта “шумная” строка ещё и вызывает несколько раз, или в разных местах. Если видите такое — смело оборачивате в отдельную функцию. Потом себе спасибо скажете, перечитывая свой код.&lt;/p&gt;

&lt;p&gt;Современные компиляторы &lt;strong&gt;умные&lt;/strong&gt;, и не стоит беспокоиться о дополнительных накладных расходах вызова такой короткой функции.&lt;/p&gt;

&lt;h3 id=&quot;аргументы&quot;&gt;Аргументы&lt;/h3&gt;

&lt;p&gt;Функция должна иметь как можно меньше аргументов, необходимых для решения свой задачи. Если у вас есть функция с 4 аргументами, наверное стоит присмотреться получше.&lt;/p&gt;

&lt;p&gt;Фунция не должна накладывать дополнительных ограничений на входные данные, кроме тех, что нужны для её работы. Это упростит использование такой функции в самых разных контекстах позднее в коде.&lt;/p&gt;

&lt;p&gt;Конечно, есть ряд случаев когда просто невозможно обойтись без большого количества аргументов. Но повторюсь снова… Это всё таки “красный флаг” для нашего внимания. Если обнаруживается что какой-то набор аргументов всегда, как бы преследует функцию — может стоит упаковать всё это дело в свою структуру (АТД)?&lt;/p&gt;

&lt;h3 id=&quot;сложность-функции&quot;&gt;Сложность функции&lt;/h3&gt;

&lt;p&gt;Код, строки кода в функции должны выражать последовательность вычислений, шагов какого-то алгоритма.&lt;/p&gt;

&lt;p&gt;Если сложность одного из таких шагов явно отвлекает от решаемой проблемы, “избыточно шумит”, то такой этап вычислений следует декомпозировать -&amp;gt; изолировать!&lt;/p&gt;

&lt;p&gt;Следует озадачиться, если какой-то из шагов алгоритма требует нескольких локальных переменных, которые нигде больше не в функции используются.&lt;/p&gt;

&lt;p&gt;Детализация всех шагов алгоритма должна быть примерно, или лучше на “одном уровне”.&lt;/p&gt;

&lt;h3 id=&quot;dry&quot;&gt;DRY!&lt;/h3&gt;

&lt;p&gt;Не стоит повторять более пары строк кода. А если пара слишком часто повторяется и выглядит сложно см. пункт про короткие процедуры.&lt;/p&gt;

&lt;p&gt;Такие повторяющеся эллементы кода должны быть помещены в собственную функцию, которая затем вызывается там, где раньше был повторяющийся код.&lt;/p&gt;

&lt;p&gt;Разумное правило: раскладываем повторяющиеся последовательности, если это сделает программу короче. В общем случае такие последовательности могут и не быть &lt;em&gt;полностью идентичными&lt;/em&gt;. Незначительные различия можно учесть в параметрах новой функции.&lt;/p&gt;

&lt;p&gt;Если мы обнаруживаем, что копируем и вставляем код — это верный признак того что мы делаем ерунду.&lt;/p&gt;

&lt;h3 id=&quot;обощай-думая-думалкой&quot;&gt;Обощай, думая думалкой&lt;/h3&gt;

&lt;p&gt;Подзадача которая представляет собой фундаментальнуя программистскую идиому обязательно должна быть декомпозирована. Речь о всяких сортировках, поисках, пересечениях множеств, etc.&lt;/p&gt;

&lt;p&gt;Всё это кандидаты на свои собственные, отличные функции. Такие абстракции всегда просты и понятны, и их реализации можно использовать по необходимости где угодно в программе.&lt;/p&gt;

&lt;p&gt;Стандартные библиотеки языков программирования с набором методов — яркий пример того, о чем тут идет речь.&lt;/p&gt;

&lt;h3 id=&quot;скоуп&quot;&gt;Скоуп&lt;/h3&gt;

&lt;p&gt;Это важно. Это поможет избежать много боли.&lt;/p&gt;

&lt;p class=&quot;error&quot;&gt;Доступ к любой переменной вне тела функции &lt;strong&gt;всегда должен быть только через параметры этой функции!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;В противном случае, о каком черном ящике вообще может идти речь? Нарушающие это правило подпрограммы становятся зависимыми от внешнего кода. Всё сломается, обязательно сломается! Как минимум вы сломаете себе мозг когда будете это дебажить :)&lt;/p&gt;

&lt;p&gt;Нелокальный доступ допустим только для констант.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;На этой позитивной ноте закругляемся. Надеюсь что вам было полезно сие чтиво!&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/decomposition_meme.jpg&quot; alt=&quot;Шуточка&quot; /&gt;&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Проектирование" /><summary type="html">“Совершенство достигнуто не тогда, когда нечего добавить, а тогда, когда нечего убрать.” — Антуан де Сент-Экзюпери</summary></entry><entry xml:lang="ru"><title type="html">Лень — двигатель прогресса?</title><link href="http://localhost:4000/2022/04/03/laziness.html" rel="alternate" type="text/html" title="Лень — двигатель прогресса?" /><published>2022-04-03T00:00:00+03:00</published><updated>2022-04-03T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/03/laziness</id><content type="html" xml:base="http://localhost:4000/2022/04/03/laziness.html">&lt;p&gt;Часики тикают. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;определимся&quot;&gt;Определимся&lt;/h2&gt;

&lt;p&gt;Даль определяет в своем словаре лень как “отвращение от труда, от дела, занятий; наклонность к праздности, к тунеядству”. И это конечно же откровенная ерунда, в контексте той &lt;em&gt;полезной&lt;/em&gt; лени, о которой я хочу поговорить.&lt;/p&gt;

&lt;p&gt;С точки зрения биологии лень — это механизм экономии энергии, и наверное, в первую очередь энергии мозга. Разумеется что в наше время, благодаря развитию цивилизации технологически довольно, и к сожалению, популярна именно та лень которую определяет Даль. Это полная жесть и явный непорядок, какой то дисбаланс в наших жизнях, что мы такой лени поддаемся.&lt;/p&gt;

&lt;p&gt;Поясню. Я считаю что психологически и физически здоровый, и хоть сколько интеллектуально развитый человек, так сказать — “осведомленный о реальности”, просто не может впадать в апатичное поведение “ничего неделания”, долгой прокрастинации. Но так как это всё же эволюционный механизм, человек как вид стремится сохранять энергию, делать жизнь проще, легче, изобретать, творить и автоматизировать процессы. Давайте поговорим именно об этой “прагматичной лени”.&lt;/p&gt;

&lt;h2 id=&quot;два-стула&quot;&gt;Два стула&lt;/h2&gt;

&lt;p&gt;Как за собой, так и за другими людьми я периодически замечаю две крайности: адский трудоголизм и чрезмерное битье баклуш. Любая крайность, не только в данном контексте это, вообще повод остановиться. Подышать минут пять свежим воздухом и попытаться понять что пошло не так.&lt;/p&gt;

&lt;p&gt;Чрезмерный трудоголизм это &lt;strong&gt;полная жесть&lt;/strong&gt;. Не поймите меня не правильно — вкалывать &lt;em&gt;надо&lt;/em&gt;. Вкалывать в какой-то форсмажорный спринт с малым количеством отдыха, вероятно принесет краткосрочную пользу (вспомнили как писали курсовую, диплом? бгг), но в долгосрочной перспективе это прямой путь к подорванному здоровью, глубокой депрессии (вплоть до апатии), состоянию когда руки над клавиатурой поднимаешь через силу. Поверье, я в этом шарю.&lt;/p&gt;

&lt;p&gt;Другая крайность — впадение в зону комфорта, когда мы уютно устроились, набили прикладной навык, и сидим бьем баклуши. Мозг прокисает, денежка падает исправно на карту, нам всего как будто бы хватает. Хорошо устроились, что сказать. Но что-то всё равно сверлит глубоко в мозгу. Знакомо? Хорошо, если знакомо :) 
Этот вариант крайности мне претит ещё больше чем первый, вообще неприемлем. Отсутствие развития -&amp;gt; отсутствие эволюции -&amp;gt; гроб, гроб, кладбище…&lt;/p&gt;

&lt;p&gt;Оба подхода не прагматичны. Как бы это пафосно не звучало, но &lt;em&gt;нам нужно найти баланс&lt;/em&gt;. И это не выдуманный work-life balance, который полная, извините, херня. Дуализм, вообще херня. А вот строгие принципы, модель жизни, мышления и поведения — отличный подход мировоспрития и жизнепрепровождения. Дисциплина, если хотите. Только вот где её взять? И где взять на неё силы? Последне — только ваша и ничья иная “факультативная задача”.&lt;/p&gt;

&lt;p&gt;Ну… Дисциплину, как и почти любую другую поведенческую тенденцию можно &lt;em&gt;выработать&lt;/em&gt;. Придется потрудиться, хех :) 
Если одна лишь идея о выработке дисциплины, характера, изменений чего-то в своей &lt;em&gt;привычной жизни&lt;/em&gt; повергает вас в дрожь и тихий ужас — это &lt;strong&gt;нормально&lt;/strong&gt;. Это как раз тот самый механизм &lt;em&gt;лени&lt;/em&gt; нашего мозга. Мозг вообще не любит работать, для этого нужно тратить много ресурсов, наращивать какие-то там нейронные связи. И страх это более чем нормальная реакция на такие потенциально тяжелые для мозга напряги.&lt;/p&gt;

&lt;p&gt;Но это никак не может быть оправданием ничего не делать вовсе. Я не хочу никого пристыдить, каждый должен “стыдить” сам себя. Если мы только и делаем что ноем о своей неудачной жизни не выходя из зоны комфорта, вечно ищем оправдания для приложения усилий, развития навыков, может стоит принять себя так как есть? Смириться с тем что &lt;em&gt;меня всё устраивает&lt;/em&gt;. Устраивает безперспективняк. Устраивает абсолютно всё что уже есть: дом, работа, образ жизни и её качества, такие как степень физической активности, пищевые привычки и тд. — это правда всё именно-то, что меня устраивает в данный момент? Устраивает то, к чему это потенциально приведет в будущем, через 5, 10, 15 лет? Если на все вопросы мы отвечаем утвердительно, то дальше и говорить не о чем. Мы счастливые люди! Закрывайте к чертям эту страницу, идите отдыхай, всё &lt;em&gt;хорошо&lt;/em&gt;. Правда. Только прекратите ныть и наслаждайтесь жизнью!&lt;/p&gt;

&lt;h2 id=&quot;адвайта-чевойта&quot;&gt;Адвайта… Чевойта?&lt;/h2&gt;

&lt;p&gt;Жесткий дуализм, противостояние каких-то концепций в некоторой области всегда ведет к насилию. Подобное противопоставление работы и отдыха неизбежно приводит к перекосу — либо к агрессивному насилию над собой, либо к насилию пассивному, тянучему, превращающему в аморфную массу.&lt;/p&gt;

&lt;p&gt;Тем не менее, “правильно ленивые” сотрудники практически всегда продуктивнее и изобретательнее в долгосрочной, “стабильной” перспективе. Прагматично ленивый человек всегда найдет способ сделать работу быстрее, проще. Но идеальная формула — это сочетание ответственности, прагматично-ленивой изобретательности и профессионализма.&lt;/p&gt;

&lt;p&gt;Профессионально, но прагматично-лениво и безответственно — сделаем тяп-ляп и в продакшен. 
Ответственно, профессионально, но упершись рогами — шизоидно начнем изобретать велосипеды. 
Ответственно и лениво… Похоже эти качества вообще не сочетаются.&lt;/p&gt;

&lt;p&gt;Прагматично-ленивый, ответственный и образованный в своей сфере трудовой активности сотрудник всегда будет показывать лучшие результаты, чем ненавидящий себя и всех вокруг, так называемый трудоголик. Просто потому что не “лентяй” не загнал себя как последнюю клячу. У его мозга всегда будут силы творить, концентрироваться, эволюционировать. В целом такой подход это залог хорошего здоровья и качественной жизни в целом, а не только продуктивности на работе.&lt;/p&gt;

&lt;h2 id=&quot;бери-больше-кидай-дальше&quot;&gt;Бери больше, кидай дальше!&lt;/h2&gt;

&lt;p&gt;Ну и вот, собственно все замечательные блага которыми мы пользуемся, часто воспринимая их как &lt;em&gt;данность по умолчанию&lt;/em&gt;, подарили нам здоровые на голову, профессионально образованные, и прагматично-ленивые — &lt;em&gt;талантливые&lt;/em&gt; люди. Но талант это не какой-то космический дар, а упорный труд кирпичик к кирпичику, зернышко за зернышком. Вы наверняка натыкались на то самое “Томас Эдисон лампочку изобрел не сразу, 1000 попыток провалились, и потом наконец — ура, эврика, получилось”.&lt;/p&gt;

&lt;p&gt;Не будем сейчас о том, что до него лампочку много кто патентовал. Лучше обратимся вот к этому его “упорству”. Во-первых, 1000 раз он не одну и ту же лампочку пытался сделать, очевидно… или не очень? Томас, как и любой нормальный ученый муж занимался &lt;em&gt;исследованием&lt;/em&gt;, и правильнее сказать &lt;em&gt;экспериментировал&lt;/em&gt;. Так что талант — это скорее &lt;em&gt;упорство в изобретательности&lt;/em&gt;, некая настойчивость в достижении определенной цели.&lt;/p&gt;

&lt;p&gt;Вкалывал ли Томас? По любому! Но неужели вы думаете, что он упирался рогом в свои ошибки, и совсем не отдыхал? И тратил ли он &lt;em&gt;время&lt;/em&gt; на какую то бесполезную хренотень, была ли вообще хренотень в его жизни? Сложно сказать наверняка, но мне кажется что если бы Томас ежедневно спал по 12 часов после тусовок в кабаках с забулдыгами, играл в карты и так далее, то ни лампочку и ничего другого бы так и не изобрел.&lt;/p&gt;

&lt;p&gt;Во-первых, я веду к этому утонченному балансу между &lt;strong&gt;вкалываением&lt;/strong&gt; и &lt;strong&gt;отдыхом&lt;/strong&gt;. 
Во-вторых, предлагаю вам задуматься вот о чем — чем вы можете пожертвовать для достижения целей (подразумевается что цели, амбиции и стремления к переменам у вас есть, раз дочитали до сюда).&lt;/p&gt;

&lt;p&gt;Ок! Мы решили не ныть, проявить смелость чтобы выйти из зоны комфорта, перестать загоняться по пустякам, начать трансформировать в прагматичных и успешных людей. Звучит как отличный план!&lt;/p&gt;

&lt;p&gt;Для этого нужен &lt;em&gt;ресурс&lt;/em&gt;, для любых трансформаций нужен ресурс и толчок, причина. С толчком-причиной, как я уже сказал — разбирайтесь сами. Никто вам не даст волшебный пендель под зад и не сделаем счастливым и просветленным &lt;strong&gt;кроме вас самих&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;А что с ресурсом? Мы выяснили что мозгу надо отдыхать, чтобы экономить энергию. Но это не главный ресурс.&lt;/p&gt;

&lt;p&gt;Самый главный и &lt;strong&gt;невосполнимый&lt;/strong&gt; ресурс который у нас есть — &lt;strong&gt;время&lt;/strong&gt;. Поглядите ретроспективно на что вы тратите его и в каком объеме. Я серьезно, это очень важно. Можете прям на бумажке, в каком нибудь блокноте планере записывать несколько дней (или недель) сколько времени и на что уходит.&lt;/p&gt;

&lt;h3 id=&quot;сколько-и-как-я-пашу&quot;&gt;Сколько и как я пашу?&lt;/h3&gt;

&lt;p&gt;Сколько времени вы тратите на работу? Может вы перерабатываете? А вам за это доплачивают вообще? Если даже доплачивают — насколько эта переработка продуктивна, полезна &lt;strong&gt;вам&lt;/strong&gt; а не дяде? Сколько вы получаете за час? Пусть вы переработали 2 часа, и получили х1.5 или даже х2 (что всё реже встречается) за каждый переработанный час. &lt;em&gt;Оно действительно того стоило&lt;/em&gt;?&lt;/p&gt;

&lt;p&gt;Если исследовать более пристально время которые тратится на работу, то ещё полезнее будет углубиться в конкретные задачи. Насколько часто вы отвлекаетесь? Отвлекаться от интеллектуальной задачи, с одной стороны — очень полезно и периодически даже категорически &lt;strong&gt;нужно&lt;/strong&gt;! Просто чтобы &lt;strong&gt;отдохнуть&lt;/strong&gt; и посмотреть на задачу под новым углом, и вполне вероятно — решить её быстрее, лучше.&lt;/p&gt;

&lt;p&gt;Проанализируйте на что именно вы отвлекаетесь. Если это откровенная &lt;strong&gt;херня&lt;/strong&gt;, типа поглощения мусорного контента в ленте тик-тока, то на самом деле &lt;strong&gt;вы не даете мозгу отдохнуть&lt;/strong&gt;. Отдых для мозга (имхо?) — это не только переключение внимания, но и прекращение потока излишней информации. Намного продуктивнее и полезнее будет пройтись, размяться, поговорить с коллегами, семьей, в общем &lt;em&gt;натуральный&lt;/em&gt; чилл. Если этот мой блейм соцсетей вызывает у вас бугурт… Извините — дело дрянь.&lt;/p&gt;

&lt;p&gt;А теперь конкретнее про IT, и вот эти все наши клацания по кнопкам. Я как-то писал вкратце про принцип DRY. D сути своей это всё тоже про время, и тоже касается продуктивности и отдыха. Если вы замечаете за собой &lt;strong&gt;часто&lt;/strong&gt; повторяемые, почти или полностью &lt;strong&gt;идентичные&lt;/strong&gt; действия… &lt;strong&gt;Почему бы не попытаться их автоматизировать???&lt;/strong&gt; Быть может мы в таком случае выкроим время на свой любимый тик-ток? Бгг :)&lt;/p&gt;

&lt;h3 id=&quot;сколько-и-как-я-отдыхаю&quot;&gt;Сколько и как я отдыхаю?&lt;/h3&gt;

&lt;p&gt;Делаем тоже самое — трекаем и исследуем время затрачиваемое на отдых и быт. Какого характера этот отдых? В какие временные промежутки распорядка дня этот отдых “вклинивается”? Может вы ежедневно играете в мморпг по 4 часа после работы. Ну, кайф, что сказать. Я когда-то и больше играл… :)&lt;/p&gt;

&lt;p&gt;Честно, наберитесь смелости, оно вам точно по 4 часа надо? Ок, допустим вам очень нравится играть в видео-игры, это нормально. Продолжайте играть! Но если у вас есть какие-то цели, амбиции которые не дают покоя, и вы набрались смелости что-то менять, возможно стоит играть на час меньше, а выкроенное время уделить на изучение какой-то новой технологии, &lt;em&gt;инвестировать&lt;/em&gt; его на достижение этой цели?&lt;/p&gt;

&lt;p&gt;А может видео-игры это как раз то самое отвлечение от работы, которое вдруг внезапно возникает в 2 часа по полудню, заканчивается в 6 вечера, потом вы понимаете что работу по тикету надо кровь из носа доделать к обеду завтрашнего дня и в итоге ложитесь спать в полночь или ещё позже?&lt;/p&gt;

&lt;p&gt;Я думаю что идея уже должна быть предельно ясна.&lt;/p&gt;

&lt;h2 id=&quot;работать-в-кайф&quot;&gt;Работать в кайф&lt;/h2&gt;

&lt;p&gt;Вероятно корнем всех наших проблем является дисбаланс и безграмотность. Я призываю вас обратиться к более авторитетным источникам, развивать критическое мышление и отдыхать (надеюсь вам хватит ума и навыка критически мыслить чтобы не клюнуть на галимых “турбосусликов”).&lt;/p&gt;

&lt;p&gt;Поверьте, работать в кайф можно и нужно. Главное что? Правильно — систематически &lt;em&gt;качественно&lt;/em&gt; отдыхать.&lt;/p&gt;

&lt;p&gt;Другой прикол — найдите &lt;em&gt;точку сопротивления&lt;/em&gt;, это очень хороший индикатор проблемных мест.&lt;/p&gt;

&lt;p&gt;Например, точка сопротивления возникает на каком-то этапе работы — вас что-то начинает раздражать, и тд. Вероятно пора отдохнуть, выдохнуть. Попейте чаю, водички, или что вы там пьете. Вполне вероятно что причину раздражения можно устранить путем автоматизации, или попытавшись посмотреть на задачу под другим углом, и то и другое путь &lt;em&gt;экспериментирования&lt;/em&gt;, силы на которое есть только у хорошо отдохнувшего мозга.&lt;/p&gt;

&lt;p&gt;Если вдруг обнаружится, что точка сопротивления превратилась уже в депрессивную лавину, то очевидно вы уже начали догорать и пора &lt;strong&gt;хорошо&lt;/strong&gt; отдохнуть.&lt;/p&gt;

&lt;p&gt;Цените себя, любите себя. Любите свое время. Мы все &lt;em&gt;можем правильно&lt;/em&gt; инвестировать его. Просто старайтесь не забывайте, что это время неизбежно кончится, и неизвестно в какой момент.&lt;/p&gt;

&lt;p&gt;Если страшно выходить из зоны комфорта, во-первых, не забывайте что это нормально! Во-вторых, начинайте с малого, но &lt;strong&gt;систематически&lt;/strong&gt;! Никто не просит идти ва-банк, начинать вставать завтра же в 6 утра, час бегать, два часа учиться программировать, потом 8 часов работать, а после этого читать 2 книги — ничего не получится, потому что это “упирание рогом”. Послезавтра вы на всё плюнете и вернетесь в колею. Перед нами стоит задача постепенно, но упорно вырастить новые связи в мозгах!&lt;/p&gt;

&lt;p&gt;Я верю в вас, и вы в себя тоже поверьте. 
Всё проще чем кажется, но сложнее чем мы думаем :)&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html">Часики тикают.</summary></entry><entry xml:lang="ru"><title type="html">Функциональное программирование, F# и Pattern Matching</title><link href="http://localhost:4000/2022/03/27/pattern-matching.html" rel="alternate" type="text/html" title="Функциональное программирование, F# и Pattern Matching" /><published>2022-03-27T00:00:00+03:00</published><updated>2022-03-27T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/27/pattern-matching</id><content type="html" xml:base="http://localhost:4000/2022/03/27/pattern-matching.html">&lt;!--more--&gt;

&lt;h2 id=&quot;вместо-введения&quot;&gt;Вместо введения&lt;/h2&gt;

&lt;p&gt;Функциональное программирование как парадигма основывается на концепции функций первого класса, о которой вкратце я уже писал &lt;a href=&quot;/2022/03/08/hack_in_declarative_model_5.html&quot;&gt;здесь.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;А вообще, функциональное программирование это &lt;em&gt;частый случай&lt;/em&gt; декларативного подхода. В функциональном программировании тоже нет растянутых во времени состояний (переменных), значения которых хранятся и могут переопределяться когда вздумается.&lt;/p&gt;

&lt;p&gt;Таким образом, функции в ФП понимаются не как какие-то подпрограммы или методы, а скорее &lt;em&gt;математически&lt;/em&gt;. В программном смысле такие функции можно представить как конвейер, который преобразует входное значение в выходное. Впрочем все это уже нам знакомо из изучения декларативной модели.&lt;/p&gt;

&lt;p&gt;Здесь же я хочу подчеркнуть взаимосвязь понимания времени, и именованных состояний. В разных парадигмах программирования время представляется по разному. Мы рассматриваем здесь время как некое абстрактное понятие, которое выражает последовательность именованных значений (именованных состояний, переменных).&lt;/p&gt;

&lt;p&gt;Так вот, в функциональном программировании и декларативной модели время непрерывно — значения вычислений как бы перетекают в другие вычисления, до тех пор пока не будет получен итоговый результат.&lt;/p&gt;

&lt;h2 id=&quot;mr-gordon-freeman-alonzo-church&quot;&gt;Mr. &lt;del&gt;Gordon Freeman&lt;/del&gt; Alonzo Church&lt;/h2&gt;

&lt;p&gt;Может сложится впечатление, что функциональное программирование это просто некоторая реализация декларативной парадигмы. Но это не так! Функциональное программирование фактически отдельная, самостоятельная парадигма программирования, основанная на математической теории, а точнее — на формальной системе, которую разработал Алонзо Чёрч в &lt;del&gt;далекой-далекой галактике&lt;/del&gt; сороковых годах!&lt;/p&gt;

&lt;p&gt;В это систему Чёрч заложил две основные операции:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Аппликация функции — это про применение (по сути вызов) функции с каким то значением. И хотя в математике итак есть обозначение подобного например как f(a), в лямбда исчислении вся фишка в том что f трактуется не просто как функция, а как &lt;em&gt;алгоритм&lt;/em&gt; который вычисляет результирующее значение, где a — входное значение.&lt;/li&gt;
  &lt;li&gt;Абстракция — если не вдаваться в математическую мудрость, это способ определения выражений. Ну, то есть, это определение того, что там функция f на самом деле внутри вычисляет. Если хотите — определение &lt;em&gt;алгоритма&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Кстати, Чёрч был научным руководителем Алана Тьюринга :)&lt;/p&gt;

&lt;p&gt;Давайте ещё проще. Лямба-исчисление эта не меньше чем &lt;em&gt;полноценный&lt;/em&gt; язык программирования, в котором нет &lt;em&gt;ничего&lt;/em&gt; кроме простых функций — функций от &lt;em&gt;одного аргумента&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;На практике же, в функциональных языках программирования в функцию можно передавать больше одного аргумента, но делается это с помощью кортежей, то есть с точки зрения математической модели это всё ещё один аргумент, и не важно что внутри него может быть несколько значений.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/i-know-lambda-calculus.jpg&quot; alt=&quot;Neo knows Lambda-calculus&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ближе-к-делу&quot;&gt;Ближе к делу&lt;/h2&gt;

&lt;p&gt;С функциональным программированием я сейчас знакомлюсь в рамках курса по изучению языка F#, который родом из семейства языков MetaLanguage (строгие языки ФП). Это синтаксически минималистичный язык (ещё бы…), но тут есть всё что нужно, чтобы писать полноценные программы: типы, функции, выражения и вычислительные выражения.&lt;/p&gt;

&lt;p&gt;Типизация, разумеется, строгая статическая.  Функции же тут являются таким же базовым типом данных (функции первого класса), а вся программа является единым выражением (выше я уже говорил про “конвейер”). Получается что программа состоит не из операций присваивания и команд, а из &lt;em&gt;применения функций к аргументам&lt;/em&gt; — аппликаций.&lt;/p&gt;

&lt;p&gt;В F# функции как тип данных определяются типом аргумента, передаваемого этой функции, и типом результирующего значения, которые перечисляются через стрелку “-&amp;gt;”.&lt;/p&gt;

&lt;p&gt;А сами функции определяются, например, так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let multiply3 N = N * 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь &lt;em&gt;multyply3&lt;/em&gt; — идентификатор (имя) функции, а N её единственный аргумент. Получается что тип этой функции будет таким: “int -&amp;gt; int”. Имя функции можно не задавать, определив тем самым так называемую &lt;em&gt;анонимную&lt;/em&gt; функцию, или &lt;em&gt;лямбда-функцию&lt;/em&gt; с помощью ключевого слова &lt;em&gt;fun&lt;/em&gt; (a lot of!). Та же самая функция с применением анонимной-функции может быть записана так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let multiply3 = fun N -&amp;gt; N * 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Видите разницу? Идентификатору multiply3 мы присваиваем результат вычисления анонимной функции, у которой N аргумент, и после стрелки -&amp;gt; выражение, которое эта функция вычисляет.&lt;/p&gt;

&lt;h3 id=&quot;нужно-построить-зиккурат&quot;&gt;Нужно построить Зиккурат&lt;/h3&gt;

&lt;p&gt;Очевидно, что есть множество случаев, когда мы хотим передать в функцию более одного значения, но аргумент может быть одним. Если вы не рыба, то помните что это мы уже затронули.&lt;/p&gt;

&lt;p&gt;Кортежи в F# обозначаются так же как во многих других языках — с помощью круглых скобок. Скажем нам нужна очень сложная функция, которая перемножает три целых числа между собой:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let toughcalc (a, b, c) = 
    let firstmul = a * b
    firstmul * c 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Конечно можно было сразу перемножить a * b * c, но в данном примере хочется подчеркнуть то, что результирующем значением функции будет значение &lt;em&gt;последнего&lt;/em&gt; выражения в её теле. Тип этой функции будет “int * int * int -&amp;gt; int”. Да, компилятор нормально понимает когда мы передаем несколько значений через кортеж, и значения типов таких составных аргументов записываются через “*”.&lt;/p&gt;

&lt;p&gt;Если мы вкорячим последним выражением какой нибудь printfn “helloworld”, тип функции станет “int * int * int -&amp;gt; string”. Если последним выражением мы поделим результат перемножений на 0.2, тип снова изменится на “int * int * int -&amp;gt; float”, и так далее.&lt;/p&gt;

&lt;h2 id=&quot;имхо--вишенка&quot;&gt;Имхо — вишенка&lt;/h2&gt;

&lt;p&gt;Pattern matching — это очень-очень круто! Что же это за колдовство? В общем, мы можем определить в функции некоторый набор вариантов выбора (clause), и жаль что такой финт есть не во всех языках программирования. В императивных языках бывают такие штуки как switch/case, но pattern matching куда круче, и идет дальше.&lt;/p&gt;

&lt;p&gt;Функция, поддерживаются сопоставление с образцом начинается с ключевого слова &lt;em&gt;function&lt;/em&gt;. Варианты для сопоставления аргумента (или аргументов), перечисляются через символ |, после которого задается шаблон проверки, и следом за стрелкой (“-&amp;gt;”) соответствующий шаблону результат.&lt;/p&gt;

&lt;p&gt;Например:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let johnDoe = function
   | &quot;age&quot;   -&amp;gt; &quot;69&quot;
   | &quot;hobby&quot; -&amp;gt; &quot;story telling&quot;
   | &quot;diagnosis&quot; -&amp;gt; &quot;ASPD&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Во-первых, тип — string -&amp;gt; string. И как видите, аргумент явно не указан, у него нет имени, нам это и не нужно. Да, так можно :)
Во-вторых, обратите внимание что 69 явно записано в кавычках, дабы быть не int, а string. В противном случае мы получим ошибку компилятора, который будет ругаться что результирующие типы шаблонов не соответствуют друг другу.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Мы можем указывать универсальный паттерн (если другие условия не сработали), или множество вариантов с помощью or-паттерна (через “&lt;/td&gt;
      &lt;td&gt;” друг за другом), выглядит это так:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let johnDoe = function
   | &quot;age&quot; | &quot;vozrast&quot;         -&amp;gt; &quot;69&quot;
   | &quot;hobby&quot; | &quot;che delart&quot;    -&amp;gt; &quot;story telling&quot;
   | &quot;diagnosis&quot; | &quot;bolyachka&quot; -&amp;gt; &quot;ASPD&quot;
   | _                         -&amp;gt; &quot;no data&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;В качестве шаблона мы можем задать некоторый внутренний для функции идентификатор, который автоматически будет связан с проверяемым значением:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let minus1 = function
   | 0 -&amp;gt; 0 
   | n -&amp;gt; n - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В F# pattern matching поддерживается так-же и как отдельная операция match, которая допускает указывать дополнительные логические условия в вариантах сопоставления после ключевого слова when:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let tendToZero n = match n with
   | 0 -&amp;gt; 0
   | n when n &amp;gt; 0 -&amp;gt; n - 1
   | n when n &amp;lt; 0 -&amp;gt; n + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;эпилог&quot;&gt;Эпилог&lt;/h3&gt;

&lt;p&gt;Пока, из того что я выучил в ФП и F#, pattern matching мне показался наиболее интересной киллер фичей. Разумеется тут можно определять рекурсивные функции (надо перед идентификатором функции добавить rec), если логические условия if\then\else\elif и так далее, но всё это привычно и, наверное, писать об этом не очень интересно.&lt;/p&gt;

&lt;p&gt;Сопоставление с образцом есть не во всех языках, но его пытаются завезти. Например в прошлом году его &lt;a href=&quot;https://habr.com/ru/company/yandex_praktikum/blog/547902/&quot;&gt;донесли в пайтон&lt;/a&gt;, но нужен ли он там и использовать ли — решайте сами.&lt;/p&gt;

&lt;p&gt;Миру мир!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"></summary></entry><entry xml:lang="ru"><title type="html">Несколько слов о проектировании</title><link href="http://localhost:4000/2022/03/20/program-design.html" rel="alternate" type="text/html" title="Несколько слов о проектировании" /><published>2022-03-20T00:00:00+03:00</published><updated>2022-03-20T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/20/program-design</id><content type="html" xml:base="http://localhost:4000/2022/03/20/program-design.html">&lt;p&gt;Как подступиться к правильному созданию программы.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;program-design&quot;&gt;Program Design&lt;/h3&gt;
&lt;p&gt;Проектирование программы, наверное, самый важный критерий успешности и качественности будущего программного продукта. 
На этапе проектирования нам нужно четко определить саму задачу, и то как мы будем её решать.&lt;/p&gt;

&lt;p&gt;Под “решанием” имеются в виду техники программирования (прадигмы), которые будут применяться, и то как они будут связанны между собой.&lt;/p&gt;

&lt;p&gt;Результатом проектирования является высокоуровневая структура, условный &lt;em&gt;“прототип”&lt;/em&gt; будущей системы.&lt;/p&gt;

&lt;p&gt;Очевидно, что в зависимости от задачи размер и сложность программы может существенно отличаться. Это может быть маленькая программа, написанная одним человеком или здоровенный комплекс, над которым трудится целая команда. В классическом случае первое называют programming in small, а второе — in large.&lt;/p&gt;

&lt;p&gt;Более интересным с инженерной точки зрения мне кажется другое определение &lt;em&gt;programming in small&lt;/em&gt; и &lt;em&gt;programming in large&lt;/em&gt;, когда подразумевается не количество людей трудящихся над программой, но “фокус” разработки.&lt;/p&gt;

&lt;p&gt;В этом случае, говоря о programming in small подразумевается само кодирование программы, а именно написание стилистически ясного, правильно (чистого) кода, выраженного через &lt;a href=&quot;/2022/01/22/algorithms_complexity.html&quot;&gt;продуктивные алгоритмы&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Programming in large, в таком случае, является “фокусом” проектирования, когда программа уже является действительно большой (от нескольких тысяч строк кода, и более). В создании таких сложных программ критически важно подходить к проектированию осознанно и правильно, иначе всё кончится плохо: бизнес потеряет деньги, разработчики — оставшиеся нервные клетки.&lt;/p&gt;

&lt;h2 id=&quot;базовый-подход&quot;&gt;Базовый подход&lt;/h2&gt;

&lt;p&gt;Предлагаю вам, в качестве примера, рассмотреть следующую методику проектирования in small, когда программа разрабатывается единолично, и ожидаемый объем кода составит менее десятков тысяч строк.&lt;/p&gt;

&lt;h4 id=&quot;1-спецификация&quot;&gt;1. Спецификация&lt;/h4&gt;
&lt;p&gt;Сперва необходимо обозначить &lt;strong&gt;неформальную спецификацию&lt;/strong&gt;. Это то, что часто называют техническим заданием. На практике же нам нужно как можно более точно записать что программа должна делать, а именно:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Что программа получает на вход?&lt;/li&gt;
  &lt;li&gt;Что должна выдавать на выходе?&lt;/li&gt;
  &lt;li&gt;Как входные и выходные данные соотносятся друг с другом?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Такая спецификация называется неформальной, потому что мы пишем её на человеческом языке (русском, английском, или на каком вы там ещё умеете).&lt;/p&gt;

&lt;h4 id=&quot;2-примеры&quot;&gt;2. Примеры&lt;/h4&gt;
&lt;p&gt;Примеры служат для прояснения спецификации, полученной на первом этапе. Будет очень полезно представить что программа делает в определенных, конкретных ситуациях. Лучшего всего это делать в &lt;em&gt;формате тестов&lt;/em&gt;. Да, сначала пишем тесты для кода, а потом код! Это называется TDD — Test Driven Development, и само по себе огромная тема для отдельного поста.&lt;/p&gt;

&lt;p&gt;Наши примеры должны показывать, во-первых, как программа ведет себя граничных условиях. Нужно проверить её самыми неожиданными способами. Никогда не нужно думать что “чего-то может не быть”, “моя программа никогда не получит на вход отрицательное значение”, и так далее.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume and check everything!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Во-вторых, примеры должны собственно отображать базовые сценарии работы программы. Может показаться, что это важнее чем тесты. Нет, не важнее.&lt;/p&gt;

&lt;h4 id=&quot;3-исследование&quot;&gt;3. Исследование&lt;/h4&gt;

&lt;p&gt;На этом этапе нам необходимо написать “кирпичики” из которых мы предполагаем строить программу. Этими “кирпичиками” должны быть небольшие и по максимуму автономные операции (низкая связанность). В результате мы получим намного более четкое представление о структуре будущей программы, и сможем определить конкретные методы программирования, уместные для решения поставленных задач.&lt;/p&gt;

&lt;h4 id=&quot;4-структура-и-реализация&quot;&gt;4. Структура и реализация&lt;/h4&gt;

&lt;p&gt;Наконец, мы начинаем формировать саму программу — приблизительно набрасываем операции для расчета входных данных, и способы (методы), которыми эти операции между собой взаимодействуют. После этого пробелы в получившемся наброске заполняются реальным кодом. Важно то, что операции &lt;em&gt;должны быть простыми&lt;/em&gt; — каждая из них должна делать &lt;strong&gt;одну&lt;/strong&gt;, и только одну вещь.&lt;/p&gt;

&lt;p&gt;Это один из самых важных принципов &lt;em&gt;ясного&lt;/em&gt; программирования, следуя которому мы избегаем потенциально много ошибок, которые могут порождаться, например, сайд-эффектами запутанных функций, которые делают “много чего” внутри. А те ошибки, которые всё таки будут появляться (А они будут!), мы сможем намного быстрее идентифицировать и исправить.&lt;/p&gt;

&lt;p&gt;Для улучшения структуры программы, связанные операции группируются в &lt;em&gt;модули&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;5-тестирования-и-обдумывание&quot;&gt;5. Тестирования и обдумывание&lt;/h4&gt;

&lt;p&gt;Пришла пора убедиться что &lt;del&gt;оно живое!&lt;/del&gt; программа вообще работает. Для этого нужно провести ряд тестов, включая те, что уже были разработаны на этапе 2. Снова и снова гоняем тесты и исправляем ошибки, до тех пор пока программа не заработает так как надо. А надо, чтобы она работала хорошо :)&lt;/p&gt;

&lt;p&gt;На этом этапе важно не забывать рассуждать о структуре программы и её сложности. Находя и исправляя ошибки потенциально возможно улучшить структуру программы и переписать плохие алгоритмы (рефакторинг кода).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Все эти этапы взаимодополняющи друг другу. Например, на этапе исследования, или даже написании примеров, мы можем понять что изначальная спецификация не совсем корректна, и изменить/дополнить её. Тестирование и обдумывание, имхо, вообще стоит ультимативно применять как жизненный принцип :)&lt;/p&gt;

&lt;p&gt;А если по делу, то тестирование, в принципе, самый важный шаг в programming in small. Существует достаточно много методик тестирования, которые стоит изучить и применять в разработке. Например, уже упомянутое TDD и &lt;em&gt;модульное тестирование&lt;/em&gt;. Это тема для отдельных постов, поэтому вкратце:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Модульное тестирование — основная идея unit-тестирования в том, чтобы писать тесты, которые проверяют &lt;strong&gt;наименьшую&lt;/strong&gt; составляющую кода (один тест проверяют одну функцию, модуль или класс)&lt;/li&gt;
  &lt;li&gt;TDD — Перед тем как писать код, мы пишем тесты для этого кода (например те же самые unit-тесты)! В принципе такие тесты выступают в роли спецификации того, что код &lt;em&gt;должен делать&lt;/em&gt;. Мощный подход, которые позволяет понимать что мы вообще делаем, программируя части системы.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;организация-программы&quot;&gt;Организация программы&lt;/h2&gt;

&lt;p&gt;В проектировании важно понимать как всё таки правильно организовать программу. Конечно, можно накодить всё как сплошной монолит, в котором по мере роста проекта всё в итоге запутается, и все участники разработки/сопровождения будут ультимативно страдать. Наверняка вы видели такие проекты, не буду показывать пальцами.&lt;/p&gt;

&lt;p&gt;Наиболее адекватный способ борьбы с растущей сложностью системы — декомпозиция программы на так называемые &lt;em&gt;логические единицы&lt;/em&gt;. Каждая такая единица должна реализовать свой набор операций, которые связанны в одно целое, например через &lt;a href=&quot;/2022/03/13/hack_in_declarative_model_6.html&quot;&gt;абстрактные типы данных.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Логическая единица делится на две части: &lt;em&gt;интерфейс&lt;/em&gt; и &lt;em&gt;реализацию&lt;/em&gt;. Снаружи логического блока доступен только интерфейс, а реализация “внутри” при этом может меняться безнаказанно.&lt;/p&gt;

&lt;p&gt;Логические единицы часто называют &lt;em&gt;модулями&lt;/em&gt; или &lt;em&gt;компонентами&lt;/em&gt; программы.&lt;/p&gt;

&lt;h3 id=&quot;слово-дня---функтор&quot;&gt;Слово дня - Функтор&lt;/h3&gt;

&lt;p&gt;А теперь немного программистской “научности”, продолжая тему организации.&lt;/p&gt;

&lt;p&gt;Спецификацию модуля рассматривают как &lt;em&gt;отдельную сущность&lt;/em&gt; — это такой “шаблон”, который создает новый модуль, примерно так же как класс создает экземпляр объекта в объектно ориентированном программировании. Есть конкретный программистский термин, для обозначения таких спецификаций.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Функтор&lt;/strong&gt; — это функция, которая получает на вход набор модулей, требующихся для создания &lt;em&gt;нового модуля&lt;/em&gt;, и возвращает этот новый созданный модуль. Правильно говоря, функтор получает на вход &lt;em&gt;интерфейсы&lt;/em&gt; модулей, и возвращает тоже &lt;em&gt;интерфейс&lt;/em&gt; нового модуля.&lt;/p&gt;

&lt;p&gt;Функтор состоит из:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;импорта, которым задается перечень требуемых функтору модулей;&lt;/li&gt;
  &lt;li&gt;экспорта, определяющего интерфейс “изготавливаемого” модуля;&lt;/li&gt;
  &lt;li&gt;реализации, включающая код инициализации самого функтора.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В программной инженерии &lt;em&gt;программным компонентом&lt;/em&gt; называется некоторый элемент для &lt;em&gt;независимого развертывания&lt;/em&gt;. Такой компонент для своей установки ничего не требует, кроме перечня стандартных библиотек. Программный компонент не имеет фиксированного внутреннего состояния, иными словами — соответствует (декларативной модели)[/archive.html?tag=Декларативная_модель]&lt;/p&gt;

&lt;p&gt;Автономное (standalone) приложение, которое не подразумевает активного взаимодействия с пользователем, например, не имеет графического интерфейса для такого взаимодействия, состоит из главного функтора, который вычисляется на старте приложения, “подтягивает” нужные себе модули, что фактически приводит к вызову других функторов.&lt;/p&gt;

&lt;p&gt;Вычисление или установка главного функтора происходит в три шага:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Идентификация необходимых для работы модулей;&lt;/li&gt;
  &lt;li&gt;Выполнение кода инициализации;&lt;/li&gt;
  &lt;li&gt;Загрузка модулей, которые будут нужны непосредственно во время работы программы.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Другие “подфункторы” могут вычисляться в разное время работы программы, как правило в те моменты, когда запрашиваются ресурсы из ещё не вычисленного функтора. Такое поведение называется &lt;strong&gt;динамическим связывание&lt;/strong&gt;, которое является полной противоположность &lt;strong&gt;статическому связыванию&lt;/strong&gt; — при котором все модули загружаются сразу на старте программы.&lt;/p&gt;

&lt;p&gt;Множество установленных (вычисленных) модулей называется &lt;strong&gt;рабочим модульным окружением&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Любите.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Проектирование" /><summary type="html">Как подступиться к правильному созданию программы.</summary></entry><entry xml:lang="ru"><title type="html">Программирование, управляемое данными. АТД.</title><link href="http://localhost:4000/2022/03/13/hack_in_declarative_model_6.html" rel="alternate" type="text/html" title="Программирование, управляемое данными. АТД." /><published>2022-03-13T00:00:00+03:00</published><updated>2022-03-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/13/hack_in_declarative_model_6</id><content type="html" xml:base="http://localhost:4000/2022/03/13/hack_in_declarative_model_6.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 6. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-driven&quot;&gt;Data-driven&lt;/h2&gt;

&lt;p&gt;Часто на практике нужно выполнить какую то операцию над достаточно большой структурой данных, например провести итеративные вычисления, или обойти одну структуру и вычислить другую, на основе “собранных” в обходе данных.&lt;/p&gt;

&lt;p&gt;Как правило, чаще всего такие вычисления проводятся над списками, массивами и деревьями. К спискам применяются операции свертки (FoldL\R), которые мы рассмотрели в прошлом посте. Но существуют и другие популярные техники.&lt;/p&gt;

&lt;h3 id=&quot;операция-map&quot;&gt;Операция Map&lt;/h3&gt;

&lt;p&gt;Реализация Map есть почти во всех стандартных библиотеках популярных языков программирования. Эта операция работает со списком, и вычисляет на его основании список такой же длинны, применяя переданную в Map функцию к каждому элементу исходного списка.&lt;/p&gt;

&lt;p&gt;С помощью &lt;del&gt;заклинаний&lt;/del&gt; программирования высшего порядка, реализовать Map можно как-то так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def function Map(some_list, some_func)

    def function iterate_map(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list
  

        list_head = list_remaining[0]
        list_tail = list_remaining[1:] 
        return iterate_map(new_list.insert(0, some_func(list_head)), list_tail, some_func)
  

    return iterate_map([], some_list, some_func)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Можем передать в Map простую функцию, типа возведения в квадрат, и передать её вторым аргументов. Напоминаю что здесь, раньше и далее сниппеты описаны в “псевдопайтанокоде”. Заварите чай, прочитайте прошлые пару статей, если сходу ничего не понятно, и реализуйте рабочий вариант на своем любимом ЯП :)&lt;/p&gt;

&lt;h3 id=&quot;операция-filter&quot;&gt;Операция Filter&lt;/h3&gt;

&lt;p&gt;Filter это ещё одна классическая операция для обработки списков. Она так же принимает вторым аргументом некоторую функцию-предикат, и на выходе отдает список с элементами исходного списка, удовлетворяющими переданный предикат:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def function Filter(some_list, some_func)

    def function iterate_filter(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list

        list_head = list_remaining[0]
        list_tail = list_remaining[1:]

        if some_func(list_head):
            return iterate_filter(new_list.insert(0, list_head), list_tail, some_func)
        else:
            return iterate_filter(new_list, list_tail, some_func)
     
   

    return iterate_filter([], some_list, some_func)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Снова взываю к вашей фантазии, напрягите волшебный интеллект! Предикат можно придумать, практически любой. Например, если список состоит из целых чисел, можем написать простую функцию которая возвращает true если результата делится на 2 без остатка (четный). Или вообще воткнуть предикат в вызов iterate_filter лямбдой. Если вы прожженый питонист, то я уверен что вы хотя бы раз втыкали лямбды в map или filter!!! :trollface:&lt;/p&gt;

&lt;h2 id=&quot;абстрактные-типы-данных&quot;&gt;Абстрактные типы данных&lt;/h2&gt;

&lt;p&gt;Абстрактный тип данных — это описание некоторой структуры данных посредством определения операций над этой структурой. И только! Только операций!
Внутренняя реализация, все атрибуты &lt;em&gt;полностью скрыты&lt;/em&gt; в АТД, или лучше сказать — &lt;strong&gt;эта реализация вообще отсутствует&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;В декларативной парадигме АТД, в первую очередь тип данных — множество значений, с которым связано множество &lt;em&gt;допустимых&lt;/em&gt; над ними операций. Базовы набор декларативных типов перечислялся в одном &lt;a href=&quot;/2022/02/06/hack_in_declarative_model.html&quot;&gt;первом посте&lt;/a&gt; из этого цикла.&lt;/p&gt;

&lt;p&gt;Мало типов, скажете вы! Да, хотелось бы определять свои. АТД в нашем распоряжении.&lt;/p&gt;

&lt;p&gt;И ещё раз, что такое &lt;em&gt;абстрактный&lt;/em&gt; тип данных? Это такой тип, который конкретно определен &lt;em&gt;множеством операций&lt;/em&gt; над собой, и при этом &lt;strong&gt;полностью&lt;/strong&gt; независим от своей реализации. Мы можем всегда быстро и легко поменять эту реализацию не трогая сам абстрактный тип.&lt;/p&gt;

&lt;h3 id=&quot;защищаем-атд&quot;&gt;Защищаем АТД&lt;/h3&gt;

&lt;p&gt;Есть такое чувство, что легкая сменяемость чего либо в программировании может привести к проблемам. Чаще всего так и происходит. В разрезе АТД не всегда будет разумным делать реализацию типа для всех. Во-первых, программа с такой открытой реализаций, то есть &lt;em&gt;открытая программа&lt;/em&gt; потенциально становится легкой мишенью для злоумышленников.&lt;/p&gt;

&lt;p&gt;Под “открытой программой” тут мы понимаем не open source софт, речь вообще не об этом. Представьте программу которая запущена в прод, в ней крутится много данных, в том числе персональных данных клиентов, и в этой программе сама реализация абстрактных типов открыта, и например непосредственно доступна для взаимодействия другим программам через API. В таком случае любая другая программа может быть вредительской и “наворошить дел” в нашем рантайме.&lt;/p&gt;

&lt;p&gt;Нам нужно защитить &lt;em&gt;конкретные&lt;/em&gt; реализации абстрактных типов данных от &lt;em&gt;неавторизованного&lt;/em&gt; вмешательства. Для этого можно ограничить внутреннюю реализацию, часть кода, которая производит вычисления.&lt;/p&gt;

&lt;p&gt;Такое ограничение можно внедрить двумя способами:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Четко определяем набор операций и их граничные значения так, чтобы вычисляемое значение вообще не могло выходить за эти границы. Сам набор операций становится ограничением, вычисляя только &lt;em&gt;стационарные значения&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Другой вариант — &lt;em&gt;мобильные значение&lt;/em&gt;. Вычисленное значение может покидать границы, а затем вернуться обратно. Пока оно “снаружи”, с ним может как-то работать внешний код (другая программа, например, или другой модуль нашей системы). Здесь описывается четкий набор операций, которые по разрешению могут выводить значение, обрабатывать его, и возвращать результат назад.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Такое разрешение называется &lt;em&gt;авторизацией&lt;/em&gt;. Для получения авторизации операция должна предоставить некоторый “ключ” (токен, называйте как хотите). В декларативной модели этот ключ-авторизацию называется просто “имя”.&lt;/p&gt;

&lt;p&gt;Для реализации второго метода классическая декларативная модель должна быть расширена. Нам надо придумать как защищать значения, и как защищать &lt;em&gt;несвязанные&lt;/em&gt; (со значением) декларативные переменные.&lt;/p&gt;

&lt;p&gt;Например, мы можем определить операции-обертки, с ключем доступа. Доступ к внутреннему функционалу абстрактного типа становится доступным только тем операциям, которые передают в обертку &lt;em&gt;правильный&lt;/em&gt; ключ.&lt;/p&gt;

&lt;p&gt;Для начала нам надо определить тип для ключей, например Name, который будет хранить атомарное значение. У этого типа нет никаких операций вывода своего значения на экран, или преобразования в число, строку и тд. Всё что должно быть возможно сделать с Name, это только создавать его новые экземпляры, и сравнивать со значениями других экземпляров Name.&lt;/p&gt;

&lt;p&gt;При этом, операция создания нового ключа должна гарантировать, что результирующее значение будет &lt;em&gt;уникальным&lt;/em&gt;. Мы тут немного отходим от талмудов декларативности, ведь операция создания нового ключа &lt;em&gt;не декларативна&lt;/em&gt; — вызывая её каждый раз, мы получаем новый результат. Но тут мы применяем этот подход только для внедрения безопасности абстрактных типов, так что это ок, ведь сами АТД остаются декларативными.&lt;/p&gt;

&lt;p&gt;Далее, например у нас есть абстрактный тип данных — стек, который внутри фактически реализован как обычный список, но у нас нет прямого доступа к его (стека) содержимому в виде обычного списка.&lt;/p&gt;

&lt;p&gt;Мы можем создать экземпляр стека, создать экземпляр ключа, для этого стека, назвав его как нибудь типа stack_key, и наконец — &lt;em&gt;реализовать функцию обертку&lt;/em&gt; (доступную “снаружи”), которая на вход получает собственно стек, и ключ. Если ключ правильный — работаем. Если нет — чао-какао.&lt;/p&gt;

&lt;p&gt;Ну вы поняли — ни Name, ни метод генерации экземпляров Name, ни сравнения с другими Name извне (другим программам) никак не доступен. Мы разделяем таким образом “внутренние” операции и “внешние”.&lt;/p&gt;

&lt;p&gt;Очевидно, что такая схема обезопасивания АТД может применяться в коде часто, поэтому отчего бы её тоже не обернуть в другой слой абстракции?
А как? А с помощью АТД! :trollface:&lt;/p&gt;

&lt;p&gt;Мы можем описать две функции “упаковки” и “распаковки” — wrap(), unwrap(), и ключи генерировать скрыто в “конструкторе” АТД.&lt;/p&gt;

&lt;p&gt;Операция Wrap получает на вход некоторое значение, возвращает &lt;em&gt;функцию&lt;/em&gt;, которая требует ключа на вызове, чтобы распаковать скрытое в себе значение.&lt;/p&gt;

&lt;p&gt;Unwrap же получает эту функцию, передает ей требуемый ключ, и если ключ правильный то возвращает значение в незащищенном виде.&lt;/p&gt;

&lt;p&gt;Например у нас есть:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;some_list = [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;y&quot;, &quot;e&quot;, &quot;a&quot;, &quot;h&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы делаем скдыщь:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;secure_list = Wrap(some_list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь обращаясь как-то к secure_list мы не получаем ничего, None, фигушки, пока не сделаем:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;show_me_what_inside = Unwrap(secure_list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Важно понимать, что ключи к нас генерируются внутри конструкторов, а сами операции упаковки и запаковки &lt;em&gt;вызываются внутри других операций абстрактных типов данных&lt;/em&gt;, и за границами АТД они никак не доступны!&lt;/p&gt;

&lt;p&gt;Например, обычный, незащищенный абстрактный тип “Stack” может быть определен таким набором операций:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;create_stack() – создает новый экземпляр стека (по сути список);&lt;/li&gt;
  &lt;li&gt;push_in(some_stack, some_element) – впихивает элемент some_element в стек some_stack;&lt;/li&gt;
  &lt;li&gt;pop_out(some_stack) – выпихивает элемент из стека;&lt;/li&gt;
  &lt;li&gt;sneak_peek(some_stack) – получить верхний элемент стека, не выталкивая элемент;&lt;/li&gt;
  &lt;li&gt;is_empty(some_stack) – true\false проверка на пустоту стека &lt;del&gt;от самобытия&lt;/del&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Такая реализация небезопасна, новый стек будет открыт, ведь это по сути список, читайте и делайте с ним что хотите. Мы можем защитить его рассмотренной упаковкой\распаковкой создав тип SecStack, который будет работать так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;create_stack() – возвращает Wrap([]) – защищенный пустой список, а не просто список;&lt;/li&gt;
  &lt;li&gt;push_in(some_stack, some_element) – делает Unwrap(some_stack) вставляет элемент some_element в стек some_stack, делает Wrap() для нового списка;&lt;/li&gt;
  &lt;li&gt;pop_out(some_stack) – делает Unwrap(some_stack) удаляет элемент из стека, делает Wrap() для нового списка;&lt;/li&gt;
  &lt;li&gt;sneak_peek(some_stack) – Unwrap(some_list) и отдает верхний элемент извлеченного списка, не выталкивая элемент (исходный список все ещё “заврапен”, не переживайте о нем, это же декларативная модель!);&lt;/li&gt;
  &lt;li&gt;is_empty(some_stack) – Unwrap(some_list), проверяет пуст или не пуст список.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Теперь надеюсь понятнее важный момент о том, что методы wrap\unwrap скрыты внутри реализации стека. Абсолютно нет никакой возможности получить содержимое извне неавторизованным операциям-методам.&lt;/p&gt;

&lt;h3 id=&quot;защищаем-несвязанные-переменные&quot;&gt;Защищаем несвязанные переменные&lt;/h3&gt;

&lt;p&gt;Несвязанные со значениями декларативные переменные можно обезопасить, дополнив декларативную модель операцией read_only. Стоп, а зачем нам вообще защищать эти переменные? Ну как, представьте что какое-то злоумышленное существо или программа, написанная таким существом, получила некоторым образом &lt;em&gt;ссылку&lt;/em&gt; на несвязанную декларативную переменную. Туда можно записать &lt;strong&gt;что угодно&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Так вот, делаем read_only переменные. Мы можем определить такую условную операцию, которая получает имя переменной на вход, а возвращает “образ” значений этой переменной, разрешая только читать его.&lt;/p&gt;

&lt;p&gt;Реализуется это с помощью дополнительного хранилища. Операция связывания переменных со значением изменяется таким образом, что прежде чем что-то куда-то привязать проверяет, не находится ли ссылка на переменную в read-only хранилище. Если такая ссылка в хранилище есть — связывание не происходит.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Ну, собственно, на этом мы заканчиваем наше скромное знакомство с Декларативной вычислительной моделью. Я завершил текущий курс. Дальше у нас ещё много, ох как много интересного! Функциональное, императивное, проектирование high-load… Продолжаем взрывать мозг, ура!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 6.</summary></entry><entry xml:lang="ru"><title type="html">Программирование высшего порядка. Процедурные абстракции.</title><link href="http://localhost:4000/2022/03/08/hack_in_declarative_model_5.html" rel="alternate" type="text/html" title="Программирование высшего порядка. Процедурные абстракции." /><published>2022-03-08T00:00:00+03:00</published><updated>2022-03-08T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/08/hack_in_declarative_model_5</id><content type="html" xml:base="http://localhost:4000/2022/03/08/hack_in_declarative_model_5.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 5. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;колдуем-по-взрослому&quot;&gt;Колдуем по взрослому&lt;/h2&gt;

&lt;p&gt;Программирование высшего порядка. Что может прийти на ум сперва…&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/high_order.jpg&quot; alt=&quot;АрхиКодер!&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Архи-кодер владеющий программированием высшего порядка&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;А теперь серьезно. Программирование высшего порядка — это такие методы программирования с использованием процедур (функций) высшего порядка (или “первого” класса). Ага! А что это за порядок такой, если речь не про сакрально-волшебные сверхсилы просветленного программиста?&lt;/p&gt;

&lt;p&gt;Сперва нужно рассмотреть такую штуку, как &lt;em&gt;лексическое замыкание&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Собственно, замыкание — это такая функция, в которой есть ссылки на объекты (например переменные), объявленные вне тела этой функции. В коде это выглядит как объявление функции в другой функции. Вот эта последняя, “внутренняя” функция, фактически имеет доступ ко внешним, по отношению к ней объектам — переменным объявленным в теле “функции-обертки”, её аргументам.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Бугурт алерт!&lt;/strong&gt; Здесь и далее примеры на пайтонопсевдокоде! Помните, что мы сейчас изучаем Декларативную модель, &lt;em&gt;т е о р и ю&lt;/em&gt;, а не прикладную практику. Это всё техники, реализация которых на одном языке будет выглядеть так, на другом иначе.&lt;/p&gt;

&lt;p&gt;Пример:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# &quot;замыкающая&quot;, внешняя функция
def mad_printer(some_new_law):

    # вложенная функция
    def actual_printer():
        print(some_new_law)

    return actual_printer

emergency_law = mad_printer(&quot;freedom is slavery&quot;)
emergency_law()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;На выходе будет получена строка, переданная в замыкающую функцию - “freedom is slavery”.&lt;/p&gt;

&lt;p&gt;Хотя функция actual_printer и не имеет в своем теле переменной some_new_law, мы видим что такой код работает без проблем. Можно сказать, что в примере выше мы привязываем определенное замыкание к переменной emergency_law. И это замыкание включает в себя &lt;em&gt;возвращаемую функцию actual_printer и доступное ей окружение&lt;/em&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Замыкание — это некоторая форма &lt;em&gt;записи&lt;/em&gt; которая хранит в себе &lt;em&gt;функцию первого порядка&lt;/em&gt; вместе с её окружением.&lt;/p&gt;

&lt;p&gt;Ладно, ладно. А что такое функция первого порядка, не только в декларативной модели, а в программировании вообще?&lt;/p&gt;

&lt;p&gt;Можно сказать, что система (язык программирования) имеет функции первого &lt;em&gt;класса&lt;/em&gt;, если функции рассматриваются как &lt;em&gt;объекты первого класса&lt;/em&gt;. Объект первого класса — это “элементы”, а по сути типы, которые могут передаваться как параметры, возвращаться их функций или присваиваться как значение переменным.&lt;/p&gt;

&lt;p&gt;Иными словами, функция первого класса означает, что есть такой тип как функция, и любая реально объявляемая функция автоматически становится значением соответствующего типа.&lt;/p&gt;

&lt;p&gt;Сам термин &lt;em&gt;высшего порядка&lt;/em&gt; исходит от концепции &lt;em&gt;порядка процедуры&lt;/em&gt;. Если у какой то процедуры в аргументах нет других процедур — это функция нулевого порядка. Процедура, у которой есть хотя бы один аргумент-процедура — процедура первого порядка. Порядок процедуры можно определить как n + 1, если у этой процедуры есть хотя бы один аргумент n порядка, и нет других аргументов &lt;em&gt;более высокого порядка&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Получатся что функция может быть функцией первого класса, так как в системе есть вышеупомянутые критерии, но может не быть функцией первого порядка, если не имеет в аргументах других функций. В таком случае это, можно сказать, функция первого класса нулевого порядка :)&lt;/p&gt;

&lt;p&gt;Короче говоря, программирование высшего порядка, по сути, это о том что процедуры могут быть любого порядка. Никакой магии, но надеюсь вы уже начали понимать, что потенциал у этой техники очень большой.&lt;/p&gt;

&lt;h2 id=&quot;основные-заклинания&quot;&gt;Основные заклинания&lt;/h2&gt;

&lt;p&gt;В основе всех программистских техник высшего порядка лежат следующие четыре операции:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Процедурная абстракция;&lt;/li&gt;
  &lt;li&gt;Обобщение;&lt;/li&gt;
  &lt;li&gt;Инстанцирование;&lt;/li&gt;
  &lt;li&gt;Встраивание.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;процедурная-абстракция&quot;&gt;Процедурная абстракция&lt;/h3&gt;

&lt;p&gt;На самом деле мы уже давно говорили о процедурных абстракциях. Настала пора четко декларировать термин.&lt;/p&gt;

&lt;p&gt;Процедурная абстракция — это, по существу, определение процедуры. Мы оборачиваем программные инструкции в процедуру, внутрь заголовка процедуры, и в результате получаем блок кода (процедурное значение — замыкание), который не выполняется до тех пор, пока не будет вызван.&lt;/p&gt;

&lt;p&gt;Вызов процедуры приводит к тому же результату, к которому приведет выполнение инструкций из её тела.&lt;/p&gt;

&lt;p&gt;У процедурных абстракций существуют параметры, которые влияют на выполнение тела процедуры.&lt;/p&gt;

&lt;p&gt;Фактически это основа основ парадигмы программирования высшего порядка, поддерживается во многих языках, а так же лежит в основе ООП.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Процедурные абстракции позволяют представить любую программную логику как значение процедуры.&lt;/p&gt;

&lt;h3 id=&quot;обобщение&quot;&gt;Обобщение&lt;/h3&gt;

&lt;p&gt;Обобщить функцию — обозначает, что любая операция или значение может становиться &lt;em&gt;аргументом в теле функции&lt;/em&gt;. Мы абстрагируем эту сущность от тела функции, а её (сущности) значение задается когда функция явно вызывается. Каждый раз, при вызове обобщенной функции, может задаваться другая сущность.&lt;/p&gt;

&lt;p&gt;Вернемся назад к итеративным вычислениям, и разберем обобщение на примере функции, суммирующей значения элементов списка. Например, мы можем написать такую декларативную функцию:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def function summary_list_values(some_list)
    if some_list == []:
        return 0
    end

    list_head = some_list[0]
    list_tail = some_list[1:]
    return list_head + summary_list_values(list_tail)
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тут есть два нейтральных элемента: 0, который мы возвращаем если some_list опустел, и операция сложения. Эти нейтральные элементы можно обобщить, сделав более универсальную функцию. Например, из примера выше можно сделать функцию FoldR. Такая функция есть во многих функциональных языках, это &lt;em&gt;функция-свертка&lt;/em&gt;, схема рекурсивных вызовов которой раскручивается в цепочку, пока не будет достигнуто самое право, по сути последнее в списке, значение, после чего начнутся сами вычисления. Есть ещё FoldL, в которой вычисления начинаются СРАЗУ, то есть с “левой ассоциацией”, считаем сразу и не ждем “правого конца”.&lt;/p&gt;

&lt;p&gt;Обобщим функцию, которую написали ранее следующим образом:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def FoldR(some_list, some_function, some_element)
    if some_list == []:
        return some_element
    end

    list_head = some_list[0]
    list_tail = some_list[1:]
    return some_function(list_head, FoldR(list_tail, some_function, some_element))
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обобщенная функция может получать на вход не только список, а функцию, которой будут обрабатываться вычисления среди элементов, и нейтральный элемент some_element. Эту функцию можно использовать для любых похожих ассоциативных вычислений, когда порядок аргументов some_function не важен для результата.&lt;/p&gt;

&lt;h3 id=&quot;инстанцирование&quot;&gt;Инстанцирование&lt;/h3&gt;

&lt;p&gt;О, это очень классная штука! Инстанцирование обозначает возможность возвращать процедуру\функцию как результата вызова другой процедуры\функции. 
Инстанцирование реализуется с помощью &lt;em&gt;фабрик&lt;/em&gt; или &lt;em&gt;генераторов функций&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Очень простой и грубый пример:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# генератор
def factory_function(calc_function):
    def inner_function(x,y):
        return calc_function(x,y)
    return inner_function

# какая то функция с вычислениями, которую скормим генератору
def addition(a,b):
    return a+b

# генерируем функцию
f = factory_function(addition)

# вернет 2
print(f(1, 1))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Очевидно что вычисления и логика внутри генератора может быть намного сложнее. Что нам это вообще дает? В первую очередь, это дает гибкость реализации каких то частей программы, которые если нужно мы можем менять на лету без особых проблем.&lt;/p&gt;

&lt;p&gt;Например, у нас может быть универсальная функция-фабрика для сортировки списков. Мы можем передавать в неё конкретный алгоритм сортировки, получая на выходе функцию, реализующую этот алгоритм.&lt;/p&gt;

&lt;h3 id=&quot;встраивание&quot;&gt;Встраивание&lt;/h3&gt;

&lt;p&gt;Примером реализации техники встраивания являются &lt;em&gt;ленивые&lt;/em&gt; вычисления. Это такие вычисления, когда вместо того, чтобы вычислять сразу всё (жадно), генерируется лишь необходимый “кусок” данных. Иными словами, техника встраивания заключается в постепенном выстраивании структуры данных, по мере запросов к элементам этой структуры. Реализуется это, собственно “встраиванием” в структуру данных некоторого кода, который генерирует соответствующие структуре и запросу данные.&lt;/p&gt;

&lt;h2 id=&quot;абстракция-цикла&quot;&gt;Абстракция цикла&lt;/h2&gt;

&lt;p&gt;Ранее мы разбирали рекурсии и итеративные вычисления. Грубо говоря, итеративные вычисления это и есть циклы. Но в декларативной модели описание таких вычислений выходит громоздким, так как требуются явные рекурсивные вызовы. Мы уже разобрали процедурную абстракцию и обобщение. Так почему бы не сделать циклы более лаконичными, выразительными?&lt;/p&gt;

&lt;p&gt;Например, классический цикл for — это целочисленный цикл, который получает на вход четыре параметра: начальное значение, конечное значение, шак, и процедуру для вычислений в каждой итерации:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def my_for(start_value, end_value, step, procedure):

    if start_value &amp;gt; end_value:
        return

    procedure(start_value)

    my_for(start_value + step, end_value, step, procedure)   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Цикл, для вычислений по элементам списка, можно выразить так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def for_list_elements(some_list, procedure):
    if some_list == []:
        return

    list_head = some_list[0]
    list_tail = some_list[1:]

    procedure(list_head)
    for_list_elements(list_tail, procedure)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это всё хорошо. Но что если нам нужно сделать какие-то более прикладные вычисления, а не просто вывести данные, или применить процедуру к каждому элементу? Ну например, хотя бы снова суммировать все элементы списка, или перемножить? Помните &lt;em&gt;аккумуляторы&lt;/em&gt; из &lt;a href=&quot;/2022/02/20/hack_in_declarative_model_3.html&quot;&gt;Части 3&lt;/a&gt;?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def my_for_acc(start_value, end_value, step, procedure, accumulator):
    if start_value &amp;gt; end_value:
        return accumulator

    accumulator = procedure(accumulator, start_value)
    my_for_acc(start_value + step, end_value, step, procedure, accumulator)   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Передадим туда, процедурой, например такой “сумматор”:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def my_sum(x,y):
    return x + y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;И вызовем как-то так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(my_for_acc(1, 10, 1, my_sum, 0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обработка списков с аккумулятором может выглядеть так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def for_list_elements_acc(some_list, procedure, accumulator)
    if some_list == []:
        return accumulator

    list_head = some_list[0]
    list_tail = some_list[1:]
    accumulator = procedure(accumulator, list_head)

    for_list_elements_acc(list_tail, procedure, accumulator)


def my_sum(x,y)
    return x + y


print(for_list_elements_acc([3,2,1], my_sum, 0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это будет работать как функция FoldL, о которой упоминалось ранее.&lt;/p&gt;

&lt;h3 id=&quot;всё-дело-в-переменной&quot;&gt;Всё дело в “переменной”&lt;/h3&gt;

&lt;p&gt;Так вот, про Folr, а точнее про &lt;em&gt;folding&lt;/em&gt; — это схема цикла с аккумулятором для обработки списков, суть которой заключается во внедрении операций между значениями списка.&lt;/p&gt;

&lt;p&gt;На самом деле способ вычисления этой конструкции зависит от компилятора, и зачастую на выходе мы получаем хорошую производительность благодаря распараллеливанию вычислений.&lt;/p&gt;

&lt;p&gt;Во многих языках программирования цикл, например for, лингвистически выглядит почти одинаково — мы пишем, собственно for и следом имя для цикла.&lt;/p&gt;

&lt;p&gt;Фактически это объявление то же самое, что передача тела цикла, следующего за определением в отдельную процедуру, которая многократно вызывается на основании счетчика-аргумента передаваемого в объявлении цикла.&lt;/p&gt;

&lt;p&gt;Хотя такое лингвистическое определение внешне может ничем не отличаться как в декларативных языках или иных других, например императивных, имеется очень важное отличие. Мы уже подробно изучали декларативные переменные, речь здесь идет как раз об этом — в императивных языках счетчик цикла является &lt;em&gt;изменяемой переменной&lt;/em&gt;, тогда как декларативных цикл работает совсем иначе.&lt;/p&gt;

&lt;p&gt;В декларативном цикле на каждой итерации объявляется &lt;em&gt;новая переменная&lt;/em&gt;, обращение к которым происходит по &lt;em&gt;одному&lt;/em&gt; идентификатору. Благодаря такой модели все итерации полностью независимы друг от друга, могут выполняться одновременно, а результат вычислений будет детерминирован.&lt;/p&gt;

&lt;p&gt;Такой финт в императивной модели провернуть нельзя, так как внутри параллельных итераций вообще нет никакой уверенности в том что мы получаем доступ к правильному значению счетчика.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Все совпадения с “реальностью” случайны. В следующий раз поговорим о Data-driven и абстрактных типах данных.&lt;/p&gt;

&lt;p&gt;Enough for today! See y’all. Peace and love.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 5.</summary></entry><entry xml:lang="ru"><title type="html">Рекурсивные типы и другие Декларативные джедайские техники.</title><link href="http://localhost:4000/2022/02/27/hack_in_declarative_model_4.html" rel="alternate" type="text/html" title="Рекурсивные типы и другие Декларативные джедайские техники." /><published>2022-02-27T00:00:00+03:00</published><updated>2022-02-27T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/27/hack_in_declarative_model_4</id><content type="html" xml:base="http://localhost:4000/2022/02/27/hack_in_declarative_model_4.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 4. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Здравствуйте! На самом деле декларативная модель сама по себе — Джедайская техника, а именно итеративная “рекурсия”. В этом посте мы скорее разберем области применения.&lt;/p&gt;

&lt;h3 id=&quot;списки-различий&quot;&gt;Списки различий&lt;/h3&gt;

&lt;p&gt;Кроме списков существуют другие рекурсивные типы данных, например — Списки различий. На самом деле это особый тип данных, который состоит из &lt;em&gt;двух списков&lt;/em&gt;. Эти списки связаны друг с другом таким способом, что &lt;em&gt;второй&lt;/em&gt; список может быть получен из &lt;em&gt;первого&lt;/em&gt;, если из этого первого списка удалить некоторое число элементов (в том числе нулевое, то есть эти списки могут быть по сути “равны”).&lt;/p&gt;

&lt;p&gt;Фактически, списки различий, являются &lt;em&gt;одним из&lt;/em&gt; типов данных, которые классифицируются как &lt;strong&gt;структуры различий&lt;/strong&gt;. Суть таких типов мы уже разобрали — это пары значений, одно из которых “встроенно” в другое.&lt;/p&gt;

&lt;p&gt;Структура различий &lt;em&gt;A&lt;/em&gt;, которая, например, состоит из &lt;em&gt;B&lt;/em&gt; и &lt;em&gt;С&lt;/em&gt;, отражает значение равное &lt;em&gt;B минус C&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В данном случае мы разбираем списки различий, потому что у них есть интересная особенность:
&lt;em&gt;Хвост списков различий может быть &lt;strong&gt;не определен&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы можем это легко представить. Как вы помните, список — рекурсивен, и условно всегда состоит из “Головы” и “Оставшейся части”. В списках различий, если мы итеративно добираемся до “хвоста”, то “оставшаяся часть” является не пустым списком, а &lt;em&gt;неопределенной декларативной переменной&lt;/em&gt; (она “есть” но ещё не связанна со значением. См. предыдущие посты), и в первом, и во втором списке различий.&lt;/p&gt;

&lt;p&gt;Что нам это дает? Самое главное преимущество, это то, что мы можем сложить оба списка за константное время O(1), вообще не зависимо от длинны списков. Это делается очень просто — неопределенную переменную в конце первого списка &lt;em&gt;инициализируем&lt;/em&gt; ссылкой на второй список. Вуаля.&lt;/p&gt;

&lt;p&gt;Цена такого трюка велика — мы можем провернуть это сложение списков только один раз, так как первый список просто перестает существовать.&lt;/p&gt;

&lt;h3 id=&quot;в-очередь&quot;&gt;В очередь!&lt;/h3&gt;

&lt;p&gt;В классической императивной модели очередь — это интуитивно понятная структура данных, которая работает на базе списка по принципу “первый вошел — первый вышел” (FIFO). У очереди есть только две операции (метода) без каких либо аргументов: добавить элемент в хвост очереди, удалить элемент из головы.&lt;/p&gt;

&lt;p&gt;Прямо как в супермаркете.&lt;/p&gt;

&lt;p&gt;В императивной модели очередь легко реализуется на основании другой структуры — &lt;em&gt;двусвязного списка&lt;/em&gt;. Это такой список, в котором элементы связываются указателями не только со следующими за ними элементами, но и с “оставшимися” позади. Благодаря этой двусвязности, методы очереди в императивной модели работают за О(1).&lt;/p&gt;

&lt;p&gt;А что в декларативной модели? Как вы помните, в декларативной модели нет указателей и нет “классических” переменных. Ну, используя “декларативный” список мы можем добавлять новые элементы в голову за О(1), но удалять из хвоста придется за линейное время О(n), так как каждый раз для этого придется рекурсивно пробегать по списку до самого хвоста, чтобы просто его найти.&lt;/p&gt;

&lt;p&gt;О(n) — не надо нам, O(n). Это долго. В декларативной модели есть способ реализовать полноценную &lt;em&gt;О(1) очередь!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Выглядит это так. Берется два декларативных списка, которые выступают как значение полей в другом базовом типе декларативной модели — &lt;em&gt;записи&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Первый список хранит одну половину очереди, второй — другую, но в &lt;em&gt;обратном порядке&lt;/em&gt;. Вторую половину мы переворачиваем чтобы добавлять в “хвост” как в “голову” за О(1). А из фактической головы очереди, которая находится в первом не перевернутом списке, мы итак можем удалять за константное время.&lt;/p&gt;

&lt;p&gt;Есть два нюанса. Первый ― менять значение полей &lt;em&gt;записи&lt;/em&gt; в декларативной модели нельзя. Поэтому любая операция над очередью всегда будет возвращать в качестве значения очереди новую “сущность”. Это важно понимать: &lt;strong&gt;Нельзя использовать одну и ту же очередь в качестве аргумента для разных операций&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Второй — если в какой то момент нам понадобиться получить очередь целиком, придется взять вторую половину, перевернуть её, слепить с первой половиной (представить как один список). И при этом этот список всё ещё должен оставаться очередью (нам надо что-то добавлять, удалять), значит он будет значением первого поля записи-очереди.&lt;/p&gt;

&lt;p&gt;В общем выглядит совсем не как O(1)… То есть, если у нас будет программа, в которой нам не только нужно пользоваться методами добавления/удаления элементов в очередь, но ещё и часто возвращать эту очередь как единое значение, эффективность страдает.&lt;/p&gt;

&lt;p&gt;И что с этим делать? Прочитайте ещё раз про списки различий :)&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/mind_blowing.gif&quot; alt=&quot;Взрыв Мозга&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;персистентные-структуры&quot;&gt;Персистентные структуры&lt;/h3&gt;

&lt;p&gt;В ряде случаев может возникнуть необходимость хранить историю изменений какого-либо типа данных. Очередь или иной объект, предоставляющий такую возможность называется &lt;em&gt;персистентной структурой&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Как такое можно реализовать? Первое что приходит на ум, это реализация отдельной очереди или списка, в которой значениями элементов будут выступать “исторические” состояния другого типа данных, доступные только для чтения.&lt;/p&gt;

&lt;p&gt;Только вот если мы захотим сохранять состояния типа данных, в котором миллион значений, да еще и состояние меняется очень динамично… Ну вы поняли  — &lt;strong&gt;не эффективно!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Для реализации персистентных структур разработаны сложные алгоритмы, разбор которых выходит за рамки поста. На данный момент нам просто нужно знать что такие структуры есть.&lt;/p&gt;

&lt;h3 id=&quot;снова-про-эффективность&quot;&gt;Снова про эффективность&lt;/h3&gt;

&lt;p&gt;Декларативная модель — сила, математическая мощь, исток всех парадигм! Но это всё ещё программирование.
Не важно в какой парадигме мы будем программировать — всегда нужно помнить о &lt;a href=&quot;/2022/01/22/algorithms_complexity.html&quot;&gt;эффективности&lt;/a&gt; разрабатываемого нами алгоритма.&lt;/p&gt;

&lt;p&gt;Хорошая новость в том, что с позиции оценки сложности алгоритмов, декларативная модель проста. Самое главное — разумно учитывать &lt;em&gt;распространенность&lt;/em&gt; рекурсии.&lt;/p&gt;

&lt;p&gt;Кроме того, оптимизировать прожорливость по памяти проще, чем сократить время выполнение программы (оптимизировать математически).&lt;/p&gt;

&lt;p&gt;Алгоритм описанный в декларативной модели проще переписать в более “экономный” вид, используя схемы рассмотренные в прошлых постах (Итеративные вычисления, аккумулятор, etc.). Для большинства задач можно подобрать подходящую рекурсивную структуру данных, а саму память можно оптимизировать сборщиком мусора или алгоритмами сжатия.&lt;/p&gt;

&lt;p&gt;Но в математическом смысле оптимизированный “по памяти” код всё равно нельзя назвать “оптимальным”, простите за тавтологию. Есть определенная грань до которой мы можем улучшать программу, после достижений которой, все последующие улучшения практически не влияют на производительность и лишь усложняют программу. Это плохая практика.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Если нет явной необходимости — не нужно пытаться оптимизировать код!&lt;/p&gt;

&lt;p&gt;Фишка в том, что почти всегда &lt;em&gt;очень малый&lt;/em&gt; участок кода действительно влияет на время работы программной системы. Но есть нюанс — &lt;em&gt;не всегда этот участок очевиден даже опытным программистам&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Поэтому очень проектировать программы ясным способом, придерживаясь правил хорошего стиля и используя подходящие для решения конкретной задачи парадигмы.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Правильно подобранная парадигма программирования &lt;strong&gt;всегда&lt;/strong&gt; повышает выразительность кода.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Спойлер к следующему посту:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Программирование высшего порядка;&lt;/li&gt;
  &lt;li&gt;Опять абстракции?&lt;/li&gt;
  &lt;li&gt;Как на самом деле работают циклы.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/no_identification.gif&quot; alt=&quot;Рекурсивные кролики&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Миру — Мир!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 4.</summary></entry><entry xml:lang="ru"><title type="html">Список списков, итеративные вычисления и прочие муми-тролли</title><link href="http://localhost:4000/2022/02/20/hack_in_declarative_model_3.html" rel="alternate" type="text/html" title="Список списков, итеративные вычисления и прочие муми-тролли" /><published>2022-02-20T00:00:00+03:00</published><updated>2022-02-20T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/20/hack_in_declarative_model_3</id><content type="html" xml:base="http://localhost:4000/2022/02/20/hack_in_declarative_model_3.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 3. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;here-we-go-again&quot;&gt;Here we go again&lt;/h3&gt;
&lt;p&gt;Здравствуйте! Это очередной пост-отчёт по мотивам материала из курса &lt;a href=&quot;https://skillsmart.ru/&quot;&gt;школы Сергея Бобровского&lt;/a&gt; – Как понять в программировании всё. Изучаем декларативную вычислительную модель.&lt;/p&gt;

&lt;p&gt;В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.&lt;/p&gt;

&lt;p&gt;Рекурсия как программистский трюк не ограничивается “самовызовом” (прочитали как самовывоз, признайтесь?) функций — &lt;em&gt;рекурсивными могут быть и типы данных&lt;/em&gt;. Базовый пример рекурсивного типа данных — список.&lt;/p&gt;

&lt;p&gt;Почему список на самом деле рекурсивная структура? Потому что он определяется &lt;em&gt;в терминах более короткой версии себя самого&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и &lt;em&gt;“список”&lt;/em&gt;, а лучше сказать набор или “последовательность” пар “ключ-значение”.&lt;/p&gt;

&lt;p&gt;Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список.&lt;/p&gt;

&lt;p&gt;Как правило этими “произвольными” значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка “впихнуть” в эти “кусочки” какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда).&lt;/p&gt;

&lt;p&gt;Части списка связанны некоторым образом с другими, и всё вместе (“элементарный кусок данных” и связь-указатель на другой) называется &lt;em&gt;узел&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.&lt;/p&gt;

&lt;p&gt;Вернемся к фундаментальным материям :)&lt;/p&gt;

&lt;p&gt;В декларативной модели список определяется &lt;em&gt;рекурсивно&lt;/em&gt;. Считается, что либо список пустой (nil или, если хотите, None), либо &lt;em&gt;есть какое-то значение связанное со списком&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, “узел” содержащий строку “shrek”, то тогда список X будет равен “shrek” &lt;em&gt;связанный со списком nil&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Короче говоря, “последний” элемент в списке всегда будет “указывать” на “пустой список”.&lt;/p&gt;

&lt;p&gt;Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.&lt;/p&gt;

&lt;p&gt;В рекурсивных функциях, работающих со списками, &lt;em&gt;базовым случаем&lt;/em&gt; будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов &lt;em&gt;более мелких списков&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Например, “декларативная” рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def list_length(some_list):
    if some_list == []
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    return 1 + list_length(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — “Ух ты ж сколько можно то намутить с этим списком!”&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/hold_on.gif&quot; alt=&quot;Подождите!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Это всё ещё рекурсивная функция, мы в прошлый уже говорили про проблему с переполнением стека. Кроме того, рекурсивные функции со списками, при их необдуманном определении, вполне могут оказываться крайней не эффективными — O(n*n) или ещё хуже.&lt;/p&gt;

&lt;p&gt;Для решения этих проблем есть техника, при которой рекурсивные функции превращаются в функции с &lt;em&gt;итеративной формой вычисления&lt;/em&gt; с &lt;strong&gt;линейной&lt;/strong&gt; эффективностью!&lt;/p&gt;

&lt;h3 id=&quot;итерируй-то&quot;&gt;Итерируй то&lt;/h3&gt;

&lt;p&gt;Ранее мы говорили про итеративные вычисления как о частном случае рекурсии. Разберемся чуть глубже.&lt;/p&gt;

&lt;p&gt;Во-первых стек. Почему он вообще формируется при рекурсивном вызове? Обратите внимание на пример функции вычисления длинны списка, а именно на хвостовой return в конце. Раз за разом при рекурсивном вызове окружение экземпляра функции должно сохраняться в стеке, потому что прибавление единицы происходит &lt;strong&gt;после&lt;/strong&gt; этого заключительного return.&lt;/p&gt;

&lt;p&gt;В нашем примере это всё происходит лишь для того, чтобы потом в обратном порядке “размотать” стек и просуммировать единцы. Кажется избыточным.&lt;/p&gt;

&lt;p&gt;Чем отличается итеративное вычисление от обычной рекурсии?&lt;/p&gt;

&lt;p&gt;Схема итеративных вычислений — это &lt;em&gt;последовательность &lt;strong&gt;трансформации состояний&lt;/strong&gt;&lt;/em&gt;. Как это работает?&lt;/p&gt;

&lt;p&gt;Ну, по сути, мы добавляем некоторый счетчик в аргумент рекурсивной функции, и делаем так чтобы увеличение этого счетчика &lt;em&gt;происходило &lt;strong&gt;до&lt;/strong&gt; рекурсивного вызова&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Рекурсивная-итеративная функция вычисления длины списка будет выглядеть так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обратите ещё раз внимание на счетчик &lt;em&gt;i&lt;/em&gt;. Мы увеличиваем его в аргументах рекурсивного вызова, &lt;strong&gt;до&lt;/strong&gt; самого вызова. Благодаря этому мы “замыкаем” окружение функции и состояние каждого экземпляра не требуется сохранять в отдельных записях в стеке.&lt;/p&gt;

&lt;p&gt;Ничего не мешает скрыть такую функции за функцией-абстракцией, которая будет принимать только list, а внутри вызывать inter_list_length(0, list).&lt;/p&gt;

&lt;h3 id=&quot;итерируй-это&quot;&gt;Итерируй это&lt;/h3&gt;

&lt;p&gt;Видите как связана “рекурсивность функции” с “рекурсивностью типа”, который она обрабатывает?&lt;/p&gt;

&lt;p&gt;Это &lt;strong&gt;важная фишка&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Мы уверенно можем сказать, что &lt;em&gt;рекурсивная структура функции зависит от рекурсивной структуры определения обрабатываемого типа данных&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы потенциально можем нагородить какой угодно рекурсивный тип, но это не есть хорошо. Эта свобода в программировании часто приводит к написанию очень неэффективных, не грамотных алгоритмов.&lt;/p&gt;

&lt;p&gt;Само по себе определение какого-то типа данных в языке программирования &lt;em&gt;описательно&lt;/em&gt;. Это значит, что такое определение является всего лишь набором логических утверждений о множестве значений, который данный тип может принять. Такие определения не являются полноценными проверками допустимостей значений, а зачастую (например какой нибудь абстрактный тип) их вообще проверить нельзя.&lt;/p&gt;

&lt;p&gt;В декларативной модели даже базовые типы могут быть не проверенны компилятором. Поэтому нам &lt;strong&gt;важно&lt;/strong&gt; предельно осознанно понимать что мы кодим, и использовать изначально свойственные декларативной модели типы данных.&lt;/p&gt;

&lt;p&gt;Список это very handy! Надо лишь включить думалку, и включить так, чтобы избежать неэффективных реализаций алгоритмов.&lt;/p&gt;

&lt;p&gt;Вернемся к нашему определению взаимосвязи рекурсивности типа с рекурсивностью функции.&lt;/p&gt;

&lt;p&gt;Сперва нам необходимо &lt;em&gt;правильно определить рекурсивный тип&lt;/em&gt;, прежде чем писать для него функцию. Что это значит?&lt;/p&gt;

&lt;p&gt;Например, у нас есть некий композитный список, элементы которого тоже могут быть списками, и нам надо посчитать количество всех значений, включая значений во вложенных списках.&lt;/p&gt;

&lt;p&gt;Нам нужно понять, или &lt;em&gt;определить&lt;/em&gt; тип “вложенный список”.&lt;/p&gt;

&lt;p&gt;Мы помним что “список” — это либо пустой [], либо некоторый “элемент” связанный с [].&lt;/p&gt;

&lt;p&gt;В таком случае “вложенный список” будет определяться как — либо пустой [], либо “вложенный список” связанный с “вложенным списком”, либо как “элемент” связанный с “вложенным списком”. Ничего не понятно?&lt;/p&gt;

&lt;p&gt;Короче говоря, у нас в любом порядке и в “ширину” и в “глубину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых в любом порядке и в “глубину” и в “ширину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых…&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/recursion_1.gif&quot; alt=&quot;Рекурсия&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Неотложка уже выехала.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Так, давайте не будем пороть горячку! Это проще чем кажется.&lt;/p&gt;

&lt;p&gt;Вложенный список, с которым может быть связан вложенный список, все ещё “обычный” список, который может быть пустым (то есь может “не быть”! Ом!) Мы с этого и начали определение.&lt;/p&gt;

&lt;p&gt;Тогда функция, основанная на таком типе будет иметь структуру:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def length_1(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if type(some_list) is list:
        return length_1(list_head) + length_1(list_tail)
    
    return 1 + length_1(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;А если структура типа будет другой? Функция будет иметь &lt;em&gt;другую&lt;/em&gt; логику. К примеру у нас есть тип подобный предыдущему, но нам не важно количество элементов во вложенных списках, и мы хотим лишь посчитать элементы на “верхнем” уровне. Не важно — является этот элемент списком или нет.&lt;/p&gt;

&lt;p&gt;Поймите, речь идет о &lt;em&gt;логическом&lt;/em&gt; определении типа.&lt;/p&gt;

&lt;p&gt;В таком случае тип “вложенный список 2” мы будем определять как — либо пустой [], либо “вложенный список 2” связанный со “вложенным списком 2”, либо как &lt;em&gt;элемент “верхнего” уровня&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ключевое отличие с прошлым примером в том, что тогда “вложенный список” всегда считался списком, а на этот раз он может считаться как простой элемент.&lt;/p&gt;

&lt;p&gt;Функция:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def length_2(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if list_tail == []:
        return 1
    
    return length_2(list_head) + length_2(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ключевой момент тут это проверка list_tail == [], суть которого в том, что если рекурсия добралась до случая, когда хвост элемента является пустым списком мы возвращаем единицу, как бы “забивая” на то, что “проваливались” во вложенный список.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Эти простые примеры приводятся как пример для понимания способа которым мы должны мыслить о рекурсивных вычислениях в декларативной модели. Почему нам всегда важно понимать логику алгоритма, и учитывать структуру рекурсивного типа, с которым работаем.&lt;/p&gt;

&lt;p&gt;Декларативная модель дает нам мощный и изящный инструмент — &lt;em&gt;минималистичность&lt;/em&gt;, которым можно и нужно пользоваться при разработке алгоритмов (если это возможно). Декларативная модель удобна и исключает множество потенциальных ошибок, если мы четко определяем типы и понимаем что делаем.&lt;/p&gt;

&lt;h3 id=&quot;аккумуляторы&quot;&gt;Аккумуляторы!&lt;/h3&gt;

&lt;p&gt;На этом моменте мы уже выяснили как писать рекурсивные функции, делать из них итеративные и как корректно определять и применять рекурсивные типы данных. Так а зачем тогда рекурсивные функции? &lt;em&gt;А не зачем&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В боевой разработке с использованием декларативной модели функции &lt;em&gt;сразу пишут итеративными&lt;/em&gt;! Мы разобрали эти тонкости сугубо в целях понимания и изучения.&lt;/p&gt;

&lt;p&gt;Давайте повторим для закрепления. Вся фишка итеративных вычислений в &lt;em&gt;передаче значения&lt;/em&gt; все “глубже” в рекурсию. Мы никогда не возвращаемся обратно с помощью return.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/buzz.gif&quot; alt=&quot;Базз&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Ну или пока память не кончится :D&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Отставить шуточки! Как это работает?&lt;/p&gt;

&lt;p&gt;Возьмем состояние, которое передаем в функцию как S. Возьмем это состояние и расширим двумя аргументами, S1 и Sn.&lt;/p&gt;

&lt;p&gt;Такой финт называется — &lt;em&gt;аккумулятор&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы берем этот аккумулятор и передаем его в &lt;strong&gt;процедуру&lt;/strong&gt; (не функцию!). В первом посте мы говорили о том, что декларативная процедура работает в своих параметрах с указателями на ещё &lt;em&gt;не инициализированные&lt;/em&gt; декларативные переменные. Иными словами, результат работы процедуры возвращается через эти параметры &lt;em&gt;по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В аккумуляторе: S1 является входным состоянием, а Sn — выходным, то есть результатом. Внутри такой процедуры происходит её рекурсивный вызов выполняющий последовательные преобразования Si в Si+1 (итеративные, тысяча чертей!!!)&lt;/p&gt;

&lt;p&gt;Псевдокод:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;procedure(S, S1, Sn):
если вычисления S не требуются:
    Sn = S1
иначе:
    ## начинается блок рекурсивных вызовов
    procedure1(S1, S2)
    procedure2(S2, S3)
    ...
    procedureN(Sn-1, Sn)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Выход каждой procedureI является входом procedureI+1&lt;/p&gt;

&lt;p&gt;Как уже объяснялось, отличие от рекурсивной функции в том, что нам не надо сохранять в стеке все промежуточные состояния-вызовы, так как значения передаются по ссылке. А “базовым случаем-ограничением” рекурсии, может быть указание границы обработанных элементов в исходной структуре S.&lt;/p&gt;

&lt;p&gt;Когда мы в этом посте разбирали итеративные вычисления на примере функции iter_length:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы практически использовали &lt;em&gt;схему с аккумулятором&lt;/em&gt;, передавая текущую длину в следующий вызов &lt;em&gt;по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Фактически в наши дни такая схема с аккумуляторами считается устаревшей, и их чрезмерное использование лишь затруднит программирование.&lt;/p&gt;

&lt;p&gt;Схема с аккумуляторами имеет право на жизнь, когда получается ограничиться минимальным количеством аккумуляторов (1-2).&lt;/p&gt;

&lt;p&gt;Тем не менее, пользу от знания таких фундаментальных приемов невозможно переоценить в контексте прокачки нашей аналитической и программистской машинки мозга.&lt;/p&gt;

&lt;p&gt;И вот ещё повторим — хотя в итеративных вычислениях мы не проваливаемся в стек “в глубину”, память потенциально может кончиться ещё как! Мы “разматываем” состояние “в ширину”.&lt;/p&gt;

&lt;p&gt;Спасибо за внимание.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 3.</summary></entry><entry xml:lang="ru"><title type="html">Бери и DRY, и так далее</title><link href="http://localhost:4000/2022/02/13/dry_etc.html" rel="alternate" type="text/html" title="Бери и DRY, и так далее" /><published>2022-02-13T00:00:00+03:00</published><updated>2022-02-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/13/dry_etc</id><content type="html" xml:base="http://localhost:4000/2022/02/13/dry_etc.html">&lt;p&gt;Рассматриваем пару универсальных принципов разработки.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;лучше-сухо-чем-мокро&quot;&gt;Лучше сухо, чем мокро!&lt;/h3&gt;

&lt;p&gt;Аббревиатура принципа DRY расшифровывается как Don’t repeat yourself, что недвусмысленно переводится как “Не повторяйся”. Само сокращение является словом dry — сухой, и нарушение принципа окрестили как WET (мокрый) — Write everything twice (Пиши всё дважды) или We enjoy typing (Нам нравится печатать).&lt;/p&gt;

&lt;p&gt;Разумеется уровень влажности тут вообще не при чем :)&lt;/p&gt;

&lt;p&gt;Вероятно вы уже встречали упоминание DRY. О нем часто говорят в бесплатных и платных уроках программирования, но как правило речь только в контексте написания кода (programming-in-small).&lt;/p&gt;

&lt;p&gt;На самом деле этому универсальному принципу можно, и обязательно нужно, следовать на всех уровнях проектирования системы.&lt;/p&gt;

&lt;h1 id=&quot;я-никогда-не-повторяюсь&quot;&gt;Я никогда не повторяюсь&lt;/h1&gt;
&lt;h3 id=&quot;неповторим-внутри&quot;&gt;Неповторим внутри&lt;/h3&gt;

&lt;p&gt;Как я уже сказал, чаще всего DRY преподносят как правило, при котором мы не должны повторно использовать (копировать) код, в разные части программы. Это лишь малая доля. Фишка в том, что DRY применим к любой сущности в системе, на любом уровне абстракции.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Если что-то где-то определено, оно должно быть определено только в этом месте.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;А что касаемо кода, то бывают случаи когда дублирование &lt;em&gt;оправдано&lt;/em&gt;. Например есть две высокоуровневые функции (методы), которые производят &lt;em&gt;похожие&lt;/em&gt; вычисления, но в разном контексте, и служат разным целям (всякие проверки истинности, etc).&lt;/p&gt;

&lt;h3 id=&quot;неповторим-снаружи&quot;&gt;Неповторим снаружи&lt;/h3&gt;

&lt;p&gt;В проектировании (programming-in-large) DRY работает аналогично. Во-первых, если есть какой-то конкретный модуль, то его спецификация должна быть единообразной и находиться в одном месте.&lt;/p&gt;

&lt;p&gt;Это значит, что нельзя просто копировать этот модуль, немного его изменять и встраивать в систему. Тогда в будущем при доработке, в случае изменений одного такого “модуля-клона”, нам придется менять то же самое и во втором. А если копий три, четыре…? Вы точно думаете что сможете вспомнить о них всех, я не говорю уже о совершенно очевидном неудобстве такой архитектуры. Это полный зашквар, не надо так делать.&lt;/p&gt;

&lt;p&gt;Во-вторых, программные интерфейсы (api) тоже должны быть единообразными, следовать спецификации. Представьте что “внутри” модули используют по разному описанные вызовы. Внешние вызовы тоже накостыляли по другому. Чувствуете аромат? Так пахнет горящая точка опоры, когда система рухнет из за того что мы поменяли один интерфейс, или &lt;em&gt;забыли&lt;/em&gt; поменять один из них, в соответствии с новыми требованиями.&lt;/p&gt;

&lt;p&gt;Во избежание этого можно использовать, например OpenAPI, или что-то в таком духе. Если мы разрабатываем собственный API, он должен быть корректно задокументирован и доступен &lt;strong&gt;в одном месте&lt;/strong&gt; (например в конкретном репозитории команды разработки).&lt;/p&gt;

&lt;h2 id=&quot;что-и-тут-тоже&quot;&gt;Что, и тут тоже?&lt;/h2&gt;

&lt;p&gt;Мы плавно подошли к документации. Многие разработчики не любят документировать проекты, и это &lt;strong&gt;плохо&lt;/strong&gt;. А если и ведут документацию то относятся очень халатно. Ctrl-c, Ctrl-v, Тяп ляп, и так сойдет!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Документация тоже должна следовать принципу DRY&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;На уровне комментариев кода (это ведь тоже документация), пример WET-поведения — зачем-то описывать подробными комментариями чуть ли не каждую функцию в коде. Ясный код должен говорить сам за себя и быть понятен читающему его программисту (например вам самим завтра или через неделю).&lt;/p&gt;

&lt;p&gt;Так зачем повторяться? Разве что код выглядит запутанным и совершенно непонятным? Если так, то это отдельная проблема и нужно решать её в первую очередь.&lt;/p&gt;

&lt;p&gt;На уровне документирования проекта — мы должны структурировать документы понятно, излагать информацию последовательно и, простите за тавтологию — &lt;em&gt;информативно&lt;/em&gt;. Документация это не удобный случай поупражняться в графомании.&lt;/p&gt;

&lt;p&gt;На самом деле писать код и писать текст по сути одно и то же, разве нет?&lt;/p&gt;

&lt;p&gt;Мы можем подойти к этой задаче почти так же, как к разработке программы. Декомпозируйте её! Если вы хорошо понимаете документируемый проект то это не вызовет проблем. Каждый модуль, согласно DRY, описывается в одном разделе документации, API в другом, и так далее.&lt;/p&gt;

&lt;h1 id=&quot;легко-поменять&quot;&gt;Легко поменять&lt;/h1&gt;

&lt;p&gt;Ещё один очень важный принцип, залог, хорошего проектирования — &lt;strong&gt;ETC&lt;/strong&gt;, или Easier to change!&lt;/p&gt;

&lt;p&gt;Мы все люди, и нам свойственно ошибаться в своих решениях. Разумеется и в разработке программных систем. Поэтому очень важно создавая что-то новое, или внося изменения в уже существующие части, всегда задаваться вопросом — “А будет ли в будущем это &lt;em&gt;легко изменить&lt;/em&gt;?”&lt;/p&gt;

&lt;p&gt;Подумайте, будет ли легко вносить изменения в проект, в котором строго следуют “сухому закону” DRY? (Я пытаюсь шутить, извините!)&lt;/p&gt;

&lt;p&gt;Разумеется будет!&lt;/p&gt;

&lt;p&gt;Этому принципу осознанности ETC нужно следовать даже (особенно!) в самых малых частях разработки, вплоть до написания функции из нескольких строк кода. Будет ли она легко заменимой, исправляемой? Ясно ли она описана?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Верно утверждать что принцип DRY является логическим продолжением ETC. Вообще &lt;em&gt;любой&lt;/em&gt; подход хорошего проектирования исходит из ETC. Например, использование понятных имен переменных и функций непосредственно упрощает дальнейшее сопровождение кода.&lt;/p&gt;

&lt;p&gt;А если мы будем как можно больше компонентов делать &lt;a href=&quot;/2022/02/12/hack_in_declarative_model_2.html&quot;&gt;декларативными&lt;/a&gt;, это поможет? Да! Архитектура будет менее запутанной, с меньшей &lt;em&gt;связностью&lt;/em&gt;, и следственно более удобной в сопровождении.&lt;/p&gt;

&lt;p&gt;Куда не глянь, если что-то сделано хорошо, это сделано осознанными в ETC инженерами!&lt;/p&gt;

&lt;p&gt;Можно уйти в словоблудие и сказать, что оба эти принципа применимы не только как ценности проектирования программных систем, и исходят из более “фундаментальных” личностных качеств.&lt;/p&gt;

&lt;p&gt;Но я оставлю это вам как пищу для размышления.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Инструменты" /><category term="Размышления" /><summary type="html">Рассматриваем пару универсальных принципов разработки.</summary></entry></feed>