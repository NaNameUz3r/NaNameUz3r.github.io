<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-07-24T22:53:46+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Связный список, он же Linked List</title><link href="http://localhost:4000/2022/07/24/linked_list.html" rel="alternate" type="text/html" title="Связный список, он же Linked List" /><published>2022-07-24T00:00:00+03:00</published><updated>2022-07-24T00:00:00+03:00</updated><id>http://localhost:4000/2022/07/24/linked_list</id><content type="html" xml:base="http://localhost:4000/2022/07/24/linked_list.html"><![CDATA[<p>Врубаемся в Linked List.
<!--more--></p>

<h1 id="вместо-введения">Вместо введения</h1>

<p>Привет! Мы уже много раз говорили про списки как про фундаментальную структуру данных в программировании. Например <a href="/2022/02/27/hack_in_declarative_model_4.html">в третьем посте о Декларативной модели</a> мы говорили, что в рамках парадигмы список — это рекурсивный тип данных.</p>

<p>Сегодня же я предлагаю вам немного ближе ознакомиться с этой замечательной структурой.</p>

<h1 id="что-такое-связный-список">Что такое связный список</h1>

<p>Связный список — это <em>“классический”</em> абстрактный тип данных, который представляет собой упорядоченный набор элементарных данных. Элементы связного списка называются <strong>узлами</strong>, и каждый узел связан с другими <em>некоторым</em> способом.</p>

<p>Список — это упорядоченная неиндексируемая коллекция, которая может перебираться от головы к хвосту. От массивов списки отличаются тем, что во-первых — они хранятся в памяти <em>по разному</em>. Массив, как правило, занимает непрерывную область памяти, которая выделяется при его инициализации.</p>

<p>Если в массиве “кончится место”, то мы не сможем просто так его расширить. Для это нам придется найти новую <em>последовательную</em> область памяти подходящего размера, аллоцировать новый массив побольше, и скопировать в него все элементы из предыдущего массива. Ну мы сегодня про списки :)</p>

<p>Так вот, узлы списка не обязательно буду храниться в последовательной области памяти, скорее наоборот — узлы будут разбросаны в памяти произвольно. При добавлении нового узла нам не нужно делать ничего кроме как просто добавить его корректно (с учетом всех указателей и граничных ситуаций).</p>

<p>Во-вторых, взяв за начало любой узел списка мы можем достаточно просто вычленить любую необходимую часть. Добавление и удаление эллементов связного списка выполняется очень эффективно.</p>

<h1 id="как-это-устроено">Как это устроено</h1>

<p>Самый тривиальный связаный список — это односвязный, или <em>однонаправленный связный список</em>. В таком списке каждый узел связан со следующим с помощью указателя на этот следующий узел. И так от головы до хвоста. Для реализации такой структуры данных нам нужно всего лишь определить два класса: Узел (Node), у которого будет два поля Value, и указатель на следующий узел Next.</p>

<p>Например, хотя в Go и нет классов и ООП как такового, узел легко определить как Struct:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Node struct {
    next  *Node
    value int  // ну или любой другой тип, который вы хотите хранить в узлах.
}
</code></pre></div></div>

<p>На самом деле, формально говоря, одного класса Node уже достаточно для того чтобы сформировать список.</p>

<p>Второй класс, собственно список LinkedList является обёрткой для узлов, и по сути играет роль синтаксического сахара.
В этом классе нам нужны два поля — head и tail, который будут указателями на голову и хвост списка соответственно:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type LinkedList struct {
    head *Node
    tail *Node
}
</code></pre></div></div>

<p>Вот и весь скелет однонаправленного списка. Далее, мы можем определить все необходимые для работы методы.
Например, метод для добавления нового узла в хвост списка может выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (l *LinkedList) AddInTail(item Node) {
    if l.head == nil {
        l.head = &amp;item
    } else {
        l.tail.next = &amp;item
    }

    l.tail = &amp;item
}
</code></pre></div></div>

<p>Раз за разом добавляя новые узлы в хвост списка, мы сначала либо делаем новый узел “головой” (если список пуст), либо в актуальный хвост записываем указатель на новый узел, и перемещаем на этот же новый узел указатель хвоста в классе\структуре LinkedList.</p>

<p>Мы можем свободно перебирать узлы списка с головы до хвоста, например, чтобы посчитать все узлы:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (l *LinkedList) Count() int {
    count := 0
    current_node := l.head
    for {
        if current_node == nil {
            break
        }
        count++
        current_node = current_node.next
    }
    return count
}
</code></pre></div></div>

<p>И добавлять узлы куда то в середину, а не только в хвост:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>func (l *LinkedList) Insert(after *Node, add Node) {
    if reflect.DeepEqual(after, l.tail) == true {
        l.AddInTail(add)
    } else {
        add.next = after.next
        after.next = &amp;add
    }

}
</code></pre></div></div>

<p>Ну и так далее.</p>

<h2 id="двунаправленный-список">Двунаправленный список</h2>

<p>Двкунаправленный, или двусвязный список — это всё тот же LinkedList, но такой у которого узлы ссылаются не только на следующие, но и на <em>предыдущий</em>, для того чтобы можно было бегать в обратную сторону от хвоста к голове.</p>

<p>В такой реализации структуры и метод добавления в хвост реализованные на Go могут выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Node struct {
    prev  *Node
    next  *Node
    value int
}

type LinkedList2 struct {
    head *Node
    tail *Node
}

func (l *LinkedList2) AddInTail(item Node) {
    if l.head == nil {
        l.head = &amp;item
        l.head.next = nil
        l.head.prev = nil
    } else {
        l.tail.next = &amp;item
        item.prev = l.tail
    }

    l.tail = &amp;item
    l.tail.next = nil
}
</code></pre></div></div>

<p>Мы платим памятью — нужно выделять дополнительную ячейку для каждого узла (дополнительный указатель prev). Реализация методов тут немного усложняется, потому что при любых модификациях двунаправленного списка нам нужно проверять три ситуации: работу с головой, хвостой, и серединой списка. Мы должны убедиться что указатели после каждой такой операции будут иметь корректные, отражающие новую реальность данные.</p>

<p>Облегчить себе жизнь можно пойти чуть дальше :)</p>

<h1 id="лист-с-двумя-дурачками">Лист с двумя дурачками</h1>

<p>Чтобы избавиться от <del>головной боли</del> граничных ситуаций упомянутых выше, можно закодить LinkedList с двумя, так называемыми, <em>dummy</em> узлами. Это такие фиктивные узлы-пустышки, которые <em>всегда</em> будут в связном списке — в голове и хвосте.</p>

<p>Имея эти узлы мы всегда можем быть уверенны в том, что у каждого узла будет и следующий (next) и предыдущий (prev) узлы\указатели, что непосредственно избавляет нас от дополнительных проверок.</p>

<p>Самый простой способ реализовать такой финт — дополнительное булевое поле у Node:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Node struct {
    prev  *Node
    next  *Node
    value int
    dummy bool
}
</code></pre></div></div>

<p>Список теперь, мы будем создавать при помощи функции-генератора, которая будет добавлять два дурочка:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type LinkedListDummy struct {
    head *Node
    tail *Node
}

func NewList() *LinkedListDummy {
    l := new(LinkedListDummy)
    l.head = &amp;Node{prev: nil, next: nil, value: -1, dummy: true}
    l.tail = &amp;Node{prev: nil, next: nil, value: -1, dummy: true}
    l.head.next = l.tail
    l.tail.prev = l.head

    return l
}
</code></pre></div></div>

<h1 id="фантазируй-дальше">Фантазируй дальше</h1>

<p>На базе такого простого списка можно реализовать более сложные абстрактные типы, в зависимости от поставленной задачи. Ну, например, можно сделать <em>кольцевой связный список</em> на базе как односвязного так и двусвязного списка. В такой реализации хвост будет иметь указатель на голову, а в случае двусвязного кольцевого — ещё и голова на хвост.</p>

<p>В таком циклическом списке мы можем как-то выделить голову, чтобы “отлавливать” по необходимости момент, когда мы обошли весь список и вернулись в начало. Очереди, в том числе двусвязные, тоже реализуются на базе списков. К очередям мы доберемся в другой раз :)</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Структуры_данных" /><summary type="html"><![CDATA[Врубаемся в Linked List.]]></summary></entry><entry xml:lang="ru"><title type="html">А что есть добавить… Наследование?</title><link href="http://localhost:4000/2022/07/05/hack_in_OOP_1.html" rel="alternate" type="text/html" title="А что есть добавить… Наследование?" /><published>2022-07-05T00:00:00+03:00</published><updated>2022-07-05T00:00:00+03:00</updated><id>http://localhost:4000/2022/07/05/hack_in_OOP_1</id><content type="html" xml:base="http://localhost:4000/2022/07/05/hack_in_OOP_1.html"><![CDATA[<p>Врубаемся в модель ООП. Часть 1.
<!--more--></p>

<h1 id="просто-добавь-наследование">Просто добавь Наследование</h1>

<p>Объектно-ориентированное программирование наверное не совсем корректно определять как жестко отдельную вычислительную модель. По той причине, что по сути ООП — это императивная вычислительная модель плюс <em>наследование</em>.</p>

<p>Можно сказать ещё, что ООП — это <em>программирование с инкапсуляцией, наследованием и явным состоянием</em>. Работа с состояниями здесь ведется активно, в виде мутабельных переменных.</p>

<p>В современных языках программирование инкапсуляция, наследование и явные состояния поддерживаются абстракцией под названием <em>класс</em>. Но если разбираться то эта абстракция на самом деле не обязательна — ООП’мы можно писать почти на любом яп.</p>

<p>Широкое распространение объектно-ориентированного программирования внесло два значимых вклада в программирование как таковое:</p>

<ol>
  <li>Стало понятно что <em>инкапсуляция нужна</em>, а программы получаются удобными и более эффективными с точки зрения продуктивности работы с ними огранизовывать в виде <em>коллекций абстрактных типов данных</em>. <a href="/2022/06/13/hack_in_imperative_2.html">Помним</a>, что АТД в ООП — Защищённые, stateful, запакованные. Это значит что каждый модуль или объект имеет свой ключ-секрет, известный только ему.</li>
  <li>Абстрактные типы данных оказалось важным <em>выстраивать постепенно</em>, через использование наследования для того чтобы избежать повторений кусков кода.</li>
</ol>

<h1 id="наследование">Наследование</h1>

<p>Итак, когда у нас есть АТД с реализацией описанной выше, выходит так что программу можно построить как иерархию — одни АТД, зависящие от других АТД. Это идея <em>компонентно ориентированного программирования</em>, но ООП развивает ещё чуть дальше, полагаясь на то, что <em>компоненты зачастую имеют много общего</em>.</p>

<p>Разберем небольшой пример. Допустим, что в нашей программе мы хотим использовать последовательности. Но есть много способов реализации разных АТД, которые будут обладать этим свойством последовательности. В одном случае мы хотим чтобы такие АТД вели себя как очереди, в другом — как стеки, и так далее.</p>

<p>В каждом из этих случаев все последовательности поддерживают основное (общее) свойство — их элементы линейно-упорядочены.</p>

<p>Очевидно, что если каждый из этих АТД описывать отдельно, то в их описании будет дублироваться некоторая часть кода.</p>

<p>Это именна та проблема, которую ООП решает введением концепции наследования. Определяя один АТД как наследник других он практически имеет ту же функциональность, с потенциальной возможностью вносить в эту функциональность какие то изменения или расширять её. При этом нужно лишь указать различия между этим АТД и его родителем.</p>

<p>Эта механика постепенного относительно родителя определения абстрактных типов данных называется <em>“класс”</em>.</p>

<hr />

<p>Наследование — <em>это <strong>техника</strong> программирования</em>. И она вносит большое различие в ОПП по отношению к другим видам программирования с использованием состояния. Как уже было сказано, вычислительная модель на которой стоит ООП это всё та же stateful-модель.</p>

<p class="info">ООП по сути просто обеспечивает синтаксическую поддержку наследования через добавление концпеций классов в виде лингвистической абстракции.</p>

<p>Сам по себе базовый компонентный подход намного проще в плане построения систем. Каждый компонент группирует в себе набор сущностей, и логически рассматривает их как одно целое с точки зрения зависимостей между ними.</p>

<p>Наследование же, хотя и имеет некоторые проблемы, обладает большим потенциалом. При использовании наследования каждая абстракция может быть реализована лишь один раз, и все реализации остаются независимыми. Изменения одной реализации не требует изменять другие. Обратная сторона (те самые проблемы) — это распределение реализации АТД в разных частях программы. Здесь реализация АТД может быть собрана в одном месте лишь в небольших проектах. В крупных системах же АТД, как правило, будут включать в себя через композицию или наследование другие АТД, которые моугут находиться далеко в коде. Насолим ещё — подключаемые реализации могут существовать вообще в виде только скомпилированного кода, лишая нас доступа к исходнику.</p>

<p>Раньше думали что наследование позволит решить проблему повторного использования кода целиком, упростит создание библиотек, которые можно будет массово распространять для переиспользования. Но это не сработало. Наследование как метод повторого использования сильно проиграло и уступило место компонентам, фреймворкам и шаблонам проектирования.</p>

<p>Тем не менее наследование остается полезным, но лишь в пределах <em>одной системы</em> или тесно связанного семейства программ, занимая достойное место рядом с программированием высшего порядка в качестве одной из самых важных техник структурирования программ.</p>

<h2 id="объекты-и-классы">Объекты и классы</h2>

<p><strong>Объект</strong> — это программная сущность, которая <em>инкапсулирует состояние</em>. Доступ к инкапсулированному состоянию извне может быть получен только контролируемым способом через использование методов. Методы являются доступными извне процедурами, которые имеют непосредственный доступ к состоянию внутри объекта. Инкапсулированные состояния можно изменять только через вызовы соответствующего метода, что гарантирует ситуацию когда состояние объекта всегда удовлетворительно по некоторому инварианту.</p>

<p><strong>Класс</strong> — это программная сущность, которая определяет <em>объект</em> постепенным способом, кусок за куском. Объект как экземпляр класса <em>определяется</em> в свою очередь “родительскими” классами, от которых он наследуется, и тем, чем он отличается от <em>прямых</em> предков. Большинство современных яп поддерживают концепцию классов как лингвистическую абстракцию через синтаксическую инструкцию class.</p>

<h1 id="классы-как-полноценные-атд">Классы как полноценные АТД</h1>

<p>Итак, зарубим себе, что <strong>класс — есть лингвистическая абстракция</strong> языка программирования, определяемая с помощью ключевого слова-токена class.</p>

<p>В идеальном случае классы в яп считаются <strong>значениями первого класса</strong> (<a href="/2022/02/27/hack_in_declarative_model_4.html">тык</a>). Как минимум класс в коде определяется так же просто как функция. Класс содержит в себе <strong>атрибуты</strong> — внутренние переменные, и <strong>методы</strong> для работы с атрибутами.</p>

<p>Работа с атрибутами, хоть по сути и представлена теми же операциями (считать значение, поменять значение) что и работа с обычными переменными, имеет <strong>отдельный синтаксис</strong>.</p>

<p>Всё это — минимум необходимый для добавление в язык программирования объектной парадигмы. Хотя концепция класса в stateful-модели может быть реализована без расширения синтаксиса языка. В большинстве императивных языков есть такая концепция как <em>модуль</em>, который представляет из себя некоторый интерфейс из набора функций, что обращаются к “внутренним” переменным в реализации модуля. Эти переменные обычно не видны за пределами модуля.</p>

<p>Идем дальше. Класс — это структура данных, которая <strong>задает</strong> внутреннее состояние <em>объекта</em> через атрибуты, и поведение объекта через методы, а так же наследуемые классы и несколько дополнительных свойств и операций.</p>

<p>Универсальное определение будет звучать так:</p>

<p class="info">Класс — это структура данных, которая описывает абстрактный тип данных и предоставляет его полную или частичную реализацию.</p>

<p>На основании класса может быть создано любое количество объектов — экземпляров класса. <strong>Отправкой сообщения объекту</strong> называют любое обращение к объекту, например вызовы методов. Такие обращения, точно так же как и обращения к функциям — синхронны, т.е. считаются завершенными только когда метод польностью закончил свою работу.</p>

<h2 id="члены-класса">Члены класса</h2>

<p>Есть три вида членов класса, из которых классы состоят:</p>

<ol>
  <li>Атрибуты. Это <em>ячейка</em>, которая содержит “часть” состояния экземпляра класса. Так же атрибуты ещё называют полями или переменными класса. Тип атрибута может быть любым допустимым в яп. В классической модели ООП атрибуты польностью скрыты внутри класса и никак недоступны извне, но свободно наследуются классами потомками.</li>
  <li>Методы. Это процедуры, привязанные к контексту <em>конкретного экземпляра класса</em> и имеющие доступ к атрибутам этого класса (объекта). Метод может иметь список параметров как обычная функция.</li>
  <li>Свойства. Задают либо специфическое поведение <em>экземпляра класса</em>, либо специфическую характеристику <em>самого класса</em>. Например, свойством может задаваться блокировка объекта (любой метод может выполняться только одним потоком, доступ других потоков к методам этого же объекта блокируется), или запрет на расширение класса <em>потомками</em>. Специальные свойства могут допускаться и для конкретных методов или атрибутов.</li>
</ol>

<h2 id="ещё-про-атрибуты">Ещё про атрибуты</h2>

<p>Атрибуты класса кроме того делятся на способы их инициализации:</p>

<ol>
  <li>Атрибут может быть инициализирован через привязку к конкретному объекту. Обычено в яп это выглядит как привязка через префиксы self или this.</li>
  <li>Атрибут может быть инициализирован с привязкой к <em>самому классу</em>. В таком случае значение атрибута во всех объектах этого класса будет одинаковым. Это так называемые <em>статические атрибуты класса</em>.</li>
  <li>Бренд — это некоторый набор классов, которые связаны друг с другом каким-то способом <em>кроме наследования</em>. Атрибуту бренда может быть присвоено общее для всех классов участников бренда через инициализацию одной и той же переменной класса. Пример — дружественные классы в С++.</li>
</ol>

<h1 id="методы-и-сообщения-первого-класса-порядка">Методы и сообщения первого класса (порядка)</h1>

<p>Сообщения — это <em>записи</em>, тогда как методы — паттерны выполняющие разбор этих записей. Когда объект получает сообщение, то для его обработки автоматически подбирается метод подходящий по всем параметрам.</p>

<p>В языке программирования Julia этот механизм реализован и называется <strong>Multiple Dispatch</strong>.</p>

<p>Выбор соответствующего метода может происходить и в момент компиляции программы в языках со статической типизацией, и во время работы программы в языках с динамической типизацией.
У такого обработчика может быть как фиксированное так и гибкое число параметров, когда к фиксированному списку параметров добавляется “…”, обозначающее заранее неизвестный список параметров произвольной длинны.</p>

<p>Метод может иметь специальное свойство “otherwise”, которое является флагом обозначающим, что в случае если никакой другой метод не подойдет для обработки сообщения его “перехватит” этот otherwise-метод. Этот метод имеет один параметр в который передается необработанное сообщение. Такой механизм реализует концепцию делегатов, что своего рода альтернатива наследованию и интерфейсам.</p>

<p>Описываемая тут концепция класса предлагает удобный синтаксис для <em>определения АТД с инкапсулированным состоянием и множеством операций</em> — классический ООП. Очень желательно в дополнении к этому синтаксису наличие поддержки “классов как значений”, чтобы сохранялись все преимущества процедурных значений. Классы здесь композиционны и могут быть вложенны в другие классы, совместимы с процедурными значениями — процедуры могут быть вложенны в классы, а классы в процедуры. Беда в том, что в поплуярных языках программирования обычно такая гибкость отсутствует.</p>

<h1 id="классы-как-инкрементальные-атд">Классы как инкрементальные АТД</h1>

<p>ООП, благодаря наследованию, позволяет определять класс постепенно через расширение уже существующих классов.</p>

<p>Недостаточно лишь отметить какие классы расширяются. Для правильного определения АТД нужно больше концепций. Разбираемая нами модель включает в себя три набора таких концепций:</p>

<ol>
  <li>Наследование, которое определяет какие уже сущетсвующие классы расширяются.</li>
  <li>Управление доступом к методам классов — как будет организован доступ к конкретным методам в новом классе и в классах выше по иерархии.</li>
  <li>Управление инкапсуляцией — определяет сопосб огранизации доступа к атрибутам и методам класса из остальной части программы (за пределами класса).</li>
</ol>

<p>Если сюда в довесок добавить поддержку сообщений первого класса (реализуем делегатов) — получаем уникальный способ <em>инкрементального определения АТД</em>.</p>

<hr />

<p>Наследование допускается как <em>единичное</em> — у класса не может быть больше одного родителя, так и <em>множественное</em>, и определяет как существующие атрибуты и методы будут доступны в новом классе.</p>

<p>Схема наследования применима и к атрибутам с методами! Это называется — <strong>связь через перезапись (overriding relation)</strong>. Метод в классе А перезаписывает любой метод с таким же именем и списком параметров определенных типов во всех находящихся выше по иерархии от класса (суперклассы А).</p>

<p>Иерархия классов представляет собой направленный граф с текущим узлом как корнем. Ребра направлены от нищестоящих классов к вышестоящим. Существует два требования корректности такой иерархии:</p>

<ol>
  <li>Отношение наследования должно быть <strong>направленным и ациклическим</strong>.</li>
  <li>После удаления всех переопределенных методов <strong>каждый оставшийся метод должен иметь уникальную сигнатуру</strong> (имя и список параметров) и быть определенным только в одном классе в иерархии.</li>
</ol>

<h2 id="статическое-и-динамическое-связывание">Статическое и динамическое связывание</h2>

<p>Когда метод выполняется “внутри” объекта зачастую приходится вызывать другой метод этого же объекта. Такой вызов можно считать <em>рекурсивным</em> относительно объекта в целом, потому что объект как бы <em>“вызывает” сам себя</em>. Если в такой ситуации допускается наследование ситуация усложняется.</p>

<p>Обычное наследование подразумевает определение нового АТД, расширяющего уже существующий АТД. Для корректной реализации этой схемы потребуется два способа поддержки рекурсивных вызовов — статическое и динамическое связывание.</p>

<p>Из за полиморфизма на этапе компиляции может не быть возможным точно определить объект какого класса хранится в той или иной переменной.</p>

<p>Динамическое связывание, когда метод связывается с конкретным классом, подразумевает, что определение нужного метода в иерархии наследования <em>выполняется непосредственно в момент обращения объекта к имени метода во время работы работы программы</em>. Этот подход не позволяет вызывать уже существующие родительские методы когда родительский АТД мы расширили новыми возможностями.</p>

<p>Статическое связывание в свою очередь подразумевает что класс, в котором находится вызываемый метод, можно определить <em>в момент компиляции</em>. Например с помощью синтаксических подсказок о имени класса через приведение типов.</p>

<h2 id="упавление-инкапсуляцией">Упавление инкапсуляцией</h2>

<p>Принцип управление инкапсуляцией заключается в ограничении доступа к атрибутам и методам класса в соответствии с архитектруными требованиями системы. Каждый член класса уточняется его областью видимости.</p>

<p>Область видимости — это часть программного кода из (в) которой виден атрибут или метод. К ним можно получить доступ по их именам. Как правило область видимости статически определяется структурой программы. Хотя она и может определяться динамически, на практике такой подход почти никогда не применяют.</p>

<p>Языка программирования обычно определяют область видимости <em>по умолчанию</em> для каждого члена класса в момент определения последнего. Эта дефолтная облась видимости может быть изменена через использование специальных ключевых слов, таких как public, private и protected. Важно понимать, что разные яп используют эти слова для определения разных областей видимости.</p>

<h3 id="универсальная-схема-видимости-членов-класса">Универсальная схема видимости членов класса</h3>

<p>Фундаментальные схемы видимости — private и public.</p>

<p>Private — член класса виден только внутри объекта.
Public — виден где угодно.
Protected — виден только внутри объекта, но так же и доступен в классах-потомках.</p>

<p>Хорошая схема, это когда атрибуты по умолчанию приватны, а методы — публичны.</p>

<p>Подход с приватными и публичными членами естественен когда классы используются для конструирования АТД.</p>

<p>Класс — это “инкремент”. <em>АТД существует сам по себе</em>, у него свои атрибуты и методы. Класс, который конструирует АТД в программе, представляет АТД как инкрементальную модификацию <em>своих суперклассов</em>.</p>

<p>Атрибуты АТД приватны — их не видно за пределами АТД, так как АТД формально задается <em>только своими методами</em>.</p>

<p>Методы определяют внешний интерфейс АТД, а это значит что они должны быть видны всем сущностям, которым этот АТД может быть необходим. Следственно видимость методов публична.</p>

<h2 id="конструирование-иных-видимостей">Конструирование иных видимостей</h2>

<p>Техники управления инкапсуляцией в коде программы основаны на двух концепциях: <em>лексической видимости</em> и <em>использовании имен</em>.</p>

<p>Приватная и публичная схемы видимости легко реализуются с помощью этих концепций. Но с их помощью можно выражать и другие, более сложные политики.</p>

<p>Основная техника заключается в организации такой схемы, когда <strong>заголовки методов могут быть именами <em>как значениями</em></strong>, а не просто жестко заданными атомами. Имя здесь — это иммутабельная константа, и единственный способ узнать его — получить ссылку на него. Из чего следует, что программа может передавать ссылку на имя контролируемым способом только в те свои области где это имя должно быть видно.</p>

<p>Выходит что атомы не являются безопасными, потому что если третья сторона, узнав программное представление атома-заголовка легко сможет вызвать сам метод.</p>

<p>Но многие современные языки поддерживают только атомы в качестве имен, и по этой причине в них добавлены эти специальные инструкции, вроде protected и private, чтобы явно ограничивать видимость.</p>

<h1 id="альтернативы-наследованию">Альтернативы наследованию</h1>

<p>Наследование часто бывает сложным для правильного использования и требует выского скила от программиста, потому что подразумевает тесную связь между классом-предком и его расширениями потомками. Поэтому иногда лучше использовать более свободные подходы:</p>

<ol>
  <li>Переадресацию</li>
  <li>и Делегирование.</li>
</ol>

<p>Оба подхода определяются на уровне объекта — в случае, если объект А не принимает сообщение Х, то оно прозрачно передаются другому объекту B.</p>

<p>Эти подходы отличаются в способах, которыми они обрабатывают self\this.</p>

<p><strong>При переадресации объекты А и В работают со своими собственными <em>оригинальными</em> self</strong>.</p>

<p><strong>При делегировании есть только одна сущность А, и обращение к self внутри B <em>подразумевает self из А</em></strong>.</p>

<p>Короче, делегирование как и наследование подразумавают какой то общий self, а переадресация — не подразумевает общего self.</p>

<p>Делегирование является мощным механизмом структурирования системы динамически через <em>конструирование иерархии <strong>объектов</strong>, а не классов</em>. По сути эффект получаем как у наследования, но есть два важных отличия:</p>

<ul>
  <li>Иерархия строится между объектами, а не между классами;</li>
  <li>Из чего следует, что иерархия может быть изменена в любой момент работы программы.</li>
</ul>

<p>В цепочке делегирования self всегда остается self’ом исходного объекта, из чего следует что состояние “текущего” объекта, т.е. его атрибуты — будут состоянием и исходного объекта. Получается что другие объекты в цепочке делегирования <em>играют роль классов</em> — <strong>только их методы важны при делегировании, а не значения атрибутов</strong>.</p>

<h1 id="рефлексия">Рефлексия</h1>

<p>Система будет считаться рефлексивной, <em>когда она может проверять части своего состояния прямо в момент работы</em>. Рефлексия может быть чисто интроспективной (только читаем состояние), или интрузивной (и читаем, и можем писать). Рефлексия может выполняться как на высоком так и на низком уровне абстрации.</p>

<p>Пример рефлексии на высоком уровне — возможность рассматривать элементы в стеке как <em>замыкания</em>. Такой пример можно объяснить в терминах абстрактной машины.
Рефлексия на низком уровне — это способность обращаться к оперативной памяти программы напрямую, как к массиву целых чисел. Не сущетсвует простого способа вырзить такую рефлексию в абстрактной машине :)</p>

<h1 id="мета-объектные-протоколы">Мета-объектные протоколы</h1>

<p>Благодаря крайне широкому потенциалу ООП предоставляет огромное поле для экспериментов. Наприме, система может позволять рефлексивное изучение или даже <em>изменение</em> иерархии наследования во время работы программы! Или вот ещё — можно изменять работу самих объектов на базовом уровне, например, работу наследования (то как происходит поиск методов в иерархии классов), или механизм вызова методов.</p>

<p>Определение того как именно объектная система будет функционировать на таких базовых уровнях называется <strong>мета-объектным протоколом</strong>. Эти протоколы используются в различных целях: для отладки, конфигурирования, разделения концепций (прозрачно добавить шифрование, изменить формат вызова метода и тд).</p>

<p>Общая схема мета-объектных протоклов представляет собой “оборачивание” методов дополнительным кодом для перехвата каждого вызова метода, например в целях выполнения определенной операции перед этим вызовом или после его завершения, изменения аргументов вызова, и так далее.</p>

<p>Первоначально мета-объектные протоколы были изобретены в рамках объектной системы Common Lisp Object System (CLOS) и остаются до сих пор бурной областью исследования ООП.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="ООП" /><summary type="html"><![CDATA[Врубаемся в модель ООП. Часть 1.]]></summary></entry><entry xml:lang="ru"><title type="html">Передача параметров, коллекции и инварианты</title><link href="http://localhost:4000/2022/06/26/hack_in_imperative_3.html" rel="alternate" type="text/html" title="Передача параметров, коллекции и инварианты" /><published>2022-06-26T00:00:00+03:00</published><updated>2022-06-26T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/26/hack_in_imperative_3</id><content type="html" xml:base="http://localhost:4000/2022/06/26/hack_in_imperative_3.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 3.
<!--more--> 
<a href="/2022/06/06/hack_in_imperative_2.html">Читать предыдущую часть.</a></p>

<p>Сегодня продолжим ровно с того момента на котором остановились. А остановились мы комбинациях аспектов АТД.</p>

<h3 id="защищённый-декларативный-распакованный">Защищённый, декларативный, распакованный</h3>

<p>Защищенный декларативный распакованный АТД, и собственно сам способ его <em>защиты</em> мы разбирали в заключительной части постов про Декларативную модель. Идея там заключалась в истользовании функций оберки и развертки (wrap/unwrap) с ключем, который знают только “авторизованные” нами части программы.</p>

<p>Если взять АТД стек, то все его методы по сути работают через эти функции. Метод создания нового стека автоматически будет возвращать “заврапленный” стек, проверка верхнего элемента в стеке и стека на пустотность обладают нужным ключем и внутри автоматически выполняют unwrap. Ну и заталкивание с выталкиванием элементов тоже модифицируют результирующий стек сначала Unwrap’нув внутренности, и за’Wrap’ив новый список (стек). Мы помним что это декларативная модель, и по этому по сути после каждой такой операции мы получаем новую сущность.</p>

<h3 id="защищённый-декларативный-запакованный">Защищённый, декларативный, запакованный</h3>

<p>Напоминаю что <em>запакованный</em> АТД, это такой у которого данные хранятся вместе с операциями над ними.</p>

<p>Реализовать это в рамках декларативной модели можно <em>спрятав стек внутри самих операций</em> через лексическое замыкание. В таком случае стек от операций просто нельзя никак отделить. В таком случае синтаксис становится похожим на знакомый ООП:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stack_1 = create_stack()
stack_1.is_empty()
stack_2 = stack_1.pop_out(X)
</code></pre></div></div>

<p>И так далее. Каждый метод возвращает новый стек не изменяя текущий. Wrap/Unwrap тут не нужны, потому что реализация <em>запакована</em> — результатом мы получаем “объект”, а не какой-то определенный стек, внутрь которого никак нельзя заглянуть.</p>

<p>Декларативной модели придерживаемся? Да. 
Явное состояние для безопасности подобного АТД нужно? Нет, не нужно! Нам хватает техники программирования высшего порядка.</p>

<h3 id="защищенные-stateful-реализации">Защищенные stateful реализации</h3>

<p>Запакованный вариант это по сути классическое ООП c АТД. У нас есть объект в котором во внутреннем поле содержится структура данных, например опять связанный список, если мы продолжаем в качестве примера использовать стек. Это внутреннее поле инкапсулировано, а у объекта есть методы для доступа и изменения этого поля.</p>

<p>Распакованный вариант редко применяется в ООП и ФП. Такой вариант не требует программирования высшего порядка. Здесь все операции АТД требуют в качестве одного параметра стек. Они не создают новых объектов и работают (модицируют) только с этим аргументом. Wrap тут используется при создании нового стека, а все остальные операции получают доступ к внутренностям через Unwrap.</p>

<h1 id="передача-параметров">Передача параметров</h1>

<p>Разобравшись с понятием явного состояния теперь нам нужно уделить внимание способам передачи параметров.</p>

<h2 id="call-by-reference">Call by reference</h2>

<p>Передача по ссылке — это когда процедуре передается <em>идентификатор</em> какой то сущности языка. После этого процедура может эту сущность свободно использовать в вычислениях в своем теле, обращаясь к сущности по переданному в параметрах идентификаторе. Это примитивный, но повсеместно используемый механизм в различных вычислительнях моделях, <em>фактически для всех сущностей языков программирования</em>.</p>

<p>Тем не менее императивные яп достаточно часто под передачей по ссылке имеют в виду что-то другое. Например они предполагают что идентификатор хранится в ячейке локальной для рассматриваемой процедуры. Короче, то что параметр функции является локальной переменной для этой функции. Строго говоря, такое поведение формально является <em>передачей по значению</em>, так как ссылка-идентификатор рассматривается как значение.</p>

<h2 id="call-by-variable">Call by variable</h2>

<p>Передача через переменную это особая версия передачи по ссылке. Идентификатор <em>ячейки</em> передаем в процедуру, и внутри процедуры этот идентификатор становится синонимом имени-параметра ячейки. В отличие от обычной передачи по ссылке в качестве параметра используется не оригинальный идентификатор ячейки, а <em>алиас</em>. При том этот алиас не является локальной переменной внутри функции (куда копируется ссылка), а представляет собой по сути синтаксический сахар.</p>

<h2 id="call-by-value">Call by value</h2>

<p>Передача по значению — значение передается в процедуру в ячейку-параметр, которая является локальной для этой процедуры. Реализация может быть либо через копирование значения целиком, либо через передачу лишь ссылки. Это неважно, потому что формально процедура не может никаким образом изменять внешние по отношению к себе значения (за пределами своего скоупа), даже если эти значения передаются по ссылке.</p>

<h2 id="call-by-value-result">Call by value-result</h2>

<p>Передача по значению-результату — это версия передачи через переменную, которая используется для <em>возвращения значения через параметр</em>. При вызове процедуры содержимое мутабельной ячейки помещается в другую, локальную для процедуры мутабельную переменную. Над этой переменной проиходят описанные вычисления, результат которых (при завершении процедуры) из локальной переменной перемещается обратно в изначальную ячейку.</p>

<h2 id="call-by-name">Call by name</h2>

<p>Передача по имени — это такой общий случай, когда для всех аргументов создаются отдельные процедурные значения. Называют их <strong>thunk</strong>, или преобразователь (или переходник…). Этот преобразователь вычисляется каждый раз когда в вычислениях запрашивается соответствующий аргумент, и возвращает имя ячейки — адрес нужной мутабельной переменной. Вообще thunk это <em>функция</em>, и в случае когда аргментами являются индексы цикла возможны сложные ситуации из за многократного перевычисления индексов.</p>

<h2 id="call-by-need">Call by need</h2>

<p>Передача по необходимости — это версия передачи по имени, в которой процедурное значение вычисляется единожды. Аргумент процедуры вычисляется тогда, когда запрашивается результат, после чего он сохраняется в замыкании (локальная переменная). При следующих обращениях к процедуре в качестве аргумента будет использоваться уже вычисленное значение из замыкания.</p>

<h1 id="stateful-коллекции">Stateful коллекции</h1>

<p>Коллекция является важной разновидностью АТД. Коллекции группируют вместе набор значений в единую сущность-контейнер. У коллекций есть две важные характеристики:</p>

<ul>
  <li>Поддержка индексации;</li>
  <li>Хранение фиксированного или переменного количества значений.</li>
</ul>

<h2 id="индексированные-коллекции">Индексированные коллекции</h2>

<p>Индексированные коллекции в декларативной модели — кортежи и записи. А их stateful версии — это массивы и словари.</p>

<p><strong>Массив</strong> — это коллекция конкретных значений которым однозначно соответствует ряд целых чисел (индексы). Область определения, или домен массива — это набор последовательных целых чисел от нижней до верхней границ массива. Домен массива задается при его объявлении <em>и не может быть изменен после этого</em>. Наиболее часто нижней границей является ноль, иногда с единицы (например в языках Julia, Fortran, R, и др.). Изредка допускаются отрицательные значения.</p>

<p>Доступ к эллементам массива и их изменение выполняются за константное O(1) время.</p>

<p><strong>Словарь</strong> — это коллекция из простых констант (имена, целые числа, атомы) однозначно соответствующих конкретным значениям. Домен словаря может спокойно изменяться в процессе его использования. Каждый элемент словаря представляет собой пару ключ-значение. Менять ключи в существующем элементе нельзя.</p>

<p>Доступ и изменение тут тоже выполняется за O(1), чаще всего это реализуется посредством хэш-таблиц.</p>

<p>Словари и записи очень похожи. Оба типа раскладывают простые константные ключи в соответствующие значения. Основное их отличие в том, что записи — stateless, а словари — stateful. У записей может быть фиксированный, неизменяемый набор ключей-значений, а в словарях их можно произвольно менять.</p>

<hr />

<p>Хотя кортежи, записи, массивы и словари обеспечивают доступ к эллементам за константное время, в остальном их продуктивность отличается.</p>

<p><em>Кортежи</em> самые ограниченные, но зато работают очень быстро и требуют мало памяти по сравнению с остальными типами индексирумых коллекций. Содержимое кортежей не может меняться, значения в них хранятся последовательно. Доступ по индексу, всегда лежащему в диапазоне от 1 до N — очень прост.</p>

<p><em>Записи</em> заметно более гибки в сравнении с кортежами, потому что в качестве индексов можно использовать любые литералы и числа. Числа-индексы тут не обязаны принадлежать к какому то конкретному диапазону. Значения хранятся последовательно — при создании записи генерируется хэш-таблица, которая преабразует ключи поля записи в его сдвиг в последовательности значений.</p>

<p><em>Массивы</em> допускают ещё большую гибкость и предоставляют возможность менять содержимое значений. Эффективность этого типа всё ещё остается высокой, из за того что значения хранятся последовательно, диапазон индексеов заранее известен и не меняется, а позиции конкретных элементов в памяти вычислятся быстро.</p>

<p><em>Словари</em> — самый общий случай индексированной коллекции. Словари комбинируют в себе возможности записей и массивов. Изначально словарь создается пустым без какого либо явно заданного диапазона индексов. Это наименее эффективная структура данных по времени доступа к эллементам и обновлению содержимого. Словари часто реализуются на динамических хэш-таблицах.</p>

<h2 id="неидексируемые-коллекции">Неидексируемые коллекции</h2>

<p>Есть две самые распространенные неидексируемые коллекции:</p>
<ul>
  <li><em>Потоки</em>;</li>
  <li><em>Списки</em>.</li>
</ul>

<p>Эти оба типа данных по сути хранят в себе линейные последовательности, могут последовательно перебираться от головы до хвоста. Кроме того одновременно над ним таки переборов может происходить любое количество. Хотя есть исключения из этого правила — <em>не всегда может допускаться повторный перебор с нуля</em>, например в потоках ввода-вывода.</p>

<p>Список от потока отличается тем, что список в момент времени имеет фактический хвост. Длина списка фиксирована. А поток это своего рода “незавершенный” список. Хвост потока может быть <em>несвязанной переменной</em>. Получается что поток можно всегда расширить как список. По эффективности использования памяти и по времени работы поток является одной из самых эффективных <strong>расширяемых коллекций</strong>.</p>

<h3 id="расширяемые-коллекции">Расширяемые коллекции</h3>

<p>Поток эффективно расширяется, но вот доступ к его эллементам работает за О(N), если в реализации вообще присутствует возможность доступа к произвольному элементу, а не только последовательный перебор. <em>Словарь</em>, который мы уже рассмотрели, это тоже расширяемая коллекция. Но расширение словаря само по себе уже происходит за неконстантное время.</p>

<p>Ещё один вид расширяемой коллекции это <em>динамический массив</em>. По сути это всё ещё массив, точнее <em>внутренний буфер</em> в котором хранятся элементы динамического массива — обычный массив. Но когда в буфере динамического массива полностью или почти полностью заканчивается место его буфер расширяется. Этот процесс расширения называется <em>релокацией массива</em>.</p>

<p>Существуют две схемы релокации:</p>
<ul>
  <li>Аддитивная;</li>
  <li>Мультипликативная.</li>
</ul>

<p>Аддитивная схема эффективна и применяется когда размер массива не очень большой, и как следствие расходы ресурсов на релокацию малы. Здесь увеличение происходит небольшими и фиксированными кусочками.</p>

<p>Мультипликативная схема релокации в свою очередь работает иначе. В этом случае размер буфера существенно увеличивается — в несколько раз. Эта схема применяется в случае когда размер массива большой, потому что его релоцирование требует много ресурсов. Обычно в этой схеме размер буфера просто удваивается, хотя возможны другие варианты, например — золотое сечение (увеличение буфера в 1.1618 раз)</p>

<p>Вычисления по которым буфер динамического массива сильно зависят от конкретно решаемой задачи.</p>

<p>Амортизационное время расширения динамического массива значительно лучше чем у словарей, при этом у нас сохраняется доступ к произвольным эллементам за O(1).</p>

<h1 id="инвариативные-утверждения">Инвариативные утверждения</h1>

<p>А вот это очень важная штука!</p>

<p>Мы разобрались с тем что появление в вычислительной модели явных состояний может вызывать проблемы. В частности снижается способность рассуждать и программе и вообще её понимать, особенно когда состояния используются бессистемно.</p>

<p>Когда состояние гуляет по всей программе, доступно всем частям, то такое состояние может быть модифицировано где угодно в этой программе. И че делать? Смотреть код от корки до корки, пытаясь проследить в каком месте в какой момент времени что, по идее, должно быть в этом состоянии? Бррр.</p>

<p>Представьте что это не скрипт на 200 строк а программная система на 200 тысяч строк.</p>

<p>Есть отличная джедайская техника, которая позволяет взять stateful-сложность под <em>линейный контроль</em>. Имя ей — “<em>Инвариативные утверждения (invariant assertions)</em>”. Метод применим для программ в которых есть и императивная (с состояниями) и декларативная части.</p>

<p>Декларативные части проверяются логическими выражениями — утверждениями, или assert-проверками.</p>

<p>Техника таких в computer science известка как <em>аксиоматическая семантика</em>, когда семантика всех конструкций языка программирования определяется через набор правил (аксиом). Вообще не сюрприз что это было разработано “святой троицей” —  Флойд, Хоар и Дейкстра в семидесятые годы. Тогда вообще много чего хорошего изобрели :)</p>

<p>В общем, используя метод инвариативных утверждений мы становимся способны рассуждать о каждой части программы независимо от других частей. Тем самым, даже если в системе используются состояния мы сохраняем одну из самых сильных фишек декларативной вычислительной модели: понимание всей системы является линейной суммой понимания подсистем.</p>

<p>Платим кровью — вся программа должна быть строго формально организованна на ассертах.</p>

<p>Ключевая мысль тут это то что система <em>организовывается как иерархия АТД</em>. АТД могут использовать другие АТД для своей реализации. Этот более глубокий подход чем наследование в классическом ООП.</p>

<p>Каждый АТД в подобной системе специфицируется набором инвариативных утверждений.</p>

<p><strong>Инвариант</strong> — это логическое утверждение которым мы четко определяем как связанно внутреннее состояние АТД с его аргументами. Каждая операция абстрактного типа данных <em>заранее предполагает</em> истинность одного инварианта, а по завершению эта операция <em>гарантирует истинность другого инварианта</em>. Эта истинность гарантируется программной реализацией операции.</p>

<h2 id="утверждения">Утверждения</h2>

<p>Инварианты реализуются благодаря такому понятию как asserion — утверждения.</p>

<p>Утверждение — это логическое выражение, которое располагается <em>между двумя инструкциями кода</em>. Это может быть вычисление булевого значения, или утверждения могут содержать переменные и идентификаторы ячеек используемых в коде. Кроме того они могут содержать вообще переменные и <em>кванторы</em> которые не встречаются в языке программирования, и используются только для выражений конретного проверяемого отношения.</p>

<p>Классические кванторы:</p>
<ul>
  <li>Квантор всеобщности “для всех…” — <strong>∀</strong>;</li>
  <li>Квантор существования “существует хотя бы один…” — <strong>∃</strong>.</li>
</ul>

<h2 id="утверждения-частичной-корректности">Утверждения частичной корректности</h2>

<p>Пусть каждая <strong>Oi</strong> операция АТД специфицурется двумя утверждениями <strong>Ai</strong> и <strong>Bi</strong>. Спецификация утверждается, что в случае когда инвариант <strong>Ai</strong> является истинным перед выполнением операции <strong>Oi</strong>, то по завершению <strong>Oi</strong> инваиант <strong>Bi</strong> будет истинным.</p>

<p>Это можно записать как: {Ai} Oi {Bi}, а называться такое утверждение будет <em>утверждением частичной корректности</em>. Частичное оно потому что всё утверждение будет корректным только в том случае, когда Oi завершится нормально (без рейзов исключений и прочих нежелательных ситуаций).</p>

<p><strong>Ai</strong> называется предусловием, а <strong>Bi</strong> — постусловием.</p>

<p>Полная спецификация абстрактного типа данных складывается из утверждений частичной корректности для <em>всех операций</em> этого АТД.</p>

<p>Как доказать корректность реализации самого АТД, даже если он формально описан? Для этого нужно доказать корректность реализации самих (всех) утверждений частичной корректности операций этого АТД. Когда нибудь я доберусь до пруф-чекеров , но пока это “глубокая кроличья нора” :)</p>

<h3 id="нормальный-я-нормальный">Нормальный, я нормальный!</h3>

<p>Утверждения частичной корректности, пусть они описаны для всех операций всех АТД в программе, ничего не гаранитируют нам в плане корректности завершения программы целиком. Они лишь фиксируют истинность тех или иных утверждений когда программа завершилась нормально.</p>

<p><em>Нам нужно доказать что программа вообще завершается.</em></p>

<p>Ненормальные случаи завершения это:</p>
<ol>
  <li>Провалились в бесконечный цикл;</li>
  <li>Вычисления заблокировались, когда dataflow-переменная не связалась со значением. Возникает при ошибках программиста или в ситуацих блокировок;</li>
  <li>Вычисления завершились с исключением.</li>
</ol>

<p>А теперь разберем что нужно делать в каждом из случаев выше.</p>
<ol>
  <li>Всегда когда в программе присутствует использование цикла без ограничения (цикл while или рекурсивные вызовы) есть риск что он никогда не завершится. Для того чтобы убедиться что такой цикл завершится нам достаточно доказать, что условие завершения цикла — это функция, которая неотрицательна и всегда убывает от итерации к итерации. Иными словами — нужно убедиться, что на каждой итерации цикла <em>уменьшается будущее пространство расчета</em>.</li>
  <li>Должно быть доказано то, что все переменные в программе становятся связанными со значениями до начала использования этих переменных. Для каждого использования переменной нужно проследить в обратном порядке все пути обращения к ней, и убедиться что в самом начале все эти пути выходят на связывание со значением.</li>
  <li>Самая частая причина исключений это <em>конфликты типов</em>. Поэтому нужно стараться избегать любых явных и неявных преобразований типов данных, включать по максимуму тайп чекеры на уровне компилятора и среды выполнения.</li>
</ol>

<hr />

<p>Притормозим. Оставшаяся часть курса про programming in large, и я обязательно напишу об этом в следующий или другой раз.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 3.]]></summary></entry><entry xml:lang="ru"><title type="html">Про Маршрутизацию и протоколы L1-L3</title><link href="http://localhost:4000/2022/06/19/TCP_UDP_and_something_else.html" rel="alternate" type="text/html" title="Про Маршрутизацию и протоколы L1-L3" /><published>2022-06-19T00:00:00+03:00</published><updated>2022-06-19T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/19/TCP_UDP_and_something_else</id><content type="html" xml:base="http://localhost:4000/2022/06/19/TCP_UDP_and_something_else.html"><![CDATA[<p>Немного про модель OSI и работу элементарной канальной среды.
<!--more--></p>

<h1 id="м-м-маршрутизация">М-м-маршрутизация!</h1>

<p>Роутеры нужны для маршрутизации трафика между канальными средами. Теоретически мы можем построить только на коммутаторах одну огромную канальную среду. Но из <a href="/2022/06/13/OSI_and_switches.html">прошлого поста</a> мы знаем про юникаст флуд. Представьте себе сколько ARP и MAC кадров будет получать каждый участник сети? Представьте что в такой сети 20 тысяч компьютеров… А если миллион?</p>

<p>Для этого того чтобы избавиться от лишней нагрузки на сеть нужно разделять большую сеть на разумно организованные канальные среды с помощью маршрутизаторов (роутеров).</p>

<p>Если у коммутаторов по умолчанию всё включено и работает “из коробки” — воткнул витые пары и забыл. То с роутером так не работает. Роутер из коробки ничего не знает и с кадрами работает не так как участники обычной канальной среды. Роутеру нужно указывать с каким его портом какая канальная среда живет, какой у этой среды <em>gateway</em>.</p>

<h2 id="что-такое-gateway">Что такое gateway?</h2>

<p>Gateway это адрес шлюза (по сути роутера), который занимается перекладыванием трафика между одной канальной средой и другой. Проще сказать — это адрес интерфейса маршрутизатора, назначенного на ту подсеть (канальную среду) в которой мы находимся. Когда компьютер отправитель трафика “видит” что целевой адрес находится в другой подсети, он “понимает” что в этом случае достучаться по мак адресу не получится, и шлет тогда не канальные кадры, а уже IP пакеты на шлюз. Роутер же в свою очередь получив пакет перенаправлет его на интерфейс соответствующей целевой канальной среды по IP адресу получателя.</p>

<p>Првда в пределах своей канальной среды отправитель шлет эти пакеты на роутер все равно по MAC адресу, только MAC получателя тут не MAC фактического получателя трафика, а физический адрес роутера-шлюза.</p>

<p>Но как отправитель всё это “видит” и “понимает”? Для этого используется <em>маска подсети</em>.</p>

<h2 id="что-такое-маска-подсети">Что такое маска подсети?</h2>

<p>Маска подсети определяет какая часть IP адреса относится к <em>адресу сети</em> а какая к <em>адресам хостов</em>.</p>

<p>Возьмем два одинаковых IP адреса, но с разными масками:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.15.20/24
192.168.15.20/16
</code></pre></div></div>

<p>В первом случае, при использования 24-ой (255.255.255.0) маски <em>первые три октета</em> относятся к адресу сети а последний к адресу хоста.</p>

<p>Во втором случае у нас маска 16, это значит что первые <em>два</em> октета относятся к адресу сети, а вторая пара к адресу хоста.</p>

<p>Иными словами и более просто — маска подсети указывает отправителю на то <em>сколько октетов адреса получателя нужно сравнивать с октетами <strong>своего</strong> IP адреса</em>, чтобы понять в <em>своей канальной среде</em> этот получатель находится, или нет.</p>

<p>Вернемся к маршрутизатору и рассмотрим простой пример.</p>

<p>Например у отправителя адрес 192.168.0.10 и маска подсети 255.255.255.0, а у получателя 172.20.20.20 и маска <em>такая же</em>. Отправитель согласно своей маске поймет что адрес получателя находится в другой канальной среде (октеты не совпали) и будет искать в своей сети <em>MAC адрес маршрутизатора</em> (основной шлюз, gateway) выполнив широковещательный ARP запрос (если в его таблице ещё нет MAC адреса маршрутизатора).</p>

<p>Получив в ответном ARP кадре от роутера его адрес, компьютер отправитель отправит <em>пакет</em> (не канальный кадр!) на MAC адрес роутера.</p>

<p>Получив пакет на свой MAC адрес роутер видит IP адрес получателя, понимает что нужно перенаправить трафик в другую канальную среду, но для этого ему нужен MAC получателя. Поэтому уже по хорошо известной нам схеме роутер ARP бродкастом будет искать MAC получателя в целевой канальной среде.</p>

<h1 id="ip-адреса">IP адреса</h1>

<p>В отличие от MAC адресов, IPv4 адреса представляются в десятеричной системе исчисления и состоит из четырех <em>октетов</em> разделяемых точками. Каждый октет является числом из 8 бит (1 байт). Компьютеры видят эти числа (да и вообще всё :D) в двоичной системе исчисления.</p>

<p>IP адреса делятся на частные и публичные диапазоны.</p>

<p>Наиболее часто используемые сетевыми инженерами диапазоны частных IP адресов:</p>
<ul>
  <li>10.0.0.0/8 (всё что начинается с 10);</li>
  <li>172.16.0.0/12 (всё что начинается с 172.16.0.0 по 172.31.255.255);</li>
  <li>192.168.0.0.16 (всё что начинается с 192.168.0.0 по 192.168.255.255).</li>
</ul>

<p>Эти IP адреса не маршрутизируются в интернет и используются только в локальных сетях (например в каких нибудь организациях), виртуальных сетях инфраструктур облачных провайдеров и так далее. Имейте в виду что нам никто не запрщает в локальной сети придумать какой угодно адрес, но он всё равно останется частным. Список выше представлен лишь самыми популярными диапазонами. Правда есть несколько исключений! Это специальные зарезервированные адреса которые либо не получится вообще назначить, либо не будут работать (вообще или возможны проблемы):</p>

<ul>
  <li>127.0.0.0-127.255.255.255 — это loopback адреса по которым хост общается сам с собой;</li>
  <li>169.254.0.0-169.254.255.255 — Automatic Private IP Adressing (APIPA), это автоматические адреса генерируемые в винде службой APIPA.</li>
  <li>0.0.0.0 и любые адреса с нуля либо не будут вообще работать, либо система не даст их назначить на устройстве. Такие адреса используются по умолчанию сетевыми устройствами, например когда у них ещё никакой адрес не назначен;</li>
  <li>255.255.255.255 — широковещательный адрес (и любой другой, в зависимости от маски);</li>
  <li>224.0.0.0-247.255.255.255 — мультикаст диапазон;</li>
  <li>248-255.х.х.х — адреса зарезервированные для целей тестирования сетей;</li>
  <li>x.x.x.0 или x.x.0.0 — адреса сетей (в случае “нормальных” масок);</li>
  <li>x.x.x.255 или x.x.255.255 (и тд) — широковещательные адреса сети (в случае “нормальных” масок).</li>
</ul>

<p>Публичные IP адреса напротив — маршрутизируются в интернете, то есть доступны в интернете практически откуда угодно.</p>

<p>Контроль и выдача публичных адресов регулируется целой цепочкой специальных организаций. Если вдруг вам понадобится IP адрес для публичного сервера, вам придется запросить его у своего интернет провайдера, который в свою очередь получает набор таких адресов от LIR, а те от RIR. RIR от IANA. А IANA наконец от ICANN. Благодаря этой цепочке контроля достигается уникальность каждого публичного IP адреса в интернете.</p>

<p>Если ваш потенциальный сервер будет “путешествовать”, вам не хотелось бы терять публичны адрес выданный интернет провайдером. В таком случае можно получить <em>провайдеро независимый IP</em> обратившись в LIR напрямую.</p>

<p>Я не очень хочу тут отвлекаться на описание этих организаций, смело гуглите аббревиатуры.</p>

<p>И ещё раз закрепим — зная маску мы (и в двоичном виде компьютер) можем определить адрес подсети. Например 192.168.15.20/24 будет находится в подсети 192.168.15.0, так как маска у нас 24 (первые три октета). Такой адрес подсети мы не можем назначить на какой-то узел самостоятельно. При такой маске адреса хостов будут находиться в диапазоне 192.168.15.1 по 192.168.15.254.</p>

<p>Но куда делся 255?</p>

<p>192.168.15.255 в нашем случае будет служебным, <em>широковещательным</em> IP адресом, по которому узлы могут отправлять пакеты всем хостам в своем домене.</p>

<h2 id="более-сложные-маски-подсети">Более сложные маски подсети</h2>

<p>Иногда границы подсетей проходят по не таким “ровным” маскам, которые мы уже рассмотрели.</p>

<p>Например мы можем встретить IP адрес с такой маской — 255.255.255.192</p>

<p>Что это такое и что с этим вообще делать?</p>

<p>Сперва нам нужно перевести эту маску в двоичную систему исчисления. Получается 11111111.11111111.11111111.11000000, значит это 26-ая маска. Да, в сокращенном формате маска это просто количество единиц в двоичном представлении. Важно чтобы в маске <em>единицы шли подряд</em>, иначе IP маска просто не будет работать. Компьютер не поймет сколько бит адреса нужно брать для сравнения.</p>

<p>Имеем, например, адрес 192.168.15.87 /26
Мы точно знаем что первые три октета оносятся к сети (маска больше 24). Но что с оставшимся октетом?</p>

<p>Чтобы найти границу подсети нужно перевести IP адрес в двоичный вид. Получаем 11000000.10101000.00001111.01010111
Ну, собственно и всё. Зная что у нас маска 26 мы понимаем что адрес сети будет составлять первые 26 бит. Отсчитываем 26 и отбрасываем всё что осталось: 11000000.10101000.00001111.01 | 010111 -&gt; всё что отбрасываем заменяем нулями и получаем адрес подсети: 11000000.10101000.00001111.01000000. Переведем его в десятичную. Получается 192.168.15.64, а значит адресом первого хоста в этой подсети будет 192.168.15.65.</p>

<p>Чтобы понять каким будет последний адрес в этой канальной серед нам сперва нужно вычислить её широковещательный адрес. Для этого мы снова берем последний октет адреса подсети, но ту часть которую мы отбрасывали и превращали в нули, наоборот — обозначаем единицами. Получаем 11000000.10101000.00001111.01111111, что в десятичной 192.168.15.127</p>

<p>Значит адрес последнего хоста в подсети будет 192.168.15.126, а 192.168.15.128 уже адресом другой подсети.
Итого диапазон адресов хостов получается 192.169.15.65-126</p>

<h1 id="osi-vs-tcpip">OSI vs TCP/IP</h1>

<p>При инкапсуляции изначальные, читаемые человеком данные дополняются заголовками протоколов на каждом уровне. В итоге на физическом уровне весь этот пирог передается в бинарном виде, а получатель начинает декапсулировать пирог обратно отрезая от него на каждом уровне нужные заголовки по пути выполняя преобразования данных возвращая их к изначальному виду.</p>

<p>На транспортном уровне появляется такое понятие как порт. Этот уровень определяет возможность устройствам “понять” какая последовательность бит передаваемых по сети какому приложению адресована.</p>

<p>TCP/IP модель на самом деле то же самое что OSI. В TCP/IP работают все те же самые протоколы, но это более обобщенная форма понимания сетевого взаимподействия. В TCP/IP стеке сетевая модель делится на 4 уровня:</p>
<ul>
  <li>Link уровень, это по сути физический и канальный уровень OSI;</li>
  <li>Internet — тоже самое что уровень Network, то есть сетевой в OSI;</li>
  <li>Transport уровень называется так же;</li>
  <li>А вот последние три уровня модели OSI: Application, Presentation и Session в понимании TCP/IP объединяются в один прикладной уровень (Application).</li>
</ul>

<p>Главное что здесь нужно понять это то что обе модели по факту одно и то же, и представляют собой лишь разное <em>логическое</em> понимание, разное логическое разделение уровней процессов которые происходят при сетевой передаче данных.</p>

<h1 id="заголовок-ethernet-l2-header">Заголовок Ethernet (L2 Header)</h1>

<p>Протокол Ethernet работает на канальном уровне. Заголовок этого протокола называется Ethernet кадром. Он определяет каким образом данные будут передаваться в одной канальной среде.</p>

<p style="text-align: center;"><img src="/images/Ethernet_Frame.jpg" alt="Кадр Ethernet" /></p>

<p>Разберемся с полями заголовка:</p>

<ul>
  <li>
    <p>Преамбула является идентификатором начала передачи кадра. Больший смысл эта часть кадра имела раньше, когда использовалась общая шина. Преамбула была своего рода предупреждающим “криком” для всех остальных участников канальной среды, вроде “Эй! Я сейчас буду кадр слать, помолчите все!”. Короче чтобы занять среду для вещания.</p>
  </li>
  <li>
    <p>Потом идут MAC адреса получателя и следом за ним отправителя, каждый из которых размером в 6 байт. Порядок физических адресов в заголовке обусловлен тем что есть такая технология как Cut-Through. Эта технология поддерживаеся некоторыми свитчами и позволяет не помещать весь получаемый кадр в буфер, а сразу “налету” перекладывать кадр в нужный исходящий буфер. Перекладывать получается быстрее, потому что адрес получателя находится ближе к “голове” кадра, чем оставшаяся часть. Таким образом свитч чисто физически быстрее видит адрес получателя и передает кадры куда надо. “Глупые” свитчи не умеют в Cut-Through и сначала помещают данные в буфер целиком.</p>
  </li>
  <li>
    <p>2-х байтовый заголовок “Тип(длинна)” в наше время содержит информацию о длинне передаваемых данных. Раньше в этом заголовке указывался тип передаваемых данных, что служило маркером для передачи кадров обработчикам соответствующих типов. Поле длинна находится перед данными для того чтобы получатель мог понять в какой момент в кадре закончатся данные и начнется чексумма.</p>
  </li>
  <li>
    <p>Следующее поле самое большое по размеру и содержит данные. Вместе с ними в это поле добавляются значения SNAP/LLC. SNAP — это Subnet Access Protocol, не слишком вдаваясь в подробности, это вложение в поле с данными служит для инкапсуляции, а именно как идентификатор того какому протоколу нужно передавать данные из кадра на уровень выше. <em>Обратите внимание на то, что это поле по умолчанию ограничено размером в 1500 байт.</em> Это ограничение продиктовано тем что необходимо эффективно (точно) вычислять чексумму. Тем не менее этот показатель можно увеличить. Это конфигурируется на сетевых устройствах параметром MTU (Maximum transmission unit). При увеличении MTU мы повышаем скорость работы сети, так как каждый из кадров начинает вмещать в себя больше данных, но важно помнить о том что мы тем самым понижаем эффективность вычисления чексуммы.</p>
  </li>
  <li>
    <p>В самом конце кадра находится чексумма (FCS) — остаток от деления битовой последовательности всего кадра на 2**32 - 1 (за исключением преамбулы). Чексумма нужна для того чтобы получатель мог проверить кадр на целостность (не побилась ли битовая последовательность при передачи по сети).</p>
  </li>
</ul>

<h1 id="заголовок-ip-l3-header">Заголовок IP (L3 Header)</h1>

<p>Переходим к сетевому уровню. На предыдущем уровне мы передавали данные в пределах одной канальной серды и заголовок Ethernet выглядит достаточно просто. Теперь задача усложняется, вступает в полную силу в работу протокол IP, данные теперь нужно как-то маршрутизировать между сетями.</p>

<p style="text-align: center;"><img src="/images/IP_Header.jpg" alt="Кадр Ethernet" /></p>

<p>Разберемся с тем что тут есть.</p>

<ul>
  <li>
    <p>Версия - IPv4 или IPv6.</p>
  </li>
  <li>
    <p>IHL - содержит размер самого заголовка (всё кроме данных). Почему тут есть такое поле а в заголовке предыдущего увроня такого не было? Потому что размеры заголовка IP не фиксированы и могут отличаться от случая к случаю (могут быть Опции).</p>
  </li>
  <li>
    <p>Тип обслуживания используется для различных сетевых механизмов. Например для механизма очередей и других которые могут быть имплементированы в сетевом оборудовании. Например тут может указываться важность пакета, то есть его приоритет, место в очереди буфера сетевого устройства на передачу.</p>
  </li>
  <li>
    <p>Длинна пакета содержит в себе длинну всего пакета (IHL + размер данных).</p>
  </li>
  <li>
    <p>Поля идентификатор, флаги и смещение фрагмента нужны для того чтобы правильно нарезать IP пакеты на канальные кадры. Как мы помним поле Ethernet кадра под данные ограниченно параметром MTU, а IP пакет разумеется может быть больше, намного больше этого значения. Когда IP пакет нарезается на части, в каждом таком кусочке записывается <em>одинаковый</em> идентификатор, который указывает на принадлженость к одному IP пакету. Устанавилвается флаг фрагментированности. А в поле “Смещение” таких кусков-фрагментов указывается сдвиг этого фрагмента относительно первого из них. Можно очень условно назвать это смещение “индексацией” фрагментов, чтобы в результате пакет собирался в правильном порядке, так как фрагменты могут доходить на конечное устройство не по порядку.</p>
  </li>
  <li>
    <p>Время жизни пакета (TTL) нужно для того чтобы избежать появление так называемых “петель маршрутизации” в сетях. Изначально в это поле записывается число 255, и каждый <em>роутер</em> на хопе через себя “отщипывает” от счетчика TTL единицу. Петля маршрутизации между роутерами это такая ситуация когда пакет никак не может прийти к устройству получателю и бегает по кругу в одной и той же цепи роутеров. Роутер при получении пакета с счетчиком TTL равным нулю уничтожает этот пакет.</p>
  </li>
  <li>
    <p>В поле “Протокол” записана информация о том какому выше по уровню протоколу предназначен пакет (Как правило UDP или TCP).</p>
  </li>
  <li>
    <p>Контрольная сумма IP пакета отличается от чексуммы канального кадра тем что она высчитывается только от полей заголовка пакета. То есть в её рассчет не входят сами данные, и как следствие их целостность на этом уровне <em>не проверяется</em>. Целостность данных, как мы уже разобрали, проверяется на канальном уровне — там чексумма вычисляется от всего кадра включая данные.</p>
  </li>
  <li>
    <p>С полями адресов я думаю всё понятно. Когда пакет отправляется с одного компьютера — IP адрес отправителя записывается в соотвеетствующее поле, а на основании IP адреса получателя пакет обрабатывается в зависимости от устройства где пакет “находится” в конкретный момент времени. Роутеры смотрят по адресам получателя куда пакет нужно перенаправить, а получатель проверяет это поле — отправлен ли пакет именно ему, и если да, то какому обработчику его нужно передать (Поле “Протокол”).</p>
  </li>
  <li>
    <p>Поле Опции служит для расширения дефолтного функционала IP заголовка. Используется редко и специфическими устройствами.</p>
  </li>
  <li>
    <p>Смещение нужно для своего рода “балансировки” поля опций. Все поля заголовка IP пакета выровнены по границе 4 Байт (спецификация протокола IP), тогда как Опции не имеют фиксированной длинны и могут “плавать”. Смещение служит для того чтобы Опции можно было подровнять до требуемой границы.</p>
  </li>
  <li>
    <p>Поле Данные содержит передаваемую информационную нагрузку.</p>
  </li>
</ul>

<h2 id="jumbo-frame">Jumbo Frame</h2>

<p>Повторюсь что нужно быть бдительным касаемо MTU. Кадр у которого размер поля данных больше дефолтных 1500 байт называется Jumbo Frame. Здесь есть подводные камни. Когда мы повышаем MTU, во-первых отправитель и получатель должны уметь работать с такими пухлыми кадрами. Короче говоря, MTU должен быть одинаково сконфигурирован на первом и втором устройстве.</p>

<p>Во-вторых, это увеличивает нагрузку на маршрутизатор. Не смотря на то что в пределах канальной среды передача по сети начинает работать быстрее, мы можем столкнуться с проблемами передачи <em>между</em> сетями. Почему? Когда на роутер приходит jumbo frame, он понимает что внутри находится здоровый IP пакет, и в какую среду нужно перенаправлять трафик. Если целевая среда не поддерживает такой MTU роутеру придется вскрывать кадр, вытаскивать из него IP пакет и фрагментировать его.</p>

<h1 id="заголовки-транспортного-уровня-l4-headers">Заголовки транспортного уровня (L4 Headers)</h1>

<p>Теперь давайте рассмотри заголовки UDP и TCP протоколов.</p>

<h2 id="udp-header">UDP Header</h2>

<p>UDP Заголовок предельно прост.</p>

<p style="text-align: center;"><img src="/images/UDP_header.jpg" alt="UDP header" /></p>

<p>UDP занимается только распределнием трафика приложений.</p>

<p>В порт отправителя записывается либо рандомный свободный порт при отправке либо какой то определенный, и нужный порт получателя в соответствующее поле. После получения датаграммы и её обработки в ответной датаграмме значения этих полей меняются местами.</p>

<p>В поле длинна записывается длинна всей датаграммы — заголовок + данные. Контрольная сумма высчитывается тоже от всей датаграммы. UDP не осуществляет контроль доставки, поэтому если чексумма не сходится получатель “молча” отбрасывает битую датаграмму.</p>

<p>Отправлять данные без контроля доставки важно в том случае, когда неприемлимы задержки. Например потоковая передача медиаконтента (аудио, видео).</p>

<h2 id="tcp-header">TCP Header</h2>

<p>А теперь про серьезного парня. TCP не только распределяет трафик, но и выполняет ещё множество других функций. Первая и самая главная из них это контроль доставки пакета. Если у получателя чексумма не сходится при проверке, то протокол ещё раз запрашивает отправку пакеты который был побит.</p>

<p>Контроль доставки нужен когда данные чувствительны к потерям (важен правильный порядок переданных бит данных), например почту, текст и так далее.</p>

<p>Заголовок выглядит так:</p>

<p style="text-align: center;"><img src="/images/TCP_header.jpg" alt="TCP header" /></p>

<p>Ещё одной задачей TCP является сбор фрагментированных пакетов в правильной последовательности.</p>

<p>Далее, TCP в отличие от UDP умеет устанавливать сессии.</p>

<p>С портами, думаю, всё понятно.</p>

<p>Поля Порядковый номер и номер подтвеждения используются по разному, в зависимости от стадии передачи — установлена уже сессия или только устанавливается.</p>

<p>Поле “Длинна заголовка” нужно потому что здесь у заголовка снова (как в IP) есть поле нефиксированной длинны (“Опции”) — даем понять получателю когда заканчивается заголовок и начинаются данные.</p>

<p>“Флаги” используются для установления сессии, а в поле “Зарезервированно” специальные флаги для “протокольных” нужд.</p>

<p>“Размер окна” нужен для осуществления оптимизации контроля доставки. Как вообще работает контроль доставки? Вкратце ― получатель должен на каждый получаеммый TCP пакет отвечать подтверждением того что всё ОК и чексумма “срослась”. Значение размера окна указывает на колличество полученных пакетов, после которых нужно отправлять подтверждение что всё с ними было ОК. После установления сессии подтверждения отправляются на каждые три пакета, если потерь не происходит то размер окна увеличивается. Протокол следит за колличеством успешных и неуспешных отправок и регулирует размер окна в соответствии с колличеством потерь. Чем реже происходят потери — тем больше становится размер окна.</p>

<p>Если вы когда нибудь что-то качали по сети то наверняка видели сначала приерное время окончания загрузки неадекватных размеров, например 2 года. А потом бах, и время всё меньше и меньше становится. Это вот как раз размер окна меняется :)</p>

<p>Чексумма вычисляется от размера всего пакета.</p>

<p>Поле опций у TCP уже интереснее, так как используется чаще, в отличие от редких случаев использования опций в IP пакетах. Это потому что у TCP есть много разных расширений и дополнений которые управляются как раз посредством этого поля.</p>

<p>В данных тут уже то с чем будет работать прикладной протокол выше (HTTP например).</p>

<h2 id="установка-tcp-сессии">Установка TCP сессии</h2>

<p>Рассмотрим в приблизительном порядке что происходит с TCP заголовками при установке сессии:</p>

<ol>
  <li>Изначально клиентом устанавливаются значения портов отправителя (источника) и получателя (назначения).</li>
  <li>Клиент устанавливае рандомное число в поле “Порядковый номер”.</li>
  <li>Отправитель (клиент) устанавливает флаг SYN, который как раз и обозначет попытку установить сессию.</li>
  <li>Сформированный SYN пакет отправляется по сети и попадает к получателю (серверу).</li>
  <li>Получатель в ответном пакете меняет местами порт получателя и отправителя.</li>
  <li>Сервер устанавливает рандомное число в поле Порядковый номер в ответном пакет.</li>
  <li>А В “Номер Подтверждения” ответного пакета сервер записывает значение из поля Порядкового номера полученного от клиента SYN пакета прибавляя к этому числу единицу.</li>
  <li>Так же к флагу SYN в ответном пакете добавляется флаг ACK.</li>
  <li>Клиент получив SYN+ACK пакет опять менят местами порты, перемещает значение из Порядкового номера в Номер подтверждения прибавляя к этому числу единицу. Убирает флаг SYN оставляя флаг ACK и снова отправляет уже такой “ACK пакет” серверу.</li>
  <li>Сессия установилась. Произошел так называемый процесс <em>3-way handshake</em> (SYN -&gt; SYN+ACK -&gt; ACK).</li>
  <li>В установленной сесии идет обмен данными. Когда сессия установилась в поле “Порядковый номер” начинают записываться <em>номера пакетов</em>, а в “Номер подтверждения” записываются номера уже <em>полученных</em> пакетов.</li>
  <li>По завершеню обмена происходит процесс закрытия сессии обменом пакетами: FIN+ACK от клиента к серверу, ответ FIN+ACK обратно клиенту, и последний ACK от клиента о получении FIN+ACK. Если клиент не завершит сессию на сервере она всё равно закроется по таймауту, если ничего не будет прилетать по открытой сессии.</li>
</ol>

<hr />

<p>На сегодня это всё!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сети" /><summary type="html"><![CDATA[Немного про модель OSI и работу элементарной канальной среды.]]></summary></entry><entry xml:lang="ru"><title type="html">Продолжаем исследовать Императивную модель</title><link href="http://localhost:4000/2022/06/13/hack_in_imperative_2.html" rel="alternate" type="text/html" title="Продолжаем исследовать Императивную модель" /><published>2022-06-13T00:00:00+03:00</published><updated>2022-06-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/13/hack_in_imperative_2</id><content type="html" xml:base="http://localhost:4000/2022/06/13/hack_in_imperative_2.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 2.
<!--more--> 
<a href="/2022/06/06/hack_in_imperative_1.html">Читать предыдущую часть.</a></p>

<h1 id="компонентно-ориентированное-программирование">Компонентно ориентированное программирование</h1>

<p>Характеристики абстракции, которые мы разбирали в прошлой части, определяют собой <em>Компонентно ориентированное программирование</em>.</p>

<p>Компонент следует понимать как определение части программной системы изнутри и снаружи, иными словами — четкое определение <em>интерфейса</em> 
той части.</p>

<p>Внутренняя составляющая компонента скрыта (инкапсуляция), изнутри доступно только то что определено интерфейсом.</p>

<p>Благодаря композиционности из компоненты могут составляться другие, новые компоненты. Это естественный способ расширения возможностей одного компонента. Для реализации компонента с новым требуемым функционалом мы можем использовать уже существующий компонент или компоненты, которые уже реализует в себе некоторую часть (в существенной степени) этого нового функционала.</p>

<p>Инстанциирование компонентов позволяет создавать их новые экземпляры, которые моментально включаются в рантайм.</p>

<p>На самом деле компонент это ещё одна фундаментальная программистская концепция, признаки которой можно обнаружить во многих, если не во всех, программных концепциях и техниках:</p>

<ul>
  <li><strong>Процедурная абстракция</strong> — это компонент! Почему? Потому что это определение функции с параметрами, а экземпляр, то есть инстанциирование процедурной абстракции — это вызов определенной функции с аргументами;</li>
  <li><strong>Функтор</strong> (разбирали <a href="/2022/03/20/program-design.html">здесь</a>) — это исходный код программного модуля, который компилируется в сам модуль независимо от других компонентов;</li>
  <li><strong>Параллельные компоненты</strong> — программная система состоящая из независимых и взаимодействующих с друг другом элементов может быть представлена нами как граф из одновременно работающих <em>компонентов</em>, которые общаются посредством обмена сообщениями.</li>
</ul>

<h1 id="ооп">ООП</h1>

<p>Объектно-ориентированное программирование это по сути компонентно ориентированное, только с добавлением ещё одной концепции\механики — <strong>наследования</strong>.</p>

<p>Наследование — это такой способ конструирования программной системы, в котором реализация нового функционала основывается на уже существующей.
Такие постепенно развивающиеся компоненты называются <em>классами</em>, а экземпляры классов — <em>объектами</em>.</p>

<p>Возможность повторно использовать код в ООП сильно снижает дублирование кода и его избыточность в системе в целом, это большой и сильный плюс.
Но как известно:</p>

<p style="text-align: center;"><img src="/images/resplonsibiliy.webp" alt="Базз" /></p>
<p><em><center>Прислушайтесь к дяде Бену!</center></em></p>

<p>Почему так? Кажется что возможность каскадно переиспользовать код очень круто, добавляет возможность гибко, практически как угодно жонглировать компонентами и внедрять их друг в друга! Здорово же, да?</p>

<p>На самом деле нет, не очень. Компоненты начинают очень сильно зависеть от компонентов, которые они наследуют. В результате система становится все менее “модульной” и всё более <em>связанной</em>. Такими зависимостями становится очень сложно управлять.</p>

<p>Несмотря на то что большая литературы и учебников по объектно-ориентированному проектированию сфокусированы на правильном использовании наследования, стоит прислушаться к светлым и опытным инсайдерским умам, которые рекомендуют по возможности <strong>использовать композицию а не наследование.</strong> Пусть композиция и менее гибкий подход, тем не менее она проще в использовании. А наследование нужно применять только тогда, когда композиции недостаточно.</p>

<p>Если поступать таким образом, то иерархии в системе будут получаться намного менее глубокими, чем при использовании исключительно наследования. И как следствие, система будет менее связанной и запутанной.</p>

<h1 id="декларативная-модель-с-явным-состоянием">Декларативная модель с явным состоянием</h1>

<p><em>Явно состояние</em> — это пара из двух сущностей ЯП:</p>
<ol>
  <li>Идентичность (identity) — способ именования состояния в программе.</li>
  <li>Текущее содержание состояния — это собственно значение, с которым связано имя состояния.</li>
</ol>

<p>Сюда добавляется ещё операция, которая позволят посредством идентичности состояния получить текущее содержание.</p>

<h2 id="ячейка">Ячейка</h2>

<p>Мы уже говорили про ячейки в прошлый раз. Ячейка — это явное состояние, и <em>базовый тип</em> который мы добавляем в вычислительную модель.</p>

<p>Ячейка состоит из неизменяемого (постоянного) имени и ссылки на объект в хранилище однократных присваиваний.</p>

<p class="info">Напоминаю где можно вспомнить про внутрнее устройство декларативной модели -&gt; <a href="/2022/02/06/hack_in_declarative_model.html">тут</a>.
А если вы до сих пор не понимаете почему мы так много говорим в этом цикле о декларативной модели, хотя сабжем вроде как является императивная — рекомендую сперва прочитать весь цикл отчетов по изучению декларативной модели (начиная со ссылки выше, там будут кросссылки на следующие посты).</p>

<p>Благодаря тому что имя ячейки не допускается изменять все они (ячейки) фактически получаются чистыми абстрактными типами данных. Множество же самих ячеек хранится в некотором мутабельном (изменяемом) хранилище.</p>

<p>В результате вычислительная модель состоит из неизменяемого хранилища однократных присваиваний, которое содержит в себе dataflow-переменные (это такие переменные которые могуть быть связаны только с одним значением), и из второго — изменяемого хранилища, в котором хранятся пары из имен и ссылок (ячейки).</p>

<p>В такой модели существует элементарный язык программирования, который расширяет базовую декларативную модель двумя операциями, которые условно назовем NewCell и Exchange.</p>

<p>У NewCell есть два параметра. Эта операция создает новую ячейку с именем из первого параметра, и с содержимым (ссылкой) во втором:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NewCell C X
</code></pre></div></div>

<p>Операция Exchange уже имеет три параметра:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exchange C X Y
</code></pre></div></div>

<p>Эта операция связывает X с прежним содержимым ячейки С, и задает этой ячейке новое содержимое, передаваемое в Y.</p>

<p>Для обеспечения большей выразительности в такую модель добавляются ещё две инструкции:</p>

<ul>
  <li>
    <p>Операция @ предоставляет доступ к содержимому ячейки С:</p>

    <p>X = @C</p>
  </li>
  <li>
    <p>Операция := присваивает ячейке C новое значение из Y, и <em>возвращает значение ячейки X</em>:</p>

    <p>C := Y</p>
  </li>
</ul>

<p>Прикол в том, что добавление такой ячейки с лишь двумя операциями хватает чтобы построить <strong>все</strong> концепции, которые может предоставить понятие <em>состояния</em>.</p>

<p class="info">Все сложные концепции абстрактных типов данных можно построить с помощью декларативной модели дополненной ячейками.</p>

<h1 id="связь-с-декларативным-программированием">Связь с декларативным программированием</h1>

<p>Строго говоря, “императивная” stateful-программа не может считаться декларативной. Потому что её выполнение несколько раз с одними и теми же входными данными может давайть разные результаты, в зависимости от внутреннего состояния.</p>

<p>Однако, stateful-программы можно писать таким образом, чтобы они <em>удовлетворяли определению декларативной операции</em>. Чтобы они <strong>вели себя декларативно</strong>.</p>

<p>Мы разбирали пару декларативных функций <a href="hack_in_declarative_model_6.html">здесь</a></p>

<p>Любую из них можно взять и переписать в императивном “стиле”, изменив внутреннюю декларативную рекурсивную реализацию например на простой перебор циклом, который будет записывать в результирущий список каждый подходящий по функции-предикату элемент. Результирующий список это явное состояние (локальная переменная) внутри реализации вычислений.</p>

<p>Таким образом интерфейс самой функции оберки filter остается неизменным, и её пользователю вообще неизвестно какая там внутри реализация, а сам filter ведет себя всё ещё декларативно.</p>

<h2 id="мемоизация">Мемоизация</h2>

<p>Ещё одна полезная техника в разрезе декларативной модели с использованием состояний — <em>мемоизация</em>. Это такой финт, когда функция запоминает результаты её предыдущих вызовов (например очень тяжелых вычислений), что позволяет при повторных вызовах такой функции использовать эти результаты сразу же. В такой функции внутри состояние реализуется в замыкании, но внешне ей поведение формально остается декларативным.</p>

<h1 id="sharing-состояний">Sharing состояний</h1>

<p>Один из важных нюансов, который нужно строго формализировать при работе с состояниями это понятие <em>равенства ячеек</em>.</p>

<p>Нужно понять, можно ли считать что две ячейки равны, когда равно их <em>содержание</em>, или если два идентификатора (X и Y) ссылаются на одну и ту же ячейку?</p>

<p>Такие случаи “равенств” называют sharing или aliasing, что по сути является совместным использованием некоторого содержания ячейками, которые являются <em>алиасами</em>.</p>

<p>Когда мы изменим содержимое ячейки X это автоматически приводит и к изменению содержимого ячейки Y, ведь физически <em>их содержимое одно и то же</em>.</p>

<p>В ООП это называется <em>передача объектов по ссылке</em>.</p>

<p>Формальное понимание программы, в которой есть много алиасов у ячейки заметно усложняется. Эта проблема решается с помощью <em>инкапсуляции состояния</em> следующим образом:</p>

<p class="info">Вся логика работы с состоянием выделяется в отдельную и четко определенную часть программы, которая гарантирует что состояние оттуда не сможет выбраться. Поэтому абстрактные типы данных идеальный способ для использования явных состояний, потому что они инкапсулируются в АТД, скрываясь за набором определенных высокоуровневых операций.</p>

<h1 id="атд-и-способы-их-организации">АТД и способы их организации</h1>

<p>В <a href="hack_in_declarative_model_6.html">последнем посте</a> из цикла изучения Декларативной модели мы уже знакомились с АТД и способами их защиты. Сейчас пришла пора добавить к этой джедайской технике понятие состояния.</p>

<p>Абстрактные типы данных с одной и той же функциональностью могут быть по разному реализованы внутри. В эволюции АТД есть ещё две “перпендикулярных оси” — <em>состояние</em> и <em>бандлинг</em>. Вметсе с защищенностью эти три аспекта составляют восемь способов организации АТД, а зависимости от применения или не применения каждого из них.</p>

<p>Давайте рассмотрим эту тему чуть более подробно.</p>

<h2 id="открытость-и-защищённость">Открытость и защищённость</h2>

<p><em>Открытый абстрактный тип данных</em> — это АТД, внутренее представление которого видно везе в программе. Реализация такого типа может быть размазана по коду, а разные его части расширяться независимо друг от друга. Такая реализация может быть полезна разве что в небольших проектах, когда выразительность важнее чем безопасность. Только не используйте это как оправдание лени писать безопасный код.</p>

<p><em>Защищенный абстрактный тип данных</em> — это АТД реализация которого недоступна остальным частям программы, и его реализация сосредоточена в одном модуле. Как я уже упоминал, способ защиты АТД мы рассматривали в последнем посте о Декларативной модели.</p>

<p>АТД может быть “частично безопасным”, когда права на чтение внутренней реализации выдаются другим частям программы некоторым контролируемым образом (wrap, unwrap).</p>

<h2 id="состояние-в-атд">Состояние в АТД</h2>

<p><strong>Stateless-АТД</strong> создаются в рамках декларативной вычислительной модели. Нужно создавать новые экземпляры АТД, так как модифицировать их запрещено. Такой подход приводит к увеличению количества экземпляров АТД в программе, из за чего ими может становиться трудно управлять. Сам код программы становится менее модульным, потому что мы помним — это <em>декларативная модель</em>, и как следствие экхемпляры должны передаваться по конвейеру вычислений даже через части программы, которые в этом АТД не нуждаются.</p>

<p><strong>Statefull-АТД</strong>, очевидно, использует внутри себя явные состояния. А значит его экземпляры могут изменяться во времени. В такой реализации нельзя быть уверенным какое значение инкапсулировано внутри экземпляра АТД, не обладая полной историей вызовов процедур с момента создания экземпляра. Здесь так же существует только один экземпляр, в отличие от декларативных АТД. Кроме того, зачастую этот экземпляр вообще не надо передавать внутрь функции как параметр, потому что доступ к нему может быть организован через лексическое замыкание.</p>

<p>Этот подход позволяет сделать программу более выразительной и лаконичной, а так же, возможно, более модульной, потому что нам не нужно “связывать” экземляр АТД с частями системы которым он не нужен.</p>

<h2 id="бандлинг">Бандлинг</h2>

<p>Бандлинг (запаковка) — это когда данные хранятся <em>вместе с операциями</em>.</p>

<p><strong>Распакованный АТД</strong> — это АТД, у которого можно отделить данные от операций. При этом распакованный АТД <em>может быть безопасным</em>. Достигается это путем создания каждого экземпляра АТД вместе с некоторым “ключем”, который представляет собой разрешение на доступ к внутренним данным экземпляра, и на измнение, если АТД обладает состоянием. Все операции такого АТД “знают” ключ, в отличе от остальной части программы. Как правило ключ — это неизменяемая константа.</p>

<hr />

<p>В реальном мире из восьми комбинаций вышеупомянутых аспектов АТД используются эти варианты:</p>

<ul>
  <li>“Открытый, декларативный, распакованный” — Такой подход реализуется в языке Prolog, и некоторых других.</li>
  <li>“Защищенный, декларативный, запакованный” — Добавляются абстракции для реализации декларативного стиля.</li>
  <li>“Защищенный, декларативный, распакованный” — Объектно-ориентированное расширение декларативного стиля.</li>
  <li>“Защищенный, stateful, запакованный” — Это классичское объектно ориентированное программирование, например Java.</li>
  <li>“Защищенный, stateful, распакованный” — “Распакованный” ООП.</li>
</ul>

<p>Эти комбинации перечислены в порядке усложнения их реализации.</p>

<p>Пример первого пункта рассматривался в последнем посте о декларативной модели (реализация стека).</p>

<hr />

<p>На сегодня всё. Пожалуйста не забывайте отдыхать!
<a href="/2022/06/26/hack_in_imperative_3.html">Читать продолжение</a></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 2.]]></summary></entry><entry xml:lang="ru"><title type="html">Про модель OSI и коммутаторы</title><link href="http://localhost:4000/2022/06/13/OSI_and_switches.html" rel="alternate" type="text/html" title="Про модель OSI и коммутаторы" /><published>2022-06-13T00:00:00+03:00</published><updated>2022-06-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/13/OSI_and_switches</id><content type="html" xml:base="http://localhost:4000/2022/06/13/OSI_and_switches.html"><![CDATA[<p>Немного про модель OSI и работу элементарной канальной среды.
<!--more--></p>

<p>Всем привет! Я наконец дожил до момента когда начал нормально изучать сети! Конечно у меня был курс по сетям в колледже, и это было самое интересное и толкое их того что там вообще преподавалось (помимо основ схемотехники). Но признаюсь честно, во-первых, я тогда не очень сильно был заинтересован в учебе (о чем сильно сожалею), во-вторых, пусть в голову нам вдалбывалось знатно — я многое уже успешно забыл.</p>

<p>Последнее время в своей профессиональной практике я всё более остро ощущал нехватку хороших, фундаментальных знаний о сетевых технология. С одной стороны, в принципе базового понимания “как оно там вообще работает”, (ну то что есть порты и тд :) жидкого знания основных протоколов в большей части задач вроде бы как достаточно, но когда дело доходит до откровенного ступора — лично мне перед самим собой стыдно бэкать и мэкать. Не стыдно бежать за помощью к коллегам, стыдно испытывать <em>нехватку компетенции.</em></p>

<p>Да, коллеги всегда помогут, но нужно же профессионально расти! И ещё один немаложваный фактор — мне до чертиков эта тема интересна!</p>

<p>Сегодня я хочу вкратце написать про модель OSI и немного поговорить про коммутаторы и физические адреса устройств.</p>

<p>Кстати, значальное описание OSI в распечатанном виде имеет толщину в один метр.</p>

<p>Поехали!</p>

<p style="text-align: center;"><img src="/images/wow.png" alt="Эмодзи шокового удивления" /></p>

<h1 id="osi">OSI</h1>

<p>OSI (Open System Intreconnection model) — это эталонная модель стека сетевых протоколов которая состоит из семи <em>логических</em> уровней. Можно сказать что эта модель своего рода “скелет” всех сетевых сущностей. Она определяет протоколы следуя которым эти самые сущности между собой как-то взаимодействуют. Протокол — это “набор правил” <em>интерфейса логического уровня</em>, которыё определяют каким образом программы должны обмениваться данными между собой. Но сегодня мы говорим не о протоколах. Я недавно писал про <a href="/2022/06/01/DNS.html">HTTP</a>, <a href="2022/05/31/FTP.html">FTP</a>, и <a href="/2022/06/01/DNS.html">DNS</a>.</p>

<p>Передача всегда происходит от уровня к уровню, последовательно подключая нужные протоколы на каждом из них.</p>

<p>Как уже было сказанно модель OSI делится на семь уровней:</p>

<p style="text-align: center;"><img src="/images/OSI.jpg" alt="Схема модели OSI" /></p>
<p><em><center>Извините что криво, я правда старался!</center></em></p>

<p>Модель OSI разрабатывалась давненько — в семидесятых годах. Задачей была попытка описать архитектуру и как вообще должны работать сети.</p>

<p>На последнем седьмом уровне передаваемые данные представляются в виде фактических данных (то как мы их воспринимаем), а на первом — бежит по каналам в бинарном виде.</p>

<p>Процесс в котором данные от уровня к уровню конвертируются из читаемых данных в биты называется знакомым нам из программирования словом <em>инкапсуляция</em>. Обратный процесс — <em>декапсуляция</em>. На каждом из уровней информация представляется в виде так называемых PDU (Protocol Data Unit), это такие блоки данных.</p>

<p>Все уровни условно делятся на две группы: уровни среды передачи, и уровни хоста. Уровни с 1 по 3 это уровни среды передачи. Они занимаются непосредственно передачей информации, тогда как остальные уровни хоста (с 4 по 7) используются непосредственно на наших девайсах (десктопы, лаптопы, смартфоны и тд).</p>

<h2 id="физический-уровень-l1">Физический уровень L1</h2>

<p>Уровень отвечает за обмен электрическими или оптическими сигналами по проводам, или радиоволнами по беспроводным сетям (Bluetooth, WiGI, GSM и вот это вот всё) между устройствами. Наши компьютеры вообще ничего не знают про то что такое картинки, какая там фотография изображена, что на нашем смешном мемасике. Компьютеру мемасы понятны только как наборы нулей и единиц (это грустно, я бы поговорил с железякой). Здесь <em>бит</em> является блоком данных (PDU).</p>

<p>Каждый уровень по сути имеет свои PDU, представляемые образом понятным протоколам этого уровня. А иногда и протоколам следующего уровня (например для возможности преобразования).</p>

<p>Работа с “чистыми” данными будет производиться только на уровнях с 5 по 7.</p>

<h2 id="канальный-уровень-l2">Канальный уровень L2</h2>

<p>На этом уровее решается проблема <em>адресации</em> передачи. Канальный уровень инкапсулирует биты в <em>кадры</em> (frame). Кадры формируются с адресами отправителя и получателя, а потом отправляются дальше.</p>

<p>Тут есть условно два “подуровня” — это MAC и LLC. Первый служит для “присвоения” физических адресов железок, а второй занимается проверкой и исправлением данных, а так же управляет их передачей.</p>

<p>На втором уровне OSI работают коммутаторы (сетевая железяка), их задачей является передача сформированныех кадров от одного устройства к другому используя в качестве адресов только физические MAC-адреса. Про комммутаторы и MAC адреса мы поговорим в заключительной части.</p>

<h2 id="сетевой-уровень-l3">Сетевой уровень L3</h2>

<p>Здесь вводится понятие маршрутизации. Маршрутизацией занимаются специальные железяки… маршрутизаторы (роутеры). Роутеры получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута между устройствами.</p>

<p>На сетевом уровне есть протокол ARP (Address Resolution Protocol), благодаря которому MAC-адреса определенным образом преобразуются в 32-битные IP-адреса и наоборот.</p>

<p>Единица данных (PDU) передаваемая с использованием маршрутизации уже называется не кадр а <em>пакет</em>.</p>

<h2 id="транспортный-уровень-l4">Транспортный уровень L4</h2>

<p>Помните мы говорил про уровни среды и уровни хоста? Так вот четвертый уровень это что-то вроде уровня посредника между этими двумя группами. Транспортный уровень управляет передачей пакетов в сети, определяет каким приложениям на уровнях выше предназначаются данные (использование портов). Тут работают такие протоколы как TCP и UDP. TCP контролирует целостность передаваемой (доставленной) информации, а UDP — нет. В TCP <em>устанавливается соединение</em> пакеты данных делятся на сегменты, успешность и целостность доставки каждого пакета некоторым образом “проверяется”. Отправили, подождали подтверждения что все дошло ОК, не дошло - отправили ещё раз. В UDP — отправил куда сказали и забыл, плевать если какая то датаграмма (в этом протоколе пакеты делятся на датаграммы а не на сегменты) потерялась или дошла битой. Чуть подробнее про эти протоколы мы поговорим в следующий раз.</p>

<p>И <em>сегмент</em> и <em>датаграмма</em> это PDU транспортного уровня.</p>

<h2 id="сеансовый-уровень-l5">Сеансовый уровень L5</h2>

<p>Уровень отвечает за поддержку сессии (сенса) связи. Начиная с этого уровня данные оперируются в “чистом” виде. Сеансовый уровень управляет тем как разные приложения взаимодействуют между собой, предоставляет возможность синхронизации задач. Всё это нужно для работы следующего уровня.</p>

<h2 id="уровень-представления-данных-l6">Уровень представления данных L6</h2>

<p>Уровень “конверитрует” данные, которые всё ещё в виде каких то PDU в представление понятное человеку (и компьютеру). Например тут происходит перевод текста из одной кодировки в другую. Видео и изображения тоже обрабатываются на этом уровне. А ещё, если соединение требует шифрования, в бой оно вступает так же на уровне представления данных.</p>

<h2 id="прикладной-уровень-l7">Прикладной уровень L7</h2>

<p>Это уровень приложений (application level). Это тот уровень с которым взаимодействуют конечные пользователи. Короче говоря, задачей протоколов этого уровня является только предоставление возможности пользователю увидеть данные в понятном ему форме (например, HTTP протокол 7 уровня).</p>

<h1 id="зачем-мне-знать-osi-если-везде-tcpip">Зачем мне знать OSI, если везде TCP/IP</h1>

<p>Модель OSI это стандарт (ISO/IEC 7498). Его просто надо знать, потому что не смотря на запятнаную репутацию и критику модель есть и она всё ещё используется.</p>

<p>Репутация… Ну, модель OSI много и оправданно критикуют. Её слишком долго разрабатывали и её обвиняют в том, что модель <em>не совсем отображает действительность</em>. На момент релиза OSI уже широко был распространен стек TCP/IP. Кто знает, если бы с разработкой OSI не затягивали она была бы фактическим, “настоящим” стандартом. Или если бы модель не проектировали в сверхсекретном “закрытом” режиме, тогда как стек TCP/IP изначально была <em>открыт</em>, она была бы принята с более распростертыми руками.</p>

<p>Ещё OSI критикуют из за того что функции уровней распределены между ними неравнозначно, и что вообще одинаковые задачи могут быть решены на <em>разных уровнях</em>. В общем ругают за то что уровней вообще слишком много, сеть можно построить используя только первые 4.</p>

<p>—-</p>

<h1 id="коммутируй-то-коммутируй-это">Коммутируй то! Коммутируй это!</h1>

<p>Я обещал чуть больше рассмотреть канальный уровень. Приступаем!</p>

<h2 id="зачем-в-сетях-нужны-коммутаторы">Зачем в сетях нужны коммутаторы?</h2>

<p>Современные сети построенны на канальном уровне с использованием коммутаторов, которые связывают разные компьютеры между собой. Грубо говоря коммутаторы нужны не только чтобы просто соединить машины, но в первую очередь — чтобы избежать коллизиий присущих такой устаревшей сетевой топологии как “шина”, в которой как раз таки все машины связывали в тупую одним каналом.</p>

<p>Так вот, шина — это когда все компьютеры в сети, грубо говоря, подключены к одному “кабелю”, а коллизия это такой “цифровой” хаос в сети, когда одновременно пытаются общаться больше двух машин по одному каналу. Например коллизия может возникнуть в шине когда в сети есть сервер и N компьютеров, и одновременно два (или больше) клиента попробуют обратиться к одному и тому же серверу.</p>

<h2 id="устройство-коммутатора">Устройство коммутатора</h2>

<p>У сетевого коммутатора (свитча) есть условно два буфера: входящий и исходящий. На самом деле буферы логически делятся на буферы портов.</p>

<p>Когда в сети с коммутатором один из компьютеров отправляет данные другому, эти данные сначала попадают во входящий буфер свитча (коммутатора) по одному из портов. После этого свитч решает на какой иной порт (куда) эти данные нужно перенаправить (используя MAC таблицу, про MAC будет дальше), а точнее <em>на <strong>исходящий</strong> буфер какого порта их нужно перенаправить</em>.</p>

<p>После этого коммутатор ждет когда целевой канал освободится, ведь с сервером могут общаться другие участники сети нему же. Когда это происходит данные из соответствующего буфера свитча отправляются целевому получателю. В одном таком исходящем буфере могут спокойно ждать своей очереди данные от двух и более участников сети (которые хотят достучаться на один и тот же сервер например).</p>

<p>Именно благодаря описанному выше механизму (очереди в буфере) коллизий в сети не происходит.</p>

<p>В старые (но не очень) времена существовали так называемые концентраторы (хабы). Отличались они от свитчей тем что у них не было буферов. Такое устройство по сути являлось всего лишь электрическим повторителем, и никак не уберегало сеть от возникновения коллизий. Вроде бы как устройство, вроде бы как компьютеры к нему подключаются физически разными кабелями, но топология по сути получается “шина”.</p>

<h2 id="домен-коллизии">Домен коллизии</h2>

<p>Домен коллизии — это участок сети на котором есть <em>возможность</em> возникновения коллизии. Очевидно что в случае с шиной домен коллизии распространяется на всю канальную среду, но в случае применения коммутаторов домен коллизии ограничен участком сети от <em>конечного узла до коммутатора</em>.</p>

<p>На этом участке коллизия может возникнуть если узел и коммутатор будут работать в <em>полудуплексном</em> (half-duplex) режиме.</p>

<p>Дуплекс — это такой сопособ связи двух устройств которые могут общаться друг с другом в оба направления. Когда <em>симплекс</em> — только в одном направлении. Устройство которое реализует в себе полный дуплекс способно передавать или принимать данные в любой момент времени, а вот полудуплекс не может делать это одновременно. <em>Полудуплекс</em> это когда в один момент времени устройство может только передавать или получать данные.</p>

<p>Коллизии при half-duplex в участках до коммутара возникают в случае когда передатчик коммутатора и сетевой карты узла начинают одновременно (или почти одновременно) передавать данные в разных режимах (прием/передача), считая что участок сети между ними свободен.</p>

<h1 id="канальная-среда-кадры-и-mac-адреса">Канальная среда, кадры и MAC адреса</h1>

<p>Мы сегодня уже использовали термин <strong>кадр</strong>.</p>

<p>Кадром в сети принято называть <em>единицу информации</em>, которая передается в пределах одной канальной среды.</p>

<p><em>Канальная среда</em> — это небольшой участок локальной сети, устройства в котором объединены одним свичом (или несколькими). В такой сети <em>нет роутера</em>, и еще её называют <em>одним широковещательным доменом</em>.</p>

<p>В пределах одной канальной среды адресация между узлами происходит в первую очередь по <em>MAC адресам</em>, а не по IP. IP здесь работает, но лишь <em>косвенно</em>.</p>

<p>Конечно же узлы в такой сети имеют свои IP адреса, но получатели кадров в ней определяются по MAC адресам.</p>

<p>Это работает благодаря протоколу <strong>ARP</strong> (<a href="https://datatracker.ietf.org/doc/html/rfc826">RFC 826</a>), который служит для сопоставления айпишников и физических адресов устройств (MAC).</p>

<p>Работа протокола организована посредством ведения так называемых ARP-таблиц, которые хранятся в памяти операционных систем на компьютерах. Устройство, которое собирается отправить данные по какому то IP адресу сперва проверяет свою ARP-таблицу на предмет наличия в ней MAC адреса. Если адрес есть — отправляем по нему. Если адреса нет — узел формирует ARP запрос в виде кадра и рассылает его <em>широковещательно</em> (по всей канальной среде). Следовательно, все узлы получают этот запрос, сравнивают в нем IP со своим, и если выявляется соответствие — узел получатель отправлет ответный ARP кадр на адрес отправителя запроса, в котором записан IP и соответствующий MAC.</p>

<p>MAC адреса есть у каждого устройства и вшиваются в постоянную память производителями этих устройств. Они состоят из двух частей по 24 бита каждая:</p>
<ul>
  <li>Уникальный идентификатор OUI, который выдается <a href="https://www.ieee.org/">IEEE</a></li>
  <li>
    <p>Часть которую назначает сам производитель</p>

    <p>Кстати, MAC адрес можно легко изменить\подменить, потому что из постоянного энергонезависимого источника при загрузке ОС он записываться в <em>оперативную память</em>.</p>
  </li>
</ul>

<p>Уникальный MAC каждого устройства называется <em>Unicast</em> адресом, но есть еще <em>широковещательный</em> (broadcast) адрес который одинаково выглядит во всех операционных системах: FF-FF-FF-FF-FF-FF.</p>

<p>Широковещательный адрес позволяет разослать кадр сразу всем участникам канальной среды (“размножается” на свитче).</p>

<p><em>Многоадресные</em> (Multicast) MAC адреса отличаются от широковещатльных тем, что по мультикасту идет рассылка кадров по определенной группе узлов, у которых установленны соответствующие мультикаст-адреса.</p>

<h2 id="unicast-flooding">Unicast Flooding</h2>

<p>У свичей есть специальная таблица MAC адресов, в которой они хранят соответствия своих каналов (портов) с MAC адресами устройств работающих за этим портом. Изначально, когда мы только включаем коммутатор его таблица как правило пуста. Она наполняется следующим образом.</p>

<p>Когда какой-то из компьютеров в канальной среде отправляет другому данные они сперва попадают на свитч. Свитч видит MAC адрес получателя, записывает в свою таблицу адрес <em>отправителя</em> в строку таблицы порта, по которому он получил данные. Но в этот момент коммутатор не знает <em>куда</em> перенаправлять (в буфер какого порта) кадр дальше.</p>

<p>Поэтому он рассылает этот кадр по всем <em>остальным</em> портам! Затем коммутатор смотрит с какой стороны пришел ответ и снова записывает MAC адрес в соотвутствующую строку порта. Таким нехитрым образом свич заполняет свою таблицу.</p>

<p>Процесс наполнения таблицы называется <em>unicast flooding.</em></p>

<hr />

<p>На сегодня это всё. На самом деле в отдельности каждую из тем можно долго-долго рассматривать. Если вы настолько жадны до сетей, то… Почитайте Таненбаума, например!</p>

<p><a href="/2022/06/19/TCP_UDP_and_something_else.html">Читать следующий пост про маршрутизацию и заголовки протоколов L1-L3</a></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сети" /><summary type="html"><![CDATA[Немного про модель OSI и работу элементарной канальной среды.]]></summary></entry><entry xml:lang="ru"><title type="html">Нам нужны явные состояния. Нужны же?…</title><link href="http://localhost:4000/2022/06/06/hack_in_imperative_1.html" rel="alternate" type="text/html" title="Нам нужны явные состояния. Нужны же?…" /><published>2022-06-06T00:00:00+03:00</published><updated>2022-06-06T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/06/hack_in_imperative_1</id><content type="html" xml:base="http://localhost:4000/2022/06/06/hack_in_imperative_1.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 1.
<!--more--></p>

<p>Всем привет! Я приступил к очередному курсу в skillsmart.ru 
На этот раз темой курса является изучение Императивной модели программирования, как расширения фундаментальной Декларативной модели.</p>

<p>Вы что нибудь помните про декларативную модель, и про состояния?
Мы разбирали эти и другие связанные темы некоторое время назад на соответствуещм курсе. Почитать про это вы можете в моих постах-отчетах, начиная с <a href="/2022/02/06/hack_in_declarative_model.html">этого.</a></p>

<p>Но тут мы тоже будем сперва говорить про декларативность, потому что никуда без неё :P</p>

<h1 id="stateful-programming">Stateful programming</h1>

<p>В императивной модели концепция времени понимается уже совсем по другому. Наверное самое главное отличие императивной модели от декларативной заключается именно в этом.</p>

<p>Время тут меняется благодаря введению в модель <em>Явных состояний</em>, которые добавляют программным сущностям возможность <em>долгосрочной памяти</em>.</p>

<p>Иными словами — тут появляются привычные нам “императивные” переменные.</p>

<p>Есть ещё умные слова, которыми достаточно часто отмечают природу состояний в моделях: <strong>stateless</strong> и <strong>stateful</strong> программирование. На самом под первым как правило имеется в виду декларативное, а под вторым — императивное.</p>

<p>Давайте вкратце повторимся.</p>

<p><em>Декларативное программирование</em> — это когда мы описываем <strong>какой результат</strong> нужно получить. Возможно с дополнительным определением “подказок” как его получить :)</p>

<p style="text-align: center;"><img src="/images/declarative_meme.jpeg" alt="Рекурсивные кролики" /></p>

<p><em>Императивное программирование</em> — это когда мы с помощью конкретных команд описываем <strong>как получить результат</strong>.</p>

<p>На самом деле декларативное программированое в какой то степени императивно, потому что всё равно зачастую используются последовательности каких то команд.</p>

<p>Вообще, Декларативная парадигма это в первую очередь математическая модель, а сама “декларативность” проще будет пониматься как <em>относительная степень</em>, в которой эта самая декларативность применяется в языке программирования.</p>

<h1 id="прелести-декларативного-подхода">Прелести декларативного подхода</h1>

<p>Хотя декларативный подход можно, грубо говоря, “спроецировать” на любой программный код, на практике же (в логических или фунциональных программах, например) он теряет большую часть аспекта <em>“что делать”</em>, так как приходится более детально описывать подробности <em>“как делать”</em>.</p>

<p>Тем не менее это не значит что от декларативного программирования можно или нужно как то отказываться, потому что у него есть три существеннных плюшки:</p>

<ol>
  <li>В декларативной модели проще формировать практически все программные абстракции благодаря тому что декларативные операции <strong>композиционны</strong>.</li>
  <li>Декларативные программы просто тестировать, потому что достаточно протестировать одиночныне вызовы команд, когда stateful программу тестировать сложнее из за того что приходится проверять <em>последовательности вызовов</em>.</li>
  <li>Рассуждать о программи в декларативной модели проще, чем при использовании императивного программирования.</li>
</ol>

<h1 id="снова-о-состояниях">Снова о состояниях</h1>

<p>Итак, мы уже выяснили что <em>состояние</em> — это растянутая во времени последовательность значений, в которой содержатся промежуточные результаты нужного вычисления.</p>

<p>Мы помним что в декларативной модели состояние характеризуется как <strong>скрытое</strong>. Такие декларативные, состояния никак <em>явно</em> не поддерживаются со стороны вычислительной модели. Последовательности вычислений могут пониматься и представляться только в сознании программирующего существа, а на уровне кода последовательности просто не существуют.</p>

<p>Явное состояние наоборот — <em>существует</em> на протяжении времени, в более чем одном вызове функции <em>без явного определения этого состояния в аргументах этой функции</em>.</p>

<p>Такое состояние реализуется с помощью некоторого “контейнера”, который принято называть <strong>ячейка</strong>. Такая ячейка уже фактически существует в коде, наблюдается, иными словами — <em>не только в сознании программирующего существа.</em></p>

<h1 id="принцип-абстракции">Принцип абстракции</h1>

<p>По мере роста системы описывать её абстракции в чисто декларативном или функциональном программировании становится всё сложнее, потому что сам <em>принцип</em> абстракции не очень хорошо поддерживается этими парадигмами. Причиной этой сложности является как раз природа состояний — мы не можем вкладывать <em>новую</em> информацию в компоненты программы или функции (инкапсулировать их внутри).</p>

<p>Для того чтобы система могла хорошо поддерживать принцип абстракции она должна обладать следующими характеристиками:</p>

<ul>
  <li><strong>Инкапсуляция</strong> — это возможность скрывать внутренние части самой системы;</li>
  <li><strong>Композиционность</strong> — это про возможность комбинирования частей системы в целях полуения новых частей;</li>
  <li><strong>Инстанциирование</strong> (invocation) — возможность создавать много конкретных экземпляров компонена на основе его единого определения.</li>
</ul>

<p>Если вы знаете хотя бы немного про ООП (объектно ориентированное программирование), то наверняка уловили сейчас знакомые концепции. Но мы говорим сейчас совсем не про “высокии материи” ООП, и используем более фундаментальные и универсальные принципы программирования для определения и понимания этих концепций.</p>

<p>Например <em>замыкани</em> обеспечивают инкапсуляцию, а инстанциирование достигается посредством программирования высшего порядка.</p>

<p><strong>Важной</strong> особенность характеристик перечисленных выше является то, что их набор <strong>не требует использования концпеции состояния</strong>.</p>

<p>На самом деле инкапсуляция вообще противоположна состоянию, и её можно применять в декларативном программировании. Состояния же могут обходиться без икапсуляции, к примеру — с помощью создания <em>глобальных переменных</em>.</p>

<p>Пришла пора поговорить о cons, а то всё про pros да про pros :)</p>

<p>Добавления концепции состояния к декларативному программированию резко и в разы усложняет понимание самой программы, становится не так просто рассуждать о ней.</p>

<p>Во-первых мы можем столкнуться с <strong>побочными эффектами</strong> у функций, которые теперь могут менять состояния что не видны во всей остальной программе.</p>

<p>Именно по этой причине явное состояние нужно обязательно <strong>применять в тесной связи с инкапсуляцией</strong>, благодаря чему появляется возможность проектировать stateful-системы корректно. Тут появляется понитие <strong>инварианта</strong>, который всегда выглядит “снаружи” правильно.</p>

<p>Это возвращает нам возможность рассуждать о подсистемах формально, считая что поведение этой подсистемы не зависит от окружающей среды, тем самым частично возвращая нас в плане рассуждений к декларативному программированию. Тем не менее, одно только введение инвариантов всё ещё не делает программирование с использованием состояний таким же простым и понятным как декларативное.</p>

<p>Потому что инвариант <em>всего лишь определяет что компонент не ведет себя некорректно</em>, и никак не гарантируется то, что он помогает в продвижении к решению итоговой задачи.</p>

<p>Из всего это следует очень важное правило:</p>

<p class="info">Сложные системы нужно проектировать так, чтобы как можно больше количество компонентов этой системы было описано в декларативной парадигме.</p>

<p>Состояния <strong>должны</strong> быть сконцентрированны в единичных компонентах. Нельзя растягивать состояния по несколькоим компонентам.</p>

<hr />

<p><a href="/2022/06/13/hack_in_imperative_2.html">Читать продолжение</a></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 1.]]></summary></entry><entry xml:lang="ru"><title type="html">F# Напоследок</title><link href="http://localhost:4000/2022/06/03/last_about_f.html" rel="alternate" type="text/html" title="F# Напоследок" /><published>2022-06-03T00:00:00+03:00</published><updated>2022-06-03T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/03/last_about_f</id><content type="html" xml:base="http://localhost:4000/2022/06/03/last_about_f.html"><![CDATA[<p>Послесловие о функциональном программировании на F#
<!--more--></p>

<p>Привет! Совсем недавно я завершил базовый курс по функциональному программированию на F# в <a href="http://skillsmart.ru/">skillsmart.ru</a>.
Хочу написать ещё немного об этом опыте, в продолжение <a href="/2022/04/17/more_about_f.html">предыдущего поста</a></p>

<p>Рассмотрим несколько фишек и типов F#</p>

<h1 id="определение-типа-и-записи">Определение типа и записи</h1>

<p>В F#, как и в большинстве языков программирования можно определять свои типы, делается это с помощью ключевого токена “type”.</p>

<p>Есть так же такой тип как Запись (record), который фактически является кортежем, но его элементы идентифицируются ключами-метками (названиями), а не порядковой позицией. Это напоминает словарь в Python.</p>

<p>Сперва нам нужно определить структуру записи как тип.
Например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type = Weapon { fullauto : bool; load_amount: int; fire_rate: float32 }
</code></pre></div></div>

<p>Затем мы можем определить “экземпляр” записи:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47 = { fullauto = true; load_amount = 30; fire_rate = 100.54 }
</code></pre></div></div>

<p>Не нужно как-то дополнительно указывать что ak47 это запись типа Weapon — компилятор F# сам поймет на основании идентификаторов используемых полей.</p>

<p>Мы можем обращаться к каждому отдельному полю записи, чтобы получить её значение используя точечную нотацию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47_firerate = ak47.fire_rate
</code></pre></div></div>

<p>Записи можно целиком сравнивать, если типы данных значений полей совпадают. Такое сравнение происходит в лексикографическом порядке.</p>

<h1 id="размеченное-объединение">Размеченное объединение</h1>

<p>Это тип данный, в котором мы задаем множество некоторых идентификаторов. Соответственно размеченное объединение может принимать только тип из своего “списка”. Синтаксис напоминает сопоставление с образцом — используем пайп:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47
  | m249_saw
  | colt_anaconda
</code></pre></div></div>

<p>На полную катушку оторваться тут можно уже фактически используя паттернматчинг фишку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47 -&gt; "автомат"
  | m249_saw -&gt; "пулемет"
  | colt_anaconda -&gt; "револьвер"

let full_auto = function
  | ak47 | m249_saw -&gt; true
  | _ -&gt; false
</code></pre></div></div>

<h2 id="конструктор-значений">Конструктор значений</h2>

<p>Мы так же можем обозначить тип данных для каждого элемента-тега размеченного объединения:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Сaliber =
  | Pistol of float32
  | Machine_gun of float32
  | Cannon of int
</code></pre></div></div>

<p>В таком случае тег связанные с типом является фактически функцией, которыю называются конструкторами значений.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak_caliber = Machine_gun 7.62
let bfgun_caliber = Cannon 666
</code></pre></div></div>

<h1 id="частичные-функции">Частичные функции</h1>

<p>Это такая функция, которая только на <em>подмножистве значений аргументов</em>.</p>

<p>Есть специальный тип <strong>option</strong>, у которого может быть только два значения:</p>
<ul>
  <li>None: тут всё понятно;</li>
  <li>Some: это <em>полиморфный</em> конструктор значений, который прнимает <em>любые</em> типы.</li>
</ul>

<p>В F# есть три случая, в которых функция может быть неопределенной:</p>
<ol>
  <li>Вычисления в функции не завершаются — упала в бесконечную рекурсию и тд.</li>
  <li>Вычисления завершились с рейзом исключения.</li>
  <li>Вычисления возвращают вышеупомянутый тип option.</li>
</ol>

<p>Простой пример:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let div x y = if y = 0 then None else Some(x / y)
let r = div 2 0 
</code></pre></div></div>

<p>Тогда:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printfn "%s" (string r) 
</code></pre></div></div>

<p>не выведет ничего. Но если значение есть, мы можем достать его из Some с помощью Option.get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let r = div 4 2 
printfn "%d" (Option.get r)
</code></pre></div></div>

<h1 id="списки-в-f">Списки в F#</h1>

<p>Списки отличаются от кортежей тем, что они являются цепочками значений <em>одного</em> типа.</p>

<p>В F# списки заключаются в квадратные скобки, а элементы перечисляются через точку с запятой.</p>

<p>В типе списков можно увидеть ключевое слово list, которое является <em>конструктором типа</em>.
У списка:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ ("hello", "world"); ("hello", "friend") ]
</code></pre></div></div>

<p>Тип будет:</p>

<p>(string * string) list</p>

<p>Добавить элемент в голову списка можно специальным оператором — “::”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"hello" :: ["w"; "o"; "r"; "l"; "d"] = ["hello"; "w"; "o"; "r"; "l"; "d"]
</code></pre></div></div>

<p>Список из целых значений с единичным шагом можно выражать зачениями диапазона используя две точки, например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 10 ]
</code></pre></div></div>

<p>Шаг можно изменить, указав его между первым и последним значеним так же — через две точки</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 3 .. 12 ]
</code></pre></div></div>

<p>Сцепить вместе два списка можно с помощью инфиксного оператора @:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "h"; "e"] @ [ "l"; "l"; "o"]
</code></pre></div></div>

<h1 id="множества">Множества</h1>

<p>Множеством называется неупорядоченный набор элементов одного типа, <em>среди которых нет повторяющихся</em>, то есть одинаковых.</p>

<p>Список преобразовать во множество можно с помощью функции Set.ofList, и обратно — Set.toList.</p>

<p>Добавить и убрать элемент — Set.add <элемент>, Set.remove <элемент></элемент></элемент></p>

<p>Проверить что элемент есть в списке можно с помощью Set.contains, или проверить на вхождение подмножества — Set.isSuset:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set.contains "hello" (set ["hello"; "w"; "o"; "r"; "l"; "d"])
Set.isSubset (set ["w"; "o"]) (set ["hello"; "w"; "o"; "r"; "l"; "d"])
</code></pre></div></div>

<p>Объединяются множества через Set.union, а пересечения и различия находятся как Set.intersect и Set.difference соответственно.</p>

<h1 id="хвостовая-рекурсия">Хвостовая рекурсия</h1>

<p>Рекурсию мы уже достаточно хорошо обсуждали во втором посте о Декларативном программированиие -&gt; <a href="/2022/02/12/hack_in_declarative_model_2.html">тык чтобы перечитать</a>.</p>

<p>Давайте рассмотрим живой пример на F#.</p>

<p>Неоптимизированная рекурсивная функция для расчета факториала будет выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec factorial = function 
 | 1  -&gt; 1
 | x  -&gt; x * factorial(x - 1)
</code></pre></div></div>

<p>Здесь x накапливает результат, но на каждом итерации рекурсии будет происходить вызов функции factorial, и её результаты умножаться на x.</p>

<p>Избавиться от лишних рекурсивных вызовов можно использовав прием с <em>аккумулятором</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let factorial n =
    let rec inner_wrapper x a =
        if x &lt;= 1 then a
        else inner_wrapper (x - 1) (a * x)
    inner_wrapper n 1
</code></pre></div></div>

<p>Здесь рекурсивные вычисления выполняются в другой, вложенной функции inner_wrapper, а её рекурсивный вызов располагается в самом конце, и не входит в какие либо вычисления как в предыдущем примере. Благодаря этому компилятор сможет оптимизировать выполнение без использования стека произвольной рекурсивной глубины.</p>

<h1 id="последовательности-и-ленивые-вычисления">Последовательности и ленивые вычисления</h1>

<p>Ленивые вычисления, это такая математическая модель вычислений в программировании. Как это работает? Например в F# есть <em>Последовательности</em>. Это как раз пример “ленивой структуры”.</p>

<p>Последовательность — это упорядоченная коллекция элементов, значения которых вычисляются <em>лишь в момент обращения к ним.</em></p>

<p>Фишка в том, что последовательность может быть <em>бесконечной</em>. И таковыми их можно представить как раз благодаря “ленивости”, никаких накладных расходов на определение последовательностей нет (не нужно сразу что-то бесконечно вычислять :)</p>

<p>Бесконечная последовательность задаётся дефолтной функцией Seq.initInfinite, и в параметр ей мы передаем другую функции которая будет генерировать последовательные значения.</p>

<p>Такая последовательность будет в себе содержать квадраты целых чисел:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let squares = Seq.initInfinite (fun x -&gt; x * x)
</code></pre></div></div>

<p>Мы можем получить (вычислить) любой по индексу элемент последовательности с помощью функции Seq.item. А ещё последовательности можно кэшировать, чтобы не приходилось при каждом обращении к последоватльности вычислять её значения.</p>

<p>Пример выше можно было бы закэшировать так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let cached_squares = Seq.cache squares
</code></pre></div></div>

<p>После этого при обращении к n-ному элементу такой последовательности будут вычислять этот и все предыдущие элементы, <em>если они ещё не были вычислен</em>, ну а в противном случае — использовать кэшированные результаты.</p>

<h1 id="резюме">Резюме</h1>

<p>В целом, наверное на этом всё. Мне кажется что не совсем уместо тупо перечислять стандартные функции. Документация F# вполне себе ок, как на английском так и на русском.</p>

<p>И рассматривать (читай спойлерить) задания из курса как в прошый раз я не хочу. Скажу лишь главное — это было круто, и стоило того. Пусть и пришлось поломать голову. Хотя, кмк я больше преувеличиваю и задания были проще чем мне казалось.</p>

<p>По крайней мере после сравнения своего решения и эталонного я так думал практически каждый раз :D</p>

<p>Я никогда особо до этого не трогал лапками функциональные языки, разве что хаскель полтора раза, и скажу честно две вещи:</p>

<ol>
  <li>Мне <strong>очень</strong> понравилось.</li>
  <li>Не знаю когда и что я буду, и буду ли вообще писать на чисто функциональных языках, но кажется что это правда как то меняет точку зрения на программирование в целом. Может мне кажется, но всё таки кажется что не кажется.</li>
</ol>

<p>Я знаю что пишу часто криво, криво рейрачу, но кто бы это не прочитал — идите потрогайте ФП, и посмотрите внимательно в зеркало, ведь там очень красивый и умный человек :)</p>

<p>P.S. 
Если вдруг захотите <del>удариться головой об косяк</del> преисполниться в ФП на F# поищите учебник: “Functional Programming Using F#” Michael R. Hansen</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"><![CDATA[Послесловие о функциональном программировании на F#]]></summary></entry><entry xml:lang="ru"><title type="html">Почтовые протоколы</title><link href="http://localhost:4000/2022/06/01/mail_protocols.html" rel="alternate" type="text/html" title="Почтовые протоколы" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/mail_protocols</id><content type="html" xml:base="http://localhost:4000/2022/06/01/mail_protocols.html"><![CDATA[<p>Немного о том как письма в интернете ходят.</p>

<!--more-->

<p>Привет! В этому посте я предлагаю немного ознакомиться с почтовыми протоколами. Какие бывают? Попробуем понять чем они отличаются. В нашем прицеле сегодня POP3, SMTP, ESMTP и IMAP.</p>

<h1 id="pop3">POP3</h1>
<p>Протокл POP3 (Post Office Protocol) — это ещё один <del>старый</del> стандартный сетевой протокол используемый локальными почтовыми клиентами для получения писем с почтового сервера по TCP/IP соединению. Первая версия протола появилась в 1984 году (<a href="https://datatracker.ietf.org/doc/html/rfc918">RFC 918</a>), а актуальная версия, как не сложно догадаться — третья!</p>

<p>Кому интересно: Вторая версия протокола описана в <a href="https://datatracker.ietf.org/doc/html/rfc937">RFC 937</a> в 85 году, третья в <a href="https://datatracker.ietf.org/doc/html/rfc1081">RFC 1081</a> в 1988. В течении следующих 10 лет протокол несколько раз прееопредялялся, и последняя актуальная версия была описана в 1996 году в <a href="https://www.ietf.org/rfc/rfc1939.txt">RFC 1939</a>.</p>

<p>Протокол до сих пор очень распространен, и одной из главных причин этому — простота его конфигурации.</p>

<h2 id="как-работает-pop3">Как работает POP3</h2>
<p>Серверы электронной почты, размещенные например у интернет провайдеров, так же часто используют POP3 для получения и харнения писем, предназначенных для их подписчиков. Периодически эти самые подписчики используют клиенты для проверки своих ящиков на удаленных почтовых серверах, и загружают письма предназначенные им.</p>

<p>Обычно, когда письмо загруженно клиентом, оно удаляется с почтового сервера. Некоторые почтовые клиенты позволяют менять это поведения, копируя письмо на локальный хост и не удаляя его с сервера в течении определенного времени.</p>

<p>Как правило клиенты используют 110 порт для подключения к POP3 серверу. Существует так же версия поддерижвающая шифрование — POP3S. Работает с TLS или SSL обычно на порту 995.</p>

<p>Преимущества POP3:</p>
<ul>
  <li>Так как почта загружается на компьютер пользователя её можно читать в оффлайне;</li>
  <li>Аттачменты можно открывать быстро, по той же причине — они уже скачаны;</li>
  <li>Нужно меньше дискового пространства на сервере, так как письма хранятся у клиента;</li>
  <li>Широко распространен, легко настроить.</li>
</ul>

<p>Минусы:</p>
<ul>
  <li>Если почты много пользователю может потребоваться выделять для её хранения слишком много дискового пространства;</li>
  <li>Всю почту можно утратить если медным тазом накроется диск, или ещё хуже — если в почте были конфиденциальные данные и ваш компьютер украли…</li>
  <li>Нет настроек сортировки писем, вся почта летит в одну директорию;</li>
  <li>Если в используемом клиенте нет возможности копировать письмо с сервера (только выкачивать с удалением), то приедтся пользоваться почтой только с одного устройства;</li>
  <li>Письма можно скачивать только целиком, вместе с аттачами.</li>
</ul>

<h1 id="imap">IMAP</h1>

<p>Inernet Message Access Protocol — ещё один почтовый протокол для получения писем с почтового сервера. Аналог POP. Точно так же работает в клиент-серверной архитектуре. Всё поверх того же TCP/IP, используя по дефолту 143 порт для незащищенного соединения, и 993 для шифрованного.</p>

<p>Первая версия задокументирована в <a href="https://datatracker.ietf.org/doc/html/rfc1064">RFC 1064</a> в июле 1988, обновлена в <a href="https://datatracker.ietf.org/doc/html/rfc1176">RFC 1176</a> в августе 1990, IMAP3 появился в феврале 1991, описан в <a href="https://datatracker.ietf.org/doc/html/rfc1203">RFC 1203</a>.</p>

<p>IMAP3, кстати, никто так и не использовал, все продолжали работать с IMAP2.</p>

<p>После этого было ещё одно изменение — внедрение поддержки MIME в расширении названном IMAPbis.</p>

<p>Наконец, современный IMAP4 впервые был описан в двух публикациях: <a href="https://datatracker.ietf.org/doc/html/rfc1730">RFC 1730</a>, которая содержит спецификацию протокола, и <a href="https://datatracker.ietf.org/doc/html/rfc1731">RFC 1731</a> — с описанием механизма аутентификации в IMAP4.</p>

<h2 id="фичи-imap">Фичи IMAP</h2>

<p>Протокол был разработан специально для обеспечения максимально гибкого спобоса доступа пользователя к своему ящику. IMAP может работать в любом из трех режимов: онлайн, оффлайн или автономно (disconnected).</p>

<p>IMAP предоставляет следующие возможности:</p>
<ul>
  <li>Доступ и получение почты с удаленного сервера (практически как в POP);</li>
  <li>Установка флага прочитанных сообщений;</li>
  <li>Управление несколькими почтовыми ящиками, перекидывание писем из одиного в другой, организация ящиков в категории, создавать иерархии из директорий для писем;</li>
  <li>Возможность загружать часть сообщения. Например без мультимедиа содержимого;</li>
  <li>Организация почты на сервере в соответствии с требованиями. Можно удалять или переименовывать свой ящик на сервере (в POP так нельзя);</li>
  <li>Можно искать письма по ключевым словам;</li>
  <li>Проверка заголовка письма, перед его загрузкой.</li>
</ul>

<p>Преимущества IMAP:</p>
<ul>
  <li>Вся почта хранится на сервере, доступна с любого устройства-клиента;</li>
  <li>Письма не загружаются все сразу на локальный компьютера как в POP, и соответственно нет таких требований к дисковому пространству.</li>
  <li>Письма хранятся в условной безопасности на сервере, риски утечек и утраты почты меньше по сравнению с POP.</li>
  <li>Благодаря возможности частичной загрузки почтой можно пользоваться даже при плохом соединении, загружая только тело письма без тяжелых аттачей.</li>
</ul>

<p>Минусы IMAP:</p>
<ul>
  <li>Вся почта на сервере, так что без интернета не получится загружать и новые и уже полученные письма, которые были кэшированы более двух недель назад;</li>
  <li>В случае компрометации ящика злоумышленниками всё его содержимое станет им доступно. В сравнении с POP это “палка о двух концах”, но проблемы информационой безопасности корреспонденции выходят за рамки этого обзора.</li>
</ul>

<h1 id="smtp">SMTP</h1>

<p>SMTP (Simple Mail Transfer Protocol) ещё один сетевой протокол старичок, представленный в 1982 году в <a href="https://datatracker.ietf.org/doc/html/rfc821">RFC 821</a>.</p>

<p>Преследует две задачи: проверка правильности конфигурации системы, авторизация на отправку письма для конкретного устройства, и собственно сама отправка исходящего письма на указанный адрес с подтверждением успешной доставки.</p>

<p>Кстати, если письмо доставить не удалось — отправитель получит алерт.</p>

<p>SMTP может работать практически с любыми протоколами транспортного уровня (TCP, UDP и тд). По умолчанию работет на двух портах: 25 служит для передачи почты между почтовыми серверами, и 587, по которому почта передается от клиента на сервер.
Поддерживает SSL шифрование (задействуется дополительно 465-ый порт).</p>

<h2 id="формат-письма-в-smtp">Формат письма в SMTP</h2>

<p>Почтовое сообщение в SMTP состоит из “конверта”, заголовка и тела письма. 
Формат заголовка и тела подробно описан в <a href="https://datatracker.ietf.org/doc/html/rfc2822">RFC 2822</a>.</p>

<p>Конверт, грубо говоря, это такая абстракция для передачи сообщений между клиентом и сервером. На самом деле они общаются в привычном клиент-серверном формате запросов и ответов.</p>

<h2 id="запросы-и-ответы-smtp">Запросы и ответы SMTP</h2>

<p>Самые часто используемые запросы (команды):</p>
<ul>
  <li>Helo: служит для установки соединения, и выполняется только когда клиент укзаывает свой домен и почтовый адрес;</li>
  <li>Mail: задает адрес отправителя;</li>
  <li>RCTP: задает адрес получателя. Если получателей несколько, то они указываются каждый в отдельной RCTP команде;</li>
  <li>DATA: сигнал серверу о конце “конверта”, после чего идет само письмо;</li>
  <li>QUIT: разрыв соединения после окончания письма.</li>
</ul>

<p>Ответы SMTP состоят из кода и текста ответного сообщения. По коду можно понять если что то пошло не так. В человекочитаемом сообщении же будет указано что произошло в ходе отправки или получения письма.</p>

<p>Коды начинаются с 2, 3 и 5. В первом случае всё прошло хорошо, во втором — письмо отправилось, но нужны дополнительные данные. А пятерка это алерт, что то сломалось и надо разбираться.</p>

<h2 id="описание-работы">Описание работы</h2>

<p>Представим частный случай, в котором уже установлен и сконфигурирован SMTP север, и мы хотим отправить письмо:</p>
<ol>
  <li>Пишем письмо, указываем адрес отправителя, после чего происходит соединение с SMTP клиентом провайдера, например Gmail.</li>
  <li>Происходит передача почтовых адресов отправителя и получателя, тема письма и содержимое на сервер.</li>
  <li>SMTP система начинает искать SMTP сервер получателя.</li>
  <li>Если целевой сервер не будет найден, наш попытается ещё несколько раз это сделать. Если все попытки проваялся мы получим алерт о том что письмо не будет доставлено.</li>
  <li>Если всё хорошо и целевой сервер нашелся, то далее в работу вступают другие почтовые протоколы — POP3 или IMAP.</li>
</ol>

<h2 id="прекратить-спам">Прекратить спам!</h2>

<p>В 1995 году в качестве меры по борьбе с безудержным почтовым спамом появилось расширения SMTP протокола — ESMTP, которое добавлет дополнительные команды для защиты серверов и повышения пропускной способности. Например ESMTP привнес:</p>

<ul>
  <li>Аутентификацию отправителя;</li>
  <li>SSL-шифрование почты;</li>
  <li>Возможность аттачить мультимедиа файлы к письмам;</li>
  <li>Возможность ограничить размер писем в соответствии со спецификациями сервера;</li>
  <li>Одновременно слать письма нескольким адресатам;</li>
  <li>Стандартизацию алертов о невозможности доставки.</li>
</ul>

<p>Разумеется сейчас везде используется ESMTP, по понятным причинам.</p>

<h1 id="резюме">Резюме</h1>

<p>Так что же выбрать, IMAP или POP? Мы вкратце рассмотрели оба протокола, и с первого взгляда кажется что IMAP намного лучше. В этом есть доля истины. В принципе, единственным серьезныем отличием является сопосб хранения писем. В POP3 мы качаем все письма себе, и <em>возможно</em> в случае каких то сверхсекретных писем можно выбрать POP3, обмазав его всевозможным шифрованием, начиная от шифрования соединения, заканчивая шифрованием диска с письмами. Но это очень спорный момент, ведь с другой стороны практически все, если не все, почтовые провайдеры поддерживают двухфакторную аутентификцаию, которую сложно обойти… Сложно же, да? :D</p>

<p>Закончим на сегодня, пока я не ударился в шифропанковский параноидальный бред. Будьте здоровы!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Немного о том как письма в интернете ходят.]]></summary></entry><entry xml:lang="ru"><title type="html">Обзор DNS</title><link href="http://localhost:4000/2022/06/01/DNS.html" rel="alternate" type="text/html" title="Обзор DNS" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/DNS</id><content type="html" xml:base="http://localhost:4000/2022/06/01/DNS.html"><![CDATA[<p>Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?</p>

<!--more-->

<p>И Артпанет и наш нынешний интернет на очень примитивном уровне и грубо говоря — телефонна сеть. У каждого участника этой сети есть свой “номер телефона” — IPv4 или IPv6 адрес, по которому к нему можно “дозвониться”, например на какой нибудь порт.</p>

<p>на заре интернета в роли DNS выступал текстовый файлик HOSTS.TXT, который хранился в некотором сетевом информационно центре, и чтобы получить нужный адрес или внести свой в этот центр <strong>нужно было… звонить!</strong>  Чем больше развивалась сеть, тем больше становилось хостов, и поддерживать HOSTS.TXT стало, мягко говоря, неудобно. Тут родился DNS.</p>

<h1 id="что-такое-dns">Что такое DNS</h1>

<p>Domain Name System — это такая распределенная система, которая “превращает” доменные имена в IP адреса, которые клиент использует для получения нужных ему ресурсов с целевого сервера. Ну там, страничку в браузере загрузить :)</p>

<p>Служит вся эта история в первую очередь для нашего человеческого удобства.</p>

<h1 id="dns-сервер">DNS сервер</h1>

<p>Грубо говоря, DNS сервер это такой сервер, который хранит у себя подобие записной книги контактов в вашем телефоне — своего рода база данны, в которой записаны публичные IP адреса и связанные с ними <em>доменные имена</em>.</p>

<p>Как только IP адрес найден и передан клиенту, этот самый клиент может устанавливать нужные ему соединения, например с ближайшим CDN (content delivery network) сервером, на котором закеширован искомый ресурс или с “исходным”, как говорится origin сервером.</p>

<h1 id="как-устроен-dns">Как устроен DNS</h1>

<p>В обычным DNS запросе URL адрес, введенный пользователем должен пройти через четыре сервера, чтобы получить клиент получил нужный адрес.</p>

<p>Все эти четыре сервера работают вместе таким образом:</p>

<ul>
  <li>
    <p>DNS Recursor: его ещё называют “преобразователем DNS”. Этот сервер получает DNS запрос от клиента, а потом связывается с другими DNS сервера, чтобы они помогли ему найти верный адрес. На этом этапе преобразователь сам действует как клиент — он создает один или несколько DNS запросов, которые отправляются дальше.</p>
  </li>
  <li>
    <p>Root nameservers: это <em>коренные серверы имен</em>. Коревой сервер назначен на определенную <em>корневую</em> DNS зону интернета. Задачей такого сервера является обработка полученных DNS запросов, отвечая на которые корневой сервер формирует список <em>Авторитетных серверов имен <strong>верхнего уровня (TLD)</strong></em>, которые <em>вероятно могут</em> знать искомый в запросе адрес.</p>

    <p>Уровень домена определяется количеством точек в доменном имени. например blablabla.com будет доменом верхнего уровня, тогда как blabla.killme.com — второго, и так далее.</p>
  </li>
  <li>
    <p>TLD nameservers: или Top Level Domain Nameservers связаны с доменами верхнего уровня, и обычно эти серверы идут после коренных. Для простоты их можно представлять как ответвления от коренных серверов. На них содержится информация о доменах следующего уровня <em>конкретных DNS зон</em>.</p>
  </li>
  <li>
    <p>Authoritative nameservers: это те сервера, которые уже наконец дают какой то реальный ответ на изначальный DNS запрос. Есть два ипа таких серверов: главный сервер, и вторчный. Главный хранит <em>исходные</em> копие записей своей зоны, а вторичный (один или несколько) являются репликами главного, которые служат для распределния нагрузки и страховым вариантом в случае сбоя главнго сервера. Эти сервера так же хранят ресурсные DNS записи (А, АААА, CNAME, MX, TXT, и так далее)</p>
  </li>
</ul>

<h1 id="кэширование-dns">Кэширование DNS</h1>

<p>Кэширование результатов DNS запросов может происходить на уровне операционной системы или браузера. Это необходимо для оптимизации, ускорения обработки запросов. Зачем искать адрес, который мы итак уже знаем?</p>

<h2 id="рекурсивные-сервера">Рекурсивные сервера</h2>

<p>Мы уже выяснили, что авторитативные серверы хранят настоящие DNS записи, тогда как <em>рекурсивные</em> серверы выступают в роли посредников, которые находятся между авторитативным сервером и конечным клиентом. Чтобы найти нужную запись (нужный сервер имен) рекурсивные серверы посредством DNS запросов “рекурсивно” проходят по дереву DNS серверов, чтобы наконец добраться до своей цели.</p>

<p>Рекурсивные серверы хранят у себя в кеше результаты своих “путешествий”, чтобы каждый раз не искать по новой. Время такого кеширования определяется хозяином домена с помощью параметра TTL (time to live).</p>

<h1 id="ещё-раз-как-как-это-работает">Ещё раз… как как это работает?</h1>

<p>Если всё ещё непонятно, давайте быстро разберем базовый случай.</p>

<ol>
  <li>Вбиваем адрес сайта в браузер.</li>
  <li>Браузер проверяет кэш. Если адреса есть — начинает работать с ресурсом используя этот адрес. Если адреса нет идем дальше.</li>
  <li>Бразуер отправляет запрос к DNS-резолверу. Резолвер это такая служба в операционной сети. Если в кэше у резолвера нашелся нужный адрес — возвращаем его браузеру для работы, если адреса нет:</li>
  <li>DNS-резолвер отправляет запрос DNS-резолверу вашего интернет провайдера, или резолверу Google (8.8.8.8, 4.4.4.4), или на худой конец в CloudFlare (1.1.1.1). Резолвер снова проверяет свой кэш на предмет запроса. Если и тут адреса нет:</li>
  <li>DNS-резолвер провайдера отправляет запросы коренным DNS серверам (кому слать резолвер понимает по домену верхнего уровня). Корневые серверы проверяют есть ли у них информация о домене верхнего уровня из полученного запроса. Если такая информация найдена, коренной сервер возвращает резолверу адрес TLD сервера. Если нет — возвращает ошибку, потому что запрощенной зоны просто не существует.</li>
  <li>Резовер, получив адрес TLD сервера отправляет к нему запрос, и TLD сервер проверяет у себя информацию о домене второго уровня из запроса. Если такой домен у него есть, значит домен существует и зарегистрирован. Тогда TLD сервер вернет адрес авторитативного сервера.</li>
  <li>Получив адрес авторитативного сервера резолвер отправляет ему запрос. Авторитативный сервер проверяет свою базу данных, и если нужный домен в ней есть — возвращает его IP адресс, который записан в А записи этого домена.</li>
  <li>Наконец, когда нужный адрес найдер и получен резолвером, последний записывает этот адрес в свой кэш и передает его в резовер нашей операционной системы, который оттуда попадает в браузер (и оседает в кэш соответственно).</li>
</ol>

<p>Всё это работает быстро, в первую очередь благодаря кэшированию на многих уровнях DNS системы.</p>

<h1 id="дайте-потрогать">Дайте потрогать!</h1>

<p>Посмотреть глазами как это работает можно с помощью утилиты dig, которая есть и на линуксе и на, простите, макоси. Если вы заядный виндузятник можете воспользоваться NSLOOKUP, но лучше поставьте Linux :D</p>

<p>Трейснуть dns с помощью dig можно командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    gid +trace &lt;интересующий_домен&gt;
</code></pre></div></div>

<p>Если dig у вас по какой то причине не установлен, нужно установить dnsutils или bind-utils для debian и redhat семейств соответственно.</p>

<p>Если вы всё таки решили сидеть на винде, и читаете это до сих пор, а NSLOOKUP вдруг неожиданно оказался не очень информативной штукой, вы можете воспользоваться любым онлайн инструментов для трейса DNS.</p>

<h1 id="резюме">Резюме</h1>

<p>Как видите в DNS ничего страшного и сложного нет, и работает эта штука предельно понятно. Я не говорю тут про имплементацию самих серверов, это наверное совсем отдельная тема :D</p>

<p>По традиции для владеющих английским языком, и жадных до знаний приведу для затравки пару RFC по теме: <a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035</a> с основой спецификацией, и <a href="https://datatracker.ietf.org/doc/html/rfc1912">RFC 1912</a> уже на тему “Common DNS Operational and Configuration Errors”.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?]]></summary></entry></feed>