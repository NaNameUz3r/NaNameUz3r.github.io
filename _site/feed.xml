<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-06-13T18:45:51+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Про модель OSI и коммутаторы</title><link href="http://localhost:4000/2022/06/13/OSI_and_switches.html" rel="alternate" type="text/html" title="Про модель OSI и коммутаторы" /><published>2022-06-13T00:00:00+03:00</published><updated>2022-06-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/13/OSI_and_switches</id><content type="html" xml:base="http://localhost:4000/2022/06/13/OSI_and_switches.html"><![CDATA[<p>Немного про модель OSI и работу элементарной канальной среды.
<!--more--></p>

<p>Всем привет! Я наконец дожил до момента когда начал нормально изучать сети! Конечно у меня был курс по сетям в колледже, и это было самое интересное и толкое что там вообще преподавалось (помимо основ схемотехники). Но признаюсь честно, во-первых, я тогда не очень сильно был заинтересован в учебе (о чем сильно сожалею), во-вторых, пусть в голову нам вдалбывалось знатно — я многое уже успешно забыл.</p>

<p>Последнее время в своей профессиональной практике я всё более остро ощущал нехватку хороших, фундаментальных знаний о сетевых технология. С одной стороны, в принципе базового понимания “как оно там вообще работает”, что есть порты, жидкого осознавания основных протоколов в большей части задач в моей текущей работе достаточно (с натяжкой), но когда дело доходит до откровенного ступора, лично мне перед самим собой стыдно бэкать и мэкать. Не стыдно бежать за помощью к коллегам, стыдно испытывать <em>нехватку компетенции.</em></p>

<p>Да, коллеги всегда помогут, но нужно профессионально расти. И ещё один фактор — мне просто до чертиков это интересно, и я рад наконец выделять на это время.</p>

<p>Сегодня я хочу вкратце написать про модель OSI и немного поговорить про коммутаторы и физические адреса устройств.</p>

<p>Кстати, значальное описание OSI в распечатанном виде имеет толщину в один метр.</p>

<p style="text-align: center;"><img src="/images/wow.png" alt="Базз" /></p>

<h1 id="osi">OSI</h1>

<p>OSI (Open System Intreconnection model) — это эталонная модель стека сетевых протоколов, которая состоит из семи уровней. Можно сказать что эта модель, некоторый “скелет” всех сетевых сущностей. Она определяет протоколы, следуя которым эти самые сетевые сущности между собой взаимодействуют. Протокол же это своеобразный набор правил <em>интерфейса логического уровня</em>, которыё определяет каким образом программы должны обмениваться данными между собой. Но сегодня мы говорим не о протоколах. Я недавно писал про <a href="/2022/06/01/DNS.html">HTTP</a>, <a href="2022/05/31/FTP.html">FTP</a>, и <a href="/2022/06/01/DNS.html">DNS</a>.</p>

<p>Передача всегда происходит от уровня к уровню, последовательно подклчая нужные протоколы на каждом из них.</p>

<p>Всего, как уже было сказано, модель OSI подразумевает семь уровней:</p>

<p style="text-align: center;"><img src="/images/OSI.jpg" alt="Базз" /></p>
<p><em><center>Извините что криво, я правда старался!</center></em></p>

<p>Модель OSI разрабатывалась давненько — в семидесятых годах. Задачей являлась попытка описать архитектуру и как вообще должны работать сети.</p>

<p>На последнем седьмом уровне передаваемае данные представляются в виде фактических данных, когда на первом — бежит по каналам в бинарном виде. Процесс в котором данные конвертируются из читаемых данных в биты называется знакомым нам из программирования термином <em>инкапсуляция</em>. Обратный процесс — <em>декапсуляция</em>. На каждом из уровней информация представляется в PDU (Protocol Data Unit), это такие блоки данных.</p>

<p>Все уровни условно делятся на две группы: уровни среды передачи, и уровни хоста. Уровни с 1 по 3 это как раз уровни среды, они занимаются непосредственно передачей информации, тогда как остальные уровни хоста (с 4 по 7) используются непосредственно на наших девайсах (десктопы, лаптопы, смартфоны и тд)</p>

<h2 id="физический-уровень-l1">Физический уровень L1</h2>

<p>Уровень отвечает за обмен электрическими или оптическими сигналами по проводам, или радиоволнами безпроводных сетей (Bluetooth, WiGI, GSM и вот это вот всё) между какими то устройствами. Наши компьютеры вообще ничего не знают про то что такое картинки, какая там фотография изображена или новый смешной мемас. Комьютеру мемасы понятны только как наборы нулей и единиц (это грустно). Здесь бит является блоком данных (PDU).</p>

<p>Каждый уровень имеет свои PDU, представляемые образом понятным протоколам того же уровня, иногда и протоколам следующего уровня, например для возможности преобразования. Работа с “чистыми” данными будет производиться только на уровнях с 5 по 7.</p>

<h2 id="канальный-уровень-l2">Канальный уровень L2</h2>

<p>На этом уровее решается проблема адресации передачи. Канальный уровень инкапсулирует биты в <em>кадры</em> (frame). Кадры формируются с адресами отправителя и получателя, а потом отправляются дальше.</p>

<p>Тут есть условно два “подуровня” — это MAC и LLC. Первый служит для “присвоения” физических адресов железок, а второй занимается проверкой и исправлением данных, а так же управляет их передачей.</p>

<p>На втором уровне OSI работают коммутаторы, их задача — передать сформированные кадры от одного устройства к другому, используя в качестве адресов только физические MAC-адреса. Про комммутаторы и MAC адреса мы поговорим в заключительной части.</p>

<h2 id="сетевой-уровень-l3">Сетевой уровень L3</h2>

<p>Здесь вводится маршрутизация. Маршрутизацией занимаются специальный устройва… маршрутизаторы (роутерами). Роутеры получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута между устройствами.</p>

<p>На сетевом уровне есть протокол ARP (Address Resolution Protocol), благодаря которому MAC-адреса некоторым образом преобразуются в 32-битные IP-адреса и наоборот.</p>

<h2 id="транспортный-уровень-l4">Транспортный уровень L4</h2>

<p>Помните мы говорил про уровни среды и уровни хоста? Так вот четвертый уровень это что-то вроде уровня посредника между этими двумя группами. Транспортный уровень регулирует транспортировкой пакетов в сети. Тут работают такие протоколы передачи как TCP и UDP. TCP контролирует целостность передаваемой (доставленной) информации, а UDP — нет. В TCP <em>устанавливается соединение</em> пакеты данных делятся на сегменты, успешность и целостность доставки каждого пакета некоторым образом “проверяется”. Отправили, подождали подтверждения что все дошло ОК, не дошло - отправили ещё раз. В UDP — отправил куда сказали и забыл, плевать если какая то датаграмма (в этом протоколе пакеты делятся на датаграммы а не на сегменты) потерялась или дошла битой.</p>

<p>Датаграммы UDP отличаются от сегментов TCP тем что у каждой датаграммы есть заголовки в которых указан адрес получателя данных. И сегмент и датаграмма это PDU транспортного уровня.</p>

<h2 id="сеансовый-уровень-l5">Сеансовый уровень L5</h2>

<p>Уровень отвечает за поддержку сесси (сенса) связи. Начиная с этого уровнядДанные оперируются в “чистом” виде. Сеансовый уровень управляет тем как разные приложения взаимодействуют между собой, предоставляет возможность синхронизации задач. Всё это нужно для работы следующего уровня.</p>

<h2 id="уровень-представления-данных-l6">Уровень представления данных L6</h2>

<p>Уровень “конверитрует” данные, которые всё ещё в виде каких то PDU в представление понятное человеку (и компьютеру). Например тут происходит перевод текста из одной кодировки в другую. Видео и изображения тоже обрабатываются на этом уровне. А ещё, если соединение требует шифрования, в бой оно вступает так же на уровне представления данных.</p>

<h2 id="прикладной-уровень-l7">Прикладной уровень L7</h2>

<p>Это уровень приложений (application level). Это тот уровень с которым взаимодействуют конечные пользователи, типа GUI всей OSI. Короче говоря, задачей протоколов этого уровня является только предоставление возможности пользователю увидеть данные в понятном ему виде (например, HTTP протокол 7 уровня).</p>

<h1 id="зачем-мне-знать-osi-если-везде-tcpip">Зачем мне знать OSI, если везде TCP/IP</h1>

<p>Модель OSI это стандарт (ISO/IEC 7498). Его просто надо знать, потому что не смотря на запятнаную репутацию и критику модель есть и она всё ещё используется.</p>

<p>Репутация… Ну, модель OSI много и оправданно критикуют. Её слишком долго разрабатывали и её обвиняют в том, что модель <em>не совсем отображает действительность</em>. На момент релиза OSI уже широко был распространен стек TCP/IP. Кто знает, если бы с разработкой OSI не затягивали она была бы фактическим, “настоящим” стандартом. Или если бы модель не проектировали в сверхсекретном “закрытом” режиме, тогда как стек TCP/IP изначально была <em>открыт</em>, она была бы принята с более распростертыми руками.</p>

<p>Ещё OSI критикуют из за того что функции уровней распределены между ними неравнозначно, и что вообще одинаковые задачи могут быть решены на <em>разных уровнях</em>. В общем ругают за то что уровней вообще слишком много, сеть можно построить используя только первые 4.</p>

<p>—-</p>

<h1 id="коммутируй-то-коммутируй-это">Коммутируй то! Коммутируй это!</h1>

<p>Я обещал чуть больше рассмотреть канальный уровень. Приступаем!</p>

<h2 id="зачем-в-сетях-нужны-коммутаторы">Зачем в сетях нужны коммутаторы?</h2>

<p>Современные сети построенны на канальном уровне с использованием коммутаторов, которые связывают разные компьютеры между собой. Грубо говоря коммутаторы нужны не только чтобы просто соединить машины, но в первую очередь — чтобы избежать коллизиий, присущих такой устаревшей сетевой топологии как “шина”, в которой как раз таки все машины связывали в тупую одним каналом.</p>

<p>Так вот, шина — это когда все компьютеры в сети подключены к одному “кабелю”, а коллизия это такой “цифровой” хаос в сети, когда одновременно пытаются общаться больше двух машин по одному каналу. Например коллизия может возникнуть в шине когда в сети есть сервер и N компьютеров, и одновременно два (или больше) клиента попробуют обратиться к одному и тому же серверу.</p>

<h2 id="устройство-коммутатора">Устройство коммутатора</h2>

<p>У сетевого коммутатора (свитча) есть условно два буфера: входящий и исходящий. На самом деле буфер логически делится на буферы портов.</p>

<p>Когда в сети с коммутатором один из компьютеров отправляет данные другому, эти данные сначала попадают во входящий буфер свитча (коммутатора) по одному из портов. После этого свитч решает на какой иной порт (куда) эти данные нужно перенаправить (используя MAC таблицу, про MAC будет дальше), а точнее <em>на <strong>исходящий</strong> буфер какого порта их нужно перенаправить</em>.</p>

<p>После этого коммутатор ждет когда целевой канал освободится, ведь с сервером могут общаться другие участники сети по этому же каналу. Когда это происходит данные из соответствующего буфера свитча отправляются на сервер. В одном таком исходящем буфере могут спокойно ждать своей очереди исходящие данные от двух и более участников сети (которые хотят достучаться на один и тот же сервер).</p>

<p>Именно благодаря описанному выше механизму (очереди в буфере) коллизий в сети не происходит.</p>

<p>В старые (но не очень) времена существовали так называемые концентраторы (хабы). Отличались они от свитчей тем что у них не было буферов. Такое устройство по сути являлось всего лишь  электрическим повторителем, и никак не уберегало сеть от возникновения коллизий.</p>

<h2 id="домен-коллизии">Домен коллизии</h2>

<p>Домен коллизии — это участок сети на котором есть <em>возможность</em> возникновения коллизии. Очевидно что в случае с топологией шина домен коллизии распространяется условно на всю сеть, но в случае применения коммутаторов он ограничен участком сети от <em>конечного узла до самого коммутатора</em>.</p>

<p>На этом участке коллизия может возникнуть если узел и коммутатор будут работать в <em>полудуплексном</em> (half-duplex) режиме.</p>

<p>Дуплекс — это, собственно такой сопосб связи двух устройств которые могут связываться друг с другом в оба направления. Когда <em>симплекс</em> — связываться только в одном направлении. Устройство которое реализует в себе полный дуплекс способно передавать или принимать данные в любой момент времени, а вот полудуплекс не может одновременно. Полудуплекс это когда в один момент времени устройство может только передавать или получать данные.</p>

<p>Коллизии при half-duplex в участках до коммутара возникают, когда передатчик коммутатора и сетевой карты узла начинают одновременно или почти одновременно передавать данные в разных режимах (прием/передача), считая что участок сети между ними свободен.</p>

<hr />

<p>На сегодня это всё. На самом деле в отдельности каждую из тем можно долго-долго рассматривать. Если вы настолько жадны до сетей, то… Почитайте Таненбаума, например!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сети" /><summary type="html"><![CDATA[Немного про модель OSI и работу элементарной канальной среды.]]></summary></entry><entry xml:lang="ru"><title type="html">Продолжаем исследовать Императивную модель</title><link href="http://localhost:4000/2022/06/13/hack_in_imperative_2.html" rel="alternate" type="text/html" title="Продолжаем исследовать Императивную модель" /><published>2022-06-13T00:00:00+03:00</published><updated>2022-06-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/13/hack_in_imperative_2</id><content type="html" xml:base="http://localhost:4000/2022/06/13/hack_in_imperative_2.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 2.
<a href="/2022/06/06/hack_in_imperative_1.html">Читать предыдущую часть.</a>
<!--more--></p>

<h1 id="компонентно-ориентированное-программирование">Компонентно ориентированное программирование</h1>

<p>Характеристики абстракции, которые мы разбирали в прошлой части, определяют собой <em>Компонентно ориентированное программирование</em>.</p>

<p>Компонент следует понимать как определение части программной системы изнутри и снаружи, иными словами — четкое определение <em>интерфейса</em> 
той части.</p>

<p>Внутренняя составляющая компонента скрыта (инкапсуляция), изнутри доступно только то что определено интерфейсом.</p>

<p>Благодаря композиционности из компоненты могут составляться другие, новые компоненты. Это естественный способ расширения возможностей одного компонента. Для реализации компонента с новым требуемым функционалом мы можем использовать уже существующий компонент или компоненты, которые уже реализует в себе некоторую часть (в существенной степени) этого нового функционала.</p>

<p>Инстанциирование компонентов позволяет создавать их новые экземпляры, которые моментально включаются в рантайм.</p>

<p>На самом деле компонент это ещё одна фундаментальная программистская концепция, признаки которой можно обнаружить во многих, если не во всех, программных концепциях и техниках:</p>

<ul>
  <li><strong>Процедурная абстракция</strong> — это компонент! Почему? Потому что это определение функции с параметрами, а экземпляр, то есть инстанциирование процедурной абстракции — это вызов определенной функции с аргументами;</li>
  <li><strong>Функтор</strong> (разбирали <a href="/2022/03/20/program-design.html">здесь</a>) — это исходный код программного модуля, который компилируется в сам модуль независимо от других компонентов;</li>
  <li><strong>Параллельные компоненты</strong> — программная система состоящая из независимых и взаимодействующих с друг другом элементов может быть представлена нами как граф из одновременно работающих <em>компонентов</em>, которые общаются посредством обмена сообщениями.</li>
</ul>

<h1 id="ооп">ООП</h1>

<p>Объектно-ориентированное программирование это по сути компонентно ориентированное, только с добавлением ещё одной концепции\механики — <strong>наследования</strong>.</p>

<p>Наследование — это такой способ конструирования программной системы, в котором реализация нового функционала основывается на уже существующей.
Такие постепенно развивающиеся компоненты называются <em>классами</em>, а экземпляры классов — <em>объектами</em>.</p>

<p>Возможность повторно использовать код в ООП сильно снижает дублирование кода и его избыточность в системе в целом, это большой и сильный плюс.
Но как известно:</p>

<p style="text-align: center;"><img src="/images/resplonsibiliy.webp" alt="Базз" /></p>
<p><em><center>Прислушайтесь к дяде Бену!</center></em></p>

<p>Почему так? Кажется что возможность каскадно переиспользовать код очень круто, добавляет возможность гибко, практически как угодно жонглировать компонентами и внедрять их друг в друга! Здорово же, да?</p>

<p>На самом деле нет, не очень. Компоненты начинают очень сильно зависеть от компонентов, которые они наследуют. В результате система становится все менее “модульной” и всё более <em>связанной</em>. Такими зависимостями становится очень сложно управлять.</p>

<p>Несмотря на то что большая литературы и учебников по объектно-ориентированному проектированию сфокусированы на правильном использовании наследования, стоит прислушаться к светлым и опытным инсайдерским умам, которые рекомендуют по возможности <strong>использовать композицию а не наследование.</strong> Пусть композиция и менее гибкий подход, тем не менее она проще в использовании. А наследование нужно применять только тогда, когда композиции недостаточно.</p>

<p>Если поступать таким образом, то иерархии в системе будут получаться намного менее глубокими, чем при использовании исключительно наследования. И как следствие, система будет менее связанной и запутанной.</p>

<h1 id="декларативная-модель-с-явным-состоянием">Декларативная модель с явным состоянием</h1>

<p><em>Явно состояние</em> — это пара из двух сущностей ЯП:</p>
<ol>
  <li>Идентичность (identity) — способ именования состояния в программе.</li>
  <li>Текущее содержание состояния — это собственно значение, с которым связано имя состояния.</li>
</ol>

<p>Сюда добавляется ещё операция, которая позволят посредством идентичности состояния получить текущее содержание.</p>

<h2 id="ячейка">Ячейка</h2>

<p>Мы уже говорили про ячейки в прошлый раз. Ячейка — это явное состояние, и <em>базовый тип</em> который мы добавляем в вычислительную модель.</p>

<p>Ячейка состоит из неизменяемого (постоянного) имени и ссылки на объект в хранилище однократных присваиваний.</p>

<p class="info">Напоминаю где можно вспомнить про внутрнее устройство декларативной модели -&gt; <a href="/2022/02/06/hack_in_declarative_model.html">тут</a>.
А если вы до сих пор не понимаете почему мы так много говорим в этом цикле о декларативной модели, хотя сабжем вроде как является императивная — рекомендую сперва прочитать весь цикл отчетов по изучению декларативной модели (начиная со ссылки выше, там будут кросссылки на следующие посты).</p>

<p>Благодаря тому что имя ячейки не допускается изменять все они (ячейки) фактически получаются чистыми абстрактными типами данных. Множество же самих ячеек хранится в некотором мутабельном (изменяемом) хранилище.</p>

<p>В результате вычислительная модель состоит из неизменяемого хранилища однократных присваиваний, которое содержит в себе dataflow-переменные (это такие переменные которые могуть быть связаны только с одним значением), и из второго — изменяемого хранилища, в котором хранятся пары из имен и ссылок (ячейки).</p>

<p>В такой модели существует элементарный язык программирования, который расширяет базовую декларативную модель двумя операциями, которые условно назовем NewCell и Exchange.</p>

<p>У NewCell есть два параметра. Эта операция создает новую ячейку с именем из первого параметра, и с содержимым (ссылкой) во втором:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NewCell C X
</code></pre></div></div>

<p>Операция Exchange уже имеет три параметра:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exchange C X Y
</code></pre></div></div>

<p>Эта операция связывает X с прежним содержимым ячейки С, и задает этой ячейке новое содержимое, передаваемое в Y.</p>

<p>Для обеспечения большей выразительности в такую модель добавляются ещё две инструкции:</p>

<ul>
  <li>
    <p>Операция @ предоставляет доступ к содержимому ячейки С:</p>

    <p>X = @C</p>
  </li>
  <li>
    <p>Операция := присваивает ячейке C новое значение из Y, и <em>возвращает значение ячейки X</em>:</p>

    <p>C := Y</p>
  </li>
</ul>

<p>Прикол в том, что добавление такой ячейки с лишь двумя операциями хватает чтобы построить <strong>все</strong> концепции, которые может предоставить понятие <em>состояния</em>.</p>

<p class="info">Все сложные концепции абстрактных типов данных можно построить с помощью декларативной модели дополненной ячейками.</p>

<h1 id="связь-с-декларативным-программированием">Связь с декларативным программированием</h1>

<p>Строго говоря, “императивная” stateful-программа не может считаться декларативной. Потому что её выполнение несколько раз с одними и теми же входными данными может давайть разные результаты, в зависимости от внутреннего состояния.</p>

<p>Однако, stateful-программы можно писать таким образом, чтобы они <em>удовлетворяли определению декларативной операции</em>. Чтобы они <strong>вели себя декларативно</strong>.</p>

<p>Мы разбирали пару декларативных функций <a href="hack_in_declarative_model_6.html">здесь</a></p>

<p>Любую из них можно взять и переписать в императивном “стиле”, изменив внутреннюю декларативную рекурсивную реализацию например на простой перебор циклом, который будет записывать в результирущий список каждый подходящий по функции-предикату элемент. Результирующий список это явное состояние (локальная переменная) внутри реализации вычислений.</p>

<p>Таким образом интерфейс самой функции оберки filter остается неизменным, и её пользователю вообще неизвестно какая там внутри реализация, а сам filter ведет себя всё ещё декларативно.</p>

<h2 id="мемоизация">Мемоизация</h2>

<p>Ещё одна полезная техника в разрезе декларативной модели с использованием состояний — <em>мемоизация</em>. Это такой финт, когда функция запоминает результаты её предыдущих вызовов (например очень тяжелых вычислений), что позволяет при повторных вызовах такой функции использовать эти результаты сразу же. В такой функции внутри состояние реализуется в замыкании, но внешне ей поведение формально остается декларативным.</p>

<h1 id="sharing-состояний">Sharing состояний</h1>

<p>Один из важных нюансов, который нужно строго формализировать при работе с состояниями это понятие <em>равенства ячеек</em>.</p>

<p>Нужно понять, можно ли считать что две ячейки равны, когда равно их <em>содержание</em>, или если два идентификатора (X и Y) ссылаются на одну и ту же ячейку?</p>

<p>Такие случаи “равенств” называют sharing или aliasing, что по сути является совместным использованием некоторого содержания ячейками, которые являются <em>алиасами</em>.</p>

<p>Когда мы изменим содержимое ячейки X это автоматически приводит и к изменению содержимого ячейки Y, ведь физически <em>их содержимое одно и то же</em>.</p>

<p>В ООП это называется <em>передача объектов по ссылке</em>.</p>

<p>Формальное понимание программы, в которой есть много алиасов у ячейки заметно усложняется. Эта проблема решается с помощью <em>инкапсуляции состояния</em> следующим образом:</p>

<p class="info">Вся логика работы с состоянием выделяется в отдельную и четко определенную часть программы, которая гарантирует что состояние оттуда не сможет выбраться. Поэтому абстрактные типы данных идеальный способ для использования явных состояний, потому что они инкапсулируются в АТД, скрываясь за набором определенных высокоуровневых операций.</p>

<h1 id="атд-и-способы-их-организации">АТД и способы их организации</h1>

<p>В <a href="hack_in_declarative_model_6.html">последнем посте</a> из цикла изучения Декларативной модели мы уже знакомились с АТД и способами их защиты. Сейчас пришла пора добавить к этой джедайской технике понятие состояния.</p>

<p>Абстрактные типы данных с одной и той же функциональностью могут быть по разному реализованы внутри. В эволюции АТД есть ещё две “перпендикулярных оси” — <em>состояние</em> и <em>бандлинг</em>. Вметсе с защищенностью эти три аспекта составляют восемь способов организации АТД, а зависимости от применения или не применения каждого из них.</p>

<p>Давайте рассмотрим эту тему чуть более подробно.</p>

<h2 id="открытость-и-защищённость">Открытость и защищённость</h2>

<p><em>Открытый абстрактный тип данных</em> — это АТД, внутренее представление которого видно везе в программе. Реализация такого типа может быть размазана по коду, а разные его части расширяться независимо друг от друга. Такая реализация может быть полезна разве что в небольших проектах, когда выразительность важнее чем безопасность. Только не используйте это как оправдание лени писать безопасный код.</p>

<p><em>Защищенный абстрактный тип данных</em> — это АТД реализация которого недоступна остальным частям программы, и его реализация сосредоточена в одном модуле. Как я уже упоминал, способ защиты АТД мы рассматривали в последнем посте о Декларативной модели.</p>

<p>АТД может быть “частично безопасным”, когда права на чтение внутренней реализации выдаются другим частям программы некоторым контролируемым образом (wrap, unwrap).</p>

<h2 id="состояние-в-атд">Состояние в АТД</h2>

<p><strong>Stateless-АТД</strong> создаются в рамках декларативной вычислительной модели. Нужно создавать новые экземпляры АТД, так как модифицировать их запрещено. Такой подход приводит к увеличению количества экземпляров АТД в программе, из за чего ими может становиться трудно управлять. Сам код программы становится менее модульным, потому что мы помним — это <em>декларативная модель</em>, и как следствие экхемпляры должны передаваться по конвейеру вычислений даже через части программы, которые в этом АТД не нуждаются.</p>

<p><strong>Statefull-АТД</strong>, очевидно, использует внутри себя явные состояния. А значит его экземпляры могут изменяться во времени. В такой реализации нельзя быть уверенным какое значение инкапсулировано внутри экземпляра АТД, не обладая полной историей вызовов процедур с момента создания экземпляра. Здесь так же существует только один экземпляр, в отличие от декларативных АТД. Кроме того, зачастую этот экземпляр вообще не надо передавать внутрь функции как параметр, потому что доступ к нему может быть организован через лексическое замыкание.</p>

<p>Этот подход позволяет сделать программу более выразительной и лаконичной, а так же, возможно, более модульной, потому что нам не нужно “связывать” экземляр АТД с частями системы которым он не нужен.</p>

<h2 id="бандлинг">Бандлинг</h2>

<p>Бандлинг (запаковка) — это когда данные хранятся <em>вместе с операциями</em>.</p>

<p><strong>Распакованный АТД</strong> — это АТД, у которого можно отделить данные от операций. При этом распакованный АТД <em>может быть безопасным</em>. Достигается это путем создания каждого экземпляра АТД вместе с некоторым “ключем”, который представляет собой разрешение на доступ к внутренним данным экземпляра, и на измнение, если АТД обладает состоянием. Все операции такого АТД “знают” ключ, в отличе от остальной части программы. Как правило ключ — это неизменяемая константа.</p>

<hr />

<p>В реальном мире из восьми комбинаций вышеупомянутых аспектов АТД используются эти варианты:</p>

<ul>
  <li>“Открытый, декларативный, распакованный” — Такой подход реализуется в языке Prolog, и некоторых других.</li>
  <li>“Защищенный, декларативный, запакованный” — Добавляются абстракции для реализации декларативного стиля.</li>
  <li>“Защищенный, декларативный, распакованный” — Объектно-ориентированное расширение декларативного стиля.</li>
  <li>“Защищенный, stateful, запакованный” — Это классичское объектно ориентированное программирование, например Java.</li>
  <li>“Защищенный, stateful, распакованный” — “Распакованный” ООП.</li>
</ul>

<p>Эти комбинации перечислены в порядке усложнения их реализации.</p>

<p>Пример первого пункта рассматривался в последнем посте о декларативной модели (реализация стека).</p>

<hr />

<p>На сегодня всё. Пожалуйста не забывайте отдыхать!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 2. Читать предыдущую часть.]]></summary></entry><entry xml:lang="ru"><title type="html">Нам нужны явные состояния. Нужны же?…</title><link href="http://localhost:4000/2022/06/06/hack_in_imperative_1.html" rel="alternate" type="text/html" title="Нам нужны явные состояния. Нужны же?…" /><published>2022-06-06T00:00:00+03:00</published><updated>2022-06-06T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/06/hack_in_imperative_1</id><content type="html" xml:base="http://localhost:4000/2022/06/06/hack_in_imperative_1.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 1.
<!--more--></p>

<p>Всем привет! Я приступил к очередному курсу в skillsmart.ru 
На этот раз темой курса является изучение Императивной модели программирования, как расширения фундаментальной Декларативной модели.</p>

<p>Вы что нибудь помните про декларативную модель, и про состояния?
Мы разбирали эти и другие связанные темы некоторое время назад на соответствуещм курсе. Почитать про это вы можете в моих постах-отчетах, начиная с <a href="/2022/02/06/hack_in_declarative_model.html">этого.</a></p>

<p>Но тут мы тоже будем сперва говорить про декларативность, потому что никуда без неё :P</p>

<h1 id="stateful-programming">Stateful programming</h1>

<p>В императивной модели концепция времени понимается уже совсем по другому. Наверное самое главное отличие императивной модели от декларативной заключается именно в этом.</p>

<p>Время тут меняется благодаря введению в модель <em>Явных состояний</em>, которые добавляют программным сущностям возможность <em>долгосрочной памяти</em>.</p>

<p>Иными словами — тут появляются привычные нам “императивные” переменные.</p>

<p>Есть ещё умные слова, которыми достаточно часто отмечают природу состояний в моделях: <strong>stateless</strong> и <strong>stateful</strong> программирование. На самом под первым как правило имеется в виду декларативное, а под вторым — императивное.</p>

<p>Давайте вкратце повторимся.</p>

<p><em>Декларативное программирование</em> — это когда мы описываем <strong>какой результат</strong> нужно получить. Возможно с дополнительным определением “подказок” как его получить :)</p>

<p style="text-align: center;"><img src="/images/declarative_meme.jpeg" alt="Рекурсивные кролики" /></p>

<p><em>Императивное программирование</em> — это когда мы с помощью конкретных команд описываем <strong>как получить результат</strong>.</p>

<p>На самом деле декларативное программированое в какой то степени императивно, потому что всё равно зачастую используются последовательности каких то команд.</p>

<p>Вообще, Декларативная парадигма это в первую очередь математическая модель, а сама “декларативность” проще будет пониматься как <em>относительная степень</em>, в которой эта самая декларативность применяется в языке программирования.</p>

<h1 id="прелести-декларативного-подхода">Прелести декларативного подхода</h1>

<p>Хотя декларативный подход можно, грубо говоря, “спроецировать” на любой программный код, на практике же (в логических или фунциональных программах, например) он теряет большую часть аспекта <em>“что делать”</em>, так как приходится более детально описывать подробности <em>“как делать”</em>.</p>

<p>Тем не менее это не значит что от декларативного программирования можно или нужно как то отказываться, потому что у него есть три существеннных плюшки:</p>

<ol>
  <li>В декларативной модели проще формировать практически все программные абстракции благодаря тому что декларативные операции <strong>композиционны</strong>.</li>
  <li>Декларативные программы просто тестировать, потому что достаточно протестировать одиночныне вызовы команд, когда stateful программу тестировать сложнее из за того что приходится проверять <em>последовательности вызовов</em>.</li>
  <li>Рассуждать о программи в декларативной модели проще, чем при использовании императивного программирования.</li>
</ol>

<h1 id="снова-о-состояниях">Снова о состояниях</h1>

<p>Итак, мы уже выяснили что <em>состояние</em> — это растянутая во времени последовательность значений, в которой содержатся промежуточные результаты нужного вычисления.</p>

<p>Мы помним что в декларативной модели состояние характеризуется как <strong>скрытое</strong>. Такие декларативные, состояния никак <em>явно</em> не поддерживаются со стороны вычислительной модели. Последовательности вычислений могут пониматься и представляться только в сознании программирующего существа, а на уровне кода последовательности просто не существуют.</p>

<p>Явное состояние наоборот — <em>существует</em> на протяжении времени, в более чем одном вызове функции <em>без явного определения этого состояния в аргументах этой функции</em>.</p>

<p>Такое состояние реализуется с помощью некоторого “контейнера”, который принято называть <strong>ячейка</strong>. Такая ячейка уже фактически существует в коде, наблюдается, иными словами — <em>не только в сознании программирующего существа.</em></p>

<h1 id="принцип-абстракции">Принцип абстракции</h1>

<p>По мере роста системы описывать её абстракции в чисто декларативном или функциональном программировании становится всё сложнее, потому что сам <em>принцип</em> абстракции не очень хорошо поддерживается этими парадигмами. Причиной этой сложности является как раз природа состояний — мы не можем вкладывать <em>новую</em> информацию в компоненты программы или функции (инкапсулировать их внутри).</p>

<p>Для того чтобы система могла хорошо поддерживать принцип абстракции она должна обладать следующими характеристиками:</p>

<ul>
  <li><strong>Инкапсуляция</strong> — это возможность скрывать внутренние части самой системы;</li>
  <li><strong>Композиционность</strong> — это про возможность комбинирования частей системы в целях полуения новых частей;</li>
  <li><strong>Инстанциирование</strong> (invocation) — возможность создавать много конкретных экземпляров компонена на основе его единого определения.</li>
</ul>

<p>Если вы знаете хотя бы немного про ООП (объектно ориентированное программирование), то наверняка уловили сейчас знакомые концепции. Но мы говорим сейчас совсем не про “высокии материи” ООП, и используем более фундаментальные и универсальные принципы программирования для определения и понимания этих концепций.</p>

<p>Например <em>замыкани</em> обеспечивают инкапсуляцию, а инстанциирование достигается посредством программирования высшего порядка.</p>

<p><strong>Важной</strong> особенность характеристик перечисленных выше является то, что их набор <strong>не требует использования концпеции состояния</strong>.</p>

<p>На самом деле инкапсуляция вообще противоположна состоянию, и её можно применять в декларативном программировании. Состояния же могут обходиться без икапсуляции, к примеру — с помощью создания <em>глобальных переменных</em>.</p>

<p>Пришла пора поговорить о cons, а то всё про pros да про pros :)</p>

<p>Добавления концепции состояния к декларативному программированию резко и в разы усложняет понимание самой программы, становится не так просто рассуждать о ней.</p>

<p>Во-первых мы можем столкнуться с <strong>побочными эффектами</strong> у функций, которые теперь могут менять состояния что не видны во всей остальной программе.</p>

<p>Именно по этой причине явное состояние нужно обязательно <strong>применять в тесной связи с инкапсуляцией</strong>, благодаря чему появляется возможность проектировать stateful-системы корректно. Тут появляется понитие <strong>инварианта</strong>, который всегда выглядит “снаружи” правильно.</p>

<p>Это возвращает нам возможность рассуждать о подсистемах формально, считая что поведение этой подсистемы не зависит от окружающей среды, тем самым частично возвращая нас в плане рассуждений к декларативному программированию. Тем не менее, одно только введение инвариантов всё ещё не делает программирование с использованием состояний таким же простым и понятным как декларативное.</p>

<p>Потому что инвариант <em>всего лишь определяет что компонент не ведет себя некорректно</em>, и никак не гарантируется то, что он помогает в продвижении к решению итоговой задачи.</p>

<p>Из всего это следует очень важное правило:</p>

<p class="info">Сложные системы нужно проектировать так, чтобы как можно больше количество компонентов этой системы было описано в декларативной парадигме.</p>

<p>Состояния <strong>должны</strong> быть сконцентрированны в единичных компонентах. Нельзя растягивать состояния по несколькоим компонентам.</p>

<hr />

<p><a href="/2022/06/13/hack_in_imperative_2.html">Читать продолжение</a></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 1.]]></summary></entry><entry xml:lang="ru"><title type="html">F# Напоследок</title><link href="http://localhost:4000/2022/06/03/last_about_f.html" rel="alternate" type="text/html" title="F# Напоследок" /><published>2022-06-03T00:00:00+03:00</published><updated>2022-06-03T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/03/last_about_f</id><content type="html" xml:base="http://localhost:4000/2022/06/03/last_about_f.html"><![CDATA[<p>Послесловие о функциональном программировании на F#
<!--more--></p>

<p>Привет! Совсем недавно я завершил базовый курс по функциональному программированию на F# в <a href="http://skillsmart.ru/">skillsmart.ru</a>.
Хочу написать ещё немного об этом опыте, в продолжение <a href="/2022/04/17/more_about_f.html">предыдущего поста</a></p>

<p>Рассмотрим несколько фишек и типов F#</p>

<h1 id="определение-типа-и-записи">Определение типа и записи</h1>

<p>В F#, как и в большинстве языков программирования можно определять свои типы, делается это с помощью ключевого токена “type”.</p>

<p>Есть так же такой тип как Запись (record), который фактически является кортежем, но его элементы идентифицируются ключами-метками (названиями), а не порядковой позицией. Это напоминает словарь в Python.</p>

<p>Сперва нам нужно определить структуру записи как тип.
Например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type = Weapon { fullauto : bool; load_amount: int; fire_rate: float32 }
</code></pre></div></div>

<p>Затем мы можем определить “экземпляр” записи:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47 = { fullauto = true; load_amount = 30; fire_rate = 100.54 }
</code></pre></div></div>

<p>Не нужно как-то дополнительно указывать что ak47 это запись типа Weapon — компилятор F# сам поймет на основании идентификаторов используемых полей.</p>

<p>Мы можем обращаться к каждому отдельному полю записи, чтобы получить её значение используя точечную нотацию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47_firerate = ak47.fire_rate
</code></pre></div></div>

<p>Записи можно целиком сравнивать, если типы данных значений полей совпадают. Такое сравнение происходит в лексикографическом порядке.</p>

<h1 id="размеченное-объединение">Размеченное объединение</h1>

<p>Это тип данный, в котором мы задаем множество некоторых идентификаторов. Соответственно размеченное объединение может принимать только тип из своего “списка”. Синтаксис напоминает сопоставление с образцом — используем пайп:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47
  | m249_saw
  | colt_anaconda
</code></pre></div></div>

<p>На полную катушку оторваться тут можно уже фактически используя паттернматчинг фишку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47 -&gt; "автомат"
  | m249_saw -&gt; "пулемет"
  | colt_anaconda -&gt; "револьвер"

let full_auto = function
  | ak47 | m249_saw -&gt; true
  | _ -&gt; false
</code></pre></div></div>

<h2 id="конструктор-значений">Конструктор значений</h2>

<p>Мы так же можем обозначить тип данных для каждого элемента-тега размеченного объединения:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Сaliber =
  | Pistol of float32
  | Machine_gun of float32
  | Cannon of int
</code></pre></div></div>

<p>В таком случае тег связанные с типом является фактически функцией, которыю называются конструкторами значений.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak_caliber = Machine_gun 7.62
let bfgun_caliber = Cannon 666
</code></pre></div></div>

<h1 id="частичные-функции">Частичные функции</h1>

<p>Это такая функция, которая только на <em>подмножистве значений аргументов</em>.</p>

<p>Есть специальный тип <strong>option</strong>, у которого может быть только два значения:</p>
<ul>
  <li>None: тут всё понятно;</li>
  <li>Some: это <em>полиморфный</em> конструктор значений, который прнимает <em>любые</em> типы.</li>
</ul>

<p>В F# есть три случая, в которых функция может быть неопределенной:</p>
<ol>
  <li>Вычисления в функции не завершаются — упала в бесконечную рекурсию и тд.</li>
  <li>Вычисления завершились с рейзом исключения.</li>
  <li>Вычисления возвращают вышеупомянутый тип option.</li>
</ol>

<p>Простой пример:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let div x y = if y = 0 then None else Some(x / y)
let r = div 2 0 
</code></pre></div></div>

<p>Тогда:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printfn "%s" (string r) 
</code></pre></div></div>

<p>не выведет ничего. Но если значение есть, мы можем достать его из Some с помощью Option.get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let r = div 4 2 
printfn "%d" (Option.get r)
</code></pre></div></div>

<h1 id="списки-в-f">Списки в F#</h1>

<p>Списки отличаются от кортежей тем, что они являются цепочками значений <em>одного</em> типа.</p>

<p>В F# списки заключаются в квадратные скобки, а элементы перечисляются через точку с запятой.</p>

<p>В типе списков можно увидеть ключевое слово list, которое является <em>конструктором типа</em>.
У списка:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ ("hello", "world"); ("hello", "friend") ]
</code></pre></div></div>

<p>Тип будет:</p>

<p>(string * string) list</p>

<p>Добавить элемент в голову списка можно специальным оператором — “::”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"hello" :: ["w"; "o"; "r"; "l"; "d"] = ["hello"; "w"; "o"; "r"; "l"; "d"]
</code></pre></div></div>

<p>Список из целых значений с единичным шагом можно выражать зачениями диапазона используя две точки, например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 10 ]
</code></pre></div></div>

<p>Шаг можно изменить, указав его между первым и последним значеним так же — через две точки</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 3 .. 12 ]
</code></pre></div></div>

<p>Сцепить вместе два списка можно с помощью инфиксного оператора @:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "h"; "e"] @ [ "l"; "l"; "o"]
</code></pre></div></div>

<h1 id="множества">Множества</h1>

<p>Множеством называется неупорядоченный набор элементов одного типа, <em>среди которых нет повторяющихся</em>, то есть одинаковых.</p>

<p>Список преобразовать во множество можно с помощью функции Set.ofList, и обратно — Set.toList.</p>

<p>Добавить и убрать элемент — Set.add <элемент>, Set.remove <элемент></элемент></элемент></p>

<p>Проверить что элемент есть в списке можно с помощью Set.contains, или проверить на вхождение подмножества — Set.isSuset:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set.contains "hello" (set ["hello"; "w"; "o"; "r"; "l"; "d"])
Set.isSubset (set ["w"; "o"]) (set ["hello"; "w"; "o"; "r"; "l"; "d"])
</code></pre></div></div>

<p>Объединяются множества через Set.union, а пересечения и различия находятся как Set.intersect и Set.difference соответственно.</p>

<h1 id="хвостовая-рекурсия">Хвостовая рекурсия</h1>

<p>Рекурсию мы уже достаточно хорошо обсуждали во втором посте о Декларативном программированиие -&gt; <a href="/2022/02/12/hack_in_declarative_model_2.html">тык чтобы перечитать</a>.</p>

<p>Давайте рассмотрим живой пример на F#.</p>

<p>Неоптимизированная рекурсивная функция для расчета факториала будет выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec factorial = function 
 | 1  -&gt; 1
 | x  -&gt; x * factorial(x - 1)
</code></pre></div></div>

<p>Здесь x накапливает результат, но на каждом итерации рекурсии будет происходить вызов функции factorial, и её результаты умножаться на x.</p>

<p>Избавиться от лишних рекурсивных вызовов можно использовав прием с <em>аккумулятором</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let factorial n =
    let rec inner_wrapper x a =
        if x &lt;= 1 then a
        else inner_wrapper (x - 1) (a * x)
    inner_wrapper n 1
</code></pre></div></div>

<p>Здесь рекурсивные вычисления выполняются в другой, вложенной функции inner_wrapper, а её рекурсивный вызов располагается в самом конце, и не входит в какие либо вычисления как в предыдущем примере. Благодаря этому компилятор сможет оптимизировать выполнение без использования стека произвольной рекурсивной глубины.</p>

<h1 id="последовательности-и-ленивые-вычисления">Последовательности и ленивые вычисления</h1>

<p>Ленивые вычисления, это такая математическая модель вычислений в программировании. Как это работает? Например в F# есть <em>Последовательности</em>. Это как раз пример “ленивой структуры”.</p>

<p>Последовательность — это упорядоченная коллекция элементов, значения которых вычисляются <em>лишь в момент обращения к ним.</em></p>

<p>Фишка в том, что последовательность может быть <em>бесконечной</em>. И таковыми их можно представить как раз благодаря “ленивости”, никаких накладных расходов на определение последовательностей нет (не нужно сразу что-то бесконечно вычислять :)</p>

<p>Бесконечная последовательность задаётся дефолтной функцией Seq.initInfinite, и в параметр ей мы передаем другую функции которая будет генерировать последовательные значения.</p>

<p>Такая последовательность будет в себе содержать квадраты целых чисел:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let squares = Seq.initInfinite (fun x -&gt; x * x)
</code></pre></div></div>

<p>Мы можем получить (вычислить) любой по индексу элемент последовательности с помощью функции Seq.item. А ещё последовательности можно кэшировать, чтобы не приходилось при каждом обращении к последоватльности вычислять её значения.</p>

<p>Пример выше можно было бы закэшировать так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let cached_squares = Seq.cache squares
</code></pre></div></div>

<p>После этого при обращении к n-ному элементу такой последовательности будут вычислять этот и все предыдущие элементы, <em>если они ещё не были вычислен</em>, ну а в противном случае — использовать кэшированные результаты.</p>

<h1 id="резюме">Резюме</h1>

<p>В целом, наверное на этом всё. Мне кажется что не совсем уместо тупо перечислять стандартные функции. Документация F# вполне себе ок, как на английском так и на русском.</p>

<p>И рассматривать (читай спойлерить) задания из курса как в прошый раз я не хочу. Скажу лишь главное — это было круто, и стоило того. Пусть и пришлось поломать голову. Хотя, кмк я больше преувеличиваю и задания были проще чем мне казалось.</p>

<p>По крайней мере после сравнения своего решения и эталонного я так думал практически каждый раз :D</p>

<p>Я никогда особо до этого не трогал лапками функциональные языки, разве что хаскель полтора раза, и скажу честно две вещи:</p>

<ol>
  <li>Мне <strong>очень</strong> понравилось.</li>
  <li>Не знаю когда и что я буду, и буду ли вообще писать на чисто функциональных языках, но кажется что это правда как то меняет точку зрения на программирование в целом. Может мне кажется, но всё таки кажется что не кажется.</li>
</ol>

<p>Я знаю что пишу часто криво, криво рейрачу, но кто бы это не прочитал — идите потрогайте ФП, и посмотрите внимательно в зеркало, ведь там очень красивый и умный человек :)</p>

<p>P.S. 
Если вдруг захотите <del>удариться головой об косяк</del> преисполниться в ФП на F# поищите учебник: “Functional Programming Using F#” Michael R. Hansen</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"><![CDATA[Послесловие о функциональном программировании на F#]]></summary></entry><entry xml:lang="ru"><title type="html">Обзор DNS</title><link href="http://localhost:4000/2022/06/01/DNS.html" rel="alternate" type="text/html" title="Обзор DNS" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/DNS</id><content type="html" xml:base="http://localhost:4000/2022/06/01/DNS.html"><![CDATA[<p>Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?</p>

<!--more-->

<p>И Артпанет и наш нынешний интернет на очень примитивном уровне и грубо говоря — телефонна сеть. У каждого участника этой сети есть свой “номер телефона” — IPv4 или IPv6 адрес, по которому к нему можно “дозвониться”, например на какой нибудь порт.</p>

<p>на заре интернета в роли DNS выступал текстовый файлик HOSTS.TXT, который хранился в некотором сетевом информационно центре, и чтобы получить нужный адрес или внести свой в этот центр <strong>нужно было… звонить!</strong>  Чем больше развивалась сеть, тем больше становилось хостов, и поддерживать HOSTS.TXT стало, мягко говоря, неудобно. Тут родился DNS.</p>

<h1 id="что-такое-dns">Что такое DNS</h1>

<p>Domain Name System — это такая распределенная система, которая “превращает” доменные имена в IP адреса, которые клиент использует для получения нужных ему ресурсов с целевого сервера. Ну там, страничку в браузере загрузить :)</p>

<p>Служит вся эта история в первую очередь для нашего человеческого удобства.</p>

<h1 id="dns-сервер">DNS сервер</h1>

<p>Грубо говоря, DNS сервер это такой сервер, который хранит у себя подобие записной книги контактов в вашем телефоне — своего рода база данны, в которой записаны публичные IP адреса и связанные с ними <em>доменные имена</em>.</p>

<p>Как только IP адрес найден и передан клиенту, этот самый клиент может устанавливать нужные ему соединения, например с ближайшим CDN (content delivery network) сервером, на котором закеширован искомый ресурс или с “исходным”, как говорится origin сервером.</p>

<h1 id="как-устроен-dns">Как устроен DNS</h1>

<p>В обычным DNS запросе URL адрес, введенный пользователем должен пройти через четыре сервера, чтобы получить клиент получил нужный адрес.</p>

<p>Все эти четыре сервера работают вместе таким образом:</p>

<ul>
  <li>
    <p>DNS Recursor: его ещё называют “преобразователем DNS”. Этот сервер получает DNS запрос от клиента, а потом связывается с другими DNS сервера, чтобы они помогли ему найти верный адрес. На этом этапе преобразователь сам действует как клиент — он создает один или несколько DNS запросов, которые отправляются дальше.</p>
  </li>
  <li>
    <p>Root nameservers: это <em>коренные серверы имен</em>. Коревой сервер назначен на определенную <em>корневую</em> DNS зону интернета. Задачей такого сервера является обработка полученных DNS запросов, отвечая на которые корневой сервер формирует список <em>Авторитетных серверов имен <strong>верхнего уровня (TLD)</strong></em>, которые <em>вероятно могут</em> знать искомый в запросе адрес.</p>

    <p>Уровень домена определяется количеством точек в доменном имени. например blablabla.com будет доменом верхнего уровня, тогда как blabla.killme.com — второго, и так далее.</p>
  </li>
  <li>
    <p>TLD nameservers: или Top Level Domain Nameservers связаны с доменами верхнего уровня, и обычно эти серверы идут после коренных. Для простоты их можно представлять как ответвления от коренных серверов. На них содержится информация о доменах следующего уровня <em>конкретных DNS зон</em>.</p>
  </li>
  <li>
    <p>Authoritative nameservers: это те сервера, которые уже наконец дают какой то реальный ответ на изначальный DNS запрос. Есть два ипа таких серверов: главный сервер, и вторчный. Главный хранит <em>исходные</em> копие записей своей зоны, а вторичный (один или несколько) являются репликами главного, которые служат для распределния нагрузки и страховым вариантом в случае сбоя главнго сервера. Эти сервера так же хранят ресурсные DNS записи (А, АААА, CNAME, MX, TXT, и так далее)</p>
  </li>
</ul>

<h1 id="кэширование-dns">Кэширование DNS</h1>

<p>Кэширование результатов DNS запросов может происходить на уровне операционной системы или браузера. Это необходимо для оптимизации, ускорения обработки запросов. Зачем искать адрес, который мы итак уже знаем?</p>

<h2 id="рекурсивные-сервера">Рекурсивные сервера</h2>

<p>Мы уже выяснили, что авторитативные серверы хранят настоящие DNS записи, тогда как <em>рекурсивные</em> серверы выступают в роли посредников, которые находятся между авторитативным сервером и конечным клиентом. Чтобы найти нужную запись (нужный сервер имен) рекурсивные серверы посредством DNS запросов “рекурсивно” проходят по дереву DNS серверов, чтобы наконец добраться до своей цели.</p>

<p>Рекурсивные серверы хранят у себя в кеше результаты своих “путешествий”, чтобы каждый раз не искать по новой. Время такого кеширования определяется хозяином домена с помощью параметра TTL (time to live).</p>

<h1 id="ещё-раз-как-как-это-работает">Ещё раз… как как это работает?</h1>

<p>Если всё ещё непонятно, давайте быстро разберем базовый случай.</p>

<ol>
  <li>Вбиваем адрес сайта в браузер.</li>
  <li>Браузер проверяет кэш. Если адреса есть — начинает работать с ресурсом используя этот адрес. Если адреса нет идем дальше.</li>
  <li>Бразуер отправляет запрос к DNS-резолверу. Резолвер это такая служба в операционной сети. Если в кэше у резолвера нашелся нужный адрес — возвращаем его браузеру для работы, если адреса нет:</li>
  <li>DNS-резолвер отправляет запрос DNS-резолверу вашего интернет провайдера, или резолверу Google (8.8.8.8, 4.4.4.4), или на худой конец в CloudFlare (1.1.1.1). Резолвер снова проверяет свой кэш на предмет запроса. Если и тут адреса нет:</li>
  <li>DNS-резолвер провайдера отправляет запросы коренным DNS серверам (кому слать резолвер понимает по домену верхнего уровня). Корневые серверы проверяют есть ли у них информация о домене верхнего уровня из полученного запроса. Если такая информация найдена, коренной сервер возвращает резолверу адрес TLD сервера. Если нет — возвращает ошибку, потому что запрощенной зоны просто не существует.</li>
  <li>Резовер, получив адрес TLD сервера отправляет к нему запрос, и TLD сервер проверяет у себя информацию о домене второго уровня из запроса. Если такой домен у него есть, значит домен существует и зарегистрирован. Тогда TLD сервер вернет адрес авторитативного сервера.</li>
  <li>Получив адрес авторитативного сервера резолвер отправляет ему запрос. Авторитативный сервер проверяет свою базу данных, и если нужный домен в ней есть — возвращает его IP адресс, который записан в А записи этого домена.</li>
  <li>Наконец, когда нужный адрес найдер и получен резолвером, последний записывает этот адрес в свой кэш и передает его в резовер нашей операционной системы, который оттуда попадает в браузер (и оседает в кэш соответственно).</li>
</ol>

<p>Всё это работает быстро, в первую очередь благодаря кэшированию на многих уровнях DNS системы.</p>

<h1 id="дайте-потрогать">Дайте потрогать!</h1>

<p>Посмотреть глазами как это работает можно с помощью утилиты dig, которая есть и на линуксе и на, простите, макоси. Если вы заядный виндузятник можете воспользоваться NSLOOKUP, но лучше поставьте Linux :D</p>

<p>Трейснуть dns с помощью dig можно командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    gid +trace &lt;интересующий_домен&gt;
</code></pre></div></div>

<p>Если dig у вас по какой то причине не установлен, нужно установить dnsutils или bind-utils для debian и redhat семейств соответственно.</p>

<p>Если вы всё таки решили сидеть на винде, и читаете это до сих пор, а NSLOOKUP вдруг неожиданно оказался не очень информативной штукой, вы можете воспользоваться любым онлайн инструментов для трейса DNS.</p>

<h1 id="резюме">Резюме</h1>

<p>Как видите в DNS ничего страшного и сложного нет, и работает эта штука предельно понятно. Я не говорю тут про имплементацию самих серверов, это наверное совсем отдельная тема :D</p>

<p>По традиции для владеющих английским языком, и жадных до знаний приведу для затравки пару RFC по теме: <a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035</a> с основой спецификацией, и <a href="https://datatracker.ietf.org/doc/html/rfc1912">RFC 1912</a> уже на тему “Common DNS Operational and Configuration Errors”.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?]]></summary></entry><entry xml:lang="ru"><title type="html">Почтовые протоколы</title><link href="http://localhost:4000/2022/06/01/mail_protocols.html" rel="alternate" type="text/html" title="Почтовые протоколы" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/mail_protocols</id><content type="html" xml:base="http://localhost:4000/2022/06/01/mail_protocols.html"><![CDATA[<p>Немного о том как письма в интернете ходят.</p>

<!--more-->

<p>Привет! В этому посте я предлагаю немного ознакомиться с почтовыми протоколами. Какие бывают? Попробуем понять чем они отличаются. В нашем прицеле сегодня POP3, SMTP, ESMTP и IMAP.</p>

<h1 id="pop3">POP3</h1>
<p>Протокл POP3 (Post Office Protocol) — это ещё один <del>старый</del> стандартный сетевой протокол используемый локальными почтовыми клиентами для получения писем с почтового сервера по TCP/IP соединению. Первая версия протола появилась в 1984 году (<a href="https://datatracker.ietf.org/doc/html/rfc918">RFC 918</a>), а актуальная версия, как не сложно догадаться — третья!</p>

<p>Кому интересно: Вторая версия протокола описана в <a href="https://datatracker.ietf.org/doc/html/rfc937">RFC 937</a> в 85 году, третья в <a href="https://datatracker.ietf.org/doc/html/rfc1081">RFC 1081</a> в 1988. В течении следующих 10 лет протокол несколько раз прееопредялялся, и последняя актуальная версия была описана в 1996 году в <a href="https://www.ietf.org/rfc/rfc1939.txt">RFC 1939</a>.</p>

<p>Протокол до сих пор очень распространен, и одной из главных причин этому — простота его конфигурации.</p>

<h2 id="как-работает-pop3">Как работает POP3</h2>
<p>Серверы электронной почты, размещенные например у интернет провайдеров, так же часто используют POP3 для получения и харнения писем, предназначенных для их подписчиков. Периодически эти самые подписчики используют клиенты для проверки своих ящиков на удаленных почтовых серверах, и загружают письма предназначенные им.</p>

<p>Обычно, когда письмо загруженно клиентом, оно удаляется с почтового сервера. Некоторые почтовые клиенты позволяют менять это поведения, копируя письмо на локальный хост и не удаляя его с сервера в течении определенного времени.</p>

<p>Как правило клиенты используют 110 порт для подключения к POP3 серверу. Существует так же версия поддерижвающая шифрование — POP3S. Работает с TLS или SSL обычно на порту 995.</p>

<p>Преимущества POP3:</p>
<ul>
  <li>Так как почта загружается на компьютер пользователя её можно читать в оффлайне;</li>
  <li>Аттачменты можно открывать быстро, по той же причине — они уже скачаны;</li>
  <li>Нужно меньше дискового пространства на сервере, так как письма хранятся у клиента;</li>
  <li>Широко распространен, легко настроить.</li>
</ul>

<p>Минусы:</p>
<ul>
  <li>Если почты много пользователю может потребоваться выделять для её хранения слишком много дискового пространства;</li>
  <li>Всю почту можно утратить если медным тазом накроется диск, или ещё хуже — если в почте были конфиденциальные данные и ваш компьютер украли…</li>
  <li>Нет настроек сортировки писем, вся почта летит в одну директорию;</li>
  <li>Если в используемом клиенте нет возможности копировать письмо с сервера (только выкачивать с удалением), то приедтся пользоваться почтой только с одного устройства;</li>
  <li>Письма можно скачивать только целиком, вместе с аттачами.</li>
</ul>

<h1 id="imap">IMAP</h1>

<p>Inernet Message Access Protocol — ещё один почтовый протокол для получения писем с почтового сервера. Аналог POP. Точно так же работает в клиент-серверной архитектуре. Всё поверх того же TCP/IP, используя по дефолту 143 порт для незащищенного соединения, и 993 для шифрованного.</p>

<p>Первая версия задокументирована в <a href="https://datatracker.ietf.org/doc/html/rfc1064">RFC 1064</a> в июле 1988, обновлена в <a href="https://datatracker.ietf.org/doc/html/rfc1176">RFC 1176</a> в августе 1990, IMAP3 появился в феврале 1991, описан в <a href="https://datatracker.ietf.org/doc/html/rfc1203">RFC 1203</a>.</p>

<p>IMAP3, кстати, никто так и не использовал, все продолжали работать с IMAP2.</p>

<p>После этого было ещё одно изменение — внедрение поддержки MIME в расширении названном IMAPbis.</p>

<p>Наконец, современный IMAP4 впервые был описан в двух публикациях: <a href="https://datatracker.ietf.org/doc/html/rfc1730">RFC 1730</a>, которая содержит спецификацию протокола, и <a href="https://datatracker.ietf.org/doc/html/rfc1731">RFC 1731</a> — с описанием механизма аутентификации в IMAP4.</p>

<h2 id="фичи-imap">Фичи IMAP</h2>

<p>Протокол был разработан специально для обеспечения максимально гибкого спобоса доступа пользователя к своему ящику. IMAP может работать в любом из трех режимов: онлайн, оффлайн или автономно (disconnected).</p>

<p>IMAP предоставляет следующие возможности:</p>
<ul>
  <li>Доступ и получение почты с удаленного сервера (практически как в POP);</li>
  <li>Установка флага прочитанных сообщений;</li>
  <li>Управление несколькими почтовыми ящиками, перекидывание писем из одиного в другой, организация ящиков в категории, создавать иерархии из директорий для писем;</li>
  <li>Возможность загружать часть сообщения. Например без мультимедиа содержимого;</li>
  <li>Организация почты на сервере в соответствии с требованиями. Можно удалять или переименовывать свой ящик на сервере (в POP так нельзя);</li>
  <li>Можно искать письма по ключевым словам;</li>
  <li>Проверка заголовка письма, перед его загрузкой.</li>
</ul>

<p>Преимущества IMAP:</p>
<ul>
  <li>Вся почта хранится на сервере, доступна с любого устройства-клиента;</li>
  <li>Письма не загружаются все сразу на локальный компьютера как в POP, и соответственно нет таких требований к дисковому пространству.</li>
  <li>Письма хранятся в условной безопасности на сервере, риски утечек и утраты почты меньше по сравнению с POP.</li>
  <li>Благодаря возможности частичной загрузки почтой можно пользоваться даже при плохом соединении, загружая только тело письма без тяжелых аттачей.</li>
</ul>

<p>Минусы IMAP:</p>
<ul>
  <li>Вся почта на сервере, так что без интернета не получится загружать и новые и уже полученные письма, которые были кэшированы более двух недель назад;</li>
  <li>В случае компрометации ящика злоумышленниками всё его содержимое станет им доступно. В сравнении с POP это “палка о двух концах”, но проблемы информационой безопасности корреспонденции выходят за рамки этого обзора.</li>
</ul>

<h1 id="smtp">SMTP</h1>

<p>SMTP (Simple Mail Transfer Protocol) ещё один сетевой протокол старичок, представленный в 1982 году в <a href="https://datatracker.ietf.org/doc/html/rfc821">RFC 821</a>.</p>

<p>Преследует две задачи: проверка правильности конфигурации системы, авторизация на отправку письма для конкретного устройства, и собственно сама отправка исходящего письма на указанный адрес с подтверждением успешной доставки.</p>

<p>Кстати, если письмо доставить не удалось — отправитель получит алерт.</p>

<p>SMTP может работать практически с любыми протоколами транспортного уровня (TCP, UDP и тд). По умолчанию работет на двух портах: 25 служит для передачи почты между почтовыми серверами, и 587, по которому почта передается от клиента на сервер.
Поддерживает SSL шифрование (задействуется дополительно 465-ый порт).</p>

<h2 id="формат-письма-в-smtp">Формат письма в SMTP</h2>

<p>Почтовое сообщение в SMTP состоит из “конверта”, заголовка и тела письма. 
Формат заголовка и тела подробно описан в <a href="https://datatracker.ietf.org/doc/html/rfc2822">RFC 2822</a>.</p>

<p>Конверт, грубо говоря, это такая абстракция для передачи сообщений между клиентом и сервером. На самом деле они общаются в привычном клиент-серверном формате запросов и ответов.</p>

<h2 id="запросы-и-ответы-smtp">Запросы и ответы SMTP</h2>

<p>Самые часто используемые запросы (команды):</p>
<ul>
  <li>Helo: служит для установки соединения, и выполняется только когда клиент укзаывает свой домен и почтовый адрес;</li>
  <li>Mail: задает адрес отправителя;</li>
  <li>RCTP: задает адрес получателя. Если получателей несколько, то они указываются каждый в отдельной RCTP команде;</li>
  <li>DATA: сигнал серверу о конце “конверта”, после чего идет само письмо;</li>
  <li>QUIT: разрыв соединения после окончания письма.</li>
</ul>

<p>Ответы SMTP состоят из кода и текста ответного сообщения. По коду можно понять если что то пошло не так. В человекочитаемом сообщении же будет указано что произошло в ходе отправки или получения письма.</p>

<p>Коды начинаются с 2, 3 и 5. В первом случае всё прошло хорошо, во втором — письмо отправилось, но нужны дополнительные данные. А пятерка это алерт, что то сломалось и надо разбираться.</p>

<h2 id="описание-работы">Описание работы</h2>

<p>Представим частный случай, в котором уже установлен и сконфигурирован SMTP север, и мы хотим отправить письмо:</p>
<ol>
  <li>Пишем письмо, указываем адрес отправителя, после чего происходит соединение с SMTP клиентом провайдера, например Gmail.</li>
  <li>Происходит передача почтовых адресов отправителя и получателя, тема письма и содержимое на сервер.</li>
  <li>SMTP система начинает искать SMTP сервер получателя.</li>
  <li>Если целевой сервер не будет найден, наш попытается ещё несколько раз это сделать. Если все попытки проваялся мы получим алерт о том что письмо не будет доставлено.</li>
  <li>Если всё хорошо и целевой сервер нашелся, то далее в работу вступают другие почтовые протоколы — POP3 или IMAP.</li>
</ol>

<h2 id="прекратить-спам">Прекратить спам!</h2>

<p>В 1995 году в качестве меры по борьбе с безудержным почтовым спамом появилось расширения SMTP протокола — ESMTP, которое добавлет дополнительные команды для защиты серверов и повышения пропускной способности. Например ESMTP привнес:</p>

<ul>
  <li>Аутентификацию отправителя;</li>
  <li>SSL-шифрование почты;</li>
  <li>Возможность аттачить мультимедиа файлы к письмам;</li>
  <li>Возможность ограничить размер писем в соответствии со спецификациями сервера;</li>
  <li>Одновременно слать письма нескольким адресатам;</li>
  <li>Стандартизацию алертов о невозможности доставки.</li>
</ul>

<p>Разумеется сейчас везде используется ESMTP, по понятным причинам.</p>

<h1 id="резюме">Резюме</h1>

<p>Так что же выбрать, IMAP или POP? Мы вкратце рассмотрели оба протокола, и с первого взгляда кажется что IMAP намного лучше. В этом есть доля истины. В принципе, единственным серьезныем отличием является сопосб хранения писем. В POP3 мы качаем все письма себе, и <em>возможно</em> в случае каких то сверхсекретных писем можно выбрать POP3, обмазав его всевозможным шифрованием, начиная от шифрования соединения, заканчивая шифрованием диска с письмами. Но это очень спорный момент, ведь с другой стороны практически все, если не все, почтовые провайдеры поддерживают двухфакторную аутентификцаию, которую сложно обойти… Сложно же, да? :D</p>

<p>Закончим на сегодня, пока я не ударился в шифропанковский параноидальный бред. Будьте здоровы!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Немного о том как письма в интернете ходят.]]></summary></entry><entry xml:lang="ru"><title type="html">FTP протокол</title><link href="http://localhost:4000/2022/05/31/FTP.html" rel="alternate" type="text/html" title="FTP протокол" /><published>2022-05-31T00:00:00+03:00</published><updated>2022-05-31T00:00:00+03:00</updated><id>http://localhost:4000/2022/05/31/FTP</id><content type="html" xml:base="http://localhost:4000/2022/05/31/FTP.html"><![CDATA[<p>Если вы ищете быстрый и простой способ отправлять и получать файлы с друзьями, семьей или коллегами по работе, возможно вам следует знать о FTP.</p>

<!--more-->

<h1 id="что-это-такое">Что это такое</h1>

<p>FTP — это аббревиатура от File Transfer Protocol. Этот сетевой протокол существует с 1980-х годов и до сих пор остается одним из наиболее часто используемых способов передачи файлов.</p>

<p>Название говорит само за себя — протокол служит для передачи файлов поверх TCP/IP, и в этой модели считается протоколом прикладного уровня.</p>

<p>В транзакциях FTP компьютер конечного пользователя принято называють “локальным хостом”, а второй — удаленный компьютер является сервером. Разумеется, между ними должно быть сетевое соединение, и у каждого участника соответвущий софт (FTP сервер на сервере, и какой-то FTP клиент у пользователя).</p>

<p>Не смотря на то что передача файлов по сети может осуществляться с помощью HTTP протокола, с которым мы уже знакомились <a href="/2022/05/22/HTTP.html">тут</a>, к сожалению или к счастью FTP, как уже сказанно выше — до сих пор широко распространён.</p>

<h1 id="как-это-работает">Как это работает</h1>

<p>FTP — это клиент-серверный протокол, который использует <em>два канала</em> связи: один, так называемый “командный канал”, который служит для управления “общением” участников транзакции, и второй — для самой передачи данных.</p>

<p>FTP сервер может быть анонимным — это когда логиниться в него не надо, и работать с ним может фактически кто угодно. Своего рода помойка…) 
А может быть не анонимным и требовать авторизации.</p>

<p>Сеансы FTP работают в двух режимах: активном или пассивном.</p>

<p>В Активном режиме, после того как клиент инициализировал сеанск через запрос по командному каналу, сервер создает обратное соединение с клиентом и начинается передача данных.</p>

<p>В Пассивном режиме сервер использует командный канал для отправки клиенту информации, необходимой для открытия канала данных. Иными словами, в этом режиме клиент инициализирует передачу файлов, а не сервер. Такой режим хорошо работает, когда соединению “препядствуют” всякие фаерволлы, прокси и тд.</p>

<p>Пользователи могут работать с FTP сервером через интерфейсы командной строки из консоли, используя какие нибудь GUI приложения, или просто веб-браузер.</p>

<h1 id="зачем-он-нужен-если-есть-http">Зачем он нужен, если есть HTTP</h1>

<p>FTP — это старый добрый стандарт. Он очень прост и понятен в использовании. Мы можем передавать данные по HTTP, или пересылать их… по электронной почте X_X, но этим вариантам не хватает ясности, простоты и быстроты настройки, которые мы получаем используя FTP.</p>

<p>Этот протокол можно применять в простых и сложных сценариях, таких как доставка или получения необходимых данных на\с сервера, резервное копирование данных на другой сервер, репликация данных. Можно навелосипедить практически любой сценарий :D</p>

<h1 id="типы-ftp">Типы FTP</h1>
<p>Есть несколько видов имплементации протокола. Рассмотрим их вкратце.</p>

<p><strong>Anonymous FTP</strong></p>

<p>Самый простой вариант и небезопасный вариант. Сервер торчит в сеть и раздает данные в незашифрованном (как правило) формате и не требует никакой аутентификации и авторизации. Обычно это какая то слабо регулируемая общедоступное файловая помойка.</p>

<p><strong>Password-protected FTP</strong></p>

<p>То же самое что предыдущий вариант, только чуть безопаснее. Потребуется логин и пароль. Шифрования обычно тут тоже отсутствует.</p>

<p><strong>FTPS</strong></p>

<p>S — значит Secure. Данные шифрутся TLS.</p>

<p><strong>SFTP</strong></p>

<p>Технически, это не FTP протокол, но работает точно так же. SFTP это дитя SSH протокола, который обычно (сервер) работает на 22 порту. Наверное это самый безопасный вариант. Про SSH поговорим в другой раз. Вренемся к FTP.</p>

<h1 id="история-и-безопасность">История и Безопасность</h1>

<p>Давайте честно. Это старинная штука. Изначально FTP проткол определили в <a href="https://datatracker.ietf.org/doc/html/rfc114">RFC 114</a>, написанной Абхаё Бхушан (тогда ещё студент MIT) 16 апреля 71 года!! А это, на минуточку, раньше чем TCP и IP! Тогда ещё не было интернета, каким мы его знаем сейчас, а был ARPANET. Собственно в этой RFC и описывается идея предачи файлов в арпанете.</p>

<p>В последствии FTP разумеется переопределяли по мере эволюции интернета. 
Дружба с TCP/IP описана в <a href="https://datatracker.ietf.org/doc/html/rfc765">RFC 765</a> в 1980 году Джоном Постелом (АйТи Университет Калифорнии), пять лет спустя в <a href="https://www.ietf.org/rfc/rfc959.txt">RFC 959</a> добавили новые возможности управления протоколом, попытались обезопасить протокол только в 1997 году в <a href="https://datatracker.ietf.org/doc/html/rfc2228">RFC 2228</a>, и ещё через два года завезли поддержку IPv6 в  <a href="https://datatracker.ietf.org/doc/html/rfc2428">RFC 2428</a>.</p>

<p>По дефолту FTP вообще не шифруте трафик, и сниффить пакеты может кто угодно посередине. Это никуда не годится, собственно так и появились варианты FTPS и FTPES с поддержкой, соответственно, неявного и явного TLS соединения.</p>

<p>Но не смотря на все улучшения и попытки внедрить безопасность, протокол FPT всё ещё уязвим к брутфорс атакам на креды пользователей и к DOS.</p>

<h1 id="недостатки-ftp">Недостатки FTP</h1>

<p>На самом деле протокол использует два порта. 21 для командного канала и 20 для передачи данных. А ещё этот активный и пассивный режимы… Протокол сложно “резать” на сетевом экране. HTTP в этом моменте намного проще.</p>

<p>Понятие кодировки отсутствует. Если кодировки сервера и клиента отличаются, то скачав файл(ы) и имена и содержимое придется перекодировать. В HTTP такой проблемы нет, так как имеем метаданный в заголовках, где указан и тип файла, и кодировка передачи.</p>

<p>Отсутствие шифрования по умолчанию. Пусть оно и есть в модификациях, но как думаете, сколько на сервере администраторов которые ставят первый попавшийся под руку сервер и не заморачиваются по безопасности…?</p>

<h1 id="резюме">Резюме</h1>
<p>Но не смотря на всё это… Оно ещё живое, и умирать похоже не планирует.
Лично я FTP не использую, а при необходимости реализовать передачу данных смотрел бы в сторону других решений. По моему “умолчанию”, это это был бы на вскидку какой нибудь rsync по ssh или тупо scp.</p>

<p>Но знать про FTP и уметь им пользоваться нужно! Только, пожалуйста, настраивайте хотя бы FTPS сервера…)</p>

<p>Миру мир! Будьте здоровы!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Если вы ищете быстрый и простой способ отправлять и получать файлы с друзьями, семьей или коллегами по работе, возможно вам следует знать о FTP.]]></summary></entry><entry xml:lang="ru"><title type="html">HTTP протокол</title><link href="http://localhost:4000/2022/05/22/HTTP.html" rel="alternate" type="text/html" title="HTTP протокол" /><published>2022-05-22T00:00:00+03:00</published><updated>2022-05-22T00:00:00+03:00</updated><id>http://localhost:4000/2022/05/22/HTTP</id><content type="html" xml:base="http://localhost:4000/2022/05/22/HTTP.html"><![CDATA[<p>Небольшой разбор повсеместно используемого протокола.</p>

<!--more-->

<h2 id="интро">Интро</h2>

<p>Всем привет! В далекой далекой галлактике однажды гумноиды придумали компьютеры, а потом придумали их вместе связывать. Задачка была не из легких, и много подумав гуманоиды разработали спецификацию — концептуальную сетевую модель, или стандарт, посредством которого компьютеры общаются между собой (к этой истории мы вернемся в другой раз).</p>

<p>А потом подумали ещё, поняли что слишком много выдумали, и отразили идеи в более прикладном и жизнеспособном виде.</p>

<p>Модели OSI и TCP/IP не являются темой этого поста. Сегодня я предлагаю разобрать нечто с их “дальнего конца”, наиболее близкого к нам — один из протоколов прикладного уровня, а именно HTTP.</p>

<h2 id="в-начале-был-текст">В начале был текст</h2>

<p>А потом появился <em>Гипертекст</em>. В нашей тусовке этим термином назвали текст размеченный с помощью собственно HTML.</p>

<p>За аббревиатурой HTML стоит —  HyperText Markup Language, переводить надеюсь не надо :)</p>

<p>Все замечательные (и не очень) странички которые вы видите в своих браузерах серфя интернет размечены HTML. Но понятно что соверменные системы не ограничиваются обменом текстовыми документами, за всем этим стоит какой то бекенд, логика, и прочие прелести.</p>

<p>Как происходит обмен данными между вашим компьютером, и другим, далеким-далеким сервером?</p>

<p>С помощью протокола HTTP!</p>

<p>Изначально задачей протокола являлось как раз получение текстовых страничек, но времена меняются, с 1990 года воды утекло много и сейчас по HTTP можно передавать практически всё, вплоть до потокового видео и аудио.</p>

<h3 id="чего-там-внутри-то">Чего там внутри-то</h3>

<p>Клиент-серверная архитектура, это такая “модель” взаимодествия вычислительных систем, в которой задачи распределяются некоторым образом между клиентам и серверами. Клиенты — это, например, опять-же ваш браузер или приложенька, а сервер — это некоторая сущность которая выполняет хотелки клиента.</p>

<p>Почему я говорю сущность? Потому что клиент и сервер это не какие то особенные железяки, а просто <em>софт</em> работающий друг с другом по сети. И общий язык этот софт находит как раз благодаря спецификациям сетевых протоколов.</p>

<p>В HTTP всё крутится вокруг <em>запросов</em> и <em>ответов</em>. Это предельно просто. Клиент Вася попросил (сделал запрос) Сервер Петю почистить картошку, на что от Пети следует какая-то реакция, в зависимости от обстоятельств.</p>

<p>Реакция Пети — это ответ. И их с Васей вазимодействие регламентировано протоколом (на самом деле не одним).</p>

<p>Сеть устроена сложно, и между Петей и Васей может, и обычно присутствует, множество роутеров, прокси-серверов, и прочей чертовщины о которой мы будем говорить позже.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Это кстати небольшой спойлер! Я скоро начну достаточно плотно изучать сети, и обо всем буду писать в блог!
</code></pre></div></div>

<h3 id="хочу-банан">Хочу банан!</h3>

<p>Целью любого запроса всегда является какой-то <em>ресурс</em>. Как мы уже выяснили выше, по HTTP может передаваться что угодно. Более умным языком это можно выразить как то, что протокол HTTP никак не ограничивает <em>ресурсы</em> которые могут запрашиваться и передаваться, а лишь определяет <em>интерфейс</em> для взаимодействия с ресурсами.</p>

<p>Каждый ресурс, хотелка клиента, должна иметь какой-то идентификатор. Этим идентификатором является <em>URI</em> — Uniform Resource Identifier. URI — это по сути символьная строка. Здесь тоже есть много интересных (или не очень) подробностей, но по сути URI это всем нам привычный URL (Uniform Resource Locator) — то что часто называют “ссылкой”, и представяется в браузере в адресной строке как как-то последовательность разделенная слэшами.</p>

<p>Ну, короче, это адрес ресурса!</p>

<h3 id="структура-сообщений">Структура сообщений</h3>

<p>Начнем с запросов.</p>

<p>В структуру запросов входят следующие метаданные:</p>

<ul>
  <li>HTTP-метод: этот элемент декларирует хотелку клиента. Есть несколько методов запроса, но чаще всего клиент хочет либо что-то получить <strong>GET</strong>, либо передать какие-то значения — <strong>POST</strong>;</li>
  <li>Адрес ресурса: URL, который мы уже разобрали;</li>
  <li>Версия протокола;</li>
  <li>Заголовки (Headrs): могут быть, а могут не быть. <del>Вот в чем вопрос.</del> Задача заголовка — передать дополнительную информацию серверу, которая может ему понадобиться для корректной обработки запроса;</li>
  <li>Тело запроса: это нужно в первую очередь для POST запрсов, чтобы передать то, что клиент собственно хочет передать.</li>
</ul>

<p>Ответы же состоят из:</p>
<ul>
  <li>Версии протокола;</li>
  <li>Кода состояния: есть список кодов, которые говорят об успешности или не успешности операции, и могут подсказать или достаточно четко дать понять что пошло не так. Например знакомый 404 — ресурс не найден, или 200 — который вы никогда не замечаете, потому что 200 это ОК.</li>
</ul>

<h2 id="краткий-обзор-отличий-версий">Краткий обзор отличий версий</h2>

<p>В 2015 году на смену HTTP/1.1 пришел HTTP/2 который родился как результат обмозговывания путей оптимизации скорости обработки запросов, в первую очередь при работе с мобильными клиентами и аудио\видео форматами.</p>

<p>Основным отличием является то, что HTTP/1.1 сообщения передает втупую плейнтекстом, тогда как HTTP/2 кодирует их в двоичный формат, благодаря чему открывается возможность использовать другую модель доставки сообщений. Семантика “внутри” осталась прежней.</p>

<p>Для чего кодировать в двоичный формат? Это позволяет разбить сообщения на более мелкие пакеты, которые ещё называют кадрами. А ещё это позволяет использовать <em>одно</em> TCP соединение, вместо нескольких.</p>

<p>Несколько соединений HTTP/1.1 приходится устанавливать для того чтобы обходить блокировку HOL.</p>

<p>Блокировка Head-of-line — это такая фигня, когда очередь из пакетов задерживается первым поступающим пакетом. Так получается когда несколько запросов оправляются на один и тот же ресурс. Пакеты просто не могут проходить друг через друга.</p>

<p>Ну вот, а в HTTP/2 есть один поток, и сами сообщения закодированны. Каждый кадр имеет идентификацию принадлежности к пакету, поэтому ничего не путается. Сервер у себя спокойно принимает сообщения, собирает их обратно. И хотя устанавливается одно TCP соединения, сообщения могут спокойно долетать до сервера параллельно друг другу.</p>

<p>А ещё HTTP/2 сжимает заголовки. Сами данные, можно сжимать и в HTTP/1.1, но не заголовки. И хотя заголовок очень мал, но если клиент или клиенты шлют огромное кол-во запросов — это может стать проблемой. Как видим, HTTP/2 решает её довольно изящно.</p>

<p>Другие отличия HTTP/2 потребуют углубиться в сетевую модель, вернемся к этому может быть в другой раз :)</p>

<h3 id="что-там-про-поток">Что там про поток?</h3>

<p>Клиент-серверное взаимодествие выглядит как-то так:</p>

<ol>
  <li>Открываем TCP соединение. Одно или несколько. Разумеется, уже открытое соединение может использоваться и переиспользоваться далее, не нужно открывать новое соединение для каждого запроса.</li>
  <li>Отправляем сообщение (или сообщения).</li>
  <li>Читаем ответ сервера.</li>
  <li>Закрываем соединение или используем его снова.</li>
</ol>

<p>Ну, тут собственно больше говорить не о чем :)</p>

<h2 id="ещё-немного">Ещё немного</h2>

<h3 id="печеньки">Печеньки!</h3>
<p>Можно устанавливать <em>сессии</em>. Это достигается путем использования кукисов! Зачем нужны куки?</p>

<p>Прикол в том, что HTTP — это протокол <em>без состояния</em>. Это значит что каждый запрос независим, никак не связан с предыдущим. Мы это уже хорошо рассмотрели — всё общение построенно на парах запрос-ответ.</p>

<p>Но ведь… Состояния нужны! Мы не хотим каждый раз логиниться, и не хотим чтобы при обновлении страницы пропала вся наша бережно скирдованная корзина товаров в интернет магазине :)</p>

<p>Тут и выходят на сцену печеньки-кукисы.</p>

<p>Куки — это такой хитрый фрагмент данных, который сервер отправляет клиенту, и клиент у себя его сохраняет. Потом клиент эту куку шлет серверу в составе других HTTP запросов. Так Петя понимает, что хочет Вася, а что хочет Саша, и что Вася есть Вася, а не Катя.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Хотя мне очень хочется тут распылиться на тему безопасности, но скажу лишь то, что куку легко украсть и подменить, если поток данных между клиентом и сервером не зашифрован. TLS — отдельная тема к которой мы *обязательно* вернемся в другой раз.
</code></pre></div></div>

<h3 id="аутентификация">Аутентификация</h3>

<p>HTTP может без всяких других штук предоставлять средства базовой аутентификации, но это не очень безопасно, и обычно специальные сессии устанавливаются с помощью куки.</p>

<h3 id="кеш">Кеш!</h3>

<p>Сервер может с помощью специальных заголовков заставлять промежуточные прокси сервера кешировать какие-то данные, и как долго их надо сохранять.
Клиент в свою очередь может схожим образом “просить” прокси игнорировать кеш, и передавать запрос на требуемые ресурсы далее.</p>

<h2 id="резюме">Резюме</h2>

<p>Мы завершаем краткий обзор протокола HTTP. Краткий, потому что там есть <em>много чего ещё</em>: можно очень долго перечислять все коды ответов, углубиться в то, как происходит сжатие, кеширование. Что такое REST, какие используются кодировк и так далее.</p>

<p>Если вам интересно умудриться то первымы местами, куда стоит обратиться, это RFC документы, в частности под номером <strong>7231</strong> и MDN доку.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Небольшой разбор повсеместно используемого протокола.]]></summary></entry><entry xml:lang="ru"><title type="html">Версионный контроль и непрерывная DevOps’ятина</title><link href="http://localhost:4000/2022/04/24/version_control_and_cicd.html" rel="alternate" type="text/html" title="Версионный контроль и непрерывная DevOps’ятина" /><published>2022-04-24T00:00:00+03:00</published><updated>2022-04-24T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/24/version_control_and_cicd</id><content type="html" xml:base="http://localhost:4000/2022/04/24/version_control_and_cicd.html"><![CDATA[<p>Как сделать свою жизнь проще. Пост про git и DevOps.
<!--more--></p>

<p>Первая попытка написать про git провалилась. Была она почти на самом старте блога, и пост просто “не пошел”. Вторая попытка закончилась тем, что я <del>забыл выпить свои таблетки</del> ударился в философию набредовав несколько нечитаемых абзацев <a href="/2022/04/03/laziness.html">тут</a>.</p>

<p>Вообще там было несколько мыслей, одна из который о том, что <em>время самый главый ресурс</em> или один из них. Прежде чем я вернусь к этой арке, давайте поговорим про версионный контроль.</p>

<h2 id="помогите-смержить-dev">Помогите смержить dev</h2>

<p>Если вы разработчик или инженер, который хоть каким-то боком заходит в редактор кода, и при этом не используете инструменты версионного контроля — у меня для вас плохие новости. Вас либо не существует, либо вы 2 дня в индустрии, либо чекисты закрыли вас в бункере в 83 году и вы до сих пор в нем сидите и паяете какую нибудь Нафаню.</p>

<p>Ладно, отставим дешевый троллинг.</p>

<p>Люди пишут программы. А ещё люди постоянно ошибаются. И в программах, и по жизни вообще. Раньше код резервиловали копировав его на несколько носителей, ну, дискетка там, и так далее. Это всё равно не надежная история, и сейчас как для резервирования кода, его версионирования, и других полезных штук используются специальные инструменты. Например <a href="https://git-scm.com/">git</a>.</p>

<p>Я не хочу писать о других системах версионного контроля по двум причинам.
Во-первых, я в принципе ламер и с другими системами не работал.
Во-вторых, давайте признаемся честно — git является де-факто стандартным инструментом, его использует все и повсюду.</p>

<h3 id="я-в-бункере-что-такое-git">Я в бункере, что такое git?</h3>

<p>Очень краткая история появления git:</p>
<ul>
  <li>Линус Торвальдс родился;</li>
  <li>Линус Торвальдс чуть-чуть вырос и написал ядро linux;</li>
  <li>Линус Торвальдс показал его людям, и людям linux понравился;</li>
  <li>Всё больше и больше людей стали учавствовать в разработке linux;</li>
  <li>Пригорело из за проблем, связанных с пунктом выше (сложно вместе разрабатывать одно и то же! Вася наклепал фичу А, Петя Б, например в том же контексте или модуле, и че делать, как дружить их код?);</li>
  <li>В 2005 году Линус релизнул git и всем стало жить проще.</li>
</ul>

<p>Git представляет рапределенную систему контроля версий. Что это значит? Есть не абстрактный <em>репозиторий</em> — это некоторая совокупность файлов с кодом, которые представляют конкретный проект. Есть его центральная “версия” на git-сервере, где собственно и лежит этот весь код.</p>

<p>Распределенность заключается в том, что любой разработчик у которого есть доступ к репозиторию может стянуть себе локальную <strong>полную</strong> копию репозитория, <em>вместе с историей измнений</em> и так далее.</p>

<p>В этом и заключается смысл распределенности, где ключевое отличие от централизованных систем, в том что в них история и все потроха хранятся в одном месте, а разработчики забирают себе лишь код, грубо говоря.</p>

<p>Таким образом, вся эта история про инструмент, который значительно облегчает совместную разработку какого либо проекта, и представляет ряд полезных фич, таких как само версионирование состояний файлов в репозитории (история измнений).</p>

<p>Git штука сложная, мозговитая, чтобы полностью с ней разобраться потребуется убить достаточно времени. Но это стоит того. Пугаться не надо, начать работать с гитом можно практически с нахрапу освоив ключевые команды и возможности.</p>

<h3 id="базовые-понятия">Базовые понятия</h3>

<p>С репозиторием мы уже разобрались. Как выглядит работа с git?</p>

<p>Во-первых, львиную долю в популярность git’а внесла такая штука как GitHub. Гитхаб — это грубо говоря гит-хостинг. Не нужно устанавливать и поддерживать свой собственный сервер git, мы можем зарегистрировать аккаунт, создать репозитории и начать пользоваться всеми прелестями версионного контроля.</p>

<h5 id="ветки-те-что-branches">Ветки, те что branches.</h5>

<p>Это возможность создавать копии-ответвления от основной ветки (которая всегда называлась master, пока не полубредовая <a href="https://xakep.ru/2020/06/16/master-slave/">история с BLM</a>).</p>

<p>Ветки могут показаться сложной штукой, но на деле ничего сложного тут нет. Представьте себе обычную девовидную структуру. Есть мастер будет стволом дерева, “основной веткой”, из которого выростают другие ветви. Другие ветви в момент выростания являются по сути копией кодовой базы из мастера.</p>

<p>Никто не запрещает из этих веток отщеплять другие, но делать так не надо.</p>

<p>Теперь немног наркомании. Представьте что отросшие из ствола ветки чуть выше вростают в ствол обратно. Эээм… чего?</p>

<p>Зачем вообще отщеплять ветки?</p>

<h5 id="git-flow-йо-мержим">git-flow, йо, мержим!</h5>

<p>git-flow, GitHub flow, и прочие git бла-бла-бла flow это эффективные, полезные (часто и не очень) методики работы с гитом. В частности с ветвлением.</p>

<p>Вспомним что git это в первую очередь для совместного ведения разработки. Чисто теоретически команда может работать в одной ветке, сразу в мастере, пихать туда каждый свои измнения и постоянно решать конфликты, но так никто (надеюсь) не делает.</p>

<p>Нужно предерживаться хорошего стиля и здравого смысла в цикле разработки. Базовых правил.</p>

<p>Во-первых, в мастере всегда должен быть рабочий код, и мастер должен быть чистым. Для внесения каких-либо измнений мы и делаем форки. Пилими фичи, что-то исправляем, и так далее.</p>

<p>Так вот вышеупомянутое врастание обратно в “ствол” есть слияние, или merge веток.</p>

<p>Обычно, хорошим flow считается иметь несколько основных веток: master, staging, develop.</p>

<p>Staging и develop, как правило, являются форками из мастера. В develop, как не сложно догадаться, идет разработка, когда состояние допиливается до какого то рабочего вида, и его нужно протестить на схожем с прод-окружении рантайме — develop сливают в staging, проверяют всё что хотят, убеждаются что оно правда работает и сливают staging в master.</p>

<p>Как я уже сказал, это вообще не табу. Есть другая хорошая практика которой стоит придерживаться. Для каждой отдельной фичи и изменения разработчик делает форк (сделать форк, это на нашем новоязе сиречь отбранчевать ветку), пилит в новой ветке свои измнения, и сливает в изначальную ветку.</p>

<p>Обычно схема получается смешанная. Разработчики форкают фича-ветки из develop, мержат в него свои феноменальные решения, пока develop не сбилдится и не поедет :), а дальше по первому шаблону.</p>

<p>Но что делать если на стейдже все работало, слили в мастер, и прод упал! Ололо!</p>

<h5 id="спокойно-у-меня-всё-осталось">Спокойно, у меня всё осталось</h5>

<p>Вот она, основная прелесть версионного контроля! Барабанная дробь… Версии!</p>

<p>Git отслеживает все измнения файлов и хранит их в своей истории. Все эти измнения можно посмотреть в логе репозитория. И откатиться на предыдущие состояния! Мы никогда ничего не теряем.</p>

<p>Есть продвинутые штуки, которые можно проворачивать с историей. Пока вы не удалили ветку — git будет хранить всю историю её измненей. Вам ничего не мешает вытащить из мастера изначальную версию на момент форка рабочей ветки, или любую другую версию, если вы её, например безвозвратно потеряли или поломали так что не хотите копаться в истории измнений этого файла в текущей, рабочей ветке.</p>

<h5 id="эй-вася-чекаут-делал">Эй, вася, чекаут делал?</h5>

<p>Каждая локальная копия репозитория связанна с “центральным” репозиторием, который называется origin. Если мы неделю назад его склонировали, что-то изменили, значит ли что за прошедшую неделю больше никто ничего там не изменил? Конечно нет.</p>

<p>Возвращаясь к работе снова и снова нужно всегда, прежде чем приступать к каким то измнениям, подтянуть свежую версию ветки, или всех нужных веток. 
В git это называется pull — выгрузить origin в локальную копию репозитория.</p>

<h5 id="я-все-сделал-катим-в-прод">Я все сделал, катим в прод!</h5>

<p>Обратная pull операция — push, которая обозначет выгрузку локального репозитория в origin. Впрочем пуш служит не только для выгрузки измнений в ветке. Вы могли локально сделать форки каких то веток, из мы “пихаем” в origin тем же пушем.</p>

<h5 id="всё-слишком-радужно-где-подвох">Всё слишком радужно, где подвох?</h5>

<p>Да, подвох есть. И этот подвох — конфликты. Скажу честно, даже в моей работе, учитывая что я всё ещё не ололо-мега-сеньор-разработчик в команде из 140 человек, конфликты мерджей бывают той ещё болью в заднице.</p>

<p>Как возникают конфликты? Ну, например, в репозитории могли вести <strong>очень корявый flow</strong>, давно не мержить dev в staging. А при этом, параллельно ещё и в staging что то меняли на протяжении целого месяца. И вот у вас возникла ситуация когда надо донести всё в master, да при этом сначала из dev в stage.</p>

<p>В такой момент просто хочется убить причастных к такому флоу товарищей.</p>

<p>Но по простому, что такое конфликт? Если из моих перлов выше непонятно, то конфликт возникает тогда, когда у нас есть изменения одних и тех же участков (строк) в файлах, которые мы пытаемся слить. Как бы не хотелось, git и вычислительная техника не настолько умны чтобы понять какой код правильный, о чем и будет сообщено в ошибках при попытке слияния.</p>

<p>Всех этих проблем можно избежать следуя чистому, хорошему flow в репозитории. Помимо этого, очень важно называть ветки адекватно, и писать информативные и коротки commit мессаджи.</p>

<p>А ещё важнее: <strong>коммитить как можно чаще, и как можно более мелкие измненеия в коде</strong>. Не каждое измнение строки, но каждое маленькое, осмысленное и обособленное само в себе измнение-фичу.</p>

<h5 id="упс">Упс</h5>

<p>До меня только что дошло что я не упомянул коммит. Это опять же про то, как работает гит. Очень поверхностно:</p>

<p>Когда мы стянули репозиторий и сделали какое то измнение, или набор измнений (я надеюсь их не много!) их нужно <em>зафиксировать</em> в репозитории.</p>

<p>В git это делается следующим образом. Сначала нужно добавить необходимые для фиксирования файлы, мы можем добавить все или выборочно. Делается это командой git add. После этого, прежде чем пушить измнения в origin нужно сделать commit.</p>

<p>Commit’s — это не что иное как кирпичики самого версионного контроля. Это своего рода снимки или снапшоты состояния, которые хранятся в истории, к ним мы можем откатываться и так далее. Создаются они коммандой git commit -m ‘Я сделал кнопку в админке’.</p>

<p>У каждого комита есть свой уникальный идентификатор — хэш, который мы можем найти в истории.</p>

<h2 id="goto-введение">Goto введение</h2>

<p>Я обещал вернуться к словоблудию по поводу времени. В общем этот тред больше про DevOps.</p>

<p>Давайте ещё раз подумаем, вспомним про время. Почему время так ценно? Ну кроме того что мы все умрем.</p>

<p>Вермя — деньги. Это правда. IT — это бизнес. Это тоже, как правило, почти всегда правда. Бизнес делает деньги. Иначе что это за бизнес?</p>

<p>И ещё одно — дедлайны <strong>всегда</strong> горят. Клиент, директор, Вася Пупкин с фриланс биржи, кто бы то ни был, если он руководит вами и дает вам работу, очень часто хочет чтобы продукт был готов как можно быстрее, фича была готова как можно быстрее. Спринт был закрыт всегда воворемя и цикл разработки работал как часы.</p>

<p>Здесь можно отступить в тему методолгий разработки, но это кроличья нора, которая заслуживает отдельного поста и я в этом вообще не очень компетентен на данный момент.</p>

<h3 id="ребят-а-что-мы-тут-вообще-делаем">Ребят а что мы тут вообще делаем?</h3>

<p>Кто нибудь знает что вообще такое DevOps. Одни говорят одно, другие про козу. А HR’s вообще ищут devops-инженероа. Чего?…</p>

<p>Кто-то скажет что devops обязательно должен уметь рулить кубернетисом, кто-то, что если devops не компилировал linux и вообще не гуру сисадмин, то никакой он не девопс. Иные будут бить себя кулаками в грудь, доказывая что девопс должен помогать их разработчикам дебажить говнокод на php, и так далее.</p>

<p>Во-первых, devops никому ничего не должен. Потому что devops — это набор практик, или ещё точнее — философия. DevOps в больше мере вылез из Agile методолгии, и ставит как главную ценность людей как индивиды, так и коллектив. DevOps признан быть некоторого рода интерфейсом между разрабами и админами, которые рулят инфраструктурой, чтобы был мир, дружба, жвачка, бизнес получал свои деньги и фичи вовремя, никто не грызся, дедлайны не горели и вот это вот всё.</p>

<h3 id="ты-в-трудовую-свою-посмотри-клоун">Ты в трудовую свою посмотри, клоун!</h3>

<p>Всё ты врешь! У меня в трудовой написано что я младший devops-инженер, я постоянно всем должен и все меня мучают кучей задач, горят и дедлайны и моя пятая точка.</p>

<p>Ну если что то горит, значит ты не девопс инженер, а обычный админ, которому в скоуп повесили кучу технологий кроме привычной узкой админской специализации, платят тебе на 20к больше, а мучают на все 100 сверху.</p>

<p>Но всё таки, кто же такой devops-инженер, и что он должен уметь?</p>

<p>Это сложный вопрос. DevOps инженер это в первую очередь инфраструктурный инжинер, который должен понимать понемногу во всем, быть и админом и чуть-чуть (или не чуть-чуть) программистом одновременно. Скоуп технологий с которым работает такой инженер разнится, и зависит от компании и инфраструктуры.</p>

<p>Разумеется, что всё таки в первую очередь, и самую главную очередь, такой инженер должен быть хорошим админом, понимать что-то в архитектуре сетей, и быть в курсе всех передовых технологий направленных на эту самую дружбу Dev и Ops — контейнеризация, пупернетисы эти ваши, и… ci-cd инструментарий.</p>

<h3 id="ладно-а-что-такое-ci-cd">Ладно, а что такое ci-cd.</h3>

<p><strong>Никто</strong> не знает что такое continuous integration и continuous delivery. По русски — непрерывная интеграция и непрерывная доставка. Вы можете нагуглить просто тонну инфы про эти штуки, вам там ещё расскажут про непрерывное развёртывание (continuous deployment)… И про прочую девпос чертовщину, софистику.</p>

<p>Можно немного почитать, но не рекомендую убиваться в эту дичь, потому что… это по большому счету пустая трата <strong>времени</strong>. Лучше пойти выучить что-то новое из прикладных навыков, и стать эффективнее в том же “dev” или “ops”, или “devops” %)</p>

<p>Во всех этих трех… тысячах терминов чаще всего встречается одно и то же слово — continuous, <em>непрерывный</em>. И это, наверное, самое главное что нужно хорошо понять.</p>

<p>Это снова про методологию, про непрерывную методолгию разработки, сборки, доставки артефактов сборки в инфраструктуру, разворачиванию этих артефактов и так далее. Без горений, четко как часики…</p>

<p><em><strong>Автоматически</strong> настолько, насолько это возможно</em>.</p>

<p>Кто-то, наверняка начитавшийся того-самого, может спорить, но devops это правда во многом, если не в первую очередь, про автоматизацию.</p>

<p>В частности поэтому в вакансиях часто можно увидеть ansible, puppet, chef и вот это всё.</p>

<p>Потому что правильная, качественная, короче — рабочая автоматизация это прагматично с любой точки зрения, и разумеется с точки экономии времени, ресурсов.</p>

<p>В частности, там где по настоящему есть и практикуется devops можно найти много общего с воплощением так называемого “Бережливого производство” или Lean.</p>

<p>Lean это такая менежментская концепция предприятия, ноги которой растут из Тойотовской операционной модели — “The Toyota Way”, которая направленна, простыми словами, на повышление эффективности предприятия в целом, путем <em>устранения утечек ресурсов</em>.</p>

<p>И устранение это очень человеческое, мудрое. Устранение проивзодственных утечек ведет к устранению утечек времени, которое тратится на починку косяков. А правильно, эффективно работающий конвейер (pipeline) работает без узких горлышек (bottleneck), что тоже ведет к сохранению ресурсов, времени, и вообще общему счастью :)</p>

<p>Рекомендую посмотереть обе части интервью с Полом Экерсом, который очень четко и правильно внедрил этот самый Lean в своем производстве.
Вот ссылка на первую часть -&gt; <a href="https://www.youtube.com/watch?v=oarLDeAFSj4">тык</a>, вторую найдете в закрепе, если интересно.</p>

<p>Вот и получается, что devops инженер в большей степени не имеет права делать херак-херак и в продакшен, в плане архитектурных решений и конфигурирования пайплайна разработки и развертывания. На самом деле, херак-херак не должен делать никто, и это то к чему должен стремиться DevOps и методологии, которые внедряются и применяются.</p>

<p>DevOps начинается и заканчивается в голове. Этот soft навык у инженера не менее, а иногда и более значим чем почти любой hardskill — уметь видеть костыли и исправлять их, или замечать попытку внедрения костылей разработчиками или другими инженерами, и делать все чтобы этого недопустить или сгладить.</p>

<p>К сожалению, далеко не всегда получается избежать костылей… Но по крайней мере мы должны помнить где эти костыли есть, и фиксить их как только такая возможность будет (появилась новая технология как решения костыля, идея, и так далее).</p>

<h3 id="так-статья-же-про-git-была-изначально">Так статья же про git была изначально?</h3>

<p>Да, git это ещё один фундаментально базовый навык, обязательный для любого devops-инженера. Если узко специализированные админы операционных сетей или баз данных могут спокойно жить и работать ничего не зная про git и связанные технологии, то devops без этого не может никак.</p>

<p>Во-первых, это диктуеся тем что devops инженер часто в той или иной степени имеет доступ к коду, как минимум — общается с разработчиками.
В ситуация когда devops инженер начинает мутировать в SRE-инженера, он может уже во всю кодить сам.</p>

<p>Во-вторых, инструменты, такие как Helm сейчас вяжутся напрямую с репозиториями проектов. Сам по себе helm это всего лишь менеджер пакетов для k8s, который эти самые пакеты описывает как чарты (chart) — набор из yaml манифестов в которых описаны состояния ресурсов для деплоя в кубы.</p>

<p>Но очень крутая методолгия, которую в частности проповедуем мы во Фланте это так называемый <em>гитерминизм</em>. Это игра слов от git и детерминизм. Коротко говоря, смысл гитерминизма в том, чтобы сделать состояние деплоя максимально детерминированным состоянием git репозитория.</p>

<p>Достигая это орекстом каких-то инструментов, один из примеров это gitlab ci-cd + werf (тулза для сборки и деплоя, разрабатываемая во Фланте), работающий с классическими helm чартами.</p>

<p>Другой пример гитерминизм тулзы для деплоя это ArgoCD, который сейчас упорно хайпят — он тоже “смотрит” в скормленную репу, и своими средствами пытается “зеркалировать” её состояние, изменения, в указанный неймспейс кластера k8s. Работает тоже поверх helm.</p>

<p>Helm чарт, плюс файл сборки werf (грубо говоря аналог докерфайла, но там все намного круче и хитрее :), как и gitlab-cicd.yaml хранятся в одном репозитории с кодом приложения, которое из этого репозитория “деплоится”.</p>

<p>Это достаточно глубокая тема, как минимум каждый из инструментов можно рассматривать отдельно, и тут я скорее привожу как пример в контексте важности навыка работы с git для инфраструктурных инженеров.</p>

<h2 id="короче-учите-git">Короче, учите git!</h2>

<p>Я там выше сказал про gitlab. Gitlab, это в общем оупенсорсный (есть энтерпрайз версия) продукт для разворачивания своего гит репозитория… И не только. У Gitlab очень крутая нативная поддержка cicd инструментов, в часотности интеграцию с исполнителями пайплайнов (runners), которые ставятся на отдельный (хотя можно и на тот же сервер), и обрабатывают пайплайны — деплоят манифесты в кубы, разворачивают докер-компоузы, или просто докерфайлы. Ну в общем там можно много ерунды костыльной нагородить, если не захотеть сделать красиво в духе Lean и лучших практик :)</p>

<p>В gitlab много фич, познакомиться с которыми вы можете сами.</p>

<p>Справедливости ради, GitHub, BitBucket и другие git-хостинги тоже имеют свои средства cicd автоматизации, но имхо (и не только) — Gitlab выглядит самым удобным и гибким. А может он просто привычен.</p>

<p>У всех этих систем есть веб интерфейс, через который, в принципе можно пользоваться прелестями git’а, но я настоятельно рекомендую работать с git’ом через cli. Пусть GitLab умеет “умно” по всякому мержить ветки, и решать некоторые простые конфликты… К этому интерфейсу можно привыкнуть и попасть в иллюзию компетентности, которая рано или поздно <strong>обязательно</strong> больно аукнется.</p>

<p>Обязательно случится так что gitlab скажет вам что-то вроде “не могу помержить, помержи локально”. Или “не могу помержить, надо делать ребейз!”
И тут вы такие… А что такое ребейз…</p>

<h2 id="на-десерт">На десерт</h2>

<p>Что такое ребейз и как работать с git вы можете узнать из <em>тонны</em> источников в сети. Это очень поплуярная штука. Просто загуглите. 
С упорством поиска в пару минут вы найдете видео материалы, и интерактивные тренажеры для знакомства с git.</p>

<p>Если вас забанили в гугле, то вот интерактивные тренажеры:</p>

<ul>
  <li><a href="https://www.katacoda.com/courses/git">Вот этот;</a></li>
  <li><a href="https://gitimmersion.com/">Или этот;</a></li>
  <li><a href="https://learngitbranching.js.org/">Тут можно разобраться с ветками;</a></li>
</ul>

<p>Лучше всего почитать документацию-учебник “Pro Git”:</p>
<ul>
  <li><a href="https://git-scm.com/book/en/v2">Вся книга онлайн и беслатно без регистрации и смс</a></li>
</ul>

<p>Там же найдете её на русском, если вдруг надо.
Всех благ, миру мир! 
А я пойду запушу этот пост в GitHub :)</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><summary type="html"><![CDATA[Как сделать свою жизнь проще. Пост про git и DevOps.]]></summary></entry><entry xml:lang="ru"><title type="html">Ещё немного про F#</title><link href="http://localhost:4000/2022/04/17/more_about_f.html" rel="alternate" type="text/html" title="Ещё немного про F#" /><published>2022-04-17T00:00:00+03:00</published><updated>2022-04-17T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/17/more_about_f</id><content type="html" xml:base="http://localhost:4000/2022/04/17/more_about_f.html"><![CDATA[<p>Продолжаем врубаться в функциональное программирование. Пусть и туго :)
<!--more--></p>

<p>Всех и повсюду приветствую! Я продолжаю заниматься по ФП курсу, и (имхо!) пришла пора написать ещё немного про фишки F# (и, наверное, вообще ФП языков ML семейства) и порефлексировать.</p>

<h2 id="перегрузка">Перегрузка</h2>

<p>Перегрузка, это такая реализованная в языке “полиморфная” штука, когда при обращениях к функциям или операторам, которые <em>имеют несколько реализаций для разных типов данных</em> компилятор ведет себя по разному. Сами эти реализации и есть “перегрузки”.</p>

<p>В F# система типов ведет себя следующим образом:</p>
<ul>
  <li>Когда компилятору “понятно” в контексте обращения, что за тип используется — символ оператора интерпретируется как функция для этого типа;</li>
  <li>В противном случае используется <em>перегруженный</em> оператор для <em>подходящего</em> типа по умолчанию.</li>
</ul>

<p>Звучит сложно, но на самом деле тут всё просто. Если какой-то оператор можно применить к целым числам (int), ну значит int и будет считаться <em>типом по умолчанию</em>.</p>

<p>Например у функции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x,y) = x + y 
</code></pre></div></div>

<p>по умолчанию тип будет int -&gt; int. Но что если мы хотим, и заранее знаем, что будем вычислять числа с плавающей точкой? 
Явно указать тип <em>аргумента</em> в F# можно так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x: float, y: float) = x + x
</code></pre></div></div>

<p>Указать явно тип результата функции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x, y) : float = x + x
</code></pre></div></div>

<p>И, наконец, можно указать явно <em>тип выражения</em>, вычисляемого функцией:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x, y) = x + x : float
</code></pre></div></div>

<h2 id="нонфиксная-запись">Нонфиксная запись</h2>

<p>Любые инфиксные операторы можно записать нонфиксной записью. Ну, короче, не 1 + 1, а (+) 1 1.</p>

<p>Просто берем оператор в скобки, и следом перечисляем аргументы. Можно представить это как функцию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let mul3 = (*)3
</code></pre></div></div>

<p>Где вызов mul3 2 будет равняться 6. Просто? Просто!</p>

<p>Ну и по сути вызов нонфиксного оператора, который на вход получает один аргумент — функция (хотя тут вообще всё функция, но давайте сохранять трезвость рассудка).</p>

<p>Применение функции работает через <em>левую ассоциацию</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printfn "%b" ((*) 3 2 = ((*)3) 2) // будет true!
</code></pre></div></div>

<p>Ну как там, с трезвостью?</p>

<h2 id="композиция-и-каррирование">Композиция и каррирование</h2>

<p>Так, это уже серьезные спеллы, первый из которых должен быть нам уже знаком (как минимум интуитивно).</p>

<h3 id="композиция">Композиция</h3>

<p>По-простому — это подход, подразумевающий вызов одних функций в качестве аргументов других. Я уже писал про high-order и вот это всё.
По-сложному, математически — композиция двух функций x и y (x o g) будет обозначать:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x o y)(x) = x(y(x)) 
</code></pre></div></div>

<p>И есть x(a) = a + 5, и y(b) = b * 2, тогда</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x o y)(b) = x(y(b)) = x(b * 2) = b * 2 + 5
</code></pre></div></div>

<p style="text-align: center;"><img src="/images/mind_blowing.gif" alt="Взрыв Мозга" /></p>
<p><em><center>Узнали? Согласны?</center></em></p>

<p>Отставить горячку!</p>

<p>В F# вся эта магия реализуется <em>инфиксным</em> оператором « или » у которых оба параметра — функции.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = fun a -&gt; a + 5
let y = fun b -&gt; b * 2
let chtoproishodit = x &lt;&lt; y

printfn "%d" (chtoproishodit 5) // посчитает: 5 * 2 + 5 = 15

let ostanovitespojaluista = ((fun y -&gt; y * 20) &lt;&lt; (fun x -&gt; x - 1)) 2 // посчитает: 2 - 1 * 20 = 20 
</code></pre></div></div>

<p>Всё просто же? Как сказано выше, можно передавать функции в другом порядке с помощью »</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let vseyasno = x &gt;&gt; y // vseyasno 3 = y ( x(3) ) = y ( 8 ) = 16  
</code></pre></div></div>

<h3 id="каррирование">Каррирование</h3>

<p>Или — <em>частичное применение функций</em>.</p>

<p>Это когда мы передаем функции <em>неполное число аргументов</em>, и в результате получаем… что? функцию!</p>

<p>Как уже говорилось в предыдущем посте по теме, все функции в F# имеют <strong>только один аргумент</strong>, когда мы кортежем передаем несколько аргументов, это по сути (формально) работает как применение функций одного аргумента ко всем аргументам из списка поочередно.</p>

<p>Вот такая каррированая функция f a будет ждать на вход один параметр b:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let f x = fun b -&gt; b * x 
let mul5 = f 5
</code></pre></div></div>

<p>Понятно, что вызвав mul5 2 получится 10. В F# допускается ещё более краткая запись без fun:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let f x b = b * x 
</code></pre></div></div>

<p>Работать будет точно так же.</p>

<h2 id="нужно-больше-операторов">Нужно больше операторов!</h2>

<p>Тут можно делать свои операторы, а не только функции (сейчас какой-то душный человек вспомнит что оператор тоже функция и пойдет поедет. Я ― помню).</p>

<p>Для определение своих <em>инфиксных</em> операторов нам доступны следующие символы:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>! % &amp; * + - . / &lt; = &gt; ? @ ^ | ~
</code></pre></div></div>

<p>А для <em>префиксных</em> такие последовательности:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ - +. -. &amp; &amp;&amp; % %% ~ ~~ ~~~ ~~~~
</code></pre></div></div>

<p>Объявление таких операторов нужно делать через скобочную нотацию: (оператор) для инфиксных, и (~оператор), соответственно для префиксных.</p>

<h2 id="операторы-применения-функций">Операторы применения функций</h2>

<p>Есть два таких оператора: “|&gt;” и “&lt;|”, они отправляют значение вправо или влево.</p>

<p>Выражение x |&gt; y и выражение y &lt;| x будут означать одно и то же — “y x”.</p>

<p>Но важный момент в том, что ассоциация этих операторов <strong>левая</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 |&gt; 2 |&gt; (+) 
</code></pre></div></div>

<p>приведет к ошибке, когда:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 |&gt; (2 |&gt; (+)) 
</code></pre></div></div>

<p>сработает.</p>

<h2 id="ещё-раз-про-кортежи">Ещё раз про кортежи</h2>

<p>Итак, мы знаем что с помощью кортежей мы можем схитрить и передать в функцию больше одного аргумента.</p>

<p>Кортежи могут объединять в себе значения разных типов, это ок. И это потенциально очень мощный инструмент. Рассмотрим несколько фишек.</p>

<h3 id="фишки-первого-уровня">Фишки первого уровня</h3>

<p>Значения типов в кортежах перевариваются в F# как объекты первого класса. Мы можем использовать их в выражениях, и получать как результат других выражений.</p>

<p>Можно использовать в качестве элемента кортежа уже связанное ранее значение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = (10, "hello")
let b = (a, 100.500)
</code></pre></div></div>

<p>Последний кортеж получится типа: ((int * string) * float)</p>

<p>Вычисляются кортежи по порядку слева-направо, и кортежи можно сравнивать, но только если совпадают значения типов их элементов (в том же порядке):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(5 = 2, "hello", 1 + 1) = (false, "hello", 2) // правда!
(5 = 2, "hello", 1 + 1) = ("friend", (10.5, 18)) // парень, не дури, типы не совпали.
</code></pre></div></div>

<p>“Легальное” сравнение (когда с типами всё ок), происходит в лексикографическом порядке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(29, 14, 100) &gt; 11, 0, 101 // не правда!
</code></pre></div></div>

<h3 id="кортеж-как-шаблон">Кортеж как шаблон</h3>

<p>Мы можем сделать кортеж состоящий только из идентификаторов:
    let (x, y) = (10, 200) // x = 10, y = 200</p>

<p>С помощью чего потенциально можем сопоставлять идентификаторы и значения.</p>

<p>Помните паттерн матчинг? Тут можно так же использовать идентификатор “_” для сопоставления с любыми значениями:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let (_, y) = (1, 2) // y = 2
</code></pre></div></div>

<h3 id="превращение-в-овцу">Превращение в овцу</h3>

<p>Это про полиморфизм, кто не понял :)</p>

<p>Пример полиморфной функции с кортежем — функция swap:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let swap (x, y) = (y, x)
</code></pre></div></div>

<p>Она меняет значения внутри кортежа местами, и типы её параметров полиморфны, то есть определяются другими типами.</p>

<p>Полиморфный тип, это такой тип, операции над которым могут нормально применяться к другим типам.</p>

<p>В F# полиморфным типом выступает базовый тип .NET System.Object, таким образом тип функции swap будет:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.Object  * System.Object -&gt; System.Object * System.Object
</code></pre></div></div>

<h2 id="рефлексия">Рефлексия</h2>

<p class="error">Спойлер Алерт!!! Если вы занимаетесь по курсам Сергея Игоревича Бобровского, и не прошли ещё курс по F# — имейте совесть и смелость решить задачки сами. В частности далее будет спойлер к задаче по кастомным операторам 23.4.1.</p>

<p style="text-align: center;"><img src="/images/serious_cat.jpg" alt="Котямба" /></p>
<p><em><center>Я серьезно.</center></em></p>

<p>Задачка следующая:</p>

<p>В фэнтези-РПГ принята следующая денежная система: в одном золотом 20 серебряных, а в одном серебряном 12 медяков. Суммы в такой системе задаются тройками целых чисел (золотые, серебряные, медяки), например (1, 0, 128) или (32, 23, 5).</p>

<p>Реализуйте инфиксный оператор .+. , который складывает деньги, представленные в виде троек, и инфиксный оператор .-. , который вычитает деньги. Результат приводите к формату, когда количество медяков не превышает 11, а количество серебряных не превышает 19.</p>

<p>Посмотрите какую хрень я накодил в первый (ладно, во второй) раз:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let (.+.) x y =
    let (g1, s1, c1) = x
    let (g2, s2, c2) = y
    
    let total_wallet = (g1 + g2, s1 + s2, c1 + c2)
    
    let rec count_coppers = function
    | (g, s, c) when c &lt;= 11 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_coppers (g, s + 1, c - 12)

    let rec count_silvers = function
    | (g, s, c) when s &lt;= 19 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_silvers (g + 1, s - 20, c)

    let copper_converted = count_coppers total_wallet
    let converted_wallet = count_silvers copper_converted
    converted_wallet


let (.-.) x y = 

    let (more, less) = 
        if x &lt; y then
            (y, x)
        else
            (x, y)

    let (g1, s1, c1) = more
    let (g2, s2, c2) = less

    let rec count_coppers = function
    | (g, s, c) when c &lt;= 11 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_coppers (g, s + 1, c - 12)

    let rec count_silvers = function
    | (g, s, c) when s &lt;= 19 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_silvers (g + 1, s - 20, c)

    let bigger_copper_converted = count_coppers more
    let bigger_converted_wallet = count_silvers bigger_copper_converted
    
    let smaller_copper_converted = count_coppers less
    let smaller_converted_wallet = count_silvers smaller_copper_converted

    let (bigger_g, bigger_s, bigger_c) = bigger_converted_wallet
    let (smaller_g, smaller_s, smaller_c) = smaller_converted_wallet
    (bigger_g - smaller_g, bigger_s - smaller_s, bigger_c - smaller_c)
</code></pre></div></div>

<p>Ну, справедливости ради, оно работает и прошло тесты. Но это какая то жесть. Пусть я и попытался применять рекурсию, здесь налицо недопонимание принципов хорошего, ясного программирования. И вообще халатность. Например в реализации оператора .-. не кажется ли вам что DRY не пахнет?</p>

<p>Эталонное решение выглядит следующим образом:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec iter = function
| (a, b, c) when c &gt; 11 -&gt; iter (a, b + (c / 12), c % 12)
| (a, b, c) when b &gt; 19 -&gt; iter (a + (b / 20), b % 20, c)
| (a, b, c) when c &lt; 0 &amp;&amp; b &gt; 0 -&gt; iter (a, b - 1, c + 12)
| (a, b, c) when b &lt; 0 &amp;&amp; a &gt; 0 -&gt; iter (a - 1, b + 20, c)
| (a, b, c) when c &lt; 0 &amp;&amp; a &gt; 0 -&gt; iter (a - 1, b + 19, c + 12)
| (a, b, c) -&gt; (a, b, c)

let (.+.) (a, b, c) (x, y, z) = iter (a + x, b + y, c + z)
let (.-.) (a, b, c) (x, y, z) = iter (a - x, b - y, c - z)
</code></pre></div></div>

<p>Ради той же справедливости попытаюсь оправдаться, что в первом своем нерабочем решении я использовал деление с остатком, но там была какая то императивная дичь с условными операторами, и компилятор ругался матом. Почему я не додумался забабахать рекурсивный паттерн матчинг… Хороший вопрос. Просто посмотрите на эту красоту, насколько это более ясно и коротко может быть выражено в коде. Паттерн матчинг воистину крутая штука!</p>

<p>Век живи — век учись. А дурнем и помрешь!</p>

<p>Слава Алонзо Черчу! Миру Мир! Я пошел.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"><![CDATA[Продолжаем врубаться в функциональное программирование. Пусть и туго :)]]></summary></entry></feed>