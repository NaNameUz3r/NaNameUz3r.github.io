<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-06-06T10:08:30+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Нам нужны явные состояния. Нужны же?…</title><link href="http://localhost:4000/2022/06/06/hack_in_imperative_1.html" rel="alternate" type="text/html" title="Нам нужны явные состояния. Нужны же?…" /><published>2022-06-06T00:00:00+03:00</published><updated>2022-06-06T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/06/hack_in_imperative_1</id><content type="html" xml:base="http://localhost:4000/2022/06/06/hack_in_imperative_1.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 1.
<!--more--></p>

<p>Всем привет! Я приступил к очередному курсу в skillsmart.ru 
На этот раз темой курса является изучение Императивной модели программирования, как расширения фундаментальной Декларативной модели.</p>

<p>Вы что нибудь помните про декларативную модель, и про состояния?
Мы разбирали эти и другие связанные темы некоторое время назад на соответствуещм курсе. Почитать про это вы можете в моих постах-отчетах, начиная с <a href="/2022/02/06/hack_in_declarative_model.html">этого.</a></p>

<p>Но тут мы тоже будем сперва говорить про декларативность, потому что никуда без неё :P</p>

<h1 id="stateful-programming">Stateful programming</h1>

<p>В императивной модели концепция времени понимается уже совсем по другому. Наверное самое главное отличие императивной модели от декларативной заключается именно в этом.</p>

<p>Время тут меняется благодаря введению в модель <em>Явных состояний</em>, которые добавляют программным сущностям возможность <em>долгосрочной памяти</em>.</p>

<p>Иными словами — тут появляются привычные нам “императивные” переменные.</p>

<p>Есть ещё умные слова, которыми достаточно часто отмечают природу состояний в моделях: <strong>stateless</strong> и <strong>stateful</strong> программирование. На самом под первым как правило имеется в виду декларативное, а под вторым — императивное.</p>

<p>Давайте вкратце повторимся.</p>

<p><em>Декларативное программирование</em> — это когда мы описываем <strong>какой результат</strong> нужно получить. Возможно с дополнительным определением “подказок” как его получить :)</p>

<p><em>Императивное программирование</em> — это когда мы с помощью конкретных команд описываем <strong>как получить результат</strong>.</p>

<p>На самом деле декларативное программированое в какой то степени императивно, потому что всё равно зачастую используются последовательности каких то команд.</p>

<p>Вообще, Декларативная парадигма это в первую очередь математическая модель, а сама “декларативность” проще будет пониматься как <em>относительная степень</em>, в которой эта самая декларативность применяется в языке программирования.</p>

<h1 id="прелести-декларативного-подхода">Прелести декларативного подхода</h1>

<p>Хотя декларативный подход можно, грубо говоря, “спроецировать” на любой программный код, на практике же (в логических или фунциональных программах, например) он теряет большую часть аспекта <em>“что делать”</em>, так как приходится более детально описывать подробности <em>“как делать”</em>.</p>

<p>Тем не менее это не значит что от декларативного программирования можно или нужно как то отказываться, потому что у него есть три существеннных плюшки:</p>

<ol>
  <li>В декларативной модели проще формировать практически все программные абстракции благодаря тому что декларативные операции <strong>композиционны</strong>.</li>
  <li>Декларативные программы просто тестировать, потому что достаточно протестировать одиночныне вызовы команд, когда stateful программу тестировать сложнее из за того что приходится проверять <em>последовательности вызовов</em>.</li>
  <li>Рассуждать о программи в декларативной модели проще, чем при использовании императивного программирования.</li>
</ol>

<h1 id="снова-о-состояниях">Снова о состояниях</h1>

<p>Итак, мы уже выяснили что <em>состояние</em> — это растянутая во времени последовательность значений, в которой содержатся промежуточные результаты нужного вычисления.</p>

<p>Мы помним что в декларативной модели состояние характеризуется как <strong>скрытое</strong>. Такие декларативные, состояния никак <em>явно</em> не поддерживаются со стороны вычислительной модели. Последовательности вычислений могут пониматься и представляться только в сознании программирующего существа, а на уровне кода последовательности просто не существуют.</p>

<p>Явное состояние наоборот — <em>существует</em> на протяжении времени, в более чем одном вызове функции <em>без явного определения этого состояния в аргументах этой функции</em>.</p>

<p>Такое состояние реализуется с помощью некоторого “контейнера”, который принято называть <strong>ячейка</strong>. Такая ячейка уже фактически существует в коде, наблюдается, иными словами — <em>не только в сознании программирующего существа.</em></p>

<h1 id="принцип-абстракции">Принцип абстракции</h1>

<p>По мере роста системы описывать её абстракции в чисто декларативном или функциональном программировании становится всё сложнее, потому что сам <em>принцип</em> абстракции не очень хорошо поддерживается этими парадигмами. Причиной этой сложности является как раз природа состояний — мы не можем вкладывать <em>новую</em> информацию в компоненты программы или функции (инкапсулировать их внутри).</p>

<p>Для того чтобы система могла хорошо поддерживать принцип абстракции она должна обладать следующими характеристиками:</p>

<ul>
  <li><strong>Инкапсуляция</strong> — это возможность скрывать внутренние части самой системы;</li>
  <li><strong>Композиционность</strong> — это про возможность комбинирования частей системы в целях полуения новых частей;</li>
  <li><strong>Инстанциирование</strong> (invocation) — возможность создавать много конкретных экземпляров компонена на основе его единого определения.</li>
</ul>

<p>Если вы знаете хотя бы немного про ООП (объектно ориентированное программирование), то наверняка уловили сейчас знакомые концепции. Но мы говорим сейчас совсем не про “высокии материи” ООП, и используем более фундаментальные и универсальные принципы программирования для определения и понимания этих концепций.</p>

<p>Например <em>замыкани</em> обеспечивают инкапсуляцию, а инстанциирование достигается посредством программирования высшего порядка.</p>

<p><strong>Важной</strong> особенность характеристик перечисленных выше является то, что их набор <strong>не требует использования концпеции состояния</strong>.</p>

<p>На самом деле инкапсуляция вообще противоположна состоянию, и её можно применять в декларативном программировании. Состояния же могут обходиться без икапсуляции, к примеру — с помощью создания <em>глобальных переменных</em>.</p>

<p>Пришла пора поговорить о cons, а то всё про pros да про pros :)</p>

<p>Добавления концепции состояния к декларативному программированию резко и в разы усложняет понимание самой программы, становится не так просто рассуждать о ней.</p>

<p>Во-первых мы можем столкнуться с <strong>побочными эффектами</strong> у функций, которые теперь могут менять состояния что не видны во всей остальной программе.</p>

<p>Именно по этой причине явное состояние нужно обязательно <strong>применять в тесной связи с инкапсуляцией</strong>, благодаря чему появляется возможность проектировать stateful-системы корректно. Тут появляется понитие <strong>инварианта</strong>, который всегда выглядит “снаружи” правильно.</p>

<p>Это возвращает нам возможность рассуждать о подсистемах формально, считая что поведение этой подсистемы не зависит от окружающей среды, тем самым частично возвращая нас в плане рассуждений к декларативному программированию. Тем не менее, одно только введение инвариантов всё ещё не делает программирование с использованием состояний таким же простым и понятным как декларативное.</p>

<p>Потому что инвариант <em>всего лишь определяет что компонент не ведет себя некорректно</em>, и никак не гарантируется то, что он помогает в продвижении к решению итоговой задачи.</p>

<p>Из всего это следует очень важное правило:</p>

<p class="info">Сложные системы нужно проектировать так, чтобы как можно больше количество компонентов этой системы было описано в декларативной парадигме.</p>

<p>Состояния <strong>должны</strong> быть сконцентрированны в единичных компонентах. Нельзя растягивать состояния по несколькоим компонентам.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 1.]]></summary></entry><entry xml:lang="ru"><title type="html">F# Напоследок</title><link href="http://localhost:4000/2022/06/03/last_about_f.html" rel="alternate" type="text/html" title="F# Напоследок" /><published>2022-06-03T00:00:00+03:00</published><updated>2022-06-03T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/03/last_about_f</id><content type="html" xml:base="http://localhost:4000/2022/06/03/last_about_f.html"><![CDATA[<p>Послесловие о функциональном программировании на F#
<!--more--></p>

<p>Привет! Совсем недавно я завершил базовый курс по функциональному программированию на F# в <a href="http://skillsmart.ru/">skillsmart.ru</a>.
Хочу написать ещё немного об этом опыте, в продолжение <a href="/2022/04/17/more_about_f.html">предыдущего поста</a></p>

<p>Рассмотрим несколько фишек и типов F#</p>

<h1 id="определение-типа-и-записи">Определение типа и записи</h1>

<p>В F#, как и в большинстве языков программирования можно определять свои типы, делается это с помощью ключевого токена “type”.</p>

<p>Есть так же такой тип как Запись (record), который фактически является кортежем, но его элементы идентифицируются ключами-метками (названиями), а не порядковой позицией. Это напоминает словарь в Python.</p>

<p>Сперва нам нужно определить структуру записи как тип.
Например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type = Weapon { fullauto : bool; load_amount: int; fire_rate: float32 }
</code></pre></div></div>

<p>Затем мы можем определить “экземпляр” записи:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47 = { fullauto = true; load_amount = 30; fire_rate = 100.54 }
</code></pre></div></div>

<p>Не нужно как-то дополнительно указывать что ak47 это запись типа Weapon — компилятор F# сам поймет на основании идентификаторов используемых полей.</p>

<p>Мы можем обращаться к каждому отдельному полю записи, чтобы получить её значение используя точечную нотацию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47_firerate = ak47.fire_rate
</code></pre></div></div>

<p>Записи можно целиком сравнивать, если типы данных значений полей совпадают. Такое сравнение происходит в лексикографическом порядке.</p>

<h1 id="размеченное-объединение">Размеченное объединение</h1>

<p>Это тип данный, в котором мы задаем множество некоторых идентификаторов. Соответственно размеченное объединение может принимать только тип из своего “списка”. Синтаксис напоминает сопоставление с образцом — используем пайп:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47
  | m249_saw
  | colt_anaconda
</code></pre></div></div>

<p>На полную катушку оторваться тут можно уже фактически используя паттернматчинг фишку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47 -&gt; "автомат"
  | m249_saw -&gt; "пулемет"
  | colt_anaconda -&gt; "револьвер"

let full_auto = function
  | ak47 | m249_saw -&gt; true
  | _ -&gt; false
</code></pre></div></div>

<h2 id="конструктор-значений">Конструктор значений</h2>

<p>Мы так же можем обозначить тип данных для каждого элемента-тега размеченного объединения:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Сaliber =
  | Pistol of float32
  | Machine_gun of float32
  | Cannon of int
</code></pre></div></div>

<p>В таком случае тег связанные с типом является фактически функцией, которыю называются конструкторами значений.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak_caliber = Machine_gun 7.62
let bfgun_caliber = Cannon 666
</code></pre></div></div>

<h1 id="частичные-функции">Частичные функции</h1>

<p>Это такая функция, которая только на <em>подмножистве значений аргументов</em>.</p>

<p>Есть специальный тип <strong>option</strong>, у которого может быть только два значения:</p>
<ul>
  <li>None: тут всё понятно;</li>
  <li>Some: это <em>полиморфный</em> конструктор значений, который прнимает <em>любые</em> типы.</li>
</ul>

<p>В F# есть три случая, в которых функция может быть неопределенной:</p>
<ol>
  <li>Вычисления в функции не завершаются — упала в бесконечную рекурсию и тд.</li>
  <li>Вычисления завершились с рейзом исключения.</li>
  <li>Вычисления возвращают вышеупомянутый тип option.</li>
</ol>

<p>Простой пример:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let div x y = if y = 0 then None else Some(x / y)
let r = div 2 0 
</code></pre></div></div>

<p>Тогда:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printfn "%s" (string r) 
</code></pre></div></div>

<p>не выведет ничего. Но если значение есть, мы можем достать его из Some с помощью Option.get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let r = div 4 2 
printfn "%d" (Option.get r)
</code></pre></div></div>

<h1 id="списки-в-f">Списки в F#</h1>

<p>Списки отличаются от кортежей тем, что они являются цепочками значений <em>одного</em> типа.</p>

<p>В F# списки заключаются в квадратные скобки, а элементы перечисляются через точку с запятой.</p>

<p>В типе списков можно увидеть ключевое слово list, которое является <em>конструктором типа</em>.
У списка:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ ("hello", "world"); ("hello", "friend") ]
</code></pre></div></div>

<p>Тип будет:</p>

<p>(string * string) list</p>

<p>Добавить элемент в голову списка можно специальным оператором — “::”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"hello" :: ["w"; "o"; "r"; "l"; "d"] = ["hello"; "w"; "o"; "r"; "l"; "d"]
</code></pre></div></div>

<p>Список из целых значений с единичным шагом можно выражать зачениями диапазона используя две точки, например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 10 ]
</code></pre></div></div>

<p>Шаг можно изменить, указав его между первым и последним значеним так же — через две точки</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 3 .. 12 ]
</code></pre></div></div>

<p>Сцепить вместе два списка можно с помощью инфиксного оператора @:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "h"; "e"] @ [ "l"; "l"; "o"]
</code></pre></div></div>

<h1 id="множества">Множества</h1>

<p>Множеством называется неупорядоченный набор элементов одного типа, <em>среди которых нет повторяющихся</em>, то есть одинаковых.</p>

<p>Список преобразовать во множество можно с помощью функции Set.ofList, и обратно — Set.toList.</p>

<p>Добавить и убрать элемент — Set.add <элемент>, Set.remove <элемент></элемент></элемент></p>

<p>Проверить что элемент есть в списке можно с помощью Set.contains, или проверить на вхождение подмножества — Set.isSuset:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set.contains "hello" (set ["hello"; "w"; "o"; "r"; "l"; "d"])
Set.isSubset (set ["w"; "o"]) (set ["hello"; "w"; "o"; "r"; "l"; "d"])
</code></pre></div></div>

<p>Объединяются множества через Set.union, а пересечения и различия находятся как Set.intersect и Set.difference соответственно.</p>

<h1 id="хвостовая-рекурсия">Хвостовая рекурсия</h1>

<p>Рекурсию мы уже достаточно хорошо обсуждали во втором посте о Декларативном программированиие -&gt; <a href="/2022/02/12/hack_in_declarative_model_2.html">тык чтобы перечитать</a>.</p>

<p>Давайте рассмотрим живой пример на F#.</p>

<p>Неоптимизированная рекурсивная функция для расчета факториала будет выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec factorial = function 
 | 1  -&gt; 1
 | x  -&gt; x * factorial(x - 1)
</code></pre></div></div>

<p>Здесь x накапливает результат, но на каждом итерации рекурсии будет происходить вызов функции factorial, и её результаты умножаться на x.</p>

<p>Избавиться от лишних рекурсивных вызовов можно использовав прием с <em>аккумулятором</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let factorial n =
    let rec inner_wrapper x a =
        if x &lt;= 1 then a
        else inner_wrapper (x - 1) (a * x)
    inner_wrapper n 1
</code></pre></div></div>

<p>Здесь рекурсивные вычисления выполняются в другой, вложенной функции inner_wrapper, а её рекурсивный вызов располагается в самом конце, и не входит в какие либо вычисления как в предыдущем примере. Благодаря этому компилятор сможет оптимизировать выполнение без использования стека произвольной рекурсивной глубины.</p>

<h1 id="последовательности-и-ленивые-вычисления">Последовательности и ленивые вычисления</h1>

<p>Ленивые вычисления, это такая математическая модель вычислений в программировании. Как это работает? Например в F# есть <em>Последовательности</em>. Это как раз пример “ленивой структуры”.</p>

<p>Последовательность — это упорядоченная коллекция элементов, значения которых вычисляются <em>лишь в момент обращения к ним.</em></p>

<p>Фишка в том, что последовательность может быть <em>бесконечной</em>. И таковыми их можно представить как раз благодаря “ленивости”, никаких накладных расходов на определение последовательностей нет (не нужно сразу что-то бесконечно вычислять :)</p>

<p>Бесконечная последовательность задаётся дефолтной функцией Seq.initInfinite, и в параметр ей мы передаем другую функции которая будет генерировать последовательные значения.</p>

<p>Такая последовательность будет в себе содержать квадраты целых чисел:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let squares = Seq.initInfinite (fun x -&gt; x * x)
</code></pre></div></div>

<p>Мы можем получить (вычислить) любой по индексу элемент последовательности с помощью функции Seq.item. А ещё последовательности можно кэшировать, чтобы не приходилось при каждом обращении к последоватльности вычислять её значения.</p>

<p>Пример выше можно было бы закэшировать так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let cached_squares = Seq.cache squares
</code></pre></div></div>

<p>После этого при обращении к n-ному элементу такой последовательности будут вычислять этот и все предыдущие элементы, <em>если они ещё не были вычислен</em>, ну а в противном случае — использовать кэшированные результаты.</p>

<h1 id="резюме">Резюме</h1>

<p>В целом, наверное на этом всё. Мне кажется что не совсем уместо тупо перечислять стандартные функции. Документация F# вполне себе ок, как на английском так и на русском.</p>

<p>И рассматривать (читай спойлерить) задания из курса как в прошый раз я не хочу. Скажу лишь главное — это было круто, и стоило того. Пусть и пришлось поломать голову. Хотя, кмк я больше преувеличиваю и задания были проще чем мне казалось.</p>

<p>По крайней мере после сравнения своего решения и эталонного я так думал практически каждый раз :D</p>

<p>Я никогда особо до этого не трогал лапками функциональные языки, разве что хаскель полтора раза, и скажу честно две вещи:</p>

<ol>
  <li>Мне <strong>очень</strong> понравилось.</li>
  <li>Не знаю когда и что я буду, и буду ли вообще писать на чисто функциональных языках, но кажется что это правда как то меняет точку зрения на программирование в целом. Может мне кажется, но всё таки кажется что не кажется.</li>
</ol>

<p>Я знаю что пишу часто криво, криво рейрачу, но кто бы это не прочитал — идите потрогайте ФП, и посмотрите внимательно в зеркало, ведь там очень красивый и умный человек :)</p>

<p>P.S. 
Если вдруг захотите <del>удариться головой об косяк</del> преисполниться в ФП на F# поищите учебник: “Functional Programming Using F#” Michael R. Hansen</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"><![CDATA[Послесловие о функциональном программировании на F#]]></summary></entry><entry xml:lang="ru"><title type="html">Обзор DNS</title><link href="http://localhost:4000/2022/06/01/DNS.html" rel="alternate" type="text/html" title="Обзор DNS" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/DNS</id><content type="html" xml:base="http://localhost:4000/2022/06/01/DNS.html"><![CDATA[<p>Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?</p>

<!--more-->

<p>И Артпанет и наш нынешний интернет на очень примитивном уровне и грубо говоря — телефонна сеть. У каждого участника этой сети есть свой “номер телефона” — IPv4 или IPv6 адрес, по которому к нему можно “дозвониться”, например на какой нибудь порт.</p>

<p>на заре интернета в роли DNS выступал текстовый файлик HOSTS.TXT, который хранился в некотором сетевом информационно центре, и чтобы получить нужный адрес или внести свой в этот центр <strong>нужно было… звонить!</strong>  Чем больше развивалась сеть, тем больше становилось хостов, и поддерживать HOSTS.TXT стало, мягко говоря, неудобно. Тут родился DNS.</p>

<h1 id="что-такое-dns">Что такое DNS</h1>

<p>Domain Name System — это такая распределенная система, которая “превращает” доменные имена в IP адреса, которые клиент использует для получения нужных ему ресурсов с целевого сервера. Ну там, страничку в браузере загрузить :)</p>

<p>Служит вся эта история в первую очередь для нашего человеческого удобства.</p>

<h1 id="dns-сервер">DNS сервер</h1>

<p>Грубо говоря, DNS сервер это такой сервер, который хранит у себя подобие записной книги контактов в вашем телефоне — своего рода база данны, в которой записаны публичные IP адреса и связанные с ними <em>доменные имена</em>.</p>

<p>Как только IP адрес найден и передан клиенту, этот самый клиент может устанавливать нужные ему соединения, например с ближайшим CDN (content delivery network) сервером, на котором закеширован искомый ресурс или с “исходным”, как говорится origin сервером.</p>

<h1 id="как-устроен-dns">Как устроен DNS</h1>

<p>В обычным DNS запросе URL адрес, введенный пользователем должен пройти через четыре сервера, чтобы получить клиент получил нужный адрес.</p>

<p>Все эти четыре сервера работают вместе таким образом:</p>

<ul>
  <li>
    <p>DNS Recursor: его ещё называют “преобразователем DNS”. Этот сервер получает DNS запрос от клиента, а потом связывается с другими DNS сервера, чтобы они помогли ему найти верный адрес. На этом этапе преобразователь сам действует как клиент — он создает один или несколько DNS запросов, которые отправляются дальше.</p>
  </li>
  <li>
    <p>Root nameservers: это <em>коренные серверы имен</em>. Коревой сервер назначен на определенную <em>корневую</em> DNS зону интернета. Задачей такого сервера является обработка полученных DNS запросов, отвечая на которые корневой сервер формирует список <em>Авторитетных серверов имен <strong>верхнего уровня (TLD)</strong></em>, которые <em>вероятно могут</em> знать искомый в запросе адрес.</p>

    <p>Уровень домена определяется количеством точек в доменном имени. например blablabla.com будет доменом верхнего уровня, тогда как blabla.killme.com — второго, и так далее.</p>
  </li>
  <li>
    <p>TLD nameservers: или Top Level Domain Nameservers связаны с доменами верхнего уровня, и обычно эти серверы идут после коренных. Для простоты их можно представлять как ответвления от коренных серверов. На них содержится информация о доменах следующего уровня <em>конкретных DNS зон</em>.</p>
  </li>
  <li>
    <p>Authoritative nameservers: это те сервера, которые уже наконец дают какой то реальный ответ на изначальный DNS запрос. Есть два ипа таких серверов: главный сервер, и вторчный. Главный хранит <em>исходные</em> копие записей своей зоны, а вторичный (один или несколько) являются репликами главного, которые служат для распределния нагрузки и страховым вариантом в случае сбоя главнго сервера. Эти сервера так же хранят ресурсные DNS записи (А, АААА, CNAME, MX, TXT, и так далее)</p>
  </li>
</ul>

<h1 id="кэширование-dns">Кэширование DNS</h1>

<p>Кэширование результатов DNS запросов может происходить на уровне операционной системы или браузера. Это необходимо для оптимизации, ускорения обработки запросов. Зачем искать адрес, который мы итак уже знаем?</p>

<h2 id="рекурсивные-сервера">Рекурсивные сервера</h2>

<p>Мы уже выяснили, что авторитативные серверы хранят настоящие DNS записи, тогда как <em>рекурсивные</em> серверы выступают в роли посредников, которые находятся между авторитативным сервером и конечным клиентом. Чтобы найти нужную запись (нужный сервер имен) рекурсивные серверы посредством DNS запросов “рекурсивно” проходят по дереву DNS серверов, чтобы наконец добраться до своей цели.</p>

<p>Рекурсивные серверы хранят у себя в кеше результаты своих “путешествий”, чтобы каждый раз не искать по новой. Время такого кеширования определяется хозяином домена с помощью параметра TTL (time to live).</p>

<h1 id="ещё-раз-как-как-это-работает">Ещё раз… как как это работает?</h1>

<p>Если всё ещё непонятно, давайте быстро разберем базовый случай.</p>

<ol>
  <li>Вбиваем адрес сайта в браузер.</li>
  <li>Браузер проверяет кэш. Если адреса есть — начинает работать с ресурсом используя этот адрес. Если адреса нет идем дальше.</li>
  <li>Бразуер отправляет запрос к DNS-резолверу. Резолвер это такая служба в операционной сети. Если в кэше у резолвера нашелся нужный адрес — возвращаем его браузеру для работы, если адреса нет:</li>
  <li>DNS-резолвер отправляет запрос DNS-резолверу вашего интернет провайдера, или резолверу Google (8.8.8.8, 4.4.4.4), или на худой конец в CloudFlare (1.1.1.1). Резолвер снова проверяет свой кэш на предмет запроса. Если и тут адреса нет:</li>
  <li>DNS-резолвер провайдера отправляет запросы коренным DNS серверам (кому слать резолвер понимает по домену верхнего уровня). Корневые серверы проверяют есть ли у них информация о домене верхнего уровня из полученного запроса. Если такая информация найдена, коренной сервер возвращает резолверу адрес TLD сервера. Если нет — возвращает ошибку, потому что запрощенной зоны просто не существует.</li>
  <li>Резовер, получив адрес TLD сервера отправляет к нему запрос, и TLD сервер проверяет у себя информацию о домене второго уровня из запроса. Если такой домен у него есть, значит домен существует и зарегистрирован. Тогда TLD сервер вернет адрес авторитативного сервера.</li>
  <li>Получив адрес авторитативного сервера резолвер отправляет ему запрос. Авторитативный сервер проверяет свою базу данных, и если нужный домен в ней есть — возвращает его IP адресс, который записан в А записи этого домена.</li>
  <li>Наконец, когда нужный адрес найдер и получен резолвером, последний записывает этот адрес в свой кэш и передает его в резовер нашей операционной системы, который оттуда попадает в браузер (и оседает в кэш соответственно).</li>
</ol>

<p>Всё это работает быстро, в первую очередь благодаря кэшированию на многих уровнях DNS системы.</p>

<h1 id="дайте-потрогать">Дайте потрогать!</h1>

<p>Посмотреть глазами как это работает можно с помощью утилиты dig, которая есть и на линуксе и на, простите, макоси. Если вы заядный виндузятник можете воспользоваться NSLOOKUP, но лучше поставьте Linux :D</p>

<p>Трейснуть dns с помощью dig можно командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    gid +trace &lt;интересующий_домен&gt;
</code></pre></div></div>

<p>Если dig у вас по какой то причине не установлен, нужно установить dnsutils или bind-utils для debian и redhat семейств соответственно.</p>

<p>Если вы всё таки решили сидеть на винде, и читаете это до сих пор, а NSLOOKUP вдруг неожиданно оказался не очень информативной штукой, вы можете воспользоваться любым онлайн инструментов для трейса DNS.</p>

<h1 id="резюме">Резюме</h1>

<p>Как видите в DNS ничего страшного и сложного нет, и работает эта штука предельно понятно. Я не говорю тут про имплементацию самих серверов, это наверное совсем отдельная тема :D</p>

<p>По традиции для владеющих английским языком, и жадных до знаний приведу для затравки пару RFC по теме: <a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035</a> с основой спецификацией, и <a href="https://datatracker.ietf.org/doc/html/rfc1912">RFC 1912</a> уже на тему “Common DNS Operational and Configuration Errors”.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?]]></summary></entry><entry xml:lang="ru"><title type="html">Почтовые протоколы</title><link href="http://localhost:4000/2022/06/01/mail_protocols.html" rel="alternate" type="text/html" title="Почтовые протоколы" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/mail_protocols</id><content type="html" xml:base="http://localhost:4000/2022/06/01/mail_protocols.html"><![CDATA[<p>Немного о том как письма в интернете ходят.</p>

<!--more-->

<p>Привет! В этому посте я предлагаю немного ознакомиться с почтовыми протоколами. Какие бывают? Попробуем понять чем они отличаются. В нашем прицеле сегодня POP3, SMTP, ESMTP и IMAP.</p>

<h1 id="pop3">POP3</h1>
<p>Протокл POP3 (Post Office Protocol) — это ещё один <del>старый</del> стандартный сетевой протокол используемый локальными почтовыми клиентами для получения писем с почтового сервера по TCP/IP соединению. Первая версия протола появилась в 1984 году (<a href="https://datatracker.ietf.org/doc/html/rfc918">RFC 918</a>), а актуальная версия, как не сложно догадаться — третья!</p>

<p>Кому интересно: Вторая версия протокола описана в <a href="https://datatracker.ietf.org/doc/html/rfc937">RFC 937</a> в 85 году, третья в <a href="https://datatracker.ietf.org/doc/html/rfc1081">RFC 1081</a> в 1988. В течении следующих 10 лет протокол несколько раз прееопредялялся, и последняя актуальная версия была описана в 1996 году в <a href="https://www.ietf.org/rfc/rfc1939.txt">RFC 1939</a>.</p>

<p>Протокол до сих пор очень распространен, и одной из главных причин этому — простота его конфигурации.</p>

<h2 id="как-работает-pop3">Как работает POP3</h2>
<p>Серверы электронной почты, размещенные например у интернет провайдеров, так же часто используют POP3 для получения и харнения писем, предназначенных для их подписчиков. Периодически эти самые подписчики используют клиенты для проверки своих ящиков на удаленных почтовых серверах, и загружают письма предназначенные им.</p>

<p>Обычно, когда письмо загруженно клиентом, оно удаляется с почтового сервера. Некоторые почтовые клиенты позволяют менять это поведения, копируя письмо на локальный хост и не удаляя его с сервера в течении определенного времени.</p>

<p>Как правило клиенты используют 110 порт для подключения к POP3 серверу. Существует так же версия поддерижвающая шифрование — POP3S. Работает с TLS или SSL обычно на порту 995.</p>

<p>Преимущества POP3:</p>
<ul>
  <li>Так как почта загружается на компьютер пользователя её можно читать в оффлайне;</li>
  <li>Аттачменты можно открывать быстро, по той же причине — они уже скачаны;</li>
  <li>Нужно меньше дискового пространства на сервере, так как письма хранятся у клиента;</li>
  <li>Широко распространен, легко настроить.</li>
</ul>

<p>Минусы:</p>
<ul>
  <li>Если почты много пользователю может потребоваться выделять для её хранения слишком много дискового пространства;</li>
  <li>Всю почту можно утратить если медным тазом накроется диск, или ещё хуже — если в почте были конфиденциальные данные и ваш компьютер украли…</li>
  <li>Нет настроек сортировки писем, вся почта летит в одну директорию;</li>
  <li>Если в используемом клиенте нет возможности копировать письмо с сервера (только выкачивать с удалением), то приедтся пользоваться почтой только с одного устройства;</li>
  <li>Письма можно скачивать только целиком, вместе с аттачами.</li>
</ul>

<h1 id="imap">IMAP</h1>

<p>Inernet Message Access Protocol — ещё один почтовый протокол для получения писем с почтового сервера. Аналог POP. Точно так же работает в клиент-серверной архитектуре. Всё поверх того же TCP/IP, используя по дефолту 143 порт для незащищенного соединения, и 993 для шифрованного.</p>

<p>Первая версия задокументирована в <a href="https://datatracker.ietf.org/doc/html/rfc1064">RFC 1064</a> в июле 1988, обновлена в <a href="https://datatracker.ietf.org/doc/html/rfc1176">RFC 1176</a> в августе 1990, IMAP3 появился в феврале 1991, описан в <a href="https://datatracker.ietf.org/doc/html/rfc1203">RFC 1203</a>.</p>

<p>IMAP3, кстати, никто так и не использовал, все продолжали работать с IMAP2.</p>

<p>После этого было ещё одно изменение — внедрение поддержки MIME в расширении названном IMAPbis.</p>

<p>Наконец, современный IMAP4 впервые был описан в двух публикациях: <a href="https://datatracker.ietf.org/doc/html/rfc1730">RFC 1730</a>, которая содержит спецификацию протокола, и <a href="https://datatracker.ietf.org/doc/html/rfc1731">RFC 1731</a> — с описанием механизма аутентификации в IMAP4.</p>

<h2 id="фичи-imap">Фичи IMAP</h2>

<p>Протокол был разработан специально для обеспечения максимально гибкого спобоса доступа пользователя к своему ящику. IMAP может работать в любом из трех режимов: онлайн, оффлайн или автономно (disconnected).</p>

<p>IMAP предоставляет следующие возможности:</p>
<ul>
  <li>Доступ и получение почты с удаленного сервера (практически как в POP);</li>
  <li>Установка флага прочитанных сообщений;</li>
  <li>Управление несколькими почтовыми ящиками, перекидывание писем из одиного в другой, организация ящиков в категории, создавать иерархии из директорий для писем;</li>
  <li>Возможность загружать часть сообщения. Например без мультимедиа содержимого;</li>
  <li>Организация почты на сервере в соответствии с требованиями. Можно удалять или переименовывать свой ящик на сервере (в POP так нельзя);</li>
  <li>Можно искать письма по ключевым словам;</li>
  <li>Проверка заголовка письма, перед его загрузкой.</li>
</ul>

<p>Преимущества IMAP:</p>
<ul>
  <li>Вся почта хранится на сервере, доступна с любого устройства-клиента;</li>
  <li>Письма не загружаются все сразу на локальный компьютера как в POP, и соответственно нет таких требований к дисковому пространству.</li>
  <li>Письма хранятся в условной безопасности на сервере, риски утечек и утраты почты меньше по сравнению с POP.</li>
  <li>Благодаря возможности частичной загрузки почтой можно пользоваться даже при плохом соединении, загружая только тело письма без тяжелых аттачей.</li>
</ul>

<p>Минусы IMAP:</p>
<ul>
  <li>Вся почта на сервере, так что без интернета не получится загружать и новые и уже полученные письма, которые были кэшированы более двух недель назад;</li>
  <li>В случае компрометации ящика злоумышленниками всё его содержимое станет им доступно. В сравнении с POP это “палка о двух концах”, но проблемы информационой безопасности корреспонденции выходят за рамки этого обзора.</li>
</ul>

<h1 id="smtp">SMTP</h1>

<p>SMTP (Simple Mail Transfer Protocol) ещё один сетевой протокол старичок, представленный в 1982 году в <a href="https://datatracker.ietf.org/doc/html/rfc821">RFC 821</a>.</p>

<p>Преследует две задачи: проверка правильности конфигурации системы, авторизация на отправку письма для конкретного устройства, и собственно сама отправка исходящего письма на указанный адрес с подтверждением успешной доставки.</p>

<p>Кстати, если письмо доставить не удалось — отправитель получит алерт.</p>

<p>SMTP может работать практически с любыми протоколами транспортного уровня (TCP, UDP и тд). По умолчанию работет на двух портах: 25 служит для передачи почты между почтовыми серверами, и 587, по которому почта передается от клиента на сервер.
Поддерживает SSL шифрование (задействуется дополительно 465-ый порт).</p>

<h2 id="формат-письма-в-smtp">Формат письма в SMTP</h2>

<p>Почтовое сообщение в SMTP состоит из “конверта”, заголовка и тела письма. 
Формат заголовка и тела подробно описан в <a href="https://datatracker.ietf.org/doc/html/rfc2822">RFC 2822</a>.</p>

<p>Конверт, грубо говоря, это такая абстракция для передачи сообщений между клиентом и сервером. На самом деле они общаются в привычном клиент-серверном формате запросов и ответов.</p>

<h2 id="запросы-и-ответы-smtp">Запросы и ответы SMTP</h2>

<p>Самые часто используемые запросы (команды):</p>
<ul>
  <li>Helo: служит для установки соединения, и выполняется только когда клиент укзаывает свой домен и почтовый адрес;</li>
  <li>Mail: задает адрес отправителя;</li>
  <li>RCTP: задает адрес получателя. Если получателей несколько, то они указываются каждый в отдельной RCTP команде;</li>
  <li>DATA: сигнал серверу о конце “конверта”, после чего идет само письмо;</li>
  <li>QUIT: разрыв соединения после окончания письма.</li>
</ul>

<p>Ответы SMTP состоят из кода и текста ответного сообщения. По коду можно понять если что то пошло не так. В человекочитаемом сообщении же будет указано что произошло в ходе отправки или получения письма.</p>

<p>Коды начинаются с 2, 3 и 5. В первом случае всё прошло хорошо, во втором — письмо отправилось, но нужны дополнительные данные. А пятерка это алерт, что то сломалось и надо разбираться.</p>

<h2 id="описание-работы">Описание работы</h2>

<p>Представим частный случай, в котором уже установлен и сконфигурирован SMTP север, и мы хотим отправить письмо:</p>
<ol>
  <li>Пишем письмо, указываем адрес отправителя, после чего происходит соединение с SMTP клиентом провайдера, например Gmail.</li>
  <li>Происходит передача почтовых адресов отправителя и получателя, тема письма и содержимое на сервер.</li>
  <li>SMTP система начинает искать SMTP сервер получателя.</li>
  <li>Если целевой сервер не будет найден, наш попытается ещё несколько раз это сделать. Если все попытки проваялся мы получим алерт о том что письмо не будет доставлено.</li>
  <li>Если всё хорошо и целевой сервер нашелся, то далее в работу вступают другие почтовые протоколы — POP3 или IMAP.</li>
</ol>

<h2 id="прекратить-спам">Прекратить спам!</h2>

<p>В 1995 году в качестве меры по борьбе с безудержным почтовым спамом появилось расширения SMTP протокола — ESMTP, которое добавлет дополнительные команды для защиты серверов и повышения пропускной способности. Например ESMTP привнес:</p>

<ul>
  <li>Аутентификацию отправителя;</li>
  <li>SSL-шифрование почты;</li>
  <li>Возможность аттачить мультимедиа файлы к письмам;</li>
  <li>Возможность ограничить размер писем в соответствии со спецификациями сервера;</li>
  <li>Одновременно слать письма нескольким адресатам;</li>
  <li>Стандартизацию алертов о невозможности доставки.</li>
</ul>

<p>Разумеется сейчас везде используется ESMTP, по понятным причинам.</p>

<h1 id="резюме">Резюме</h1>

<p>Так что же выбрать, IMAP или POP? Мы вкратце рассмотрели оба протокола, и с первого взгляда кажется что IMAP намного лучше. В этом есть доля истины. В принципе, единственным серьезныем отличием является сопосб хранения писем. В POP3 мы качаем все письма себе, и <em>возможно</em> в случае каких то сверхсекретных писем можно выбрать POP3, обмазав его всевозможным шифрованием, начиная от шифрования соединения, заканчивая шифрованием диска с письмами. Но это очень спорный момент, ведь с другой стороны практически все, если не все, почтовые провайдеры поддерживают двухфакторную аутентификцаию, которую сложно обойти… Сложно же, да? :D</p>

<p>Закончим на сегодня, пока я не ударился в шифропанковский параноидальный бред. Будьте здоровы!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Немного о том как письма в интернете ходят.]]></summary></entry><entry xml:lang="ru"><title type="html">FTP протокол</title><link href="http://localhost:4000/2022/05/31/FTP.html" rel="alternate" type="text/html" title="FTP протокол" /><published>2022-05-31T00:00:00+03:00</published><updated>2022-05-31T00:00:00+03:00</updated><id>http://localhost:4000/2022/05/31/FTP</id><content type="html" xml:base="http://localhost:4000/2022/05/31/FTP.html"><![CDATA[<p>Если вы ищете быстрый и простой способ отправлять и получать файлы с друзьями, семьей или коллегами по работе, возможно вам следует знать о FTP.</p>

<!--more-->

<h1 id="что-это-такое">Что это такое</h1>

<p>FTP — это аббревиатура от File Transfer Protocol. Этот сетевой протокол существует с 1980-х годов и до сих пор остается одним из наиболее часто используемых способов передачи файлов.</p>

<p>Название говорит само за себя — протокол служит для передачи файлов поверх TCP/IP, и в этой модели считается протоколом прикладного уровня.</p>

<p>В транзакциях FTP компьютер конечного пользователя принято называють “локальным хостом”, а второй — удаленный компьютер является сервером. Разумеется, между ними должно быть сетевое соединение, и у каждого участника соответвущий софт (FTP сервер на сервере, и какой-то FTP клиент у пользователя).</p>

<p>Не смотря на то что передача файлов по сети может осуществляться с помощью HTTP протокола, с которым мы уже знакомились <a href="/2022/05/22/HTTP.html">тут</a>, к сожалению или к счастью FTP, как уже сказанно выше — до сих пор широко распространён.</p>

<h1 id="как-это-работает">Как это работает</h1>

<p>FTP — это клиент-серверный протокол, который использует <em>два канала</em> связи: один, так называемый “командный канал”, который служит для управления “общением” участников транзакции, и второй — для самой передачи данных.</p>

<p>FTP сервер может быть анонимным — это когда логиниться в него не надо, и работать с ним может фактически кто угодно. Своего рода помойка…) 
А может быть не анонимным и требовать авторизации.</p>

<p>Сеансы FTP работают в двух режимах: активном или пассивном.</p>

<p>В Активном режиме, после того как клиент инициализировал сеанск через запрос по командному каналу, сервер создает обратное соединение с клиентом и начинается передача данных.</p>

<p>В Пассивном режиме сервер использует командный канал для отправки клиенту информации, необходимой для открытия канала данных. Иными словами, в этом режиме клиент инициализирует передачу файлов, а не сервер. Такой режим хорошо работает, когда соединению “препядствуют” всякие фаерволлы, прокси и тд.</p>

<p>Пользователи могут работать с FTP сервером через интерфейсы командной строки из консоли, используя какие нибудь GUI приложения, или просто веб-браузер.</p>

<h1 id="зачем-он-нужен-если-есть-http">Зачем он нужен, если есть HTTP</h1>

<p>FTP — это старый добрый стандарт. Он очень прост и понятен в использовании. Мы можем передавать данные по HTTP, или пересылать их… по электронной почте X_X, но этим вариантам не хватает ясности, простоты и быстроты настройки, которые мы получаем используя FTP.</p>

<p>Этот протокол можно применять в простых и сложных сценариях, таких как доставка или получения необходимых данных на\с сервера, резервное копирование данных на другой сервер, репликация данных. Можно навелосипедить практически любой сценарий :D</p>

<h1 id="типы-ftp">Типы FTP</h1>
<p>Есть несколько видов имплементации протокола. Рассмотрим их вкратце.</p>

<p><strong>Anonymous FTP</strong></p>

<p>Самый простой вариант и небезопасный вариант. Сервер торчит в сеть и раздает данные в незашифрованном (как правило) формате и не требует никакой аутентификации и авторизации. Обычно это какая то слабо регулируемая общедоступное файловая помойка.</p>

<p><strong>Password-protected FTP</strong></p>

<p>То же самое что предыдущий вариант, только чуть безопаснее. Потребуется логин и пароль. Шифрования обычно тут тоже отсутствует.</p>

<p><strong>FTPS</strong></p>

<p>S — значит Secure. Данные шифрутся TLS.</p>

<p><strong>SFTP</strong></p>

<p>Технически, это не FTP протокол, но работает точно так же. SFTP это дитя SSH протокола, который обычно (сервер) работает на 22 порту. Наверное это самый безопасный вариант. Про SSH поговорим в другой раз. Вренемся к FTP.</p>

<h1 id="история-и-безопасность">История и Безопасность</h1>

<p>Давайте честно. Это старинная штука. Изначально FTP проткол определили в <a href="https://datatracker.ietf.org/doc/html/rfc114">RFC 114</a>, написанной Абхаё Бхушан (тогда ещё студент MIT) 16 апреля 71 года!! А это, на минуточку, раньше чем TCP и IP! Тогда ещё не было интернета, каким мы его знаем сейчас, а был ARPANET. Собственно в этой RFC и описывается идея предачи файлов в арпанете.</p>

<p>В последствии FTP разумеется переопределяли по мере эволюции интернета. 
Дружба с TCP/IP описана в <a href="https://datatracker.ietf.org/doc/html/rfc765">RFC 765</a> в 1980 году Джоном Постелом (АйТи Университет Калифорнии), пять лет спустя в <a href="https://www.ietf.org/rfc/rfc959.txt">RFC 959</a> добавили новые возможности управления протоколом, попытались обезопасить протокол только в 1997 году в <a href="https://datatracker.ietf.org/doc/html/rfc2228">RFC 2228</a>, и ещё через два года завезли поддержку IPv6 в  <a href="https://datatracker.ietf.org/doc/html/rfc2428">RFC 2428</a>.</p>

<p>По дефолту FTP вообще не шифруте трафик, и сниффить пакеты может кто угодно посередине. Это никуда не годится, собственно так и появились варианты FTPS и FTPES с поддержкой, соответственно, неявного и явного TLS соединения.</p>

<p>Но не смотря на все улучшения и попытки внедрить безопасность, протокол FPT всё ещё уязвим к брутфорс атакам на креды пользователей и к DOS.</p>

<h1 id="недостатки-ftp">Недостатки FTP</h1>

<p>На самом деле протокол использует два порта. 21 для командного канала и 20 для передачи данных. А ещё этот активный и пассивный режимы… Протокол сложно “резать” на сетевом экране. HTTP в этом моменте намного проще.</p>

<p>Понятие кодировки отсутствует. Если кодировки сервера и клиента отличаются, то скачав файл(ы) и имена и содержимое придется перекодировать. В HTTP такой проблемы нет, так как имеем метаданный в заголовках, где указан и тип файла, и кодировка передачи.</p>

<p>Отсутствие шифрования по умолчанию. Пусть оно и есть в модификациях, но как думаете, сколько на сервере администраторов которые ставят первый попавшийся под руку сервер и не заморачиваются по безопасности…?</p>

<h1 id="резюме">Резюме</h1>
<p>Но не смотря на всё это… Оно ещё живое, и умирать похоже не планирует.
Лично я FTP не использую, а при необходимости реализовать передачу данных смотрел бы в сторону других решений. По моему “умолчанию”, это это был бы на вскидку какой нибудь rsync по ssh или тупо scp.</p>

<p>Но знать про FTP и уметь им пользоваться нужно! Только, пожалуйста, настраивайте хотя бы FTPS сервера…)</p>

<p>Миру мир! Будьте здоровы!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Если вы ищете быстрый и простой способ отправлять и получать файлы с друзьями, семьей или коллегами по работе, возможно вам следует знать о FTP.]]></summary></entry><entry xml:lang="ru"><title type="html">HTTP протокол</title><link href="http://localhost:4000/2022/05/22/HTTP.html" rel="alternate" type="text/html" title="HTTP протокол" /><published>2022-05-22T00:00:00+03:00</published><updated>2022-05-22T00:00:00+03:00</updated><id>http://localhost:4000/2022/05/22/HTTP</id><content type="html" xml:base="http://localhost:4000/2022/05/22/HTTP.html"><![CDATA[<p>Небольшой разбор повсеместно используемого протокола.</p>

<!--more-->

<h2 id="интро">Интро</h2>

<p>Всем привет! В далекой далекой галлактике однажды гумноиды придумали компьютеры, а потом придумали их вместе связывать. Задачка была не из легких, и много подумав гуманоиды разработали спецификацию — концептуальную сетевую модель, или стандарт, посредством которого компьютеры общаются между собой (к этой истории мы вернемся в другой раз).</p>

<p>А потом подумали ещё, поняли что слишком много выдумали, и отразили идеи в более прикладном и жизнеспособном виде.</p>

<p>Модели OSI и TCP/IP не являются темой этого поста. Сегодня я предлагаю разобрать нечто с их “дальнего конца”, наиболее близкого к нам — один из протоколов прикладного уровня, а именно HTTP.</p>

<h2 id="в-начале-был-текст">В начале был текст</h2>

<p>А потом появился <em>Гипертекст</em>. В нашей тусовке этим термином назвали текст размеченный с помощью собственно HTML.</p>

<p>За аббревиатурой HTML стоит —  HyperText Markup Language, переводить надеюсь не надо :)</p>

<p>Все замечательные (и не очень) странички которые вы видите в своих браузерах серфя интернет размечены HTML. Но понятно что соверменные системы не ограничиваются обменом текстовыми документами, за всем этим стоит какой то бекенд, логика, и прочие прелести.</p>

<p>Как происходит обмен данными между вашим компьютером, и другим, далеким-далеким сервером?</p>

<p>С помощью протокола HTTP!</p>

<p>Изначально задачей протокола являлось как раз получение текстовых страничек, но времена меняются, с 1990 года воды утекло много и сейчас по HTTP можно передавать практически всё, вплоть до потокового видео и аудио.</p>

<h3 id="чего-там-внутри-то">Чего там внутри-то</h3>

<p>Клиент-серверная архитектура, это такая “модель” взаимодествия вычислительных систем, в которой задачи распределяются некоторым образом между клиентам и серверами. Клиенты — это, например, опять-же ваш браузер или приложенька, а сервер — это некоторая сущность которая выполняет хотелки клиента.</p>

<p>Почему я говорю сущность? Потому что клиент и сервер это не какие то особенные железяки, а просто <em>софт</em> работающий друг с другом по сети. И общий язык этот софт находит как раз благодаря спецификациям сетевых протоколов.</p>

<p>В HTTP всё крутится вокруг <em>запросов</em> и <em>ответов</em>. Это предельно просто. Клиент Вася попросил (сделал запрос) Сервер Петю почистить картошку, на что от Пети следует какая-то реакция, в зависимости от обстоятельств.</p>

<p>Реакция Пети — это ответ. И их с Васей вазимодействие регламентировано протоколом (на самом деле не одним).</p>

<p>Сеть устроена сложно, и между Петей и Васей может, и обычно присутствует, множество роутеров, прокси-серверов, и прочей чертовщины о которой мы будем говорить позже.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Это кстати небольшой спойлер! Я скоро начну достаточно плотно изучать сети, и обо всем буду писать в блог!
</code></pre></div></div>

<h3 id="хочу-банан">Хочу банан!</h3>

<p>Целью любого запроса всегда является какой-то <em>ресурс</em>. Как мы уже выяснили выше, по HTTP может передаваться что угодно. Более умным языком это можно выразить как то, что протокол HTTP никак не ограничивает <em>ресурсы</em> которые могут запрашиваться и передаваться, а лишь определяет <em>интерфейс</em> для взаимодействия с ресурсами.</p>

<p>Каждый ресурс, хотелка клиента, должна иметь какой-то идентификатор. Этим идентификатором является <em>URI</em> — Uniform Resource Identifier. URI — это по сути символьная строка. Здесь тоже есть много интересных (или не очень) подробностей, но по сути URI это всем нам привычный URL (Uniform Resource Locator) — то что часто называют “ссылкой”, и представяется в браузере в адресной строке как как-то последовательность разделенная слэшами.</p>

<p>Ну, короче, это адрес ресурса!</p>

<h3 id="структура-сообщений">Структура сообщений</h3>

<p>Начнем с запросов.</p>

<p>В структуру запросов входят следующие метаданные:</p>

<ul>
  <li>HTTP-метод: этот элемент декларирует хотелку клиента. Есть несколько методов запроса, но чаще всего клиент хочет либо что-то получить <strong>GET</strong>, либо передать какие-то значения — <strong>POST</strong>;</li>
  <li>Адрес ресурса: URL, который мы уже разобрали;</li>
  <li>Версия протокола;</li>
  <li>Заголовки (Headrs): могут быть, а могут не быть. <del>Вот в чем вопрос.</del> Задача заголовка — передать дополнительную информацию серверу, которая может ему понадобиться для корректной обработки запроса;</li>
  <li>Тело запроса: это нужно в первую очередь для POST запрсов, чтобы передать то, что клиент собственно хочет передать.</li>
</ul>

<p>Ответы же состоят из:</p>
<ul>
  <li>Версии протокола;</li>
  <li>Кода состояния: есть список кодов, которые говорят об успешности или не успешности операции, и могут подсказать или достаточно четко дать понять что пошло не так. Например знакомый 404 — ресурс не найден, или 200 — который вы никогда не замечаете, потому что 200 это ОК.</li>
</ul>

<h2 id="краткий-обзор-отличий-версий">Краткий обзор отличий версий</h2>

<p>В 2015 году на смену HTTP/1.1 пришел HTTP/2 который родился как результат обмозговывания путей оптимизации скорости обработки запросов, в первую очередь при работе с мобильными клиентами и аудио\видео форматами.</p>

<p>Основным отличием является то, что HTTP/1.1 сообщения передает втупую плейнтекстом, тогда как HTTP/2 кодирует их в двоичный формат, благодаря чему открывается возможность использовать другую модель доставки сообщений. Семантика “внутри” осталась прежней.</p>

<p>Для чего кодировать в двоичный формат? Это позволяет разбить сообщения на более мелкие пакеты, которые ещё называют кадрами. А ещё это позволяет использовать <em>одно</em> TCP соединение, вместо нескольких.</p>

<p>Несколько соединений HTTP/1.1 приходится устанавливать для того чтобы обходить блокировку HOL.</p>

<p>Блокировка Head-of-line — это такая фигня, когда очередь из пакетов задерживается первым поступающим пакетом. Так получается когда несколько запросов оправляются на один и тот же ресурс. Пакеты просто не могут проходить друг через друга.</p>

<p>Ну вот, а в HTTP/2 есть один поток, и сами сообщения закодированны. Каждый кадр имеет идентификацию принадлежности к пакету, поэтому ничего не путается. Сервер у себя спокойно принимает сообщения, собирает их обратно. И хотя устанавливается одно TCP соединения, сообщения могут спокойно долетать до сервера параллельно друг другу.</p>

<p>А ещё HTTP/2 сжимает заголовки. Сами данные, можно сжимать и в HTTP/1.1, но не заголовки. И хотя заголовок очень мал, но если клиент или клиенты шлют огромное кол-во запросов — это может стать проблемой. Как видим, HTTP/2 решает её довольно изящно.</p>

<p>Другие отличия HTTP/2 потребуют углубиться в сетевую модель, вернемся к этому может быть в другой раз :)</p>

<h3 id="что-там-про-поток">Что там про поток?</h3>

<p>Клиент-серверное взаимодествие выглядит как-то так:</p>

<ol>
  <li>Открываем TCP соединение. Одно или несколько. Разумеется, уже открытое соединение может использоваться и переиспользоваться далее, не нужно открывать новое соединение для каждого запроса.</li>
  <li>Отправляем сообщение (или сообщения).</li>
  <li>Читаем ответ сервера.</li>
  <li>Закрываем соединение или используем его снова.</li>
</ol>

<p>Ну, тут собственно больше говорить не о чем :)</p>

<h2 id="ещё-немного">Ещё немного</h2>

<h3 id="печеньки">Печеньки!</h3>
<p>Можно устанавливать <em>сессии</em>. Это достигается путем использования кукисов! Зачем нужны куки?</p>

<p>Прикол в том, что HTTP — это протокол <em>без состояния</em>. Это значит что каждый запрос независим, никак не связан с предыдущим. Мы это уже хорошо рассмотрели — всё общение построенно на парах запрос-ответ.</p>

<p>Но ведь… Состояния нужны! Мы не хотим каждый раз логиниться, и не хотим чтобы при обновлении страницы пропала вся наша бережно скирдованная корзина товаров в интернет магазине :)</p>

<p>Тут и выходят на сцену печеньки-кукисы.</p>

<p>Куки — это такой хитрый фрагмент данных, который сервер отправляет клиенту, и клиент у себя его сохраняет. Потом клиент эту куку шлет серверу в составе других HTTP запросов. Так Петя понимает, что хочет Вася, а что хочет Саша, и что Вася есть Вася, а не Катя.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Хотя мне очень хочется тут распылиться на тему безопасности, но скажу лишь то, что куку легко украсть и подменить, если поток данных между клиентом и сервером не зашифрован. TLS — отдельная тема к которой мы *обязательно* вернемся в другой раз.
</code></pre></div></div>

<h3 id="аутентификация">Аутентификация</h3>

<p>HTTP может без всяких других штук предоставлять средства базовой аутентификации, но это не очень безопасно, и обычно специальные сессии устанавливаются с помощью куки.</p>

<h3 id="кеш">Кеш!</h3>

<p>Сервер может с помощью специальных заголовков заставлять промежуточные прокси сервера кешировать какие-то данные, и как долго их надо сохранять.
Клиент в свою очередь может схожим образом “просить” прокси игнорировать кеш, и передавать запрос на требуемые ресурсы далее.</p>

<h2 id="резюме">Резюме</h2>

<p>Мы завершаем краткий обзор протокола HTTP. Краткий, потому что там есть <em>много чего ещё</em>: можно очень долго перечислять все коды ответов, углубиться в то, как происходит сжатие, кеширование. Что такое REST, какие используются кодировк и так далее.</p>

<p>Если вам интересно умудриться то первымы местами, куда стоит обратиться, это RFC документы, в частности под номером <strong>7231</strong> и MDN доку.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Небольшой разбор повсеместно используемого протокола.]]></summary></entry><entry xml:lang="ru"><title type="html">Версионный контроль и непрерывная DevOps’ятина</title><link href="http://localhost:4000/2022/04/24/version_control_and_cicd.html" rel="alternate" type="text/html" title="Версионный контроль и непрерывная DevOps’ятина" /><published>2022-04-24T00:00:00+03:00</published><updated>2022-04-24T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/24/version_control_and_cicd</id><content type="html" xml:base="http://localhost:4000/2022/04/24/version_control_and_cicd.html"><![CDATA[<p>Как сделать свою жизнь проще. Пост про git и DevOps.
<!--more--></p>

<p>Первая попытка написать про git провалилась. Была она почти на самом старте блога, и пост просто “не пошел”. Вторая попытка закончилась тем, что я <del>забыл выпить свои таблетки</del> ударился в философию набредовав несколько нечитаемых абзацев <a href="/2022/04/03/laziness.html">тут</a>.</p>

<p>Вообще там было несколько мыслей, одна из который о том, что <em>время самый главый ресурс</em> или один из них. Прежде чем я вернусь к этой арке, давайте поговорим про версионный контроль.</p>

<h2 id="помогите-смержить-dev">Помогите смержить dev</h2>

<p>Если вы разработчик или инженер, который хоть каким-то боком заходит в редактор кода, и при этом не используете инструменты версионного контроля — у меня для вас плохие новости. Вас либо не существует, либо вы 2 дня в индустрии, либо чекисты закрыли вас в бункере в 83 году и вы до сих пор в нем сидите и паяете какую нибудь Нафаню.</p>

<p>Ладно, отставим дешевый троллинг.</p>

<p>Люди пишут программы. А ещё люди постоянно ошибаются. И в программах, и по жизни вообще. Раньше код резервиловали копировав его на несколько носителей, ну, дискетка там, и так далее. Это всё равно не надежная история, и сейчас как для резервирования кода, его версионирования, и других полезных штук используются специальные инструменты. Например <a href="https://git-scm.com/">git</a>.</p>

<p>Я не хочу писать о других системах версионного контроля по двум причинам.
Во-первых, я в принципе ламер и с другими системами не работал.
Во-вторых, давайте признаемся честно — git является де-факто стандартным инструментом, его использует все и повсюду.</p>

<h3 id="я-в-бункере-что-такое-git">Я в бункере, что такое git?</h3>

<p>Очень краткая история появления git:</p>
<ul>
  <li>Линус Торвальдс родился;</li>
  <li>Линус Торвальдс чуть-чуть вырос и написал ядро linux;</li>
  <li>Линус Торвальдс показал его людям, и людям linux понравился;</li>
  <li>Всё больше и больше людей стали учавствовать в разработке linux;</li>
  <li>Пригорело из за проблем, связанных с пунктом выше (сложно вместе разрабатывать одно и то же! Вася наклепал фичу А, Петя Б, например в том же контексте или модуле, и че делать, как дружить их код?);</li>
  <li>В 2005 году Линус релизнул git и всем стало жить проще.</li>
</ul>

<p>Git представляет рапределенную систему контроля версий. Что это значит? Есть не абстрактный <em>репозиторий</em> — это некоторая совокупность файлов с кодом, которые представляют конкретный проект. Есть его центральная “версия” на git-сервере, где собственно и лежит этот весь код.</p>

<p>Распределенность заключается в том, что любой разработчик у которого есть доступ к репозиторию может стянуть себе локальную <strong>полную</strong> копию репозитория, <em>вместе с историей измнений</em> и так далее.</p>

<p>В этом и заключается смысл распределенности, где ключевое отличие от централизованных систем, в том что в них история и все потроха хранятся в одном месте, а разработчики забирают себе лишь код, грубо говоря.</p>

<p>Таким образом, вся эта история про инструмент, который значительно облегчает совместную разработку какого либо проекта, и представляет ряд полезных фич, таких как само версионирование состояний файлов в репозитории (история измнений).</p>

<p>Git штука сложная, мозговитая, чтобы полностью с ней разобраться потребуется убить достаточно времени. Но это стоит того. Пугаться не надо, начать работать с гитом можно практически с нахрапу освоив ключевые команды и возможности.</p>

<h3 id="базовые-понятия">Базовые понятия</h3>

<p>С репозиторием мы уже разобрались. Как выглядит работа с git?</p>

<p>Во-первых, львиную долю в популярность git’а внесла такая штука как GitHub. Гитхаб — это грубо говоря гит-хостинг. Не нужно устанавливать и поддерживать свой собственный сервер git, мы можем зарегистрировать аккаунт, создать репозитории и начать пользоваться всеми прелестями версионного контроля.</p>

<h5 id="ветки-те-что-branches">Ветки, те что branches.</h5>

<p>Это возможность создавать копии-ответвления от основной ветки (которая всегда называлась master, пока не полубредовая <a href="https://xakep.ru/2020/06/16/master-slave/">история с BLM</a>).</p>

<p>Ветки могут показаться сложной штукой, но на деле ничего сложного тут нет. Представьте себе обычную девовидную структуру. Есть мастер будет стволом дерева, “основной веткой”, из которого выростают другие ветви. Другие ветви в момент выростания являются по сути копией кодовой базы из мастера.</p>

<p>Никто не запрещает из этих веток отщеплять другие, но делать так не надо.</p>

<p>Теперь немног наркомании. Представьте что отросшие из ствола ветки чуть выше вростают в ствол обратно. Эээм… чего?</p>

<p>Зачем вообще отщеплять ветки?</p>

<h5 id="git-flow-йо-мержим">git-flow, йо, мержим!</h5>

<p>git-flow, GitHub flow, и прочие git бла-бла-бла flow это эффективные, полезные (часто и не очень) методики работы с гитом. В частности с ветвлением.</p>

<p>Вспомним что git это в первую очередь для совместного ведения разработки. Чисто теоретически команда может работать в одной ветке, сразу в мастере, пихать туда каждый свои измнения и постоянно решать конфликты, но так никто (надеюсь) не делает.</p>

<p>Нужно предерживаться хорошего стиля и здравого смысла в цикле разработки. Базовых правил.</p>

<p>Во-первых, в мастере всегда должен быть рабочий код, и мастер должен быть чистым. Для внесения каких-либо измнений мы и делаем форки. Пилими фичи, что-то исправляем, и так далее.</p>

<p>Так вот вышеупомянутое врастание обратно в “ствол” есть слияние, или merge веток.</p>

<p>Обычно, хорошим flow считается иметь несколько основных веток: master, staging, develop.</p>

<p>Staging и develop, как правило, являются форками из мастера. В develop, как не сложно догадаться, идет разработка, когда состояние допиливается до какого то рабочего вида, и его нужно протестить на схожем с прод-окружении рантайме — develop сливают в staging, проверяют всё что хотят, убеждаются что оно правда работает и сливают staging в master.</p>

<p>Как я уже сказал, это вообще не табу. Есть другая хорошая практика которой стоит придерживаться. Для каждой отдельной фичи и изменения разработчик делает форк (сделать форк, это на нашем новоязе сиречь отбранчевать ветку), пилит в новой ветке свои измнения, и сливает в изначальную ветку.</p>

<p>Обычно схема получается смешанная. Разработчики форкают фича-ветки из develop, мержат в него свои феноменальные решения, пока develop не сбилдится и не поедет :), а дальше по первому шаблону.</p>

<p>Но что делать если на стейдже все работало, слили в мастер, и прод упал! Ололо!</p>

<h5 id="спокойно-у-меня-всё-осталось">Спокойно, у меня всё осталось</h5>

<p>Вот она, основная прелесть версионного контроля! Барабанная дробь… Версии!</p>

<p>Git отслеживает все измнения файлов и хранит их в своей истории. Все эти измнения можно посмотреть в логе репозитория. И откатиться на предыдущие состояния! Мы никогда ничего не теряем.</p>

<p>Есть продвинутые штуки, которые можно проворачивать с историей. Пока вы не удалили ветку — git будет хранить всю историю её измненей. Вам ничего не мешает вытащить из мастера изначальную версию на момент форка рабочей ветки, или любую другую версию, если вы её, например безвозвратно потеряли или поломали так что не хотите копаться в истории измнений этого файла в текущей, рабочей ветке.</p>

<h5 id="эй-вася-чекаут-делал">Эй, вася, чекаут делал?</h5>

<p>Каждая локальная копия репозитория связанна с “центральным” репозиторием, который называется origin. Если мы неделю назад его склонировали, что-то изменили, значит ли что за прошедшую неделю больше никто ничего там не изменил? Конечно нет.</p>

<p>Возвращаясь к работе снова и снова нужно всегда, прежде чем приступать к каким то измнениям, подтянуть свежую версию ветки, или всех нужных веток. 
В git это называется pull — выгрузить origin в локальную копию репозитория.</p>

<h5 id="я-все-сделал-катим-в-прод">Я все сделал, катим в прод!</h5>

<p>Обратная pull операция — push, которая обозначет выгрузку локального репозитория в origin. Впрочем пуш служит не только для выгрузки измнений в ветке. Вы могли локально сделать форки каких то веток, из мы “пихаем” в origin тем же пушем.</p>

<h5 id="всё-слишком-радужно-где-подвох">Всё слишком радужно, где подвох?</h5>

<p>Да, подвох есть. И этот подвох — конфликты. Скажу честно, даже в моей работе, учитывая что я всё ещё не ололо-мега-сеньор-разработчик в команде из 140 человек, конфликты мерджей бывают той ещё болью в заднице.</p>

<p>Как возникают конфликты? Ну, например, в репозитории могли вести <strong>очень корявый flow</strong>, давно не мержить dev в staging. А при этом, параллельно ещё и в staging что то меняли на протяжении целого месяца. И вот у вас возникла ситуация когда надо донести всё в master, да при этом сначала из dev в stage.</p>

<p>В такой момент просто хочется убить причастных к такому флоу товарищей.</p>

<p>Но по простому, что такое конфликт? Если из моих перлов выше непонятно, то конфликт возникает тогда, когда у нас есть изменения одних и тех же участков (строк) в файлах, которые мы пытаемся слить. Как бы не хотелось, git и вычислительная техника не настолько умны чтобы понять какой код правильный, о чем и будет сообщено в ошибках при попытке слияния.</p>

<p>Всех этих проблем можно избежать следуя чистому, хорошему flow в репозитории. Помимо этого, очень важно называть ветки адекватно, и писать информативные и коротки commit мессаджи.</p>

<p>А ещё важнее: <strong>коммитить как можно чаще, и как можно более мелкие измненеия в коде</strong>. Не каждое измнение строки, но каждое маленькое, осмысленное и обособленное само в себе измнение-фичу.</p>

<h5 id="упс">Упс</h5>

<p>До меня только что дошло что я не упомянул коммит. Это опять же про то, как работает гит. Очень поверхностно:</p>

<p>Когда мы стянули репозиторий и сделали какое то измнение, или набор измнений (я надеюсь их не много!) их нужно <em>зафиксировать</em> в репозитории.</p>

<p>В git это делается следующим образом. Сначала нужно добавить необходимые для фиксирования файлы, мы можем добавить все или выборочно. Делается это командой git add. После этого, прежде чем пушить измнения в origin нужно сделать commit.</p>

<p>Commit’s — это не что иное как кирпичики самого версионного контроля. Это своего рода снимки или снапшоты состояния, которые хранятся в истории, к ним мы можем откатываться и так далее. Создаются они коммандой git commit -m ‘Я сделал кнопку в админке’.</p>

<p>У каждого комита есть свой уникальный идентификатор — хэш, который мы можем найти в истории.</p>

<h2 id="goto-введение">Goto введение</h2>

<p>Я обещал вернуться к словоблудию по поводу времени. В общем этот тред больше про DevOps.</p>

<p>Давайте ещё раз подумаем, вспомним про время. Почему время так ценно? Ну кроме того что мы все умрем.</p>

<p>Вермя — деньги. Это правда. IT — это бизнес. Это тоже, как правило, почти всегда правда. Бизнес делает деньги. Иначе что это за бизнес?</p>

<p>И ещё одно — дедлайны <strong>всегда</strong> горят. Клиент, директор, Вася Пупкин с фриланс биржи, кто бы то ни был, если он руководит вами и дает вам работу, очень часто хочет чтобы продукт был готов как можно быстрее, фича была готова как можно быстрее. Спринт был закрыт всегда воворемя и цикл разработки работал как часы.</p>

<p>Здесь можно отступить в тему методолгий разработки, но это кроличья нора, которая заслуживает отдельного поста и я в этом вообще не очень компетентен на данный момент.</p>

<h3 id="ребят-а-что-мы-тут-вообще-делаем">Ребят а что мы тут вообще делаем?</h3>

<p>Кто нибудь знает что вообще такое DevOps. Одни говорят одно, другие про козу. А HR’s вообще ищут devops-инженероа. Чего?…</p>

<p>Кто-то скажет что devops обязательно должен уметь рулить кубернетисом, кто-то, что если devops не компилировал linux и вообще не гуру сисадмин, то никакой он не девопс. Иные будут бить себя кулаками в грудь, доказывая что девопс должен помогать их разработчикам дебажить говнокод на php, и так далее.</p>

<p>Во-первых, devops никому ничего не должен. Потому что devops — это набор практик, или ещё точнее — философия. DevOps в больше мере вылез из Agile методолгии, и ставит как главную ценность людей как индивиды, так и коллектив. DevOps признан быть некоторого рода интерфейсом между разрабами и админами, которые рулят инфраструктурой, чтобы был мир, дружба, жвачка, бизнес получал свои деньги и фичи вовремя, никто не грызся, дедлайны не горели и вот это вот всё.</p>

<h3 id="ты-в-трудовую-свою-посмотри-клоун">Ты в трудовую свою посмотри, клоун!</h3>

<p>Всё ты врешь! У меня в трудовой написано что я младший devops-инженер, я постоянно всем должен и все меня мучают кучей задач, горят и дедлайны и моя пятая точка.</p>

<p>Ну если что то горит, значит ты не девопс инженер, а обычный админ, которому в скоуп повесили кучу технологий кроме привычной узкой админской специализации, платят тебе на 20к больше, а мучают на все 100 сверху.</p>

<p>Но всё таки, кто же такой devops-инженер, и что он должен уметь?</p>

<p>Это сложный вопрос. DevOps инженер это в первую очередь инфраструктурный инжинер, который должен понимать понемногу во всем, быть и админом и чуть-чуть (или не чуть-чуть) программистом одновременно. Скоуп технологий с которым работает такой инженер разнится, и зависит от компании и инфраструктуры.</p>

<p>Разумеется, что всё таки в первую очередь, и самую главную очередь, такой инженер должен быть хорошим админом, понимать что-то в архитектуре сетей, и быть в курсе всех передовых технологий направленных на эту самую дружбу Dev и Ops — контейнеризация, пупернетисы эти ваши, и… ci-cd инструментарий.</p>

<h3 id="ладно-а-что-такое-ci-cd">Ладно, а что такое ci-cd.</h3>

<p><strong>Никто</strong> не знает что такое continuous integration и continuous delivery. По русски — непрерывная интеграция и непрерывная доставка. Вы можете нагуглить просто тонну инфы про эти штуки, вам там ещё расскажут про непрерывное развёртывание (continuous deployment)… И про прочую девпос чертовщину, софистику.</p>

<p>Можно немного почитать, но не рекомендую убиваться в эту дичь, потому что… это по большому счету пустая трата <strong>времени</strong>. Лучше пойти выучить что-то новое из прикладных навыков, и стать эффективнее в том же “dev” или “ops”, или “devops” %)</p>

<p>Во всех этих трех… тысячах терминов чаще всего встречается одно и то же слово — continuous, <em>непрерывный</em>. И это, наверное, самое главное что нужно хорошо понять.</p>

<p>Это снова про методологию, про непрерывную методолгию разработки, сборки, доставки артефактов сборки в инфраструктуру, разворачиванию этих артефактов и так далее. Без горений, четко как часики…</p>

<p><em><strong>Автоматически</strong> настолько, насолько это возможно</em>.</p>

<p>Кто-то, наверняка начитавшийся того-самого, может спорить, но devops это правда во многом, если не в первую очередь, про автоматизацию.</p>

<p>В частности поэтому в вакансиях часто можно увидеть ansible, puppet, chef и вот это всё.</p>

<p>Потому что правильная, качественная, короче — рабочая автоматизация это прагматично с любой точки зрения, и разумеется с точки экономии времени, ресурсов.</p>

<p>В частности, там где по настоящему есть и практикуется devops можно найти много общего с воплощением так называемого “Бережливого производство” или Lean.</p>

<p>Lean это такая менежментская концепция предприятия, ноги которой растут из Тойотовской операционной модели — “The Toyota Way”, которая направленна, простыми словами, на повышление эффективности предприятия в целом, путем <em>устранения утечек ресурсов</em>.</p>

<p>И устранение это очень человеческое, мудрое. Устранение проивзодственных утечек ведет к устранению утечек времени, которое тратится на починку косяков. А правильно, эффективно работающий конвейер (pipeline) работает без узких горлышек (bottleneck), что тоже ведет к сохранению ресурсов, времени, и вообще общему счастью :)</p>

<p>Рекомендую посмотереть обе части интервью с Полом Экерсом, который очень четко и правильно внедрил этот самый Lean в своем производстве.
Вот ссылка на первую часть -&gt; <a href="https://www.youtube.com/watch?v=oarLDeAFSj4">тык</a>, вторую найдете в закрепе, если интересно.</p>

<p>Вот и получается, что devops инженер в большей степени не имеет права делать херак-херак и в продакшен, в плане архитектурных решений и конфигурирования пайплайна разработки и развертывания. На самом деле, херак-херак не должен делать никто, и это то к чему должен стремиться DevOps и методологии, которые внедряются и применяются.</p>

<p>DevOps начинается и заканчивается в голове. Этот soft навык у инженера не менее, а иногда и более значим чем почти любой hardskill — уметь видеть костыли и исправлять их, или замечать попытку внедрения костылей разработчиками или другими инженерами, и делать все чтобы этого недопустить или сгладить.</p>

<p>К сожалению, далеко не всегда получается избежать костылей… Но по крайней мере мы должны помнить где эти костыли есть, и фиксить их как только такая возможность будет (появилась новая технология как решения костыля, идея, и так далее).</p>

<h3 id="так-статья-же-про-git-была-изначально">Так статья же про git была изначально?</h3>

<p>Да, git это ещё один фундаментально базовый навык, обязательный для любого devops-инженера. Если узко специализированные админы операционных сетей или баз данных могут спокойно жить и работать ничего не зная про git и связанные технологии, то devops без этого не может никак.</p>

<p>Во-первых, это диктуеся тем что devops инженер часто в той или иной степени имеет доступ к коду, как минимум — общается с разработчиками.
В ситуация когда devops инженер начинает мутировать в SRE-инженера, он может уже во всю кодить сам.</p>

<p>Во-вторых, инструменты, такие как Helm сейчас вяжутся напрямую с репозиториями проектов. Сам по себе helm это всего лишь менеджер пакетов для k8s, который эти самые пакеты описывает как чарты (chart) — набор из yaml манифестов в которых описаны состояния ресурсов для деплоя в кубы.</p>

<p>Но очень крутая методолгия, которую в частности проповедуем мы во Фланте это так называемый <em>гитерминизм</em>. Это игра слов от git и детерминизм. Коротко говоря, смысл гитерминизма в том, чтобы сделать состояние деплоя максимально детерминированным состоянием git репозитория.</p>

<p>Достигая это орекстом каких-то инструментов, один из примеров это gitlab ci-cd + werf (тулза для сборки и деплоя, разрабатываемая во Фланте), работающий с классическими helm чартами.</p>

<p>Другой пример гитерминизм тулзы для деплоя это ArgoCD, который сейчас упорно хайпят — он тоже “смотрит” в скормленную репу, и своими средствами пытается “зеркалировать” её состояние, изменения, в указанный неймспейс кластера k8s. Работает тоже поверх helm.</p>

<p>Helm чарт, плюс файл сборки werf (грубо говоря аналог докерфайла, но там все намного круче и хитрее :), как и gitlab-cicd.yaml хранятся в одном репозитории с кодом приложения, которое из этого репозитория “деплоится”.</p>

<p>Это достаточно глубокая тема, как минимум каждый из инструментов можно рассматривать отдельно, и тут я скорее привожу как пример в контексте важности навыка работы с git для инфраструктурных инженеров.</p>

<h2 id="короче-учите-git">Короче, учите git!</h2>

<p>Я там выше сказал про gitlab. Gitlab, это в общем оупенсорсный (есть энтерпрайз версия) продукт для разворачивания своего гит репозитория… И не только. У Gitlab очень крутая нативная поддержка cicd инструментов, в часотности интеграцию с исполнителями пайплайнов (runners), которые ставятся на отдельный (хотя можно и на тот же сервер), и обрабатывают пайплайны — деплоят манифесты в кубы, разворачивают докер-компоузы, или просто докерфайлы. Ну в общем там можно много ерунды костыльной нагородить, если не захотеть сделать красиво в духе Lean и лучших практик :)</p>

<p>В gitlab много фич, познакомиться с которыми вы можете сами.</p>

<p>Справедливости ради, GitHub, BitBucket и другие git-хостинги тоже имеют свои средства cicd автоматизации, но имхо (и не только) — Gitlab выглядит самым удобным и гибким. А может он просто привычен.</p>

<p>У всех этих систем есть веб интерфейс, через который, в принципе можно пользоваться прелестями git’а, но я настоятельно рекомендую работать с git’ом через cli. Пусть GitLab умеет “умно” по всякому мержить ветки, и решать некоторые простые конфликты… К этому интерфейсу можно привыкнуть и попасть в иллюзию компетентности, которая рано или поздно <strong>обязательно</strong> больно аукнется.</p>

<p>Обязательно случится так что gitlab скажет вам что-то вроде “не могу помержить, помержи локально”. Или “не могу помержить, надо делать ребейз!”
И тут вы такие… А что такое ребейз…</p>

<h2 id="на-десерт">На десерт</h2>

<p>Что такое ребейз и как работать с git вы можете узнать из <em>тонны</em> источников в сети. Это очень поплуярная штука. Просто загуглите. 
С упорством поиска в пару минут вы найдете видео материалы, и интерактивные тренажеры для знакомства с git.</p>

<p>Если вас забанили в гугле, то вот интерактивные тренажеры:</p>

<ul>
  <li><a href="https://www.katacoda.com/courses/git">Вот этот;</a></li>
  <li><a href="https://gitimmersion.com/">Или этот;</a></li>
  <li><a href="https://learngitbranching.js.org/">Тут можно разобраться с ветками;</a></li>
</ul>

<p>Лучше всего почитать документацию-учебник “Pro Git”:</p>
<ul>
  <li><a href="https://git-scm.com/book/en/v2">Вся книга онлайн и беслатно без регистрации и смс</a></li>
</ul>

<p>Там же найдете её на русском, если вдруг надо.
Всех благ, миру мир! 
А я пойду запушу этот пост в GitHub :)</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><summary type="html"><![CDATA[Как сделать свою жизнь проще. Пост про git и DevOps.]]></summary></entry><entry xml:lang="ru"><title type="html">Ещё немного про F#</title><link href="http://localhost:4000/2022/04/17/more_about_f.html" rel="alternate" type="text/html" title="Ещё немного про F#" /><published>2022-04-17T00:00:00+03:00</published><updated>2022-04-17T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/17/more_about_f</id><content type="html" xml:base="http://localhost:4000/2022/04/17/more_about_f.html"><![CDATA[<p>Продолжаем врубаться в функциональное программирование. Пусть и туго :)
<!--more--></p>

<p>Всех и повсюду приветствую! Я продолжаю заниматься по ФП курсу, и (имхо!) пришла пора написать ещё немного про фишки F# (и, наверное, вообще ФП языков ML семейства) и порефлексировать.</p>

<h2 id="перегрузка">Перегрузка</h2>

<p>Перегрузка, это такая реализованная в языке “полиморфная” штука, когда при обращениях к функциям или операторам, которые <em>имеют несколько реализаций для разных типов данных</em> компилятор ведет себя по разному. Сами эти реализации и есть “перегрузки”.</p>

<p>В F# система типов ведет себя следующим образом:</p>
<ul>
  <li>Когда компилятору “понятно” в контексте обращения, что за тип используется — символ оператора интерпретируется как функция для этого типа;</li>
  <li>В противном случае используется <em>перегруженный</em> оператор для <em>подходящего</em> типа по умолчанию.</li>
</ul>

<p>Звучит сложно, но на самом деле тут всё просто. Если какой-то оператор можно применить к целым числам (int), ну значит int и будет считаться <em>типом по умолчанию</em>.</p>

<p>Например у функции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x,y) = x + y 
</code></pre></div></div>

<p>по умолчанию тип будет int -&gt; int. Но что если мы хотим, и заранее знаем, что будем вычислять числа с плавающей точкой? 
Явно указать тип <em>аргумента</em> в F# можно так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x: float, y: float) = x + x
</code></pre></div></div>

<p>Указать явно тип результата функции:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x, y) : float = x + x
</code></pre></div></div>

<p>И, наконец, можно указать явно <em>тип выражения</em>, вычисляемого функцией:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let addition (x, y) = x + x : float
</code></pre></div></div>

<h2 id="нонфиксная-запись">Нонфиксная запись</h2>

<p>Любые инфиксные операторы можно записать нонфиксной записью. Ну, короче, не 1 + 1, а (+) 1 1.</p>

<p>Просто берем оператор в скобки, и следом перечисляем аргументы. Можно представить это как функцию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let mul3 = (*)3
</code></pre></div></div>

<p>Где вызов mul3 2 будет равняться 6. Просто? Просто!</p>

<p>Ну и по сути вызов нонфиксного оператора, который на вход получает один аргумент — функция (хотя тут вообще всё функция, но давайте сохранять трезвость рассудка).</p>

<p>Применение функции работает через <em>левую ассоциацию</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printfn "%b" ((*) 3 2 = ((*)3) 2) // будет true!
</code></pre></div></div>

<p>Ну как там, с трезвостью?</p>

<h2 id="композиция-и-каррирование">Композиция и каррирование</h2>

<p>Так, это уже серьезные спеллы, первый из которых должен быть нам уже знаком (как минимум интуитивно).</p>

<h3 id="композиция">Композиция</h3>

<p>По-простому — это подход, подразумевающий вызов одних функций в качестве аргументов других. Я уже писал про high-order и вот это всё.
По-сложному, математически — композиция двух функций x и y (x o g) будет обозначать:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x o y)(x) = x(y(x)) 
</code></pre></div></div>

<p>И есть x(a) = a + 5, и y(b) = b * 2, тогда</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x o y)(b) = x(y(b)) = x(b * 2) = b * 2 + 5
</code></pre></div></div>

<p style="text-align: center;"><img src="/images/mind_blowing.gif" alt="Взрыв Мозга" /></p>
<p><em><center>Узнали? Согласны?</center></em></p>

<p>Отставить горячку!</p>

<p>В F# вся эта магия реализуется <em>инфиксным</em> оператором « или » у которых оба параметра — функции.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let x = fun a -&gt; a + 5
let y = fun b -&gt; b * 2
let chtoproishodit = x &lt;&lt; y

printfn "%d" (chtoproishodit 5) // посчитает: 5 * 2 + 5 = 15

let ostanovitespojaluista = ((fun y -&gt; y * 20) &lt;&lt; (fun x -&gt; x - 1)) 2 // посчитает: 2 - 1 * 20 = 20 
</code></pre></div></div>

<p>Всё просто же? Как сказано выше, можно передавать функции в другом порядке с помощью »</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let vseyasno = x &gt;&gt; y // vseyasno 3 = y ( x(3) ) = y ( 8 ) = 16  
</code></pre></div></div>

<h3 id="каррирование">Каррирование</h3>

<p>Или — <em>частичное применение функций</em>.</p>

<p>Это когда мы передаем функции <em>неполное число аргументов</em>, и в результате получаем… что? функцию!</p>

<p>Как уже говорилось в предыдущем посте по теме, все функции в F# имеют <strong>только один аргумент</strong>, когда мы кортежем передаем несколько аргументов, это по сути (формально) работает как применение функций одного аргумента ко всем аргументам из списка поочередно.</p>

<p>Вот такая каррированая функция f a будет ждать на вход один параметр b:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let f x = fun b -&gt; b * x 
let mul5 = f 5
</code></pre></div></div>

<p>Понятно, что вызвав mul5 2 получится 10. В F# допускается ещё более краткая запись без fun:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let f x b = b * x 
</code></pre></div></div>

<p>Работать будет точно так же.</p>

<h2 id="нужно-больше-операторов">Нужно больше операторов!</h2>

<p>Тут можно делать свои операторы, а не только функции (сейчас какой-то душный человек вспомнит что оператор тоже функция и пойдет поедет. Я ― помню).</p>

<p>Для определение своих <em>инфиксных</em> операторов нам доступны следующие символы:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>! % &amp; * + - . / &lt; = &gt; ? @ ^ | ~
</code></pre></div></div>

<p>А для <em>префиксных</em> такие последовательности:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+ - +. -. &amp; &amp;&amp; % %% ~ ~~ ~~~ ~~~~
</code></pre></div></div>

<p>Объявление таких операторов нужно делать через скобочную нотацию: (оператор) для инфиксных, и (~оператор), соответственно для префиксных.</p>

<h2 id="операторы-применения-функций">Операторы применения функций</h2>

<p>Есть два таких оператора: “|&gt;” и “&lt;|”, они отправляют значение вправо или влево.</p>

<p>Выражение x |&gt; y и выражение y &lt;| x будут означать одно и то же — “y x”.</p>

<p>Но важный момент в том, что ассоциация этих операторов <strong>левая</strong>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 |&gt; 2 |&gt; (+) 
</code></pre></div></div>

<p>приведет к ошибке, когда:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10 |&gt; (2 |&gt; (+)) 
</code></pre></div></div>

<p>сработает.</p>

<h2 id="ещё-раз-про-кортежи">Ещё раз про кортежи</h2>

<p>Итак, мы знаем что с помощью кортежей мы можем схитрить и передать в функцию больше одного аргумента.</p>

<p>Кортежи могут объединять в себе значения разных типов, это ок. И это потенциально очень мощный инструмент. Рассмотрим несколько фишек.</p>

<h3 id="фишки-первого-уровня">Фишки первого уровня</h3>

<p>Значения типов в кортежах перевариваются в F# как объекты первого класса. Мы можем использовать их в выражениях, и получать как результат других выражений.</p>

<p>Можно использовать в качестве элемента кортежа уже связанное ранее значение:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let a = (10, "hello")
let b = (a, 100.500)
</code></pre></div></div>

<p>Последний кортеж получится типа: ((int * string) * float)</p>

<p>Вычисляются кортежи по порядку слева-направо, и кортежи можно сравнивать, но только если совпадают значения типов их элементов (в том же порядке):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(5 = 2, "hello", 1 + 1) = (false, "hello", 2) // правда!
(5 = 2, "hello", 1 + 1) = ("friend", (10.5, 18)) // парень, не дури, типы не совпали.
</code></pre></div></div>

<p>“Легальное” сравнение (когда с типами всё ок), происходит в лексикографическом порядке:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(29, 14, 100) &gt; 11, 0, 101 // не правда!
</code></pre></div></div>

<h3 id="кортеж-как-шаблон">Кортеж как шаблон</h3>

<p>Мы можем сделать кортеж состоящий только из идентификаторов:
    let (x, y) = (10, 200) // x = 10, y = 200</p>

<p>С помощью чего потенциально можем сопоставлять идентификаторы и значения.</p>

<p>Помните паттерн матчинг? Тут можно так же использовать идентификатор “_” для сопоставления с любыми значениями:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let (_, y) = (1, 2) // y = 2
</code></pre></div></div>

<h3 id="превращение-в-овцу">Превращение в овцу</h3>

<p>Это про полиморфизм, кто не понял :)</p>

<p>Пример полиморфной функции с кортежем — функция swap:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let swap (x, y) = (y, x)
</code></pre></div></div>

<p>Она меняет значения внутри кортежа местами, и типы её параметров полиморфны, то есть определяются другими типами.</p>

<p>Полиморфный тип, это такой тип, операции над которым могут нормально применяться к другим типам.</p>

<p>В F# полиморфным типом выступает базовый тип .NET System.Object, таким образом тип функции swap будет:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>System.Object  * System.Object -&gt; System.Object * System.Object
</code></pre></div></div>

<h2 id="рефлексия">Рефлексия</h2>

<p class="error">Спойлер Алерт!!! Если вы занимаетесь по курсам Сергея Игоревича Бобровского, и не прошли ещё курс по F# — имейте совесть и смелость решить задачки сами. В частности далее будет спойлер к задаче по кастомным операторам 23.4.1.</p>

<p style="text-align: center;"><img src="/images/serious_cat.jpg" alt="Котямба" /></p>
<p><em><center>Я серьезно.</center></em></p>

<p>Задачка следующая:</p>

<p>В фэнтези-РПГ принята следующая денежная система: в одном золотом 20 серебряных, а в одном серебряном 12 медяков. Суммы в такой системе задаются тройками целых чисел (золотые, серебряные, медяки), например (1, 0, 128) или (32, 23, 5).</p>

<p>Реализуйте инфиксный оператор .+. , который складывает деньги, представленные в виде троек, и инфиксный оператор .-. , который вычитает деньги. Результат приводите к формату, когда количество медяков не превышает 11, а количество серебряных не превышает 19.</p>

<p>Посмотрите какую хрень я накодил в первый (ладно, во второй) раз:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let (.+.) x y =
    let (g1, s1, c1) = x
    let (g2, s2, c2) = y
    
    let total_wallet = (g1 + g2, s1 + s2, c1 + c2)
    
    let rec count_coppers = function
    | (g, s, c) when c &lt;= 11 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_coppers (g, s + 1, c - 12)

    let rec count_silvers = function
    | (g, s, c) when s &lt;= 19 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_silvers (g + 1, s - 20, c)

    let copper_converted = count_coppers total_wallet
    let converted_wallet = count_silvers copper_converted
    converted_wallet


let (.-.) x y = 

    let (more, less) = 
        if x &lt; y then
            (y, x)
        else
            (x, y)

    let (g1, s1, c1) = more
    let (g2, s2, c2) = less

    let rec count_coppers = function
    | (g, s, c) when c &lt;= 11 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_coppers (g, s + 1, c - 12)

    let rec count_silvers = function
    | (g, s, c) when s &lt;= 19 -&gt; (g, s, c)
    | (g, s, c) -&gt; count_silvers (g + 1, s - 20, c)

    let bigger_copper_converted = count_coppers more
    let bigger_converted_wallet = count_silvers bigger_copper_converted
    
    let smaller_copper_converted = count_coppers less
    let smaller_converted_wallet = count_silvers smaller_copper_converted

    let (bigger_g, bigger_s, bigger_c) = bigger_converted_wallet
    let (smaller_g, smaller_s, smaller_c) = smaller_converted_wallet
    (bigger_g - smaller_g, bigger_s - smaller_s, bigger_c - smaller_c)
</code></pre></div></div>

<p>Ну, справедливости ради, оно работает и прошло тесты. Но это какая то жесть. Пусть я и попытался применять рекурсию, здесь налицо недопонимание принципов хорошего, ясного программирования. И вообще халатность. Например в реализации оператора .-. не кажется ли вам что DRY не пахнет?</p>

<p>Эталонное решение выглядит следующим образом:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec iter = function
| (a, b, c) when c &gt; 11 -&gt; iter (a, b + (c / 12), c % 12)
| (a, b, c) when b &gt; 19 -&gt; iter (a + (b / 20), b % 20, c)
| (a, b, c) when c &lt; 0 &amp;&amp; b &gt; 0 -&gt; iter (a, b - 1, c + 12)
| (a, b, c) when b &lt; 0 &amp;&amp; a &gt; 0 -&gt; iter (a - 1, b + 20, c)
| (a, b, c) when c &lt; 0 &amp;&amp; a &gt; 0 -&gt; iter (a - 1, b + 19, c + 12)
| (a, b, c) -&gt; (a, b, c)

let (.+.) (a, b, c) (x, y, z) = iter (a + x, b + y, c + z)
let (.-.) (a, b, c) (x, y, z) = iter (a - x, b - y, c - z)
</code></pre></div></div>

<p>Ради той же справедливости попытаюсь оправдаться, что в первом своем нерабочем решении я использовал деление с остатком, но там была какая то императивная дичь с условными операторами, и компилятор ругался матом. Почему я не додумался забабахать рекурсивный паттерн матчинг… Хороший вопрос. Просто посмотрите на эту красоту, насколько это более ясно и коротко может быть выражено в коде. Паттерн матчинг воистину крутая штука!</p>

<p>Век живи — век учись. А дурнем и помрешь!</p>

<p>Слава Алонзо Черчу! Миру Мир! Я пошел.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"><![CDATA[Продолжаем врубаться в функциональное программирование. Пусть и туго :)]]></summary></entry><entry xml:lang="ru"><title type="html">Декомпозиция</title><link href="http://localhost:4000/2022/04/10/decomposition.html" rel="alternate" type="text/html" title="Декомпозиция" /><published>2022-04-10T00:00:00+03:00</published><updated>2022-04-10T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/10/decomposition</id><content type="html" xml:base="http://localhost:4000/2022/04/10/decomposition.html"><![CDATA[<p><em>“Совершенство достигнуто не тогда, когда нечего добавить, а тогда, когда нечего убрать.”</em> — Антуан де Сент-Экзюпери
<!--more--></p>

<h2 id="старый-мастер">Старый мастер</h2>

<p>Помните эту затёртую человечеством до дыр притчу, про старика который поучает сына о важности единства с <del>кентами</del> братьями, давая ему ломать тростинки по одной, а потом вместе связав их в веник? Ну так то оно да, очень мудро. Но касаемо разработки программного обеспечения мейнстрим проповедует микросервисы, ортогональность, уход от высокой связности как в программировании в малом, так и в программировании в большом.</p>

<p>Справедливости ради — декомпозиция это не какое-то новомодное изобретение инженерной мысли 21 века. Напротив, декомпозиция, как и все самые лучшие идеи нашей научной отрасли уже давно изобретены мудрецами прошлого века, на заре всего того, что творится здесь и сейчас. Многие из этих идей до сих пор не воплощены полноценно, многие из них нами, молодыми разработчиками — игнорируются к глубокому изучению и осмыслению. Это печально.</p>

<p>Так что же мы будем делать если веник — это большая задача, и нам его <em>нужно</em> “сломать”? Разумеется, за неимением средств к его сожжению и иной дезинтеграции мы будем тянуть по одной тростинке на последующий излом :) 
Но ломать конечно же ничего не надо, особенно продакшен, особенно в пятницу, бугага :)</p>

<p>Ключевая идея принципа декомпозии в том, что очень обьемные задачи намного сложнее решать, чем мелкие.</p>

<p style="text-align: center;"><img src="/images/very_hard_graph.png" alt="Сложный график" /></p>
<p><em><center>Высокоточный и крайне искусно выполненный, важный график для наглядности понимания</center></em></p>

<h2 id="люк-используй-декомпозицию">Люк, используй декомпозицию!</h2>

<p>Вообще про декомпозицию как способ мышления для решения задачи сформулировал ещё Рене Декарт в своем “Рассуждении о методе”. Нас интересует применение этого инструмента, в первую очередь в своих программистских начинаниях.</p>

<h3 id="о-это-было-в-школе">О, это было в школе!</h3>

<p>Разбивка на части сложной системы, для последующей её реализации в виде подпрограмм, лежит в основе <em>структурного программирования</em>. С развитием идеи декомпозиции этот метод стали называть <em>процедурной декомпозиций</em>, потому что сформировались концепции логической, объектной и других “декомпозиций”.</p>

<p>Метод заключается, примерно в следующем:</p>
<ol>
  <li>Определяем общую структуру программы, если хотите — прототипируем, в виде одного из вариантов:
    <ul>
      <li>Последовательность подзадач (ввод данных, вычисление, вывод, ну вы поняли);</li>
      <li>Условия, или <em>альтернативные</em> подзадачи (тут нечего пояснять, правда?);</li>
      <li>Повторения подзадач (циклы).</li>
    </ul>
  </li>
  <li>Теперь, в определенной структуре нам нужно каждую подзадачу беспощадно и снова разбивать на подзадачи используя структуры из пункта 1. Разбивать до тех пор, пока на минимальном “атомарном” уровне подзадачи не будут из себя представлять простые процедуры, реализуемые несколькими операциями языка программирования.</li>
</ol>

<p>В частном случае <strong>строгой</strong> структурной декомпозиции запрещаются циклы и обратные вызовы подпрограмм. В таком случае иерархия программы становится древовидной без всяких goto петель.</p>

<p>В чем вообще плюс всей этой идеи? Ну, в первую очередь, применяя структурное программирование мы минимизируем количество ошибок в работе программы, и более детально разрабатываем алгоритм в целом. У нас просто нет выбора не разобраться что и как тут будет работать, нет выбора напороться на ужасающие и непонятные сайд-эффекты, которые лихорадочно дебажутся до поздней ночи. Хотя… :D</p>

<p>Если школьный курс информатики у вас был такой же как у меня, то вероятно подобные блок схемы это всё, что вы оттуда запомнили:</p>

<p style="text-align: center;"><img src="/images/very_hard_sсheme.png" alt="Сложная схема" /></p>
<p><em><center>Подарите мне графический планшет 😢 </center></em></p>

<h3 id="врубаемся-в-декомпозицию">Врубаемся в декомпозицию</h3>

<p>В низкоуровневых процедурных языках “декомпозиционной единицей” является <em>функция</em> (или процедура) и <em>абстрактные типы данных</em> (ADT). В высокоуровневых языках поддерживаюзих объектно ориентированную парадигму такой единицей является <em>класс</em>.</p>

<p>Чтобы декомпозиция “работала” и вообще имела смысл, подпрограммы выделенные из общей системы должны быть независимы (ортогональны) друг от друга настолько, насколько это возможно. Разумеется, это не значит (в принципе, скорее всего и невозможно) что подпрограммы должны быть полностью независимы. Имеется в виду что они не должны иметь бесмысленных, избыточных связей друг с другом.</p>

<p>Такая независимость особенно важна в проектах, над которым трудится несколько разработчиков. Каждый из нас может работать намного более продуктивно, если сосредоточится в один момент времени на одной задаче полностью, не беспокоясь обо всей остальной части системы.</p>

<p>Конечно, разработчик <em>должен</em> понимать систему и учитывать все ключевые моменты разработки! Тут имеется в виду работа над конкретно решаемой задачей. Если части системы максимально независимы друг от друга, перерабатывая какую-то из существующих частей, или разрабатывая новый модуль программист может сосредоточиться на решении своей задачи, если интерфейс взаимодействия с другими модулями понятен, унифицирован, и нет никаких подводных камней, сайд-эффектов.</p>

<p>Может показаться что декомпозиция не имеет особого смысла в программе из тысячи или менее строк кода. Но на самом деле это не так. Намного продуктивнее развить в себе привычку декомпозировать код даже в таких маленьких системках, потому что этот навык невозможно переоценить и он обязательно даст плоды при разработке систем на 100 тысяч и более строк кода.</p>

<h2 id="сектор-приз-на-барабане">Сектор приз на барабане</h2>

<p>Правильно декомпозированную процедуру или класс часто сравнивают с “черным ящиком”. Что это значит?</p>

<p>Имеется в виду то, что внутрнее устройство, работа этого черного ящика <em>неочевидна</em>. Такой ящик <em>определяется тем что он делает</em>.</p>

<p><strong>Флешбек:</strong>
Если вы читали предыдущии мои посты, а именно цикл по изучению Декларативной модели, мы там разбирали абстрактные типы данных. Напомню — абстрактный тип, это такая струтура данных, которая описана исключительно посредством операций над этой структурой. Смекаете?</p>

<p><em>Внутренняя реализация АТД неочевидна, она может меняться на лету, в любой момент времени, без влияния на остальную систему, если изменения полностью соответствуют определению типа!</em></p>

<hr />

<p>Так вот, черный ящик имеет четко определенное поведение с точки зрения ввода данных в него, представляет собой максимально простую абстракцию (в контексте задачи) для описания того, <em>что будет получено на выходе</em>, а реализация… реализация <em>безопасно</em> скрыта внутри!</p>

<p>Черный ящик можно обозвать <em>“единицей делигировани”</em>, мы просто говорим ему <em>чего мы хотим</em> (продолжаем лоавить декларативные флешбеки). Например — я хочу воткнуть запись в стек, я хочу узнать что наверху стека, я хочу вытолкнуть запись из стека, и так далее.</p>

<p>Как уже было сказано, ключевая цель декомпозиции — разделение задачи на независимые подзадачи. И идея черных ящиков это естественное, логическое продолжение этой цели. Большинство таких ящиком могут быть описаны как независимые, или полностью независимые струкруты.</p>

<p>Любые взаимодействия между черными ящиками при необходимости могут быть описаны четко определенными и простыми программистскими механизмами.</p>

<h2 id="абстракция">Абстракция</h2>

<p>На самом деле декомпозиция, это не что иное как пример применения стратегии <em>“разделяй и влавствуй”</em>. 
Самое главное преимущество, повторюсь, заключается в том что работать с модулями (ящиками) можно независимо друг от друга.</p>

<p>Снаружи все модули просты и понятны, поэтому мы можем легко понять как и где их использовать, как их сочетать.</p>

<p>Но это хорошо работает только в том случае, если <em>асбтракция</em>, которую представляет собой черный ящик <em>имет какой то фундаментальный смысл</em>. Между входными и выходными данными должна быть понятная, четкая связь.</p>

<p>Как правило, почти всегда есть ряд сложностей и тонкостей в реализации программы, <em>которые <strong>не должны</strong> быть частью реализации асбтракции</em>.</p>

<p>Фишка в том, что “ящик” должен в качестве входны данных требовать <em>только то что ему нужно для вычисления этих данных</em>.</p>

<p>Понять правильно ли описана абстракция на самом деле достаточно просто. Первый, и самый главный критерий:</p>

<p class="info">Легко ли описать своими словами то, что данный компонент делает?</p>

<p>Для функции хорошим признаком будет ситуация, в которой в формируемом описании её поведения имя функции будет глаголом, а параметры (аргументы) — существительными.</p>

<h2 id="хорошие-функции">Хорошие функции</h2>

<p>Так что же все таки должно быть параметрами функции? Как понять, что подзадача достаточно сложна и независима для того, чтобы быть “достойной” выделния её в отдельную функцию?</p>

<p>Зарубим себе на носу:</p>

<p class="info">Функция должна решать <strong>одну конкретную задачу</strong>. Её аргументы должны включать в себя <strong>только то, что необходимо</strong>. Абстракция того, что функция выполняет со своими аргументами, <strong>должна иметь смысл</strong>.</p>

<h3 id="одна-задача">Одна задача!</h3>

<p>Это не значит что функция должна состоять из одной строки кода с несколькими операторами. Код в функции должен решать эту одну задачу. Занимаясь рефакторингом, просматривая код снова и снова, в какой-то момент мы обязательно сможем выделить часть кода, которая достойна стать подпрограммой.</p>

<h3 id="длинна-функции">Длинна функции</h3>

<p>Длинна функции это хрень. Это очень упрощенная мера, которая не выдерживает критики с точки зрения анализа структуры задачи. Конечно функция может оказаться длинной из за того что она решает несколько задач. Части такой функции можно и нужно декомпозировать.</p>

<p>Но функция может всё ещё решать одну задачу и быть “вынужденно” длинной, просто потому что вычисления для задачи, решаемой функций, могут быть достаточно объемны. Эти вычисления не могут выполняться независимо друг от друга, части этих вычислений не могут или “не заслуживаю” быть выделенными в отдельную функцию.</p>

<p>Или могут и заслуживают?… Это очень важный момент. Здоровенная функция <strong>автоматически должна вызывать подозрения</strong> о качестве её декомозиции. Перечитайте её, действительно ли алгоритм написан грамотно и ничего нельзя разложить?</p>

<p>Это очень условно, но в идеале функция должна иметь от 5 до 25 строк.</p>

<h3 id="короткие-процедуры">Короткие процедуры</h3>

<p>Может показаться, что 2 строчки кода не имеет смысла выделять в отдельную функцию. А вот и нет, ещё как имеет. 
Например у вас может быть какая-то сложная строка, которая явно “шумит” в коде и лишь отвлекает внимание.</p>

<p>Может статься так, что эта “шумная” строка ещё и вызывает несколько раз, или в разных местах. Если видите такое — смело оборачивате в отдельную функцию. Потом себе спасибо скажете, перечитывая свой код.</p>

<p>Современные компиляторы <strong>умные</strong>, и не стоит беспокоиться о дополнительных накладных расходах вызова такой короткой функции.</p>

<h3 id="аргументы">Аргументы</h3>

<p>Функция должна иметь как можно меньше аргументов, необходимых для решения свой задачи. Если у вас есть функция с 4 аргументами, наверное стоит присмотреться получше.</p>

<p>Фунция не должна накладывать дополнительных ограничений на входные данные, кроме тех, что нужны для её работы. Это упростит использование такой функции в самых разных контекстах позднее в коде.</p>

<p>Конечно, есть ряд случаев когда просто невозможно обойтись без большого количества аргументов. Но повторюсь снова… Это всё таки “красный флаг” для нашего внимания. Если обнаруживается что какой-то набор аргументов всегда, как бы преследует функцию — может стоит упаковать всё это дело в свою структуру (АТД)?</p>

<h3 id="сложность-функции">Сложность функции</h3>

<p>Код, строки кода в функции должны выражать последовательность вычислений, шагов какого-то алгоритма.</p>

<p>Если сложность одного из таких шагов явно отвлекает от решаемой проблемы, “избыточно шумит”, то такой этап вычислений следует декомпозировать -&gt; изолировать!</p>

<p>Следует озадачиться, если какой-то из шагов алгоритма требует нескольких локальных переменных, которые нигде больше не в функции используются.</p>

<p>Детализация всех шагов алгоритма должна быть примерно, или лучше на “одном уровне”.</p>

<h3 id="dry">DRY!</h3>

<p>Не стоит повторять более пары строк кода. А если пара слишком часто повторяется и выглядит сложно см. пункт про короткие процедуры.</p>

<p>Такие повторяющеся эллементы кода должны быть помещены в собственную функцию, которая затем вызывается там, где раньше был повторяющийся код.</p>

<p>Разумное правило: раскладываем повторяющиеся последовательности, если это сделает программу короче. В общем случае такие последовательности могут и не быть <em>полностью идентичными</em>. Незначительные различия можно учесть в параметрах новой функции.</p>

<p>Если мы обнаруживаем, что копируем и вставляем код — это верный признак того что мы делаем ерунду.</p>

<h3 id="обощай-думая-думалкой">Обощай, думая думалкой</h3>

<p>Подзадача которая представляет собой фундаментальнуя программистскую идиому обязательно должна быть декомпозирована. Речь о всяких сортировках, поисках, пересечениях множеств, etc.</p>

<p>Всё это кандидаты на свои собственные, отличные функции. Такие абстракции всегда просты и понятны, и их реализации можно использовать по необходимости где угодно в программе.</p>

<p>Стандартные библиотеки языков программирования с набором методов — яркий пример того, о чем тут идет речь.</p>

<h3 id="скоуп">Скоуп</h3>

<p>Это важно. Это поможет избежать много боли.</p>

<p class="error">Доступ к любой переменной вне тела функции <strong>всегда должен быть только через параметры этой функции!</strong></p>

<p>В противном случае, о каком черном ящике вообще может идти речь? Нарушающие это правило подпрограммы становятся зависимыми от внешнего кода. Всё сломается, обязательно сломается! Как минимум вы сломаете себе мозг когда будете это дебажить :)</p>

<p>Нелокальный доступ допустим только для констант.</p>

<hr />

<p>На этой позитивной ноте закругляемся. Надеюсь что вам было полезно сие чтиво!</p>

<p style="text-align: center;"><img src="/images/decomposition_meme.jpg" alt="Шуточка" /></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Проектирование" /><summary type="html"><![CDATA[“Совершенство достигнуто не тогда, когда нечего добавить, а тогда, когда нечего убрать.” — Антуан де Сент-Экзюпери]]></summary></entry><entry xml:lang="ru"><title type="html">Лень — двигатель прогресса?</title><link href="http://localhost:4000/2022/04/03/laziness.html" rel="alternate" type="text/html" title="Лень — двигатель прогресса?" /><published>2022-04-03T00:00:00+03:00</published><updated>2022-04-03T00:00:00+03:00</updated><id>http://localhost:4000/2022/04/03/laziness</id><content type="html" xml:base="http://localhost:4000/2022/04/03/laziness.html"><![CDATA[<p>Часики тикают. 
<!--more--></p>

<h2 id="определимся">Определимся</h2>

<p>Даль определяет в своем словаре лень как “отвращение от труда, от дела, занятий; наклонность к праздности, к тунеядству”. И это конечно же откровенная ерунда, в контексте той <em>полезной</em> лени, о которой я хочу поговорить.</p>

<p>С точки зрения биологии лень — это механизм экономии энергии, и наверное, в первую очередь энергии мозга. Разумеется что в наше время, благодаря развитию цивилизации технологически довольно, и к сожалению, популярна именно та лень которую определяет Даль. Это полная жесть и явный непорядок, какой то дисбаланс в наших жизнях, что мы такой лени поддаемся.</p>

<p>Поясню. Я считаю что психологически и физически здоровый, и хоть сколько интеллектуально развитый человек, так сказать — “осведомленный о реальности”, просто не может впадать в апатичное поведение “ничего неделания”, долгой прокрастинации. Но так как это всё же эволюционный механизм, человек как вид стремится сохранять энергию, делать жизнь проще, легче, изобретать, творить и автоматизировать процессы. Давайте поговорим именно об этой “прагматичной лени”.</p>

<h2 id="два-стула">Два стула</h2>

<p>Как за собой, так и за другими людьми я периодически замечаю две крайности: адский трудоголизм и чрезмерное битье баклуш. Любая крайность, не только в данном контексте это, вообще повод остановиться. Подышать минут пять свежим воздухом и попытаться понять что пошло не так.</p>

<p>Чрезмерный трудоголизм это <strong>полная жесть</strong>. Не поймите меня не правильно — вкалывать <em>надо</em>. Вкалывать в какой-то форсмажорный спринт с малым количеством отдыха, вероятно принесет краткосрочную пользу (вспомнили как писали курсовую, диплом? бгг), но в долгосрочной перспективе это прямой путь к подорванному здоровью, глубокой депрессии (вплоть до апатии), состоянию когда руки над клавиатурой поднимаешь через силу. Поверье, я в этом шарю.</p>

<p>Другая крайность — впадение в зону комфорта, когда мы уютно устроились, набили прикладной навык, и сидим бьем баклуши. Мозг прокисает, денежка падает исправно на карту, нам всего как будто бы хватает. Хорошо устроились, что сказать. Но что-то всё равно сверлит глубоко в мозгу. Знакомо? Хорошо, если знакомо :) 
Этот вариант крайности мне претит ещё больше чем первый, вообще неприемлем. Отсутствие развития -&gt; отсутствие эволюции -&gt; гроб, гроб, кладбище…</p>

<p>Оба подхода не прагматичны. Как бы это пафосно не звучало, но <em>нам нужно найти баланс</em>. И это не выдуманный work-life balance, который полная, извините, херня. Дуализм, вообще херня. А вот строгие принципы, модель жизни, мышления и поведения — отличный подход мировоспрития и жизнепрепровождения. Дисциплина, если хотите. Только вот где её взять? И где взять на неё силы? Последне — только ваша и ничья иная “факультативная задача”.</p>

<p>Ну… Дисциплину, как и почти любую другую поведенческую тенденцию можно <em>выработать</em>. Придется потрудиться, хех :) 
Если одна лишь идея о выработке дисциплины, характера, изменений чего-то в своей <em>привычной жизни</em> повергает вас в дрожь и тихий ужас — это <strong>нормально</strong>. Это как раз тот самый механизм <em>лени</em> нашего мозга. Мозг вообще не любит работать, для этого нужно тратить много ресурсов, наращивать какие-то там нейронные связи. И страх это более чем нормальная реакция на такие потенциально тяжелые для мозга напряги.</p>

<p>Но это никак не может быть оправданием ничего не делать вовсе. Я не хочу никого пристыдить, каждый должен “стыдить” сам себя. Если мы только и делаем что ноем о своей неудачной жизни не выходя из зоны комфорта, вечно ищем оправдания для приложения усилий, развития навыков, может стоит принять себя так как есть? Смириться с тем что <em>меня всё устраивает</em>. Устраивает безперспективняк. Устраивает абсолютно всё что уже есть: дом, работа, образ жизни и её качества, такие как степень физической активности, пищевые привычки и тд. — это правда всё именно-то, что меня устраивает в данный момент? Устраивает то, к чему это потенциально приведет в будущем, через 5, 10, 15 лет? Если на все вопросы мы отвечаем утвердительно, то дальше и говорить не о чем. Мы счастливые люди! Закрывайте к чертям эту страницу, идите отдыхай, всё <em>хорошо</em>. Правда. Только прекратите ныть и наслаждайтесь жизнью!</p>

<h2 id="адвайта-чевойта">Адвайта… Чевойта?</h2>

<p>Жесткий дуализм, противостояние каких-то концепций в некоторой области всегда ведет к насилию. Подобное противопоставление работы и отдыха неизбежно приводит к перекосу — либо к агрессивному насилию над собой, либо к насилию пассивному, тянучему, превращающему в аморфную массу.</p>

<p>Тем не менее, “правильно ленивые” сотрудники практически всегда продуктивнее и изобретательнее в долгосрочной, “стабильной” перспективе. Прагматично ленивый человек всегда найдет способ сделать работу быстрее, проще. Но идеальная формула — это сочетание ответственности, прагматично-ленивой изобретательности и профессионализма.</p>

<p>Профессионально, но прагматично-лениво и безответственно — сделаем тяп-ляп и в продакшен. 
Ответственно, профессионально, но упершись рогами — шизоидно начнем изобретать велосипеды. 
Ответственно и лениво… Похоже эти качества вообще не сочетаются.</p>

<p>Прагматично-ленивый, ответственный и образованный в своей сфере трудовой активности сотрудник всегда будет показывать лучшие результаты, чем ненавидящий себя и всех вокруг, так называемый трудоголик. Просто потому что не “лентяй” не загнал себя как последнюю клячу. У его мозга всегда будут силы творить, концентрироваться, эволюционировать. В целом такой подход это залог хорошего здоровья и качественной жизни в целом, а не только продуктивности на работе.</p>

<h2 id="бери-больше-кидай-дальше">Бери больше, кидай дальше!</h2>

<p>Ну и вот, собственно все замечательные блага которыми мы пользуемся, часто воспринимая их как <em>данность по умолчанию</em>, подарили нам здоровые на голову, профессионально образованные, и прагматично-ленивые — <em>талантливые</em> люди. Но талант это не какой-то космический дар, а упорный труд кирпичик к кирпичику, зернышко за зернышком. Вы наверняка натыкались на то самое “Томас Эдисон лампочку изобрел не сразу, 1000 попыток провалились, и потом наконец — ура, эврика, получилось”.</p>

<p>Не будем сейчас о том, что до него лампочку много кто патентовал. Лучше обратимся вот к этому его “упорству”. Во-первых, 1000 раз он не одну и ту же лампочку пытался сделать, очевидно… или не очень? Томас, как и любой нормальный ученый муж занимался <em>исследованием</em>, и правильнее сказать <em>экспериментировал</em>. Так что талант — это скорее <em>упорство в изобретательности</em>, некая настойчивость в достижении определенной цели.</p>

<p>Вкалывал ли Томас? По любому! Но неужели вы думаете, что он упирался рогом в свои ошибки, и совсем не отдыхал? И тратил ли он <em>время</em> на какую то бесполезную хренотень, была ли вообще хренотень в его жизни? Сложно сказать наверняка, но мне кажется что если бы Томас ежедневно спал по 12 часов после тусовок в кабаках с забулдыгами, играл в карты и так далее, то ни лампочку и ничего другого бы так и не изобрел.</p>

<p>Во-первых, я веду к этому утонченному балансу между <strong>вкалываением</strong> и <strong>отдыхом</strong>. 
Во-вторых, предлагаю вам задуматься вот о чем — чем вы можете пожертвовать для достижения целей (подразумевается что цели, амбиции и стремления к переменам у вас есть, раз дочитали до сюда).</p>

<p>Ок! Мы решили не ныть, проявить смелость чтобы выйти из зоны комфорта, перестать загоняться по пустякам, начать трансформировать в прагматичных и успешных людей. Звучит как отличный план!</p>

<p>Для этого нужен <em>ресурс</em>, для любых трансформаций нужен ресурс и толчок, причина. С толчком-причиной, как я уже сказал — разбирайтесь сами. Никто вам не даст волшебный пендель под зад и не сделаем счастливым и просветленным <strong>кроме вас самих</strong>.</p>

<p>А что с ресурсом? Мы выяснили что мозгу надо отдыхать, чтобы экономить энергию. Но это не главный ресурс.</p>

<p>Самый главный и <strong>невосполнимый</strong> ресурс который у нас есть — <strong>время</strong>. Поглядите ретроспективно на что вы тратите его и в каком объеме. Я серьезно, это очень важно. Можете прям на бумажке, в каком нибудь блокноте планере записывать несколько дней (или недель) сколько времени и на что уходит.</p>

<h3 id="сколько-и-как-я-пашу">Сколько и как я пашу?</h3>

<p>Сколько времени вы тратите на работу? Может вы перерабатываете? А вам за это доплачивают вообще? Если даже доплачивают — насколько эта переработка продуктивна, полезна <strong>вам</strong> а не дяде? Сколько вы получаете за час? Пусть вы переработали 2 часа, и получили х1.5 или даже х2 (что всё реже встречается) за каждый переработанный час. <em>Оно действительно того стоило</em>?</p>

<p>Если исследовать более пристально время которые тратится на работу, то ещё полезнее будет углубиться в конкретные задачи. Насколько часто вы отвлекаетесь? Отвлекаться от интеллектуальной задачи, с одной стороны — очень полезно и периодически даже категорически <strong>нужно</strong>! Просто чтобы <strong>отдохнуть</strong> и посмотреть на задачу под новым углом, и вполне вероятно — решить её быстрее, лучше.</p>

<p>Проанализируйте на что именно вы отвлекаетесь. Если это откровенная <strong>херня</strong>, типа поглощения мусорного контента в ленте тик-тока, то на самом деле <strong>вы не даете мозгу отдохнуть</strong>. Отдых для мозга (имхо?) — это не только переключение внимания, но и прекращение потока излишней информации. Намного продуктивнее и полезнее будет пройтись, размяться, поговорить с коллегами, семьей, в общем <em>натуральный</em> чилл. Если этот мой блейм соцсетей вызывает у вас бугурт… Извините — дело дрянь.</p>

<p>А теперь конкретнее про IT, и вот эти все наши клацания по кнопкам. Я как-то писал вкратце про принцип DRY. D сути своей это всё тоже про время, и тоже касается продуктивности и отдыха. Если вы замечаете за собой <strong>часто</strong> повторяемые, почти или полностью <strong>идентичные</strong> действия… <strong>Почему бы не попытаться их автоматизировать???</strong> Быть может мы в таком случае выкроим время на свой любимый тик-ток? Бгг :)</p>

<h3 id="сколько-и-как-я-отдыхаю">Сколько и как я отдыхаю?</h3>

<p>Делаем тоже самое — трекаем и исследуем время затрачиваемое на отдых и быт. Какого характера этот отдых? В какие временные промежутки распорядка дня этот отдых “вклинивается”? Может вы ежедневно играете в мморпг по 4 часа после работы. Ну, кайф, что сказать. Я когда-то и больше играл… :)</p>

<p>Честно, наберитесь смелости, оно вам точно по 4 часа надо? Ок, допустим вам очень нравится играть в видео-игры, это нормально. Продолжайте играть! Но если у вас есть какие-то цели, амбиции которые не дают покоя, и вы набрались смелости что-то менять, возможно стоит играть на час меньше, а выкроенное время уделить на изучение какой-то новой технологии, <em>инвестировать</em> его на достижение этой цели?</p>

<p>А может видео-игры это как раз то самое отвлечение от работы, которое вдруг внезапно возникает в 2 часа по полудню, заканчивается в 6 вечера, потом вы понимаете что работу по тикету надо кровь из носа доделать к обеду завтрашнего дня и в итоге ложитесь спать в полночь или ещё позже?</p>

<p>Я думаю что идея уже должна быть предельно ясна.</p>

<h2 id="работать-в-кайф">Работать в кайф</h2>

<p>Вероятно корнем всех наших проблем является дисбаланс и безграмотность. Я призываю вас обратиться к более авторитетным источникам, развивать критическое мышление и отдыхать (надеюсь вам хватит ума и навыка критически мыслить чтобы не клюнуть на галимых “турбосусликов”).</p>

<p>Поверьте, работать в кайф можно и нужно. Главное что? Правильно — систематически <em>качественно</em> отдыхать.</p>

<p>Другой прикол — найдите <em>точку сопротивления</em>, это очень хороший индикатор проблемных мест.</p>

<p>Например, точка сопротивления возникает на каком-то этапе работы — вас что-то начинает раздражать, и тд. Вероятно пора отдохнуть, выдохнуть. Попейте чаю, водички, или что вы там пьете. Вполне вероятно что причину раздражения можно устранить путем автоматизации, или попытавшись посмотреть на задачу под другим углом, и то и другое путь <em>экспериментирования</em>, силы на которое есть только у хорошо отдохнувшего мозга.</p>

<p>Если вдруг обнаружится, что точка сопротивления превратилась уже в депрессивную лавину, то очевидно вы уже начали догорать и пора <strong>хорошо</strong> отдохнуть.</p>

<p>Цените себя, любите себя. Любите свое время. Мы все <em>можем правильно</em> инвестировать его. Просто старайтесь не забывайте, что это время неизбежно кончится, и неизвестно в какой момент.</p>

<p>Если страшно выходить из зоны комфорта, во-первых, не забывайте что это нормально! Во-вторых, начинайте с малого, но <strong>систематически</strong>! Никто не просит идти ва-банк, начинать вставать завтра же в 6 утра, час бегать, два часа учиться программировать, потом 8 часов работать, а после этого читать 2 книги — ничего не получится, потому что это “упирание рогом”. Послезавтра вы на всё плюнете и вернетесь в колею. Перед нами стоит задача постепенно, но упорно вырастить новые связи в мозгах!</p>

<p>Я верю в вас, и вы в себя тоже поверьте. 
Всё проще чем кажется, но сложнее чем мы думаем :)</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html"><![CDATA[Часики тикают.]]></summary></entry></feed>