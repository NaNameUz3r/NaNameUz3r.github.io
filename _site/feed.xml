<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-03-27T23:37:53+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Функциональное программирование, F# и Pattern Matching</title><link href="http://localhost:4000/2022/03/27/pattern-matching.html" rel="alternate" type="text/html" title="Функциональное программирование, F# и Pattern Matching" /><published>2022-03-27T00:00:00+03:00</published><updated>2022-03-27T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/27/pattern-matching</id><content type="html" xml:base="http://localhost:4000/2022/03/27/pattern-matching.html">&lt;!--more--&gt;

&lt;h2 id=&quot;вместо-введения&quot;&gt;Вместо введения&lt;/h2&gt;

&lt;p&gt;Функциональное программирование как парадигма основывается на концепции функций первого класса, о которой вкратце я уже писал &lt;a href=&quot;/2022/03/08/hack_in_declarative_model_5.html&quot;&gt;здесь.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;А вообще, функциональное программирование это &lt;em&gt;частый случай&lt;/em&gt; декларативного подхода. В функциональном программировании тоже нет растянутых во времени состояний (переменных), значения которых хранятся и могут переопределяться когда вздумается.&lt;/p&gt;

&lt;p&gt;Таким образом, функции в ФП понимаются не как какие-то подпрограммы или методы, а скорее &lt;em&gt;математически&lt;/em&gt;. В программном смысле такие функции можно представить как конвейер, который преобразует входное значение в выходное. Впрочем все это уже нам знакомо из изучения декларативной модели.&lt;/p&gt;

&lt;p&gt;Здесь же я хочу подчеркнуть взаимосвязь понимания времени, и именованных состояний. В разных парадигмах программирования время представляется по разному. Мы рассматриваем здесь время как некое абстрактное понятие, которое выражает последовательность именованных значений (именованных состояний, переменных).&lt;/p&gt;

&lt;p&gt;Так вот, в функциональном программировании и декларативной модели время непрерывно — значения вычислений как бы перетекают в другие вычисления, до тех пор пока не будет получен итоговый результат.&lt;/p&gt;

&lt;h2 id=&quot;mr-gordon-freeman-alonzo-church&quot;&gt;Mr. &lt;del&gt;Gordon Freeman&lt;/del&gt; Alonzo Church&lt;/h2&gt;

&lt;p&gt;Может сложится впечатление, что функциональное программирование это просто некоторая реализация декларативной парадигмы. Но это не так! Функциональное программирование фактически отдельная, самостоятельная парадигма программирования, основанная на математической теории, а точнее — на формальной системе, которую разработал Алонзо Чёрч в &lt;del&gt;далекой-далекой галактике&lt;/del&gt; сороковых годах!&lt;/p&gt;

&lt;p&gt;В это систему Чёрч заложил две основные операции:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Аппликация функции — это про применение (по сути вызов) функции с каким то значением. И хотя в математике итак есть обозначение подобного например как f(a), в лямбда исчислении вся фишка в том что f трактуется не просто как функция, а как &lt;em&gt;алгоритм&lt;/em&gt; который вычисляет результирующее значение, где a — входное значение.&lt;/li&gt;
  &lt;li&gt;Абстракция — если не вдаваться в математическую мудрость, это способ определения выражений. Ну, то есть, это определение того, что там функция f на самом деле внутри вычисляет. Если хотите — определение &lt;em&gt;алгоритма&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Кстати, Чёрч был научным руководителем Алана Тьюринга :)&lt;/p&gt;

&lt;p&gt;Давайте ещё проще. Лямба-исчисление эта не меньше чем &lt;em&gt;полноценный&lt;/em&gt; язык программирования, в котором нет &lt;em&gt;ничего&lt;/em&gt; кроме простых функций — функций от &lt;em&gt;одного аргумента&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;На практике же, в функциональных языках программирования в функцию можно передавать больше одного аргумента, но делается это с помощью кортежей, то есть с точки зрения математической модели это всё ещё один аргумент, и не важно что внутри него может быть несколько значений.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/i-know-lambda-calculus.jpg&quot; alt=&quot;Neo knows Lambda-calculus&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ближе-к-делу&quot;&gt;Ближе к делу&lt;/h2&gt;

&lt;p&gt;С функциональным программированием я сейчас знакомлюсь в рамках курса по изучению языка F#, который родом из семейства языков MetaLanguage (строгие языки ФП). Это синтаксически минималистичный язык (ещё бы…), но тут есть всё что нужно, чтобы писать полноценные программы: типы, функции, выражения и вычислительные выражения.&lt;/p&gt;

&lt;p&gt;Типизация, разумеется, строгая статическая.  Функции же тут являются таким же базовым типом данных (функции первого класса), а вся программа является единым выражением (выше я уже говорил про “конвейер”). Получается что программа состоит не из операций присваивания и команд, а из &lt;em&gt;применения функций к аргументам&lt;/em&gt; — аппликаций.&lt;/p&gt;

&lt;p&gt;В F# функции как тип данных определяются типом аргумента, передаваемого этой функции, и типом результирующего значения, которые перечисляются через стрелку “-&amp;gt;”.&lt;/p&gt;

&lt;p&gt;А сами функции определяются, например, так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let multiply3 N = N * 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Здесь &lt;em&gt;multyply3&lt;/em&gt; — идентификатор (имя) функции, а N её единственный аргумент. Получается что тип этой функции будет таким: “int -&amp;gt; int”. Имя функции можно не задавать, определив тем самым так называемую &lt;em&gt;анонимную&lt;/em&gt; функцию, или &lt;em&gt;лямбда-функцию&lt;/em&gt; с помощью ключевого слова &lt;em&gt;fun&lt;/em&gt; (a lot of!). Та же самая функция с применением анонимной-функции может быть записана так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let multiply3 = fun N -&amp;gt; N * 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Видите разницу? Идентификатору multiply3 мы присваиваем результат вычисления анонимной функции, у которой N аргумент, и после стрелки -&amp;gt; выражение, которое эта функция вычисляет.&lt;/p&gt;

&lt;h3 id=&quot;нужно-построить-зиккурат&quot;&gt;Нужно построить Зиккурат&lt;/h3&gt;

&lt;p&gt;Очевидно, что есть множество случаев, когда мы хотим передать в функцию более одного значения, но аргумент может быть одним. Если вы не рыба, то помните что это мы уже затронули.&lt;/p&gt;

&lt;p&gt;Кортежи в F# обозначаются так же как во многих других языках — с помощью круглых скобок. Скажем нам нужна очень сложная функция, которая перемножает три целых числа между собой:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let toughcalc (a, b, c) = 
    let firstmul = a * b
    firstmul * c 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Конечно можно было сразу перемножить a * b * c, но в данном примере хочется подчеркнуть то, что результирующем значением функции будет значение &lt;em&gt;последнего&lt;/em&gt; выражения в её теле. Тип этой функции будет “int * int * int -&amp;gt; int”. Да, компилятор нормально понимает когда мы передаем несколько значений через кортеж, и значения типов таких составных аргументов записываются через “*”.&lt;/p&gt;

&lt;p&gt;Если мы вкорячим последним выражением какой нибудь printfn “helloworld”, тип функции станет “int * int * int -&amp;gt; string”. Если последним выражением мы поделим результат перемножений на 0.2, тип снова изменится на “int * int * int -&amp;gt; float”, и так далее.&lt;/p&gt;

&lt;h2 id=&quot;имхо--вишенка&quot;&gt;Имхо — вишенка&lt;/h2&gt;

&lt;p&gt;Pattern matching — это очень-очень круто! Что же это за колдовство? В общем, мы можем определить в функции некоторый набор вариантов выбора (clause), и жаль что такой финт есть не во всех языках программирования. В императивных языках бывают такие штуки как switch/case, но pattern matching куда круче, и идет дальше.&lt;/p&gt;

&lt;p&gt;Функция, поддерживаются сопоставление с образцом начинается с ключевого слова &lt;em&gt;function&lt;/em&gt;. Варианты для сопоставления аргумента (или аргументов), перечисляются через символ |, после которого задается шаблон проверки, и следом за стрелкой (“-&amp;gt;”) соответствующий шаблону результат.&lt;/p&gt;

&lt;p&gt;Например:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let johnDoe = function
   | &quot;age&quot;   -&amp;gt; &quot;69&quot;
   | &quot;hobby&quot; -&amp;gt; &quot;story telling&quot;
   | &quot;diagnosis&quot; -&amp;gt; &quot;ASPD&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Во-первых, тип — string -&amp;gt; string. И как видите, аргумент явно не указан, у него нет имени, нам это и не нужно. Да, так можно :)
Во-вторых, обратите внимание что 69 явно записано в кавычках, дабы быть не int, а string. В противном случае мы получим ошибку компилятора, который будет ругаться что результирующие типы шаблонов не соответствуют друг другу.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Мы можем указывать универсальный паттерн (если другие условия не сработали), или множество вариантов с помощью or-паттерна (через “&lt;/td&gt;
      &lt;td&gt;” друг за другом), выглядит это так:&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let johnDoe = function
   | &quot;age&quot; | &quot;vozrast&quot;         -&amp;gt; &quot;69&quot;
   | &quot;hobby&quot; | &quot;che delart&quot;    -&amp;gt; &quot;story telling&quot;
   | &quot;diagnosis&quot; | &quot;bolyachka&quot; -&amp;gt; &quot;ASPD&quot;
   | _                         -&amp;gt; &quot;no data&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;В качестве шаблона мы можем задать некоторый внутренний для функции идентификатор, который автоматически будет связан с проверяемым значением:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let minus1 = function
   | 0 -&amp;gt; 0 
   | n -&amp;gt; n - 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;В F# pattern matching поддерживается так-же и как отдельная операция match, которая допускает указывать дополнительные логические условия в вариантах сопоставления после ключевого слова when:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  let tendToZero n = match n with
   | 0 -&amp;gt; 0
   | n when n &amp;gt; 0 -&amp;gt; n - 1
   | n when n &amp;lt; 0 -&amp;gt; n + 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;эпилог&quot;&gt;Эпилог&lt;/h3&gt;

&lt;p&gt;Пока, из того что я выучил в ФП и F#, pattern matching мне показался наиболее интересной киллер фичей. Разумеется тут можно определять рекурсивные функции (надо перед идентификатором функции добавить rec), если логические условия if\then\else\elif и так далее, но всё это привычно и, наверное, писать об этом не очень интересно.&lt;/p&gt;

&lt;p&gt;Сопоставление с образцом есть не во всех языках, но его пытаются завезти. Например в прошлом году его &lt;a href=&quot;https://habr.com/ru/company/yandex_praktikum/blog/547902/&quot;&gt;донесли в пайтон&lt;/a&gt;, но нужен ли он там и использовать ли — решайте сами.&lt;/p&gt;

&lt;p&gt;Миру мир!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"></summary></entry><entry xml:lang="ru"><title type="html">Несколько слов о проектировании</title><link href="http://localhost:4000/2022/03/20/program-design.html" rel="alternate" type="text/html" title="Несколько слов о проектировании" /><published>2022-03-20T00:00:00+03:00</published><updated>2022-03-20T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/20/program-design</id><content type="html" xml:base="http://localhost:4000/2022/03/20/program-design.html">&lt;p&gt;Как подступиться к правильному созданию программы.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;program-design&quot;&gt;Program Design&lt;/h3&gt;
&lt;p&gt;Проектирование программы, наверное, самый важный критерий успешности и качественности будущего программного продукта. 
На этапе проектирования нам нужно четко определить саму задачу, и то как мы будем её решать.&lt;/p&gt;

&lt;p&gt;Под “решанием” имеются в виду техники программирования (прадигмы), которые будут применяться, и то как они будут связанны между собой.&lt;/p&gt;

&lt;p&gt;Результатом проектирования является высокоуровневая структура, условный &lt;em&gt;“прототип”&lt;/em&gt; будущей системы.&lt;/p&gt;

&lt;p&gt;Очевидно, что в зависимости от задачи размер и сложность программы может существенно отличаться. Это может быть маленькая программа, написанная одним человеком или здоровенный комплекс, над которым трудится целая команда. В классическом случае первое называют programming in small, а второе — in large.&lt;/p&gt;

&lt;p&gt;Более интересным с инженерной точки зрения мне кажется другое определение &lt;em&gt;programming in small&lt;/em&gt; и &lt;em&gt;programming in large&lt;/em&gt;, когда подразумевается не количество людей трудящихся над программой, но “фокус” разработки.&lt;/p&gt;

&lt;p&gt;В этом случае, говоря о programming in small подразумевается само кодирование программы, а именно написание стилистически ясного, правильно (чистого) кода, выраженного через &lt;a href=&quot;/2022/01/22/algorithms_complexity.html&quot;&gt;продуктивные алгоритмы&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Programming in large, в таком случае, является “фокусом” проектирования, когда программа уже является действительно большой (от нескольких тысяч строк кода, и более). В создании таких сложных программ критически важно подходить к проектированию осознанно и правильно, иначе всё кончится плохо: бизнес потеряет деньги, разработчики — оставшиеся нервные клетки.&lt;/p&gt;

&lt;h2 id=&quot;базовый-подход&quot;&gt;Базовый подход&lt;/h2&gt;

&lt;p&gt;Предлагаю вам, в качестве примера, рассмотреть следующую методику проектирования in small, когда программа разрабатывается единолично, и ожидаемый объем кода составит менее десятков тысяч строк.&lt;/p&gt;

&lt;h4 id=&quot;1-спецификация&quot;&gt;1. Спецификация&lt;/h4&gt;
&lt;p&gt;Сперва необходимо обозначить &lt;strong&gt;неформальную спецификацию&lt;/strong&gt;. Это то, что часто называют техническим заданием. На практике же нам нужно как можно более точно записать что программа должна делать, а именно:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Что программа получает на вход?&lt;/li&gt;
  &lt;li&gt;Что должна выдавать на выходе?&lt;/li&gt;
  &lt;li&gt;Как входные и выходные данные соотносятся друг с другом?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Такая спецификация называется неформальной, потому что мы пишем её на человеческом языке (русском, английском, или на каком вы там ещё умеете).&lt;/p&gt;

&lt;h4 id=&quot;2-примеры&quot;&gt;2. Примеры&lt;/h4&gt;
&lt;p&gt;Примеры служат для прояснения спецификации, полученной на первом этапе. Будет очень полезно представить что программа делает в определенных, конкретных ситуациях. Лучшего всего это делать в &lt;em&gt;формате тестов&lt;/em&gt;. Да, сначала пишем тесты для кода, а потом код! Это называется TDD — Test Driven Development, и само по себе огромная тема для отдельного поста.&lt;/p&gt;

&lt;p&gt;Наши примеры должны показывать, во-первых, как программа ведет себя граничных условиях. Нужно проверить её самыми неожиданными способами. Никогда не нужно думать что “чего-то может не быть”, “моя программа никогда не получит на вход отрицательное значение”, и так далее.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assume and check everything!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Во-вторых, примеры должны собственно отображать базовые сценарии работы программы. Может показаться, что это важнее чем тесты. Нет, не важнее.&lt;/p&gt;

&lt;h4 id=&quot;3-исследование&quot;&gt;3. Исследование&lt;/h4&gt;

&lt;p&gt;На этом этапе нам необходимо написать “кирпичики” из которых мы предполагаем строить программу. Этими “кирпичиками” должны быть небольшие и по максимуму автономные операции (низкая связанность). В результате мы получим намного более четкое представление о структуре будущей программы, и сможем определить конкретные методы программирования, уместные для решения поставленных задач.&lt;/p&gt;

&lt;h4 id=&quot;4-структура-и-реализация&quot;&gt;4. Структура и реализация&lt;/h4&gt;

&lt;p&gt;Наконец, мы начинаем формировать саму программу — приблизительно набрасываем операции для расчета входных данных, и способы (методы), которыми эти операции между собой взаимодействуют. После этого пробелы в получившемся наброске заполняются реальным кодом. Важно то, что операции &lt;em&gt;должны быть простыми&lt;/em&gt; — каждая из них должна делать &lt;strong&gt;одну&lt;/strong&gt;, и только одну вещь.&lt;/p&gt;

&lt;p&gt;Это один из самых важных принципов &lt;em&gt;ясного&lt;/em&gt; программирования, следуя которому мы избегаем потенциально много ошибок, которые могут порождаться, например, сайд-эффектами запутанных функций, которые делают “много чего” внутри. А те ошибки, которые всё таки будут появляться (А они будут!), мы сможем намного быстрее идентифицировать и исправить.&lt;/p&gt;

&lt;p&gt;Для улучшения структуры программы, связанные операции группируются в &lt;em&gt;модули&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;5-тестирования-и-обдумывание&quot;&gt;5. Тестирования и обдумывание&lt;/h4&gt;

&lt;p&gt;Пришла пора убедиться что &lt;del&gt;оно живое!&lt;/del&gt; программа вообще работает. Для этого нужно провести ряд тестов, включая те, что уже были разработаны на этапе 2. Снова и снова гоняем тесты и исправляем ошибки, до тех пор пока программа не заработает так как надо. А надо, чтобы она работала хорошо :)&lt;/p&gt;

&lt;p&gt;На этом этапе важно не забывать рассуждать о структуре программы и её сложности. Находя и исправляя ошибки потенциально возможно улучшить структуру программы и переписать плохие алгоритмы (рефакторинг кода).&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Все эти этапы взаимодополняющи друг другу. Например, на этапе исследования, или даже написании примеров, мы можем понять что изначальная спецификация не совсем корректна, и изменить/дополнить её. Тестирование и обдумывание, имхо, вообще стоит ультимативно применять как жизненный принцип :)&lt;/p&gt;

&lt;p&gt;А если по делу, то тестирование, в принципе, самый важный шаг в programming in small. Существует достаточно много методик тестирования, которые стоит изучить и применять в разработке. Например, уже упомянутое TDD и &lt;em&gt;модульное тестирование&lt;/em&gt;. Это тема для отдельных постов, поэтому вкратце:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Модульное тестирование — основная идея unit-тестирования в том, чтобы писать тесты, которые проверяют &lt;strong&gt;наименьшую&lt;/strong&gt; составляющую кода (один тест проверяют одну функцию, модуль или класс)&lt;/li&gt;
  &lt;li&gt;TDD — Перед тем как писать код, мы пишем тесты для этого кода (например те же самые unit-тесты)! В принципе такие тесты выступают в роли спецификации того, что код &lt;em&gt;должен делать&lt;/em&gt;. Мощный подход, которые позволяет понимать что мы вообще делаем, программируя части системы.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;организация-программы&quot;&gt;Организация программы&lt;/h2&gt;

&lt;p&gt;В проектировании важно понимать как всё таки правильно организовать программу. Конечно, можно накодить всё как сплошной монолит, в котором по мере роста проекта всё в итоге запутается, и все участники разработки/сопровождения будут ультимативно страдать. Наверняка вы видели такие проекты, не буду показывать пальцами.&lt;/p&gt;

&lt;p&gt;Наиболее адекватный способ борьбы с растущей сложностью системы — декомпозиция программы на так называемые &lt;em&gt;логические единицы&lt;/em&gt;. Каждая такая единица должна реализовать свой набор операций, которые связанны в одно целое, например через &lt;a href=&quot;/2022/03/13/hack_in_declarative_model_6.html&quot;&gt;абстрактные типы данных.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Логическая единица делится на две части: &lt;em&gt;интерфейс&lt;/em&gt; и &lt;em&gt;реализацию&lt;/em&gt;. Снаружи логического блока доступен только интерфейс, а реализация “внутри” при этом может меняться безнаказанно.&lt;/p&gt;

&lt;p&gt;Логические единицы часто называют &lt;em&gt;модулями&lt;/em&gt; или &lt;em&gt;компонентами&lt;/em&gt; программы.&lt;/p&gt;

&lt;h3 id=&quot;слово-дня---функтор&quot;&gt;Слово дня - Функтор&lt;/h3&gt;

&lt;p&gt;А теперь немного программистской “научности”, продолжая тему организации.&lt;/p&gt;

&lt;p&gt;Спецификацию модуля рассматривают как &lt;em&gt;отдельную сущность&lt;/em&gt; — это такой “шаблон”, который создает новый модуль, примерно так же как класс создает экземпляр объекта в объектно ориентированном программировании. Есть конкретный программистский термин, для обозначения таких спецификаций.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Функтор&lt;/strong&gt; — это функция, которая получает на вход набор модулей, требующихся для создания &lt;em&gt;нового модуля&lt;/em&gt;, и возвращает этот новый созданный модуль. Правильно говоря, функтор получает на вход &lt;em&gt;интерфейсы&lt;/em&gt; модулей, и возвращает тоже &lt;em&gt;интерфейс&lt;/em&gt; нового модуля.&lt;/p&gt;

&lt;p&gt;Функтор состоит из:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;импорта, которым задается перечень требуемых функтору модулей;&lt;/li&gt;
  &lt;li&gt;экспорта, определяющего интерфейс “изготавливаемого” модуля;&lt;/li&gt;
  &lt;li&gt;реализации, включающая код инициализации самого функтора.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В программной инженерии &lt;em&gt;программным компонентом&lt;/em&gt; называется некоторый элемент для &lt;em&gt;независимого развертывания&lt;/em&gt;. Такой компонент для своей установки ничего не требует, кроме перечня стандартных библиотек. Программный компонент не имеет фиксированного внутреннего состояния, иными словами — соответствует (декларативной модели)[/archive.html?tag=Декларативная_модель]&lt;/p&gt;

&lt;p&gt;Автономное (standalone) приложение, которое не подразумевает активного взаимодействия с пользователем, например, не имеет графического интерфейса для такого взаимодействия, состоит из главного функтора, который вычисляется на старте приложения, “подтягивает” нужные себе модули, что фактически приводит к вызову других функторов.&lt;/p&gt;

&lt;p&gt;Вычисление или установка главного функтора происходит в три шага:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Идентификация необходимых для работы модулей;&lt;/li&gt;
  &lt;li&gt;Выполнение кода инициализации;&lt;/li&gt;
  &lt;li&gt;Загрузка модулей, которые будут нужны непосредственно во время работы программы.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Другие “подфункторы” могут вычисляться в разное время работы программы, как правило в те моменты, когда запрашиваются ресурсы из ещё не вычисленного функтора. Такое поведение называется &lt;strong&gt;динамическим связывание&lt;/strong&gt;, которое является полной противоположность &lt;strong&gt;статическому связыванию&lt;/strong&gt; — при котором все модули загружаются сразу на старте программы.&lt;/p&gt;

&lt;p&gt;Множество установленных (вычисленных) модулей называется &lt;strong&gt;рабочим модульным окружением&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Любите.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Проектирование" /><summary type="html">Как подступиться к правильному созданию программы.</summary></entry><entry xml:lang="ru"><title type="html">Программирование, управляемое данными. АТД.</title><link href="http://localhost:4000/2022/03/13/hack_in_declarative_model_6.html" rel="alternate" type="text/html" title="Программирование, управляемое данными. АТД." /><published>2022-03-13T00:00:00+03:00</published><updated>2022-03-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/13/hack_in_declarative_model_6</id><content type="html" xml:base="http://localhost:4000/2022/03/13/hack_in_declarative_model_6.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 6. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;data-driven&quot;&gt;Data-driven&lt;/h2&gt;

&lt;p&gt;Часто на практике нужно выполнить какую то операцию над достаточно большой структурой данных, например провести итеративные вычисления, или обойти одну структуру и вычислить другую, на основе “собранных” в обходе данных.&lt;/p&gt;

&lt;p&gt;Как правило, чаще всего такие вычисления проводятся над списками, массивами и деревьями. К спискам применяются операции свертки (FoldL\R), которые мы рассмотрели в прошлом посте. Но существуют и другие популярные техники.&lt;/p&gt;

&lt;h3 id=&quot;операция-map&quot;&gt;Операция Map&lt;/h3&gt;

&lt;p&gt;Реализация Map есть почти во всех стандартных библиотеках популярных языков программирования. Эта операция работает со списком, и вычисляет на его основании список такой же длинны, применяя переданную в Map функцию к каждому элементу исходного списка.&lt;/p&gt;

&lt;p&gt;С помощью &lt;del&gt;заклинаний&lt;/del&gt; программирования высшего порядка, реализовать Map можно как-то так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def function Map(some_list, some_func)

    def function iterate_map(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list
  

        list_head = list_remaining[0]
        list_tail = list_remaining[1:] 
        return iterate_map(new_list.insert(0, some_func(list_head)), list_tail, some_func)
  

    return iterate_map([], some_list, some_func)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Можем передать в Map простую функцию, типа возведения в квадрат, и передать её вторым аргументов. Напоминаю что здесь, раньше и далее сниппеты описаны в “псевдопайтанокоде”. Заварите чай, прочитайте прошлые пару статей, если сходу ничего не понятно, и реализуйте рабочий вариант на своем любимом ЯП :)&lt;/p&gt;

&lt;h3 id=&quot;операция-filter&quot;&gt;Операция Filter&lt;/h3&gt;

&lt;p&gt;Filter это ещё одна классическая операция для обработки списков. Она так же принимает вторым аргументом некоторую функцию-предикат, и на выходе отдает список с элементами исходного списка, удовлетворяющими переданный предикат:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def function Filter(some_list, some_func)

    def function iterate_filter(new_list, list_remaining, some_func)
        if list_remaining == []:
            return new_list

        list_head = list_remaining[0]
        list_tail = list_remaining[1:]

        if some_func(list_head):
            return iterate_filter(new_list.insert(0, list_head), list_tail, some_func)
        else:
            return iterate_filter(new_list, list_tail, some_func)
     
   

    return iterate_filter([], some_list, some_func)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Снова взываю к вашей фантазии, напрягите волшебный интеллект! Предикат можно придумать, практически любой. Например, если список состоит из целых чисел, можем написать простую функцию которая возвращает true если результата делится на 2 без остатка (четный). Или вообще воткнуть предикат в вызов iterate_filter лямбдой. Если вы прожженый питонист, то я уверен что вы хотя бы раз втыкали лямбды в map или filter!!! :trollface:&lt;/p&gt;

&lt;h2 id=&quot;абстрактные-типы-данных&quot;&gt;Абстрактные типы данных&lt;/h2&gt;

&lt;p&gt;Абстрактный тип данных — это описание некоторой структуры данных посредством определения операций над этой структурой. И только! Только операций!
Внутренняя реализация, все атрибуты &lt;em&gt;полностью скрыты&lt;/em&gt; в АТД, или лучше сказать — &lt;strong&gt;эта реализация вообще отсутствует&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;В декларативной парадигме АТД, в первую очередь тип данных — множество значений, с которым связано множество &lt;em&gt;допустимых&lt;/em&gt; над ними операций. Базовы набор декларативных типов перечислялся в одном &lt;a href=&quot;/2022/02/06/hack_in_declarative_model.html&quot;&gt;первом посте&lt;/a&gt; из этого цикла.&lt;/p&gt;

&lt;p&gt;Мало типов, скажете вы! Да, хотелось бы определять свои. АТД в нашем распоряжении.&lt;/p&gt;

&lt;p&gt;И ещё раз, что такое &lt;em&gt;абстрактный&lt;/em&gt; тип данных? Это такой тип, который конкретно определен &lt;em&gt;множеством операций&lt;/em&gt; над собой, и при этом &lt;strong&gt;полностью&lt;/strong&gt; независим от своей реализации. Мы можем всегда быстро и легко поменять эту реализацию не трогая сам абстрактный тип.&lt;/p&gt;

&lt;h3 id=&quot;защищаем-атд&quot;&gt;Защищаем АТД&lt;/h3&gt;

&lt;p&gt;Есть такое чувство, что легкая сменяемость чего либо в программировании может привести к проблемам. Чаще всего так и происходит. В разрезе АТД не всегда будет разумным делать реализацию типа для всех. Во-первых, программа с такой открытой реализаций, то есть &lt;em&gt;открытая программа&lt;/em&gt; потенциально становится легкой мишенью для злоумышленников.&lt;/p&gt;

&lt;p&gt;Под “открытой программой” тут мы понимаем не open source софт, речь вообще не об этом. Представьте программу которая запущена в прод, в ней крутится много данных, в том числе персональных данных клиентов, и в этой программе сама реализация абстрактных типов открыта, и например непосредственно доступна для взаимодействия другим программам через API. В таком случае любая другая программа может быть вредительской и “наворошить дел” в нашем рантайме.&lt;/p&gt;

&lt;p&gt;Нам нужно защитить &lt;em&gt;конкретные&lt;/em&gt; реализации абстрактных типов данных от &lt;em&gt;неавторизованного&lt;/em&gt; вмешательства. Для этого можно ограничить внутреннюю реализацию, часть кода, которая производит вычисления.&lt;/p&gt;

&lt;p&gt;Такое ограничение можно внедрить двумя способами:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Четко определяем набор операций и их граничные значения так, чтобы вычисляемое значение вообще не могло выходить за эти границы. Сам набор операций становится ограничением, вычисляя только &lt;em&gt;стационарные значения&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Другой вариант — &lt;em&gt;мобильные значение&lt;/em&gt;. Вычисленное значение может покидать границы, а затем вернуться обратно. Пока оно “снаружи”, с ним может как-то работать внешний код (другая программа, например, или другой модуль нашей системы). Здесь описывается четкий набор операций, которые по разрешению могут выводить значение, обрабатывать его, и возвращать результат назад.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Такое разрешение называется &lt;em&gt;авторизацией&lt;/em&gt;. Для получения авторизации операция должна предоставить некоторый “ключ” (токен, называйте как хотите). В декларативной модели этот ключ-авторизацию называется просто “имя”.&lt;/p&gt;

&lt;p&gt;Для реализации второго метода классическая декларативная модель должна быть расширена. Нам надо придумать как защищать значения, и как защищать &lt;em&gt;несвязанные&lt;/em&gt; (со значением) декларативные переменные.&lt;/p&gt;

&lt;p&gt;Например, мы можем определить операции-обертки, с ключем доступа. Доступ к внутреннему функционалу абстрактного типа становится доступным только тем операциям, которые передают в обертку &lt;em&gt;правильный&lt;/em&gt; ключ.&lt;/p&gt;

&lt;p&gt;Для начала нам надо определить тип для ключей, например Name, который будет хранить атомарное значение. У этого типа нет никаких операций вывода своего значения на экран, или преобразования в число, строку и тд. Всё что должно быть возможно сделать с Name, это только создавать его новые экземпляры, и сравнивать со значениями других экземпляров Name.&lt;/p&gt;

&lt;p&gt;При этом, операция создания нового ключа должна гарантировать, что результирующее значение будет &lt;em&gt;уникальным&lt;/em&gt;. Мы тут немного отходим от талмудов декларативности, ведь операция создания нового ключа &lt;em&gt;не декларативна&lt;/em&gt; — вызывая её каждый раз, мы получаем новый результат. Но тут мы применяем этот подход только для внедрения безопасности абстрактных типов, так что это ок, ведь сами АТД остаются декларативными.&lt;/p&gt;

&lt;p&gt;Далее, например у нас есть абстрактный тип данных — стек, который внутри фактически реализован как обычный список, но у нас нет прямого доступа к его (стека) содержимому в виде обычного списка.&lt;/p&gt;

&lt;p&gt;Мы можем создать экземпляр стека, создать экземпляр ключа, для этого стека, назвав его как нибудь типа stack_key, и наконец — &lt;em&gt;реализовать функцию обертку&lt;/em&gt; (доступную “снаружи”), которая на вход получает собственно стек, и ключ. Если ключ правильный — работаем. Если нет — чао-какао.&lt;/p&gt;

&lt;p&gt;Ну вы поняли — ни Name, ни метод генерации экземпляров Name, ни сравнения с другими Name извне (другим программам) никак не доступен. Мы разделяем таким образом “внутренние” операции и “внешние”.&lt;/p&gt;

&lt;p&gt;Очевидно, что такая схема обезопасивания АТД может применяться в коде часто, поэтому отчего бы её тоже не обернуть в другой слой абстракции?
А как? А с помощью АТД! :trollface:&lt;/p&gt;

&lt;p&gt;Мы можем описать две функции “упаковки” и “распаковки” — wrap(), unwrap(), и ключи генерировать скрыто в “конструкторе” АТД.&lt;/p&gt;

&lt;p&gt;Операция Wrap получает на вход некоторое значение, возвращает &lt;em&gt;функцию&lt;/em&gt;, которая требует ключа на вызове, чтобы распаковать скрытое в себе значение.&lt;/p&gt;

&lt;p&gt;Unwrap же получает эту функцию, передает ей требуемый ключ, и если ключ правильный то возвращает значение в незащищенном виде.&lt;/p&gt;

&lt;p&gt;Например у нас есть:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;some_list = [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;y&quot;, &quot;e&quot;, &quot;a&quot;, &quot;h&quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы делаем скдыщь:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;secure_list = Wrap(some_list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Теперь обращаясь как-то к secure_list мы не получаем ничего, None, фигушки, пока не сделаем:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;show_me_what_inside = Unwrap(secure_list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Важно понимать, что ключи к нас генерируются внутри конструкторов, а сами операции упаковки и запаковки &lt;em&gt;вызываются внутри других операций абстрактных типов данных&lt;/em&gt;, и за границами АТД они никак не доступны!&lt;/p&gt;

&lt;p&gt;Например, обычный, незащищенный абстрактный тип “Stack” может быть определен таким набором операций:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;create_stack() – создает новый экземпляр стека (по сути список);&lt;/li&gt;
  &lt;li&gt;push_in(some_stack, some_element) – впихивает элемент some_element в стек some_stack;&lt;/li&gt;
  &lt;li&gt;pop_out(some_stack) – выпихивает элемент из стека;&lt;/li&gt;
  &lt;li&gt;sneak_peek(some_stack) – получить верхний элемент стека, не выталкивая элемент;&lt;/li&gt;
  &lt;li&gt;is_empty(some_stack) – true\false проверка на пустоту стека &lt;del&gt;от самобытия&lt;/del&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Такая реализация небезопасна, новый стек будет открыт, ведь это по сути список, читайте и делайте с ним что хотите. Мы можем защитить его рассмотренной упаковкой\распаковкой создав тип SecStack, который будет работать так:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;create_stack() – возвращает Wrap([]) – защищенный пустой список, а не просто список;&lt;/li&gt;
  &lt;li&gt;push_in(some_stack, some_element) – делает Unwrap(some_stack) вставляет элемент some_element в стек some_stack, делает Wrap() для нового списка;&lt;/li&gt;
  &lt;li&gt;pop_out(some_stack) – делает Unwrap(some_stack) удаляет элемент из стека, делает Wrap() для нового списка;&lt;/li&gt;
  &lt;li&gt;sneak_peek(some_stack) – Unwrap(some_list) и отдает верхний элемент извлеченного списка, не выталкивая элемент (исходный список все ещё “заврапен”, не переживайте о нем, это же декларативная модель!);&lt;/li&gt;
  &lt;li&gt;is_empty(some_stack) – Unwrap(some_list), проверяет пуст или не пуст список.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Теперь надеюсь понятнее важный момент о том, что методы wrap\unwrap скрыты внутри реализации стека. Абсолютно нет никакой возможности получить содержимое извне неавторизованным операциям-методам.&lt;/p&gt;

&lt;h3 id=&quot;защищаем-несвязанные-переменные&quot;&gt;Защищаем несвязанные переменные&lt;/h3&gt;

&lt;p&gt;Несвязанные со значениями декларативные переменные можно обезопасить, дополнив декларативную модель операцией read_only. Стоп, а зачем нам вообще защищать эти переменные? Ну как, представьте что какое-то злоумышленное существо или программа, написанная таким существом, получила некоторым образом &lt;em&gt;ссылку&lt;/em&gt; на несвязанную декларативную переменную. Туда можно записать &lt;strong&gt;что угодно&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Так вот, делаем read_only переменные. Мы можем определить такую условную операцию, которая получает имя переменной на вход, а возвращает “образ” значений этой переменной, разрешая только читать его.&lt;/p&gt;

&lt;p&gt;Реализуется это с помощью дополнительного хранилища. Операция связывания переменных со значением изменяется таким образом, что прежде чем что-то куда-то привязать проверяет, не находится ли ссылка на переменную в read-only хранилище. Если такая ссылка в хранилище есть — связывание не происходит.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Ну, собственно, на этом мы заканчиваем наше скромное знакомство с Декларативной вычислительной моделью. Я завершил текущий курс. Дальше у нас ещё много, ох как много интересного! Функциональное, императивное, проектирование high-load… Продолжаем взрывать мозг, ура!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 6.</summary></entry><entry xml:lang="ru"><title type="html">Программирование высшего порядка. Процедурные абстракции.</title><link href="http://localhost:4000/2022/03/08/hack_in_declarative_model_5.html" rel="alternate" type="text/html" title="Программирование высшего порядка. Процедурные абстракции." /><published>2022-03-08T00:00:00+03:00</published><updated>2022-03-08T00:00:00+03:00</updated><id>http://localhost:4000/2022/03/08/hack_in_declarative_model_5</id><content type="html" xml:base="http://localhost:4000/2022/03/08/hack_in_declarative_model_5.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 5. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;колдуем-по-взрослому&quot;&gt;Колдуем по взрослому&lt;/h2&gt;

&lt;p&gt;Программирование высшего порядка. Что может прийти на ум сперва…&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/high_order.jpg&quot; alt=&quot;АрхиКодер!&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Архи-кодер владеющий программированием высшего порядка&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;А теперь серьезно. Программирование высшего порядка — это такие методы программирования с использованием процедур (функций) высшего порядка (или “первого” класса). Ага! А что это за порядок такой, если речь не про сакрально-волшебные сверхсилы просветленного программиста?&lt;/p&gt;

&lt;p&gt;Сперва нужно рассмотреть такую штуку, как &lt;em&gt;лексическое замыкание&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Собственно, замыкание — это такая функция, в которой есть ссылки на объекты (например переменные), объявленные вне тела этой функции. В коде это выглядит как объявление функции в другой функции. Вот эта последняя, “внутренняя” функция, фактически имеет доступ ко внешним, по отношению к ней объектам — переменным объявленным в теле “функции-обертки”, её аргументам.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Бугурт алерт!&lt;/strong&gt; Здесь и далее примеры на пайтонопсевдокоде! Помните, что мы сейчас изучаем Декларативную модель, &lt;em&gt;т е о р и ю&lt;/em&gt;, а не прикладную практику. Это всё техники, реализация которых на одном языке будет выглядеть так, на другом иначе.&lt;/p&gt;

&lt;p&gt;Пример:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# &quot;замыкающая&quot;, внешняя функция
def mad_printer(some_new_law):

    # вложенная функция
    def actual_printer():
        print(some_new_law)

    return actual_printer

emergency_law = mad_printer(&quot;freedom is slavery&quot;)
emergency_law()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;На выходе будет получена строка, переданная в замыкающую функцию - “freedom is slavery”.&lt;/p&gt;

&lt;p&gt;Хотя функция actual_printer и не имеет в своем теле переменной some_new_law, мы видим что такой код работает без проблем. Можно сказать, что в примере выше мы привязываем определенное замыкание к переменной emergency_law. И это замыкание включает в себя &lt;em&gt;возвращаемую функцию actual_printer и доступное ей окружение&lt;/em&gt;.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Замыкание — это некоторая форма &lt;em&gt;записи&lt;/em&gt; которая хранит в себе &lt;em&gt;функцию первого порядка&lt;/em&gt; вместе с её окружением.&lt;/p&gt;

&lt;p&gt;Ладно, ладно. А что такое функция первого порядка, не только в декларативной модели, а в программировании вообще?&lt;/p&gt;

&lt;p&gt;Можно сказать, что система (язык программирования) имеет функции первого &lt;em&gt;класса&lt;/em&gt;, если функции рассматриваются как &lt;em&gt;объекты первого класса&lt;/em&gt;. Объект первого класса — это “элементы”, а по сути типы, которые могут передаваться как параметры, возвращаться их функций или присваиваться как значение переменным.&lt;/p&gt;

&lt;p&gt;Иными словами, функция первого класса означает, что есть такой тип как функция, и любая реально объявляемая функция автоматически становится значением соответствующего типа.&lt;/p&gt;

&lt;p&gt;Сам термин &lt;em&gt;высшего порядка&lt;/em&gt; исходит от концепции &lt;em&gt;порядка процедуры&lt;/em&gt;. Если у какой то процедуры в аргументах нет других процедур — это функция нулевого порядка. Процедура, у которой есть хотя бы один аргумент-процедура — процедура первого порядка. Порядок процедуры можно определить как n + 1, если у этой процедуры есть хотя бы один аргумент n порядка, и нет других аргументов &lt;em&gt;более высокого порядка&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Получатся что функция может быть функцией первого класса, так как в системе есть вышеупомянутые критерии, но может не быть функцией первого порядка, если не имеет в аргументах других функций. В таком случае это, можно сказать, функция первого класса нулевого порядка :)&lt;/p&gt;

&lt;p&gt;Короче говоря, программирование высшего порядка, по сути, это о том что процедуры могут быть любого порядка. Никакой магии, но надеюсь вы уже начали понимать, что потенциал у этой техники очень большой.&lt;/p&gt;

&lt;h2 id=&quot;основные-заклинания&quot;&gt;Основные заклинания&lt;/h2&gt;

&lt;p&gt;В основе всех программистских техник высшего порядка лежат следующие четыре операции:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Процедурная абстракция;&lt;/li&gt;
  &lt;li&gt;Обобщение;&lt;/li&gt;
  &lt;li&gt;Инстанцирование;&lt;/li&gt;
  &lt;li&gt;Встраивание.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;процедурная-абстракция&quot;&gt;Процедурная абстракция&lt;/h3&gt;

&lt;p&gt;На самом деле мы уже давно говорили о процедурных абстракциях. Настала пора четко декларировать термин.&lt;/p&gt;

&lt;p&gt;Процедурная абстракция — это, по существу, определение процедуры. Мы оборачиваем программные инструкции в процедуру, внутрь заголовка процедуры, и в результате получаем блок кода (процедурное значение — замыкание), который не выполняется до тех пор, пока не будет вызван.&lt;/p&gt;

&lt;p&gt;Вызов процедуры приводит к тому же результату, к которому приведет выполнение инструкций из её тела.&lt;/p&gt;

&lt;p&gt;У процедурных абстракций существуют параметры, которые влияют на выполнение тела процедуры.&lt;/p&gt;

&lt;p&gt;Фактически это основа основ парадигмы программирования высшего порядка, поддерживается во многих языках, а так же лежит в основе ООП.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Процедурные абстракции позволяют представить любую программную логику как значение процедуры.&lt;/p&gt;

&lt;h3 id=&quot;обобщение&quot;&gt;Обобщение&lt;/h3&gt;

&lt;p&gt;Обобщить функцию — обозначает, что любая операция или значение может становиться &lt;em&gt;аргументом в теле функции&lt;/em&gt;. Мы абстрагируем эту сущность от тела функции, а её (сущности) значение задается когда функция явно вызывается. Каждый раз, при вызове обобщенной функции, может задаваться другая сущность.&lt;/p&gt;

&lt;p&gt;Вернемся назад к итеративным вычислениям, и разберем обобщение на примере функции, суммирующей значения элементов списка. Например, мы можем написать такую декларативную функцию:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def function summary_list_values(some_list)
    if some_list == []:
        return 0
    end

    list_head = some_list[0]
    list_tail = some_list[1:]
    return list_head + summary_list_values(list_tail)
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Тут есть два нейтральных элемента: 0, который мы возвращаем если some_list опустел, и операция сложения. Эти нейтральные элементы можно обобщить, сделав более универсальную функцию. Например, из примера выше можно сделать функцию FoldR. Такая функция есть во многих функциональных языках, это &lt;em&gt;функция-свертка&lt;/em&gt;, схема рекурсивных вызовов которой раскручивается в цепочку, пока не будет достигнуто самое право, по сути последнее в списке, значение, после чего начнутся сами вычисления. Есть ещё FoldL, в которой вычисления начинаются СРАЗУ, то есть с “левой ассоциацией”, считаем сразу и не ждем “правого конца”.&lt;/p&gt;

&lt;p&gt;Обобщим функцию, которую написали ранее следующим образом:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def FoldR(some_list, some_function, some_element)
    if some_list == []:
        return some_element
    end

    list_head = some_list[0]
    list_tail = some_list[1:]
    return some_function(list_head, FoldR(list_tail, some_function, some_element))
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обобщенная функция может получать на вход не только список, а функцию, которой будут обрабатываться вычисления среди элементов, и нейтральный элемент some_element. Эту функцию можно использовать для любых похожих ассоциативных вычислений, когда порядок аргументов some_function не важен для результата.&lt;/p&gt;

&lt;h3 id=&quot;инстанцирование&quot;&gt;Инстанцирование&lt;/h3&gt;

&lt;p&gt;О, это очень классная штука! Инстанцирование обозначает возможность возвращать процедуру\функцию как результата вызова другой процедуры\функции. 
Инстанцирование реализуется с помощью &lt;em&gt;фабрик&lt;/em&gt; или &lt;em&gt;генераторов функций&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Очень простой и грубый пример:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# генератор
def factory_function(calc_function):
    def inner_function(x,y):
        return calc_function(x,y)
    return inner_function

# какая то функция с вычислениями, которую скормим генератору
def addition(a,b):
    return a+b

# генерируем функцию
f = factory_function(addition)

# вернет 2
print(f(1, 1))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Очевидно что вычисления и логика внутри генератора может быть намного сложнее. Что нам это вообще дает? В первую очередь, это дает гибкость реализации каких то частей программы, которые если нужно мы можем менять на лету без особых проблем.&lt;/p&gt;

&lt;p&gt;Например, у нас может быть универсальная функция-фабрика для сортировки списков. Мы можем передавать в неё конкретный алгоритм сортировки, получая на выходе функцию, реализующую этот алгоритм.&lt;/p&gt;

&lt;h3 id=&quot;встраивание&quot;&gt;Встраивание&lt;/h3&gt;

&lt;p&gt;Примером реализации техники встраивания являются &lt;em&gt;ленивые&lt;/em&gt; вычисления. Это такие вычисления, когда вместо того, чтобы вычислять сразу всё (жадно), генерируется лишь необходимый “кусок” данных. Иными словами, техника встраивания заключается в постепенном выстраивании структуры данных, по мере запросов к элементам этой структуры. Реализуется это, собственно “встраиванием” в структуру данных некоторого кода, который генерирует соответствующие структуре и запросу данные.&lt;/p&gt;

&lt;h2 id=&quot;абстракция-цикла&quot;&gt;Абстракция цикла&lt;/h2&gt;

&lt;p&gt;Ранее мы разбирали рекурсии и итеративные вычисления. Грубо говоря, итеративные вычисления это и есть циклы. Но в декларативной модели описание таких вычислений выходит громоздким, так как требуются явные рекурсивные вызовы. Мы уже разобрали процедурную абстракцию и обобщение. Так почему бы не сделать циклы более лаконичными, выразительными?&lt;/p&gt;

&lt;p&gt;Например, классический цикл for — это целочисленный цикл, который получает на вход четыре параметра: начальное значение, конечное значение, шак, и процедуру для вычислений в каждой итерации:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def my_for(start_value, end_value, step, procedure):

    if start_value &amp;gt; end_value:
        return

    procedure(start_value)

    my_for(start_value + step, end_value, step, procedure)   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Цикл, для вычислений по элементам списка, можно выразить так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def for_list_elements(some_list, procedure):
    if some_list == []:
        return

    list_head = some_list[0]
    list_tail = some_list[1:]

    procedure(list_head)
    for_list_elements(list_tail, procedure)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это всё хорошо. Но что если нам нужно сделать какие-то более прикладные вычисления, а не просто вывести данные, или применить процедуру к каждому элементу? Ну например, хотя бы снова суммировать все элементы списка, или перемножить? Помните &lt;em&gt;аккумуляторы&lt;/em&gt; из &lt;a href=&quot;/2022/02/20/hack_in_declarative_model_3.html&quot;&gt;Части 3&lt;/a&gt;?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def my_for_acc(start_value, end_value, step, procedure, accumulator):
    if start_value &amp;gt; end_value:
        return accumulator

    accumulator = procedure(accumulator, start_value)
    my_for_acc(start_value + step, end_value, step, procedure, accumulator)   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Передадим туда, процедурой, например такой “сумматор”:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def my_sum(x,y):
    return x + y
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;И вызовем как-то так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(my_for_acc(1, 10, 1, my_sum, 0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обработка списков с аккумулятором может выглядеть так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def for_list_elements_acc(some_list, procedure, accumulator)
    if some_list == []:
        return accumulator

    list_head = some_list[0]
    list_tail = some_list[1:]
    accumulator = procedure(accumulator, list_head)

    for_list_elements_acc(list_tail, procedure, accumulator)


def my_sum(x,y)
    return x + y


print(for_list_elements_acc([3,2,1], my_sum, 0))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Это будет работать как функция FoldL, о которой упоминалось ранее.&lt;/p&gt;

&lt;h3 id=&quot;всё-дело-в-переменной&quot;&gt;Всё дело в “переменной”&lt;/h3&gt;

&lt;p&gt;Так вот, про Folr, а точнее про &lt;em&gt;folding&lt;/em&gt; — это схема цикла с аккумулятором для обработки списков, суть которой заключается во внедрении операций между значениями списка.&lt;/p&gt;

&lt;p&gt;На самом деле способ вычисления этой конструкции зависит от компилятора, и зачастую на выходе мы получаем хорошую производительность благодаря распараллеливанию вычислений.&lt;/p&gt;

&lt;p&gt;Во многих языках программирования цикл, например for, лингвистически выглядит почти одинаково — мы пишем, собственно for и следом имя для цикла.&lt;/p&gt;

&lt;p&gt;Фактически это объявление то же самое, что передача тела цикла, следующего за определением в отдельную процедуру, которая многократно вызывается на основании счетчика-аргумента передаваемого в объявлении цикла.&lt;/p&gt;

&lt;p&gt;Хотя такое лингвистическое определение внешне может ничем не отличаться как в декларативных языках или иных других, например императивных, имеется очень важное отличие. Мы уже подробно изучали декларативные переменные, речь здесь идет как раз об этом — в императивных языках счетчик цикла является &lt;em&gt;изменяемой переменной&lt;/em&gt;, тогда как декларативных цикл работает совсем иначе.&lt;/p&gt;

&lt;p&gt;В декларативном цикле на каждой итерации объявляется &lt;em&gt;новая переменная&lt;/em&gt;, обращение к которым происходит по &lt;em&gt;одному&lt;/em&gt; идентификатору. Благодаря такой модели все итерации полностью независимы друг от друга, могут выполняться одновременно, а результат вычислений будет детерминирован.&lt;/p&gt;

&lt;p&gt;Такой финт в императивной модели провернуть нельзя, так как внутри параллельных итераций вообще нет никакой уверенности в том что мы получаем доступ к правильному значению счетчика.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Все совпадения с “реальностью” случайны. В следующий раз поговорим о Data-driven и абстрактных типах данных.&lt;/p&gt;

&lt;p&gt;Enough for today! See y’all. Peace and love.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 5.</summary></entry><entry xml:lang="ru"><title type="html">Рекурсивные типы и другие Декларативные джедайские техники.</title><link href="http://localhost:4000/2022/02/27/hack_in_declarative_model_4.html" rel="alternate" type="text/html" title="Рекурсивные типы и другие Декларативные джедайские техники." /><published>2022-02-27T00:00:00+03:00</published><updated>2022-02-27T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/27/hack_in_declarative_model_4</id><content type="html" xml:base="http://localhost:4000/2022/02/27/hack_in_declarative_model_4.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 4. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Здравствуйте! На самом деле декларативная модель сама по себе — Джедайская техника, а именно итеративная “рекурсия”. В этом посте мы скорее разберем области применения.&lt;/p&gt;

&lt;h3 id=&quot;списки-различий&quot;&gt;Списки различий&lt;/h3&gt;

&lt;p&gt;Кроме списков существуют другие рекурсивные типы данных, например — Списки различий. На самом деле это особый тип данных, который состоит из &lt;em&gt;двух списков&lt;/em&gt;. Эти списки связаны друг с другом таким способом, что &lt;em&gt;второй&lt;/em&gt; список может быть получен из &lt;em&gt;первого&lt;/em&gt;, если из этого первого списка удалить некоторое число элементов (в том числе нулевое, то есть эти списки могут быть по сути “равны”).&lt;/p&gt;

&lt;p&gt;Фактически, списки различий, являются &lt;em&gt;одним из&lt;/em&gt; типов данных, которые классифицируются как &lt;strong&gt;структуры различий&lt;/strong&gt;. Суть таких типов мы уже разобрали — это пары значений, одно из которых “встроенно” в другое.&lt;/p&gt;

&lt;p&gt;Структура различий &lt;em&gt;A&lt;/em&gt;, которая, например, состоит из &lt;em&gt;B&lt;/em&gt; и &lt;em&gt;С&lt;/em&gt;, отражает значение равное &lt;em&gt;B минус C&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В данном случае мы разбираем списки различий, потому что у них есть интересная особенность:
&lt;em&gt;Хвост списков различий может быть &lt;strong&gt;не определен&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы можем это легко представить. Как вы помните, список — рекурсивен, и условно всегда состоит из “Головы” и “Оставшейся части”. В списках различий, если мы итеративно добираемся до “хвоста”, то “оставшаяся часть” является не пустым списком, а &lt;em&gt;неопределенной декларативной переменной&lt;/em&gt; (она “есть” но ещё не связанна со значением. См. предыдущие посты), и в первом, и во втором списке различий.&lt;/p&gt;

&lt;p&gt;Что нам это дает? Самое главное преимущество, это то, что мы можем сложить оба списка за константное время O(1), вообще не зависимо от длинны списков. Это делается очень просто — неопределенную переменную в конце первого списка &lt;em&gt;инициализируем&lt;/em&gt; ссылкой на второй список. Вуаля.&lt;/p&gt;

&lt;p&gt;Цена такого трюка велика — мы можем провернуть это сложение списков только один раз, так как первый список просто перестает существовать.&lt;/p&gt;

&lt;h3 id=&quot;в-очередь&quot;&gt;В очередь!&lt;/h3&gt;

&lt;p&gt;В классической императивной модели очередь — это интуитивно понятная структура данных, которая работает на базе списка по принципу “первый вошел — первый вышел” (FIFO). У очереди есть только две операции (метода) без каких либо аргументов: добавить элемент в хвост очереди, удалить элемент из головы.&lt;/p&gt;

&lt;p&gt;Прямо как в супермаркете.&lt;/p&gt;

&lt;p&gt;В императивной модели очередь легко реализуется на основании другой структуры — &lt;em&gt;двусвязного списка&lt;/em&gt;. Это такой список, в котором элементы связываются указателями не только со следующими за ними элементами, но и с “оставшимися” позади. Благодаря этой двусвязности, методы очереди в императивной модели работают за О(1).&lt;/p&gt;

&lt;p&gt;А что в декларативной модели? Как вы помните, в декларативной модели нет указателей и нет “классических” переменных. Ну, используя “декларативный” список мы можем добавлять новые элементы в голову за О(1), но удалять из хвоста придется за линейное время О(n), так как каждый раз для этого придется рекурсивно пробегать по списку до самого хвоста, чтобы просто его найти.&lt;/p&gt;

&lt;p&gt;О(n) — не надо нам, O(n). Это долго. В декларативной модели есть способ реализовать полноценную &lt;em&gt;О(1) очередь!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Выглядит это так. Берется два декларативных списка, которые выступают как значение полей в другом базовом типе декларативной модели — &lt;em&gt;записи&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Первый список хранит одну половину очереди, второй — другую, но в &lt;em&gt;обратном порядке&lt;/em&gt;. Вторую половину мы переворачиваем чтобы добавлять в “хвост” как в “голову” за О(1). А из фактической головы очереди, которая находится в первом не перевернутом списке, мы итак можем удалять за константное время.&lt;/p&gt;

&lt;p&gt;Есть два нюанса. Первый ― менять значение полей &lt;em&gt;записи&lt;/em&gt; в декларативной модели нельзя. Поэтому любая операция над очередью всегда будет возвращать в качестве значения очереди новую “сущность”. Это важно понимать: &lt;strong&gt;Нельзя использовать одну и ту же очередь в качестве аргумента для разных операций&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Второй — если в какой то момент нам понадобиться получить очередь целиком, придется взять вторую половину, перевернуть её, слепить с первой половиной (представить как один список). И при этом этот список всё ещё должен оставаться очередью (нам надо что-то добавлять, удалять), значит он будет значением первого поля записи-очереди.&lt;/p&gt;

&lt;p&gt;В общем выглядит совсем не как O(1)… То есть, если у нас будет программа, в которой нам не только нужно пользоваться методами добавления/удаления элементов в очередь, но ещё и часто возвращать эту очередь как единое значение, эффективность страдает.&lt;/p&gt;

&lt;p&gt;И что с этим делать? Прочитайте ещё раз про списки различий :)&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/mind_blowing.gif&quot; alt=&quot;Взрыв Мозга&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;персистентные-структуры&quot;&gt;Персистентные структуры&lt;/h3&gt;

&lt;p&gt;В ряде случаев может возникнуть необходимость хранить историю изменений какого-либо типа данных. Очередь или иной объект, предоставляющий такую возможность называется &lt;em&gt;персистентной структурой&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Как такое можно реализовать? Первое что приходит на ум, это реализация отдельной очереди или списка, в которой значениями элементов будут выступать “исторические” состояния другого типа данных, доступные только для чтения.&lt;/p&gt;

&lt;p&gt;Только вот если мы захотим сохранять состояния типа данных, в котором миллион значений, да еще и состояние меняется очень динамично… Ну вы поняли  — &lt;strong&gt;не эффективно!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Для реализации персистентных структур разработаны сложные алгоритмы, разбор которых выходит за рамки поста. На данный момент нам просто нужно знать что такие структуры есть.&lt;/p&gt;

&lt;h3 id=&quot;снова-про-эффективность&quot;&gt;Снова про эффективность&lt;/h3&gt;

&lt;p&gt;Декларативная модель — сила, математическая мощь, исток всех парадигм! Но это всё ещё программирование.
Не важно в какой парадигме мы будем программировать — всегда нужно помнить о &lt;a href=&quot;/2022/01/22/algorithms_complexity.html&quot;&gt;эффективности&lt;/a&gt; разрабатываемого нами алгоритма.&lt;/p&gt;

&lt;p&gt;Хорошая новость в том, что с позиции оценки сложности алгоритмов, декларативная модель проста. Самое главное — разумно учитывать &lt;em&gt;распространенность&lt;/em&gt; рекурсии.&lt;/p&gt;

&lt;p&gt;Кроме того, оптимизировать прожорливость по памяти проще, чем сократить время выполнение программы (оптимизировать математически).&lt;/p&gt;

&lt;p&gt;Алгоритм описанный в декларативной модели проще переписать в более “экономный” вид, используя схемы рассмотренные в прошлых постах (Итеративные вычисления, аккумулятор, etc.). Для большинства задач можно подобрать подходящую рекурсивную структуру данных, а саму память можно оптимизировать сборщиком мусора или алгоритмами сжатия.&lt;/p&gt;

&lt;p&gt;Но в математическом смысле оптимизированный “по памяти” код всё равно нельзя назвать “оптимальным”, простите за тавтологию. Есть определенная грань до которой мы можем улучшать программу, после достижений которой, все последующие улучшения практически не влияют на производительность и лишь усложняют программу. Это плохая практика.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Если нет явной необходимости — не нужно пытаться оптимизировать код!&lt;/p&gt;

&lt;p&gt;Фишка в том, что почти всегда &lt;em&gt;очень малый&lt;/em&gt; участок кода действительно влияет на время работы программной системы. Но есть нюанс — &lt;em&gt;не всегда этот участок очевиден даже опытным программистам&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Поэтому очень проектировать программы ясным способом, придерживаясь правил хорошего стиля и используя подходящие для решения конкретной задачи парадигмы.&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Правильно подобранная парадигма программирования &lt;strong&gt;всегда&lt;/strong&gt; повышает выразительность кода.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Спойлер к следующему посту:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Программирование высшего порядка;&lt;/li&gt;
  &lt;li&gt;Опять абстракции?&lt;/li&gt;
  &lt;li&gt;Как на самом деле работают циклы.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/no_identification.gif&quot; alt=&quot;Рекурсивные кролики&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Миру — Мир!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 4.</summary></entry><entry xml:lang="ru"><title type="html">Список списков, итеративные вычисления и прочие муми-тролли</title><link href="http://localhost:4000/2022/02/20/hack_in_declarative_model_3.html" rel="alternate" type="text/html" title="Список списков, итеративные вычисления и прочие муми-тролли" /><published>2022-02-20T00:00:00+03:00</published><updated>2022-02-20T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/20/hack_in_declarative_model_3</id><content type="html" xml:base="http://localhost:4000/2022/02/20/hack_in_declarative_model_3.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 3. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;here-we-go-again&quot;&gt;Here we go again&lt;/h3&gt;
&lt;p&gt;Здравствуйте! Это очередной пост-отчёт по мотивам материала из курса &lt;a href=&quot;https://skillsmart.ru/&quot;&gt;школы Сергея Бобровского&lt;/a&gt; – Как понять в программировании всё. Изучаем декларативную вычислительную модель.&lt;/p&gt;

&lt;p&gt;В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.&lt;/p&gt;

&lt;p&gt;Рекурсия как программистский трюк не ограничивается “самовызовом” (прочитали как самовывоз, признайтесь?) функций — &lt;em&gt;рекурсивными могут быть и типы данных&lt;/em&gt;. Базовый пример рекурсивного типа данных — список.&lt;/p&gt;

&lt;p&gt;Почему список на самом деле рекурсивная структура? Потому что он определяется &lt;em&gt;в терминах более короткой версии себя самого&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и &lt;em&gt;“список”&lt;/em&gt;, а лучше сказать набор или “последовательность” пар “ключ-значение”.&lt;/p&gt;

&lt;p&gt;Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список.&lt;/p&gt;

&lt;p&gt;Как правило этими “произвольными” значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка “впихнуть” в эти “кусочки” какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда).&lt;/p&gt;

&lt;p&gt;Части списка связанны некоторым образом с другими, и всё вместе (“элементарный кусок данных” и связь-указатель на другой) называется &lt;em&gt;узел&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.&lt;/p&gt;

&lt;p&gt;Вернемся к фундаментальным материям :)&lt;/p&gt;

&lt;p&gt;В декларативной модели список определяется &lt;em&gt;рекурсивно&lt;/em&gt;. Считается, что либо список пустой (nil или, если хотите, None), либо &lt;em&gt;есть какое-то значение связанное со списком&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, “узел” содержащий строку “shrek”, то тогда список X будет равен “shrek” &lt;em&gt;связанный со списком nil&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Короче говоря, “последний” элемент в списке всегда будет “указывать” на “пустой список”.&lt;/p&gt;

&lt;p&gt;Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.&lt;/p&gt;

&lt;p&gt;В рекурсивных функциях, работающих со списками, &lt;em&gt;базовым случаем&lt;/em&gt; будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов &lt;em&gt;более мелких списков&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Например, “декларативная” рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def list_length(some_list):
    if some_list == []
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    return 1 + list_length(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — “Ух ты ж сколько можно то намутить с этим списком!”&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/hold_on.gif&quot; alt=&quot;Подождите!&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Это всё ещё рекурсивная функция, мы в прошлый уже говорили про проблему с переполнением стека. Кроме того, рекурсивные функции со списками, при их необдуманном определении, вполне могут оказываться крайней не эффективными — O(n*n) или ещё хуже.&lt;/p&gt;

&lt;p&gt;Для решения этих проблем есть техника, при которой рекурсивные функции превращаются в функции с &lt;em&gt;итеративной формой вычисления&lt;/em&gt; с &lt;strong&gt;линейной&lt;/strong&gt; эффективностью!&lt;/p&gt;

&lt;h3 id=&quot;итерируй-то&quot;&gt;Итерируй то&lt;/h3&gt;

&lt;p&gt;Ранее мы говорили про итеративные вычисления как о частном случае рекурсии. Разберемся чуть глубже.&lt;/p&gt;

&lt;p&gt;Во-первых стек. Почему он вообще формируется при рекурсивном вызове? Обратите внимание на пример функции вычисления длинны списка, а именно на хвостовой return в конце. Раз за разом при рекурсивном вызове окружение экземпляра функции должно сохраняться в стеке, потому что прибавление единицы происходит &lt;strong&gt;после&lt;/strong&gt; этого заключительного return.&lt;/p&gt;

&lt;p&gt;В нашем примере это всё происходит лишь для того, чтобы потом в обратном порядке “размотать” стек и просуммировать единцы. Кажется избыточным.&lt;/p&gt;

&lt;p&gt;Чем отличается итеративное вычисление от обычной рекурсии?&lt;/p&gt;

&lt;p&gt;Схема итеративных вычислений — это &lt;em&gt;последовательность &lt;strong&gt;трансформации состояний&lt;/strong&gt;&lt;/em&gt;. Как это работает?&lt;/p&gt;

&lt;p&gt;Ну, по сути, мы добавляем некоторый счетчик в аргумент рекурсивной функции, и делаем так чтобы увеличение этого счетчика &lt;em&gt;происходило &lt;strong&gt;до&lt;/strong&gt; рекурсивного вызова&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Рекурсивная-итеративная функция вычисления длины списка будет выглядеть так:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Обратите ещё раз внимание на счетчик &lt;em&gt;i&lt;/em&gt;. Мы увеличиваем его в аргументах рекурсивного вызова, &lt;strong&gt;до&lt;/strong&gt; самого вызова. Благодаря этому мы “замыкаем” окружение функции и состояние каждого экземпляра не требуется сохранять в отдельных записях в стеке.&lt;/p&gt;

&lt;p&gt;Ничего не мешает скрыть такую функции за функцией-абстракцией, которая будет принимать только list, а внутри вызывать inter_list_length(0, list).&lt;/p&gt;

&lt;h3 id=&quot;итерируй-это&quot;&gt;Итерируй это&lt;/h3&gt;

&lt;p&gt;Видите как связана “рекурсивность функции” с “рекурсивностью типа”, который она обрабатывает?&lt;/p&gt;

&lt;p&gt;Это &lt;strong&gt;важная фишка&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Мы уверенно можем сказать, что &lt;em&gt;рекурсивная структура функции зависит от рекурсивной структуры определения обрабатываемого типа данных&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы потенциально можем нагородить какой угодно рекурсивный тип, но это не есть хорошо. Эта свобода в программировании часто приводит к написанию очень неэффективных, не грамотных алгоритмов.&lt;/p&gt;

&lt;p&gt;Само по себе определение какого-то типа данных в языке программирования &lt;em&gt;описательно&lt;/em&gt;. Это значит, что такое определение является всего лишь набором логических утверждений о множестве значений, который данный тип может принять. Такие определения не являются полноценными проверками допустимостей значений, а зачастую (например какой нибудь абстрактный тип) их вообще проверить нельзя.&lt;/p&gt;

&lt;p&gt;В декларативной модели даже базовые типы могут быть не проверенны компилятором. Поэтому нам &lt;strong&gt;важно&lt;/strong&gt; предельно осознанно понимать что мы кодим, и использовать изначально свойственные декларативной модели типы данных.&lt;/p&gt;

&lt;p&gt;Список это very handy! Надо лишь включить думалку, и включить так, чтобы избежать неэффективных реализаций алгоритмов.&lt;/p&gt;

&lt;p&gt;Вернемся к нашему определению взаимосвязи рекурсивности типа с рекурсивностью функции.&lt;/p&gt;

&lt;p&gt;Сперва нам необходимо &lt;em&gt;правильно определить рекурсивный тип&lt;/em&gt;, прежде чем писать для него функцию. Что это значит?&lt;/p&gt;

&lt;p&gt;Например, у нас есть некий композитный список, элементы которого тоже могут быть списками, и нам надо посчитать количество всех значений, включая значений во вложенных списках.&lt;/p&gt;

&lt;p&gt;Нам нужно понять, или &lt;em&gt;определить&lt;/em&gt; тип “вложенный список”.&lt;/p&gt;

&lt;p&gt;Мы помним что “список” — это либо пустой [], либо некоторый “элемент” связанный с [].&lt;/p&gt;

&lt;p&gt;В таком случае “вложенный список” будет определяться как — либо пустой [], либо “вложенный список” связанный с “вложенным списком”, либо как “элемент” связанный с “вложенным списком”. Ничего не понятно?&lt;/p&gt;

&lt;p&gt;Короче говоря, у нас в любом порядке и в “ширину” и в “глубину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых в любом порядке и в “глубину” и в “ширину” элементы могут быть либо “простыми” элементами-значениями, либо списками, в которых…&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/recursion_1.gif&quot; alt=&quot;Рекурсия&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Неотложка уже выехала.&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Так, давайте не будем пороть горячку! Это проще чем кажется.&lt;/p&gt;

&lt;p&gt;Вложенный список, с которым может быть связан вложенный список, все ещё “обычный” список, который может быть пустым (то есь может “не быть”! Ом!) Мы с этого и начали определение.&lt;/p&gt;

&lt;p&gt;Тогда функция, основанная на таком типе будет иметь структуру:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def length_1(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if type(some_list) is list:
        return length_1(list_head) + length_1(list_tail)
    
    return 1 + length_1(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;А если структура типа будет другой? Функция будет иметь &lt;em&gt;другую&lt;/em&gt; логику. К примеру у нас есть тип подобный предыдущему, но нам не важно количество элементов во вложенных списках, и мы хотим лишь посчитать элементы на “верхнем” уровне. Не важно — является этот элемент списком или нет.&lt;/p&gt;

&lt;p&gt;Поймите, речь идет о &lt;em&gt;логическом&lt;/em&gt; определении типа.&lt;/p&gt;

&lt;p&gt;В таком случае тип “вложенный список 2” мы будем определять как — либо пустой [], либо “вложенный список 2” связанный со “вложенным списком 2”, либо как &lt;em&gt;элемент “верхнего” уровня&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ключевое отличие с прошлым примером в том, что тогда “вложенный список” всегда считался списком, а на этот раз он может считаться как простой элемент.&lt;/p&gt;

&lt;p&gt;Функция:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def length_2(some_list):
    if some_list == []:
        return 0
    
    list_head = some_list[0]
    list_tail = some_list[1:]

    if list_tail == []:
        return 1
    
    return length_2(list_head) + length_2(list_tail)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ключевой момент тут это проверка list_tail == [], суть которого в том, что если рекурсия добралась до случая, когда хвост элемента является пустым списком мы возвращаем единицу, как бы “забивая” на то, что “проваливались” во вложенный список.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Эти простые примеры приводятся как пример для понимания способа которым мы должны мыслить о рекурсивных вычислениях в декларативной модели. Почему нам всегда важно понимать логику алгоритма, и учитывать структуру рекурсивного типа, с которым работаем.&lt;/p&gt;

&lt;p&gt;Декларативная модель дает нам мощный и изящный инструмент — &lt;em&gt;минималистичность&lt;/em&gt;, которым можно и нужно пользоваться при разработке алгоритмов (если это возможно). Декларативная модель удобна и исключает множество потенциальных ошибок, если мы четко определяем типы и понимаем что делаем.&lt;/p&gt;

&lt;h3 id=&quot;аккумуляторы&quot;&gt;Аккумуляторы!&lt;/h3&gt;

&lt;p&gt;На этом моменте мы уже выяснили как писать рекурсивные функции, делать из них итеративные и как корректно определять и применять рекурсивные типы данных. Так а зачем тогда рекурсивные функции? &lt;em&gt;А не зачем&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В боевой разработке с использованием декларативной модели функции &lt;em&gt;сразу пишут итеративными&lt;/em&gt;! Мы разобрали эти тонкости сугубо в целях понимания и изучения.&lt;/p&gt;

&lt;p&gt;Давайте повторим для закрепления. Вся фишка итеративных вычислений в &lt;em&gt;передаче значения&lt;/em&gt; все “глубже” в рекурсию. Мы никогда не возвращаемся обратно с помощью return.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/buzz.gif&quot; alt=&quot;Базз&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Ну или пока память не кончится :D&lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Отставить шуточки! Как это работает?&lt;/p&gt;

&lt;p&gt;Возьмем состояние, которое передаем в функцию как S. Возьмем это состояние и расширим двумя аргументами, S1 и Sn.&lt;/p&gt;

&lt;p&gt;Такой финт называется — &lt;em&gt;аккумулятор&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы берем этот аккумулятор и передаем его в &lt;strong&gt;процедуру&lt;/strong&gt; (не функцию!). В первом посте мы говорили о том, что декларативная процедура работает в своих параметрах с указателями на ещё &lt;em&gt;не инициализированные&lt;/em&gt; декларативные переменные. Иными словами, результат работы процедуры возвращается через эти параметры &lt;em&gt;по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В аккумуляторе: S1 является входным состоянием, а Sn — выходным, то есть результатом. Внутри такой процедуры происходит её рекурсивный вызов выполняющий последовательные преобразования Si в Si+1 (итеративные, тысяча чертей!!!)&lt;/p&gt;

&lt;p&gt;Псевдокод:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;procedure(S, S1, Sn):
если вычисления S не требуются:
    Sn = S1
иначе:
    ## начинается блок рекурсивных вызовов
    procedure1(S1, S2)
    procedure2(S2, S3)
    ...
    procedureN(Sn-1, Sn)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Выход каждой procedureI является входом procedureI+1&lt;/p&gt;

&lt;p&gt;Как уже объяснялось, отличие от рекурсивной функции в том, что нам не надо сохранять в стеке все промежуточные состояния-вызовы, так как значения передаются по ссылке. А “базовым случаем-ограничением” рекурсии, может быть указание границы обработанных элементов в исходной структуре S.&lt;/p&gt;

&lt;p&gt;Когда мы в этом посте разбирали итеративные вычисления на примере функции iter_length:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;iter_list_length(i, some_list):
    if some_list == []:
        return 0
    
    return iter_list_length(i+1, some_list[1:])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Мы практически использовали &lt;em&gt;схему с аккумулятором&lt;/em&gt;, передавая текущую длину в следующий вызов &lt;em&gt;по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Фактически в наши дни такая схема с аккумуляторами считается устаревшей, и их чрезмерное использование лишь затруднит программирование.&lt;/p&gt;

&lt;p&gt;Схема с аккумуляторами имеет право на жизнь, когда получается ограничиться минимальным количеством аккумуляторов (1-2).&lt;/p&gt;

&lt;p&gt;Тем не менее, пользу от знания таких фундаментальных приемов невозможно переоценить в контексте прокачки нашей аналитической и программистской машинки мозга.&lt;/p&gt;

&lt;p&gt;И вот ещё повторим — хотя в итеративных вычислениях мы не проваливаемся в стек “в глубину”, память потенциально может кончиться ещё как! Мы “разматываем” состояние “в ширину”.&lt;/p&gt;

&lt;p&gt;Спасибо за внимание.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 3.</summary></entry><entry xml:lang="ru"><title type="html">Бери и DRY, и так далее</title><link href="http://localhost:4000/2022/02/13/dry_etc.html" rel="alternate" type="text/html" title="Бери и DRY, и так далее" /><published>2022-02-13T00:00:00+03:00</published><updated>2022-02-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/13/dry_etc</id><content type="html" xml:base="http://localhost:4000/2022/02/13/dry_etc.html">&lt;p&gt;Рассматриваем пару универсальных принципов разработки.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h3 id=&quot;лучше-сухо-чем-мокро&quot;&gt;Лучше сухо, чем мокро!&lt;/h3&gt;

&lt;p&gt;Аббревиатура принципа DRY расшифровывается как Don’t repeat yourself, что недвусмысленно переводится как “Не повторяйся”. Само сокращение является словом dry — сухой, и нарушение принципа окрестили как WET (мокрый) — Write everything twice (Пиши всё дважды) или We enjoy typing (Нам нравится печатать).&lt;/p&gt;

&lt;p&gt;Разумеется уровень влажности тут вообще не при чем :)&lt;/p&gt;

&lt;p&gt;Вероятно вы уже встречали упоминание DRY. О нем часто говорят в бесплатных и платных уроках программирования, но как правило речь только в контексте написания кода (programming-in-small).&lt;/p&gt;

&lt;p&gt;На самом деле этому универсальному принципу можно, и обязательно нужно, следовать на всех уровнях проектирования системы.&lt;/p&gt;

&lt;h1 id=&quot;я-никогда-не-повторяюсь&quot;&gt;Я никогда не повторяюсь&lt;/h1&gt;
&lt;h3 id=&quot;неповторим-внутри&quot;&gt;Неповторим внутри&lt;/h3&gt;

&lt;p&gt;Как я уже сказал, чаще всего DRY преподносят как правило, при котором мы не должны повторно использовать (копировать) код, в разные части программы. Это лишь малая доля. Фишка в том, что DRY применим к любой сущности в системе, на любом уровне абстракции.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Если что-то где-то определено, оно должно быть определено только в этом месте.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;А что касаемо кода, то бывают случаи когда дублирование &lt;em&gt;оправдано&lt;/em&gt;. Например есть две высокоуровневые функции (методы), которые производят &lt;em&gt;похожие&lt;/em&gt; вычисления, но в разном контексте, и служат разным целям (всякие проверки истинности, etc).&lt;/p&gt;

&lt;h3 id=&quot;неповторим-снаружи&quot;&gt;Неповторим снаружи&lt;/h3&gt;

&lt;p&gt;В проектировании (programming-in-large) DRY работает аналогично. Во-первых, если есть какой-то конкретный модуль, то его спецификация должна быть единообразной и находиться в одном месте.&lt;/p&gt;

&lt;p&gt;Это значит, что нельзя просто копировать этот модуль, немного его изменять и встраивать в систему. Тогда в будущем при доработке, в случае изменений одного такого “модуля-клона”, нам придется менять то же самое и во втором. А если копий три, четыре…? Вы точно думаете что сможете вспомнить о них всех, я не говорю уже о совершенно очевидном неудобстве такой архитектуры. Это полный зашквар, не надо так делать.&lt;/p&gt;

&lt;p&gt;Во-вторых, программные интерфейсы (api) тоже должны быть единообразными, следовать спецификации. Представьте что “внутри” модули используют по разному описанные вызовы. Внешние вызовы тоже накостыляли по другому. Чувствуете аромат? Так пахнет горящая точка опоры, когда система рухнет из за того что мы поменяли один интерфейс, или &lt;em&gt;забыли&lt;/em&gt; поменять один из них, в соответствии с новыми требованиями.&lt;/p&gt;

&lt;p&gt;Во избежание этого можно использовать, например OpenAPI, или что-то в таком духе. Если мы разрабатываем собственный API, он должен быть корректно задокументирован и доступен &lt;strong&gt;в одном месте&lt;/strong&gt; (например в конкретном репозитории команды разработки).&lt;/p&gt;

&lt;h2 id=&quot;что-и-тут-тоже&quot;&gt;Что, и тут тоже?&lt;/h2&gt;

&lt;p&gt;Мы плавно подошли к документации. Многие разработчики не любят документировать проекты, и это &lt;strong&gt;плохо&lt;/strong&gt;. А если и ведут документацию то относятся очень халатно. Ctrl-c, Ctrl-v, Тяп ляп, и так сойдет!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Документация тоже должна следовать принципу DRY&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;На уровне комментариев кода (это ведь тоже документация), пример WET-поведения — зачем-то описывать подробными комментариями чуть ли не каждую функцию в коде. Ясный код должен говорить сам за себя и быть понятен читающему его программисту (например вам самим завтра или через неделю).&lt;/p&gt;

&lt;p&gt;Так зачем повторяться? Разве что код выглядит запутанным и совершенно непонятным? Если так, то это отдельная проблема и нужно решать её в первую очередь.&lt;/p&gt;

&lt;p&gt;На уровне документирования проекта — мы должны структурировать документы понятно, излагать информацию последовательно и, простите за тавтологию — &lt;em&gt;информативно&lt;/em&gt;. Документация это не удобный случай поупражняться в графомании.&lt;/p&gt;

&lt;p&gt;На самом деле писать код и писать текст по сути одно и то же, разве нет?&lt;/p&gt;

&lt;p&gt;Мы можем подойти к этой задаче почти так же, как к разработке программы. Декомпозируйте её! Если вы хорошо понимаете документируемый проект то это не вызовет проблем. Каждый модуль, согласно DRY, описывается в одном разделе документации, API в другом, и так далее.&lt;/p&gt;

&lt;h1 id=&quot;легко-поменять&quot;&gt;Легко поменять&lt;/h1&gt;

&lt;p&gt;Ещё один очень важный принцип, залог, хорошего проектирования — &lt;strong&gt;ETC&lt;/strong&gt;, или Easier to change!&lt;/p&gt;

&lt;p&gt;Мы все люди, и нам свойственно ошибаться в своих решениях. Разумеется и в разработке программных систем. Поэтому очень важно создавая что-то новое, или внося изменения в уже существующие части, всегда задаваться вопросом — “А будет ли в будущем это &lt;em&gt;легко изменить&lt;/em&gt;?”&lt;/p&gt;

&lt;p&gt;Подумайте, будет ли легко вносить изменения в проект, в котором строго следуют “сухому закону” DRY? (Я пытаюсь шутить, извините!)&lt;/p&gt;

&lt;p&gt;Разумеется будет!&lt;/p&gt;

&lt;p&gt;Этому принципу осознанности ETC нужно следовать даже (особенно!) в самых малых частях разработки, вплоть до написания функции из нескольких строк кода. Будет ли она легко заменимой, исправляемой? Ясно ли она описана?&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Верно утверждать что принцип DRY является логическим продолжением ETC. Вообще &lt;em&gt;любой&lt;/em&gt; подход хорошего проектирования исходит из ETC. Например, использование понятных имен переменных и функций непосредственно упрощает дальнейшее сопровождение кода.&lt;/p&gt;

&lt;p&gt;А если мы будем как можно больше компонентов делать &lt;a href=&quot;/2022/02/12/hack_in_declarative_model_2.html&quot;&gt;декларативными&lt;/a&gt;, это поможет? Да! Архитектура будет менее запутанной, с меньшей &lt;em&gt;связностью&lt;/em&gt;, и следственно более удобной в сопровождении.&lt;/p&gt;

&lt;p&gt;Куда не глянь, если что-то сделано хорошо, это сделано осознанными в ETC инженерами!&lt;/p&gt;

&lt;p&gt;Можно уйти в словоблудие и сказать, что оба эти принципа применимы не только как ценности проектирования программных систем, и исходят из более “фундаментальных” личностных качеств.&lt;/p&gt;

&lt;p&gt;Но я оставлю это вам как пищу для размышления.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Инструменты" /><category term="Размышления" /><summary type="html">Рассматриваем пару универсальных принципов разработки.</summary></entry><entry xml:lang="ru"><title type="html">Декларативное программирование и рекурсия.</title><link href="http://localhost:4000/2022/02/12/hack_in_declarative_model_2.html" rel="alternate" type="text/html" title="Декларативное программирование и рекурсия." /><published>2022-02-12T00:00:00+03:00</published><updated>2022-02-12T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/12/hack_in_declarative_model_2</id><content type="html" xml:base="http://localhost:4000/2022/02/12/hack_in_declarative_model_2.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 2. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Здравствуйте! Мы продолжаем изучать декларативную вычислительную модель. На этой неделе я добрался до более практичных тем, и начну рассказывать вам о том, как собственно устроено программирование в декларативном “стиле”.&lt;/p&gt;

&lt;p&gt;В прошлый раз мы разобрали декларативную модель с теоретической точки зрения, и в общих чертах должны хорошо понимать её внутреннее устройство.&lt;/p&gt;

&lt;h2 id=&quot;польза-декларативной-модели&quot;&gt;Польза декларативной модели&lt;/h2&gt;
&lt;h4 id=&quot;детерминированный-конструктор&quot;&gt;Детерминированный “конструктор”&lt;/h4&gt;
&lt;p&gt;Одна из главных крутостей декларативного программирования заключается в том, что декларативные программы &lt;strong&gt;композиционны&lt;/strong&gt;. Это значит, что программа состоит из некоторых &lt;em&gt;компонентов&lt;/em&gt;, каждый из которых, благодаря заложенным в вычислительной модели принципам, является строго и ясно ограниченной частью программы.&lt;/p&gt;

&lt;p&gt;В декларативной программе каждый компонент всегда хорошо различим, у него есть определенные входы и выходы. При этом компонент не обязательно является “малым” фрагментом кода, функций или процедурой. Процедура лишь частный вид компонента, и в более “сложном” компоненте могут быть определены другие, сохраняя всю декларативную ясность и мощь.&lt;/p&gt;

&lt;p&gt;Композиционность достигается благодаря свойственным декларативной модели качествам. Напоминаю, мы не используем “динамические переменные”, не храним внутренние состояния процедур\функций, не передаем их куда-то вовне. Получается что компоненты, “сущности сами в себе”, или по русски — независимые сущности. Выход из одной декларативной операции становится входом для другой, сайд-эффекты, фактически — невозможны.&lt;/p&gt;

&lt;p&gt;Благодаря этому качеству в декларативной модели мы можем разрабатывать сложные и &lt;em&gt;надежные&lt;/em&gt; системы.&lt;/p&gt;

&lt;h4 id=&quot;ясно-понятно&quot;&gt;Ясно, понятно&lt;/h4&gt;

&lt;p&gt;Вторая сила декларативного программирования вытекает и связана с первой — декларативные программы достаточно просты для понимания. Мы можем легко рассуждать о них сквозь призму, например, логического анализа. Чтобы понять программу в целом, нам нужно лишь понять все её компоненты.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Исходя из этого мы можем предположить, что можно забить на все остальные вычислительные модели, хорошо разобраться в декларативной, и все программы описывать только в ней. Жаль что это невозможно. Если бы все было так просто, то другие модели бы просто не появились. Дело в том, что задачи бывают разные, и для их решения подходят разные парадигмы.&lt;/p&gt;

&lt;p&gt;Но хорошая новость в том, что на уровне разработки (написания) кода отдельных функций или модулей (ещё это называется &lt;em&gt;programming-in-small&lt;/em&gt;), декларативный стиль применять можно &lt;strong&gt;всегда!&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;На самом деле так &lt;strong&gt;нужно&lt;/strong&gt; поступать. Это залог хорошего продукта не только в виде отдельных программных модулей, но и качественной программной системы в целом (&lt;em&gt;programming-in-large&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Компоненты не должны иметь лишних связей, потому что это приводит к запутыванию и усложнению системы. В такой ситуации мы не можем говорить о композиционности или понятности. Как разобраться в отдельной части, если она явным образом зависит от кучи других? А те, в свою очередь, от кучи других? А если не явным? Брррр.&lt;/p&gt;

&lt;p&gt;Другие вычислительные модели, свойством которых является тесная связь многих компонентов, &lt;em&gt;нужно использовать изолировано и в ограниченном количестве модулей&lt;/em&gt;. Мы пытаемся, как-бы, “компонизировать” части системы со сложными связями, чтобы сами эти части становились &lt;strong&gt;декларативными компонентами&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Вот вам новая мантра:&lt;/p&gt;

&lt;p class=&quot;info&quot;&gt;Я делаю как можно больше компонентов системы декларативными.&lt;/p&gt;

&lt;p&gt;Говорят, если повторять её каждый раз когда садишься программировать, и применять на практике — станешь хорошим инженером.&lt;/p&gt;

&lt;h2 id=&quot;рекурсия&quot;&gt;Рекурсия&lt;/h2&gt;

&lt;p&gt;Как много будоражащего ум в этом слове (пока не разобраться :) ). 
Помню в детстве я сидел в парикмахерской, и места там были напротив друг друга у противоположных стен, и зеркала соответственно. Слово рекурсия я тогда не знал, но залип &lt;em&gt;глубоко&lt;/em&gt; и надолго.&lt;/p&gt;

&lt;p&gt;В программировании рекурсией называют “прием”, когда в теле функции вызывается эта же функция. На самом деле рекурсия может применяться по разному, самый простой и частный случай это &lt;em&gt;прямая&lt;/em&gt; или простая рекурсия, когда функцию явно вызывает “саму себя”. Ещё рекурсии бывают &lt;em&gt;косвенные&lt;/em&gt; или — &lt;em&gt;непрямые&lt;/em&gt;. Это более хитрый способ, когда, например, функция А, вызывает функцию В, которая в свою очередь снова вызывает функцию А, и так далее.&lt;/p&gt;

&lt;p&gt;Если рекурсивный вызов в теле функции является последним оператором, то в этом случае такую рекурсию называют &lt;em&gt;хвостовой&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Глубина&lt;/em&gt; рекурсии определяется количеством рекурсивных вызовов. Как это работает? Ну, в общем, есть такая структура данных &lt;strong&gt;стек&lt;/strong&gt;. Наивно-абстрактно мы сейчас можем представить её как некоторую “вертикальную стопку” записей. Мы можем складывать туда записи одна за другой, и извлекать в обратном порядке, то есть забирать “верхние” записи поочередно.&lt;/p&gt;

&lt;p&gt;Например, возьмем рекурсивную функцию А и изначально пустой стек. В вызове А0 что-то происходит, этот вызов с его “окружением” помещается в виде записи в стек, и в процессе выполнения происходит рекурсивный вызов А1. Ситуация повторяется, А1 помещается в стек следом за А0, вызывается А2, и так далее.&lt;/p&gt;

&lt;p&gt;На самом деле это может происходить бесконечно, до тех пор пока не кончится память и стек не будет переполнен (stack overflow). Во избежание подобного в рекурсивных функциях определяют конечное условие, в случае удовлетворения которого функция должна что-то вернуть, а не снова провалиться в дальнейшую рекурсию.&lt;/p&gt;

&lt;p&gt;Это ещё называется “базовым случаем” — условие в рекурсивной функции, при котором не происходит рекурсивный вызов и функция завершая, как правило вернув какое-то значение. Соответственно, если проверка базового случая не проходит, функция выполняется дальше в “рекурсивный случай”.&lt;/p&gt;

&lt;p&gt;Возвращаясь к примеру выше, представим что в вызове А4 это конечное условие было удовлетворено. В результате мы имеем стек, условно, такого вида А0 -&amp;gt; А1 -&amp;gt; А2 - A3 -&amp;gt; A4. Стрелки в данном случае отображают последовательность рекурсивных вызовов. Получается, что результат работы А4 вернется в А3, оттуда в А2, А1, и наконец в изначальный вызов А0 (который в общем тоже имеет какой-то выход, в данном случае это не важно).&lt;/p&gt;

&lt;p&gt;Если вы смотрели мультик Гравити Фолз, то должны помнить что там была такая бездонная яма, в которую что не упади, обязательно рано или поздно вылетит назад. Можно представить рекурсивные вызовы и стек таким образом, для запоминания.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/botomless_pit.gif&quot; alt=&quot;Стэн в яме&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Дядюшка Стен ждет конечного условия, или пока стек переполнится. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Очевидно что бездумное использование рекурсии может накладывать существенные расходы памяти.&lt;/p&gt;

&lt;h3 id=&quot;что-происходит&quot;&gt;Что происходит?&lt;/h3&gt;

&lt;p&gt;Иван, при чем тут рекурсия? Этот пост про программирование в декларативной модели был. Ага! Я не отошел от темы.&lt;/p&gt;

&lt;p&gt;Сейчас мы уже знаем всё что нужно, чтобы применять “декларативщину” на практике. Подытожим.&lt;/p&gt;

&lt;p&gt;Для соблюдения декларативной модели нам нужно, во-первых, использовать переменные исключительно для однократного присваивания. Во-вторых, использовать простые (арифметические) операции над исконно декларативными типами данных — списками и записями. В-третьих, комбинировать декларативные операции, получая декларативные операции в результате (компонуем по полной!).&lt;/p&gt;

&lt;p&gt;Так а что с этим всем делать? Комбинировать компоненты декларативной программы по правилам &lt;strong&gt;программирования высшего порядка&lt;/strong&gt;! Звучит серьезно, правда?&lt;/p&gt;

&lt;p&gt;Программирование высшего порядка, это когда в модели функции могут получать в качестве аргументов другие функции (как параметры), и &lt;em&gt;возвращать их в качестве результата&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Догадались, нет?&lt;/p&gt;

&lt;p&gt;Технически корректной реализацией декларативной программы будет её описание как &lt;strong&gt;чистых рекурсивных функций&lt;/strong&gt; организованных согласно &lt;strong&gt;программированию высшего порядка&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Помните, в самом начале первой части мы говорили о том, что декларативная модель, это когда мы описываем “что должно получиться в итоге”, а как этого результата достигать? Вот это как раз и реализуется по канону высшего порядка, рассмотрим совсем простой псевдокод.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ИтерацияВычислений(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо):
    if ФункцияПроверкиРезультата(ОбрабатываемыеДанные) == True:
        Возвращаем ОбрабатываемыеДанные
    env

    ОбрабатываемыеДанные = ФункцияВычисляющаяЧтоТо(ОбрабатываемыеДанные)
    return ИтерацияВычислений(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо)
end
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Разберем по порядку. Всё вместе называется &lt;strong&gt;абстракцией управления&lt;/strong&gt;. Это как раз пример программирования высшего порядка.
У нас есть функция которая вызывается рекурсивно — &lt;em&gt;ИтерацияВычислений&lt;/em&gt;. В данном примере я назвал её так, потому что &lt;strong&gt;итеративные вычисления&lt;/strong&gt; это &lt;em&gt;частный случай рекурсии.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ФункцияПроверкиРезультата&lt;/em&gt;, в данном случае, это как раз то, с помощью чего определяется то самое условие “что должно получиться в итоге”.&lt;/p&gt;

&lt;p&gt;Ну а &lt;em&gt;ФункцияВычисляющаяЧтоТо&lt;/em&gt;, это рабочая лошадка, производящая фактические преобразования исходного значения “&lt;em&gt;ОбрабатываемыеДанные&lt;/em&gt;”&lt;/p&gt;

&lt;p&gt;Всё это мы можем обернуть в ещё одну функцию, в которую аргументом будут передавать лишь ОбрабатываемыеДанные, которые нужно преобразовать способом, скрытым внутри реализации. В результате мы получаем компонент, который может использоваться в проекте. В прошлой части я писал о &lt;em&gt;лингвистических абстракциях&lt;/em&gt;. Подобный компонент, если он должен часто использоваться в проекте, может быть представлен как раз в виде такой абстракции.&lt;/p&gt;

&lt;p&gt;Учитывая правило, о котором мы уже говорили — использование простых арифметических операций, глубокий стек рекурсивных вызовов формироваться не будет. Во-первых, потому что мы имеем четко определенное конечное состояние, которое проверяется “ФункциейПроверкиРезультатов”. Во-вторых, такие простые вычисления хорошо оптимизируются компиляторами.&lt;/p&gt;

&lt;h2 id=&quot;резюме&quot;&gt;Резюме&lt;/h2&gt;

&lt;p&gt;Если декларативная модель — это исток всех остальных моделей, их сердцевина. То сердцевина самой декларативной модели — рекурсивные вычисления! Это чрезвычайно мощный инструмент с огромным потенциалом. Кроличья нора &lt;em&gt;очень глубока&lt;/em&gt;, но ослепительно проста и прекрасна.&lt;/p&gt;

&lt;p&gt;В следующий раз мы разберемся в том, что списки, на самом деле &lt;strong&gt;рекурсивный тип данных!&lt;/strong&gt; и продолжим гнаться за декларативным белым кроликом.&lt;/p&gt;

&lt;p&gt;Будьте здоровы.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/white_rabbits.gif&quot; alt=&quot;Рекурсивные кролики&quot; /&gt;&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 2.</summary></entry><entry xml:lang="ru"><title type="html">Средоточие и исток любой парадигмы программирования.</title><link href="http://localhost:4000/2022/02/06/hack_in_declarative_model.html" rel="alternate" type="text/html" title="Средоточие и исток любой парадигмы программирования." /><published>2022-02-06T00:00:00+03:00</published><updated>2022-02-06T00:00:00+03:00</updated><id>http://localhost:4000/2022/02/06/hack_in_declarative_model</id><content type="html" xml:base="http://localhost:4000/2022/02/06/hack_in_declarative_model.html">&lt;p&gt;Врубаемся в Декларативную модель — Часть 1. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Не без помощи ментора мне удалось пройти последний тест по предыдущему курсу. Спойлерить вопросы из теста не стану, но поверьте, 2 и них были почти Дзен коанами, ну или Concurrency коанами.&lt;/p&gt;

&lt;p&gt;На этой неделе я приступил ко второму курсу, главная тема которого — &lt;em&gt;Декларативная модель программирования&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Без изучения декларативной модели глубоко понять программирование в принципе невозможно, потому что эта модель является &lt;strong&gt;фундаментальной&lt;/strong&gt; — корнем, из которого возникли все остальные парадигмы. Хорошее понимание декларативной модели автоматически дает возможность быстрее разобраться в других технологиях программирования.&lt;/p&gt;

&lt;h2 id=&quot;декларативная-парадигма&quot;&gt;Декларативная парадигма&lt;/h2&gt;

&lt;p&gt;Напоминаю, что парадигма — это в первую очередь по сути математическая теория, но в более прикладном понимании это &lt;em&gt;подход программирования&lt;/em&gt; (воплощающий эту мат. теорию). Или ещё вернее — набор программно-инженерных техник для решения задач, или класса задач, с помощью которых мы проектируем программу в соответствии с определенной &lt;strong&gt;вычислительной моделью&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Глубокое понимание, знание разных парадигм программирования воспитывает наше мышление и дает возможность разрабатывать качественно эффективный код, применяя различные парадигмы для решения подходящего класса задач.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/cat_hammer.gif&quot; alt=&quot;Котик с молотком&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Ну вы знаете эту популярную присказку, про забивание гвоздя микроскопом? Не надо так, надо как котик. &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Соответственно поэтому мы и начинаем свое изучение с логического начала — с Декларативной парадигмы.&lt;/p&gt;

&lt;h3 id=&quot;в-чем-суть&quot;&gt;В чем суть?&lt;/h3&gt;

&lt;p&gt;Декларативную парадигму часто противопоставляют императивной. В императивной парадигме всё крутится вокруг &lt;em&gt;состояний&lt;/em&gt; (переменных), и мы последовательно описываем шаги, которые исполнитель (компуктер), должен выполнить для решения поставленной задачи. Короче говоря мы придумываем и подробно описываем алгоритм.&lt;/p&gt;

&lt;p&gt;В декларативной парадигме мы описываем сам &lt;em&gt;результат&lt;/em&gt; который хотим достичь, а не то как его достигать. Ого, скайнет?! Машины такие умные стали что мы можем сказать “хочу печеньку” и они напекут? Нет, по крайней мере пока :)&lt;/p&gt;

&lt;p&gt;Точнее мы описываем соотношение &lt;em&gt;входных данных&lt;/em&gt; и результата, и по необходимости уточняем некоторые детали выполнения, пока интерпретатор не “поймет” что ему делать. Мы всё ещё не говорим исполнителю как именно решать задачу, а просто точнее описываем как “вход” соотносится с “выходом”.&lt;/p&gt;

&lt;p&gt;Продолжая проповедовать научность программирования, предлагаю погрузиться глубже.&lt;/p&gt;

&lt;h2 id=&quot;diving-deeper-&quot;&gt;Diving deeper 👨‍🚀&lt;/h2&gt;

&lt;p&gt;Я тут уже сказал про вычислительную модель. В общем это та самая научно-математическая штука (формальная система), которая определяет язык программирования и то как инструкции на этом языке будут обрабатываться исполнителем (абстрактной вычислительной машиной).&lt;/p&gt;

&lt;p&gt;Вообще есть набор разных математических концепций, из которых не всегда получается полезная нам вычислительная модель. Поэтому существующие и применяемые на практике парадигмы (модели) программирования основаны на &lt;strong&gt;целесообразных&lt;/strong&gt; вычислительных моделях. Это такие модели, которые не ставят нам палки в колеса, и предлагают ясные и толковые техники которые можно применять на практике.&lt;/p&gt;

&lt;p&gt;Так вот, декларативное программирование это первая и самая простая целесообразная вычислительная модель, где основной идеей является вычисление функций без использования переменных.&lt;/p&gt;

&lt;h3 id=&quot;внутреннее-устройство&quot;&gt;Внутреннее устройство&lt;/h3&gt;

&lt;p&gt;Сейчас может быть будет сложно, но я постараюсь написать проще. В общем, переменные в декларативной модели используются, но не используются. А?&lt;/p&gt;

&lt;p&gt;Переменные в &lt;em&gt;классическом&lt;/em&gt; программистском понимании не используются. Но с памятью и значениями же как-то надо работать, вычислять там…&lt;/p&gt;

&lt;p&gt;В декларативной модели есть такая штука как &lt;strong&gt;хранилище однократных присваиваний&lt;/strong&gt;. Это множество уникальных идентификаторов-переменных, которые &lt;em&gt;изначально не определены&lt;/em&gt;. Они могут быть связаны с каким-то значением (инициализированы), но &lt;strong&gt;только один раз&lt;/strong&gt;, и называются &lt;em&gt;декларативными переменными&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;В хранилище однократных присваиваний могут одновременно находиться как уже инициализированные переменные, так и ещё “свободные”. Если в хранилище все переменные связаны со значениями, то оно так и называется — хранилище значений.&lt;/p&gt;

&lt;p&gt;В принципе всё что с хранилищем можно сделать — это связать значение с декларативной переменной внутри него. 
Если в хранилище уже есть инициализированная переменная (идентификатор связан со значением), и мы попытаемся связать её же с другим, отличным от инициализированного значения — операция связывания свалится с ошибкой.&lt;/p&gt;

&lt;p&gt;Переменные как “привычные” переменные в коде в этой модели тоже есть, и называются &lt;em&gt;идентификаторы переменных&lt;/em&gt;. Эти идентификаторы &lt;strong&gt;существуют вне хранилища&lt;/strong&gt;, которые каким-то образом указывают на декларативные переменные в хранилище.&lt;/p&gt;

&lt;p&gt;Эта система внешних “переменных” называется &lt;em&gt;окружение&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Возможно вы запутались. Сначала я говорю в декларативной модели фишка в вычислении без использования переменных, потом пишу что переменные есть, и ещё “ссылки” из окружения на них есть. Ну есть, есть, только это не “переменные”, это &lt;strong&gt;постоянные&lt;/strong&gt; (перечитайте ещё раз про хранилище, если не поняли).&lt;/p&gt;

&lt;h3 id=&quot;переменные-которые-постоянные&quot;&gt;Переменные, которые постоянные&lt;/h3&gt;

&lt;p&gt;Чувствуете красоту строгости этих декларативных переменных? Их фишка в том, что создание переменной не есть та же операция, что и связывание этой переменной со значением. Мы &lt;strong&gt;не можем&lt;/strong&gt; использовать переменную пока у неё нет значения. Попытка это сделать приведет к ошибке!&lt;/p&gt;

&lt;p&gt;Сперва это может быть не просто понять, потому что в большинстве языков программирования для большей выразительности и удобства операции создания и связывания со значением переменной происходят одновременно. Хотя в некоторых языках эти механизмы могут быть реализованы иначе.&lt;/p&gt;

&lt;p&gt;В С++ указатель &lt;em&gt;может указывать на неинициализированную область памяти&lt;/em&gt;, представляете к чему может привести? Я никогда не трогал С++, но начинаю понимать критику, по мере углубления в программирования. В целом это самая плохая ситуация которая может возникнуть в рассматриваемом вопросе о переменных.&lt;/p&gt;

&lt;p&gt;Есть ещё сценарий, когда переменная определена, не связана со значением, но ошибки использования переменной при обращении к ней не возникает. Это обеспечивается благодаря присваиванию переменной дефолтного значения (по умолчанию) при создании. Например так происходит в Go — мы можем создать переменную какого типа, и не присвоить ей значение. По умолчанию у каждого типа будет свое значение, например 0 у integer, nil (он же None) у слайсов (аналог динамического массива, но не совсем). В целом, этот вариант лучше чем предыдущий, но далек от “идеала”. Хотя в том же Go есть дополнительное ограничение — хотя мы и можем создать переменную без связывания значения, если эта переменная нигде н будет использована наша программа вообще не скомпилируется (это так же касается не используемых импортированных модулей.) То есть это своеобразная реализация следующего варианта, когда &lt;em&gt;исполнение программы завершается с ошибкой&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Самый крутой вариант это &lt;strong&gt;&lt;em&gt;dataflow-переменные&lt;/em&gt;&lt;/strong&gt;!&lt;/p&gt;

&lt;p&gt;Dataflow-переменные, это декларативные переменные, у которых ещё не привязано значение. Но фишка в том, что система не падает с ошибкой, а &lt;em&gt;ожидает&lt;/em&gt; когда переменная получит свое значение, и продолжает работать дальше. Благодаря наличию такого механизма мы “из коробки” получаем &lt;em&gt;декларативный параллелизм!&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Мы уже рассматривали параллелизм и недетерминизм в прошлом &lt;a href=&quot;/2022/01/30/hack_in_codding_1.html&quot;&gt;посте-отчете&lt;/a&gt;, так что название говорит само за себя. Декларативный параллелизм &lt;em&gt;великолепен&lt;/em&gt;, нет никаких race condition. Как мы помним, “формула” недетерминизма = использование именованных состояний (переменных) + параллельные вычисления, так что реализация декларативного параллелизма, по сути, заключена в самой декларативной модели.&lt;/p&gt;

&lt;h2 id=&quot;типы-данных-и-вычисления&quot;&gt;Типы данных и вычисления&lt;/h2&gt;

&lt;p&gt;Тип, или тип данных — это такая “сущность”, которая определяет возможные значения и их &lt;em&gt;смысл&lt;/em&gt;, а так же возможные над этими значениями операции. В языках программирования всегда есть какие-то базовые наборы типов данных: целые числа, числа с плавающей точкой, строки, etc.&lt;/p&gt;

&lt;p&gt;В декларативной модели проверяется каждая операция над всеми значениями, учитывая типы данных этих значений. Если встречается какая-то “не законная” операция (над значениями несовместимых типов) — в программе возникает ошибка. Изначально в модели нет обработчиков ошибок, любая ошибка сразу обрушает выполнение программы. Ещё могут возникать &lt;em&gt;исключительные ситуации&lt;/em&gt;, например — попытка деления на ноль.&lt;/p&gt;

&lt;h4 id=&quot;базовые-типы-данных-декларативной-модели&quot;&gt;Базовые типы данных декларативной модели&lt;/h4&gt;

&lt;p&gt;Разумеется тут есть стандартные булевы величины true-false, останавливаться тут не на чем.&lt;/p&gt;

&lt;p&gt;Тип данных &lt;strong&gt;Атом&lt;/strong&gt;! Прикиньте, тут есть Атомы! По крайней мере такая у меня была первая реакция. Ну на самом деле это просто символическая константа которую можно использовать в выражениях. По факту просто строка или идентификатор. Но название что надо :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Запись&lt;/strong&gt; — это композитная структура у которой есть идентификатор-название и список пар ключ-значение. Самый простой пример для понимания — словари в Python. Записи поддерживают стандартные операции над ними, вроде обращения к полям по имени записи, получение их списка, etc.
Вообще, запись это &lt;em&gt;фундаментальная&lt;/em&gt; программистская концепция структурирования данных. Этот тип можно найти практически в любой реализации более сложных структур, от связанных списков до деревьев и графов.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Кортеж&lt;/strong&gt; — это &lt;em&gt;запись&lt;/em&gt;, у которой имена полей являются последовательно увеличивающимися числами, начиная с единицы. Получается что массивы тоже наследники записей :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Список&lt;/strong&gt; — а это тоже наследник записей :D В списке есть некоторое количество произвольных значений, и они между с собой связаны определенным способом, например последовательно.&lt;/p&gt;

&lt;p&gt;И наконец &lt;strong&gt;Процедуры&lt;/strong&gt; — проще всего понять процедуру как определение функции в обычном её понимании. Значение процедурного типа может иметь идентификатор (имя функции) или быть безымянным (анонимным).&lt;/p&gt;

&lt;p&gt;Но на самом деле процедуры это не привычные нам функции. Процедуры проще функций, так как не требуют строгого определения. Иными словами, процедуры не ограничены так как функции!&lt;/p&gt;

&lt;p&gt;Например у функций обязательно должен быть &lt;em&gt;один&lt;/em&gt; выход, а у процедур может быть много выходов — любое количество. Как и входов. Или не быть их вообще!&lt;/p&gt;

&lt;p&gt;А ещё &lt;em&gt;любую&lt;/em&gt; инструкцию декларативной программы можно переместить внутрь определения процедуры. Такой финт называется &lt;strong&gt;процедурная абстракция&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Записи и процедуры это &lt;em&gt;фундаментальные&lt;/em&gt; и очень мощные строительные блоки из которых, грубо говоря, &lt;em&gt;в программировании собирают всё остальное&lt;/em&gt;.&lt;/p&gt;

&lt;h4 id=&quot;организация-вычислений&quot;&gt;Организация вычислений&lt;/h4&gt;

&lt;p&gt;Не смотря на то что переменные в декларативной модели строго определяются один раз и навсегда, допускается определение локальных видимостей &lt;strong&gt;идентификаторов&lt;/strong&gt; декларативных переменных. Это работает так, что при каждом новом &lt;em&gt;локальном&lt;/em&gt; определении создается новая инстанция необходимой декларативной переменной. Физически этот инстанс отличается от переменных в хранилище, но имя и значение остаются теми же.&lt;/p&gt;

&lt;p&gt;У процедур есть ряд интересных особенностей. Во-первых, для того чтобы получить результат работы процедуры в её аргументах нужно передать указатель на ещё не инициализированную переменную. Результат работы процедуры будет связан с этим идентификатором, т.е. проинициализирует переменную. Это называется &lt;em&gt;передача по ссылке&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Во-вторых, в процедурах могут быть &lt;strong&gt;свободные идентификаторы&lt;/strong&gt;. Это такие переменные, которые не входят в число параметров процедуры, и не определены в ее теле (из внешнего скоупа).&lt;/p&gt;

&lt;p&gt;Фишка в том, что значениями этих свободных идентификаторов будут определены как значения соответствующих переменных (согласно областям видимости) &lt;strong&gt;на момент определения&lt;/strong&gt; процедуры, а не на момент её вызова! Это называется &lt;strong&gt;статическая видимости&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Дело в том что определение процедуры в декларативной модели — &lt;em&gt;обычная&lt;/em&gt; операция (инструкция), и выполняется наравне с другими.&lt;/p&gt;

&lt;p&gt;В привычных языках определение функций работают по другому. Операция определения функции не является “обычной”, и выполняется как бы отделено от остального кода, а сама функция вообще ничего не делает без явного вызова. Это называется &lt;strong&gt;динамическая видимость&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;То есть, если в такой функции со статической видимостью есть какие-то указатели на переменные из внешнего скоупа, значениями этих “локальных” переменных станут значения внешних переменных &lt;strong&gt;на момент вызова&lt;/strong&gt; такой функции.&lt;/p&gt;

&lt;p&gt;Это вообще плохо, так как чревато ошибками. По этой причине в языках с использованием функций доступ к внешним переменным обычно запрещается.&lt;/p&gt;

&lt;p&gt;Сочетание статической видимости с процедурными абстракциями дает мощный инструмент для проектирования надежных программ без побочных эффектов. При этом реализация остается простой. Вот что значит целесообразная вычислительная модель! Песня!&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Справедливости ради хочется упомянуть о том, что декларативная модель в принципе “поддерживает” функции с помощью &lt;em&gt;лингвистической абстракции&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Лингвистическая абстракция — это создание новой конструкции в некотором языке программирования, с целью расширения синтаксиса этого языка. В целом это повсеместный прием, который служит как для улучшения выразительности кода, так и для повышения качества языка программирования в целом, благодаря улучшению безопасности и эффективности языковых конструкций.&lt;/p&gt;

&lt;p&gt;Так вот в декларативной модели лингвистическая абстракция функции, как не сложно догадаться — это процедура с одним выходом, которая возвращает некоторое выражение, значением которой является результат &lt;em&gt;вычисляемый&lt;/em&gt; в ходе вызова функции с конкретными аргументами.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;На сегодня это всё. Как видите, декларативная модель настоящая “всему голова” программирования. Вероятно этот пост-отчет будет дополнен.
Всех благ!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Декларативная_модель" /><summary type="html">Врубаемся в Декларативную модель — Часть 1.</summary></entry><entry xml:lang="ru"><title type="html">Предки суслика</title><link href="http://localhost:4000/2022/01/31/go_closely.html" rel="alternate" type="text/html" title="Предки суслика" /><published>2022-01-31T00:00:00+03:00</published><updated>2022-01-31T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/31/go_closely</id><content type="html" xml:base="http://localhost:4000/2022/01/31/go_closely.html">&lt;p&gt;Продолжаем знакомиться с Go. Зачем Google разработал новый язык, и чем вдохновлялись разработчики?&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;В прошлой заметке о &lt;a href=&quot;2022/01/23/go_language.html&quot;&gt;первом знакомстве с Go&lt;/a&gt; я очень сжато и сумбурно описал первые впечатления об этом языке программирования.&lt;/p&gt;

&lt;p&gt;За минувшую неделю я в увереном темпе прошел первый курс по Go на coursera из &lt;a href=&quot;https://www.coursera.org/specializations/google-golang&quot;&gt;этой&lt;/a&gt; специализации. Сложность заявлена как intermediate, и это похоже на правду. В четырех модулях были рассмотрены основные концепции языка, синтаксис, структуры данных и core features.&lt;/p&gt;

&lt;p&gt;В небольших практических задачах нас знакомят с основными модулями, содержащими методы для работы со строками, вводом-выводом, и json’ами. Дается емкое объяснение того как работает сборщик мусора и указатели. Если вы не полный ноль в программировании то послее этого короткого курса довольно бегло сможете начать работать на Go. Хочу отметить что я уже отсмотрел лекции из первого модуля второго курса — &lt;a href=&quot;https://www.coursera.org/learn/golang-functions-methods?specialization=google-golang&quot;&gt;Functions, Methods, and Interfaces in Go&lt;/a&gt; и тут уже начинаются более интересные и качественные вещи.&lt;/p&gt;

&lt;p&gt;Например, меня отдельно порадовало то, что во тут профессор Ирвин подчеркивает важность нейминга и “чистоты” функций. В первом знакомстве я обмолвился что по неведомой причине в сообществе разработчиков Go всё ещё считается нормой однобуквенный нейминг, и прочая ересь. Это лютая жесть и полный баттхёрт.&lt;/p&gt;

&lt;p&gt;Я не преследую цель пересказывать весь первый курс тут, вы можете бесплатно его посмотреть на курсере, пусть и без доступа к задачкам и тестам — не много потеряете. В целом рекомендую как отправную точку в Go, я ничуть не жалею о потраченном времени, и материал подается явно попроще, но ничуть не хуже чем в A tour of Go. Эти материалы отлично дополняют друг друга.&lt;/p&gt;

&lt;p&gt;По 2 и 3 курсу я обязательно выберу какую-то тему, которую освящу отдельным постом, например интерфейсы. В этот раз я предлагаю вам чуть больше информации об истоках языка и некоторых концепциях заложенных в нем.&lt;/p&gt;

&lt;h3 id=&quot;люк-я-твой-отец&quot;&gt;Люк, я твой отец&lt;/h3&gt;

&lt;p&gt;Я уже упоминал фразу, что  “Go это Си на стероидах”. Называть его может кто угодно и как угодно, но по внутреннему устройству это вообще новый язык, и помимо Си на Go оказали влияние и другие “&lt;em&gt;родословные&lt;/em&gt;” языков программирования.&lt;/p&gt;

&lt;p&gt;Go пытается заимствовать лучшие идеи и парадигмы, при этом его создатели старались достичь максимальной семантической выразительности кода.&lt;/p&gt;

&lt;p&gt;От Си язык Go унаследовал:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Синтаксис выражений;&lt;/li&gt;
  &lt;li&gt;Конструкции управления потоком;&lt;/li&gt;
  &lt;li&gt;Базовые типы данных (но с некоторым расширением);&lt;/li&gt;
  &lt;li&gt;А так же передачу параметров &lt;em&gt;по значению&lt;/em&gt; и указатели.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вторым деревом предков являются языки Никлауса Вирта, начиная с самого Паскаля. От следующего потомка паскаля - Modula-2 в Go пришла концепция &lt;em&gt;пакетов&lt;/em&gt;, от Oberton - использвание одного центрального файла с определением модулей (в Go этот файл называется go.mod). Из чуть более позднего Oberton-2 взята концепция пакетов, импоторов и объявления методов.&lt;/p&gt;

&lt;p&gt;Ну всё это мы видели и в других языках программирования :)&lt;/p&gt;

&lt;p&gt;А вот самая вишенка, это концепция CSP (communicating sequential processes) из статьи Тони Хоара 1978 года об основах &lt;em&gt;параллелизма&lt;/em&gt;, которая развивалась в научных языках компании Bell Labs, и в итоге добралась до нашего Go-суслика.&lt;/p&gt;

&lt;p&gt;CSP — это скорее не концепция, а формальный язык, которым описываются модели взаимодействия процессов в параллельных программных системах &lt;strong&gt;не имеющих общего состояния&lt;/strong&gt;. В этой модели процессы взаимодействуют и синхронизируются между собой с помощью &lt;em&gt;каналов&lt;/em&gt;. Мне кажется это на порядок более мощная модель чем атомарность, которую я рассматривал вкратце &lt;a href=&quot;/2022/01/30/hack_in_codding_1.html&quot;&gt;здесь&lt;/a&gt;. CSP до сих пор является темой для активного исследования в Computer Science.&lt;/p&gt;

&lt;h3 id=&quot;зачем-нам-суслик&quot;&gt;Зачем нам суслик?&lt;/h3&gt;

&lt;p&gt;Google устал от так называемого &lt;em&gt;взрыва сложности&lt;/em&gt;. О какой сложности идет речь, в Гугле что, сидят дураки которым сложно программы писать на уже имеющихся языках? Вовсе нет. Здесь имеется в виду такая проблема (при чем вообще не уникальная для Google) как &lt;em&gt;сложность программной системы&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Эта сложность характеризуется количеством абстрактных сущностей, которые между собой связаны и как-то взаимодействуют. Всё просто — чем сущностей больше, тем сложнее становится система. А чем сложнее система, тем затруднительнее в ней разобраться и что-то допиливать. Хороший пример сложной системы это СУБД Оракл, погуглите статью на хабре (треш алерт!).&lt;/p&gt;

&lt;p&gt;Так вот, Роб Пайк (один из создатлей Go), не без оснований заметил, что сложность &lt;em&gt;мультипликативна&lt;/em&gt;. Имеется в виду что если мы усложняем одну часть системы, например дорабатываем какие то фичи, etc., то обязательно будут усложняться и другие части.&lt;/p&gt;

&lt;p&gt;С течением времени постоянно требуется вносить новые фичи в проект, бизнес требует &lt;del&gt;крови&lt;/del&gt; денег, и требует быстро! В итоге мы получаем сложную, вообще не выразительную систему жертвуя простотой кода, хотя в долгосрочной перспективе &lt;em&gt;именно простота&lt;/em&gt; является ключевым аспектом качественного софта. Простота означает ясность (выразительность), меньше шансов наплодить багов, etc.&lt;/p&gt;

&lt;p&gt;Фишка в том, что такая “долгосрочная простота” требует большой работы в самом начале проекта. Необходимо четко сформулировать ключевые аспекты и поддерживать строгую дисциплину во время всего цикла разработки. Благодаря такой дисциплине становится возможным отличать плохие изменения от хороших. На практике же мы часто, и к сожалению, наблюдаем хреняк-хреняк и в продакшен.&lt;/p&gt;

&lt;p&gt;Нет строгой спецификации и дисциплины — есть банальный размен &lt;em&gt;простоты&lt;/em&gt; на мнимое &lt;em&gt;удобство&lt;/em&gt;, которое в итоге приводит к хаосу и сплошному копанию в легаси и попытке докостылять.&lt;/p&gt;

&lt;p&gt;Короче, Google устал, и разрабатывая Go одним из важных факторов стала &lt;em&gt;культура радикальной простоты&lt;/em&gt;. В прошлый раз я мельком упоминал о том как медленно и неохотно в Go допиливаются новые “фичи”, и как слезно сообщество выпрашивало, например, дженерики.&lt;/p&gt;

&lt;p&gt;Go выигрывает преимущство во времени в которое он появился. И преимущество это — возможность ретроспективно проанилизировать “опыт” других языков программирования, в чем разрабочики “оторвались по полной”.&lt;/p&gt;

&lt;p&gt;В Go есть сборщик мусора, мы не мучаемся с памятью. Есть система пакетов, как уже было сказанно. Полноценные функции, замыкаем со спокойной душой. &lt;em&gt;Лексическая область видимости&lt;/em&gt;. Интерфейс системных вызовов! И иммутабельные строки в UTF-8.&lt;/p&gt;

&lt;p&gt;Но при этом, (помните про культуру радикальной простоты?): Нет конструкторов и деструкторов; Нет перегрузки операторов; Нет неявных числовых преобразований; Нет значений параметров по умолчанию. &lt;strong&gt;Нет наследования&lt;/strong&gt;, обощенных типов и &lt;strong&gt;исключений&lt;/strong&gt;. Нет макросов! Нет аннотаций функий и локальной памяти потока. В общем если вы до этого кодили только на Python, то сперва может будет немного больно, но не так, как на Си, или Си++ :D&lt;/p&gt;

&lt;p&gt;Как вы уже могли догадаться, система типов в Go тоже своеобразна. Она боле ограниченна, чем в других языках со сторой типизацией, но при этом &lt;em&gt;достаточна&lt;/em&gt; для того чтобы избежать большую часть ошибок, на которые мы можем напарываться в языках с динамической типизацией. Мы можем создавать изолированные части кода с “нетипизированным программированием”, которые в свою очередь будут включены в более широкую, и более строгую схему типов.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Go точно заслуживает вашего внимания, даже если не как основной язык программирования, то как дополнительный инструмент точно.
Совсем не похоже что этот проект отправится на знаменитое кладбище Google.&lt;/p&gt;

&lt;p&gt;Этот пост получился таким же обобщенным как и предыдующий, тут нет сниппетов кода, мы не разбирали вглубь особенности и примеры.&lt;/p&gt;

&lt;p&gt;Хочу сказать что мне кажется я очень своевременно начал учить Go. Параллельно с курсом “Как понять в програмировании всё”, красота простоты Go становится ещё понятнее, как задумка, и как ценность.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Основанно на введении из книги “The Go Programming Language”&lt;/em&gt;&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Go" /><summary type="html">Продолжаем знакомиться с Go. Зачем Google разработал новый язык, и чем вдохновлялись разработчики?</summary></entry></feed>