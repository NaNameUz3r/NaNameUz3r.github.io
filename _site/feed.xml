<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-01-31T00:15:42+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Врубаемся в программирование</title><link href="http://localhost:4000/2022/01/30/hack_in_codding_1.html" rel="alternate" type="text/html" title="Врубаемся в программирование" /><published>2022-01-30T00:00:00+03:00</published><updated>2022-01-30T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/30/hack_in_codding_1</id><content type="html" xml:base="http://localhost:4000/2022/01/30/hack_in_codding_1.html">&lt;p&gt;Научный взгляд на программирование. Concurrency, atomicity и кое что ещё.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;В данный момент я прохожу курс Бобровского Сергея Игоревича, который называется “Как понять в программировании всё”. На самом деле это цикл курсов, направленный на освоение научного, или лучше сказать — инженерного взгляда на программироваание, от фундаментальных концепций до осмысления &lt;em&gt;парадигм&lt;/em&gt; программирования.&lt;/p&gt;

&lt;p&gt;Этот пост является отчетом о пройденном материале, больший фокус я хочу сделать на теме параллельного программирования и атомарности — я застрял на тесте по этой теме :), надеюсь вместе мы разберемся. В дополнение я постараюсь освятить некоторые важные концепции. Остальная и не затрагивамая в этом посте часть курса либо связана с синтаксисом и особенностями мультипарадигрмального языка программирования Julia, который изучается в рамках этого же курса, либо это отдельные и сложные концепции, которые пока мы затроули поверхностно, но обязательно вернемся позже (или я их плохо понял). Lets rock.&lt;/p&gt;

&lt;h3 id=&quot;что-там-научного-то&quot;&gt;Что там научного-то?&lt;/h3&gt;

&lt;p&gt;В посте про &lt;a href=&quot;/2022/01/22/algorithms_complexity.html&quot;&gt;сложность алгоритмов&lt;/a&gt; я пытался развить мысль о том, что программирование — дитя математики, и подходить к анализу и понимаю алгоритмов нужно с научно-математической позиции мышления, а не с интуитивно-наивной. С программированием всё обстоит точно-так же. Чтобы разрабатывать эффективные и надежные программные системы необходимо понимать как работает “под капотом” сама система, и инструменты которые для разработки этой системы используются (языки программирования, парадигмы, подходы к программированию, etc.).&lt;/p&gt;

&lt;h3 id=&quot;фундаментальные-концепции&quot;&gt;Фундаментальные концепции&lt;/h3&gt;

&lt;h4 id=&quot;переменная&quot;&gt;Переменная&lt;/h4&gt;

&lt;p&gt;Программе, или алгоритму, в процессе работы необходимо “пространство” в котором будут производиться вычисления. Этим пространством является оперативная память и процессорные кеши. Устройство оперативной памяти (и кешей) отдельная и сложная тема, сейчас нам нужно понимать что есть некоторый &lt;em&gt;ресурс&lt;/em&gt; в который программа может быстро записывать какие-то данные, и читать их откуда.&lt;/p&gt;

&lt;p&gt;Проще всего представить оперативную память как набор ячеек, у которых есть адрес. По этому адреса с ячейками можно работать. В данном случае имеются в виду &lt;strong&gt;физические&lt;/strong&gt; ячейки оперативной памяти.&lt;/p&gt;

&lt;p&gt;В коде программы, в частном случае, мы напрямую (явно) с этими адресами не работаем, а используем &lt;em&gt;переменные&lt;/em&gt; которым присваиваем &lt;em&gt;значения&lt;/em&gt;. Имя переменной — это её идентификатор, а значениями являются какие-то данные, которые мы этому имени &lt;em&gt;присваиваем&lt;/em&gt;, чаще всего с помощью оператора “=”.&lt;/p&gt;

&lt;p&gt;Ещё более научно это называется &lt;em&gt;именованным состоянием&lt;/em&gt;, что уже чуть более сложная концепция, которая является одной из главных характеристик в &lt;em&gt;любой&lt;/em&gt; парадигме программирования, и реализация (степень поддержки) зависит от конкретно рассматриваемой парадигмы.&lt;/p&gt;

&lt;p&gt;В общем и целом, &lt;em&gt;состояние&lt;/em&gt; — это “способность” программы запоминать данные (присвоенные значения), в будущем с этими данными работать. Если состояние имеет идентификатор, то есть, напрямую и явно доступно для операций в исходном коде, то оно называется &lt;em&gt;“именованное состояние”&lt;/em&gt;. Да, состояния могут не иметь идентификаторов и быть своего рода &lt;em&gt;безымянными&lt;/em&gt;.&lt;/p&gt;

&lt;h5 id=&quot;зачем-идентификаторы-есть-у-ячеек-есть-адреса&quot;&gt;Зачем идентификаторы, есть у ячеек есть адреса?&lt;/h5&gt;

&lt;p&gt;Во-первых, как я уже писал, мы с адресами напрямую, как правило, не работаем. Во-вторых, на самом деле значения ячейкам памяти присваиваются как “константа”, то есть “на постоянку” и однократно (в момент присваивания).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;“Однократное присваивание”&lt;/em&gt; это одна из фундаментальных концепций программирования, суть которой в том, что как только в коде определяется переменная (некоторому идентификатору присваивется его “первое” значение), эта переменная становится неизменяемой (иммутабельной).&lt;/p&gt;

&lt;p&gt;Подождите, но я могу сделать в своем любимом пайтоне что-то вроде: my_special_var = “hello dear friend”, и следом my_special_var = “goodbye fella”, и расшибусь головой о стену от уверенности в том что print(my_special_var) вернёт последнюю строку — “goodbye fella”. Всё так! Просто почти во всех современных языках программирования кроме концепции однократного присваивания переменных существует дополнительный механизм — уже упомянутое “явное определение”, которое позволяет присвоить &lt;em&gt;новые&lt;/em&gt; значения уже &lt;em&gt;существующему&lt;/em&gt; идентификатору (переменной). Но использоваться, как правило, будет &lt;strong&gt;не та же самая ячейка памяти&lt;/strong&gt;, а новая и с другим адресом. &lt;em&gt;Тот же самый, уже существующий идентификатор (имя переменной)&lt;/em&gt; будет связан с другой областью (ячейкой) в памяти, в которую будет записано новое значение.&lt;/p&gt;

&lt;p&gt;Не увлекайтесь “явным &lt;em&gt;переопределением&lt;/em&gt;”, это удобно, но есть один &lt;strong&gt;серьезный минус&lt;/strong&gt; — потенциально эта возможность переопредления приводит к куче ошибок. Относитесь к переменным чутко и ответствено, используйте адекватный нейминг, старайтесь не переопределять уже существующие переменные (если нужно, используйте новые имена соответствующие контексту изменений и “смыслу кода”). Но так же не стоит плодить явно лишние переменные, а необходимые определяйте в непосредственной близости к коду, в котором эти переменные используются. Это короткое отступление о базовых приницпах “ясносного стиля” программирования :)&lt;/p&gt;

&lt;h3 id=&quot;опять-математика&quot;&gt;Опять математика?&lt;/h3&gt;

&lt;p&gt;Как было сказано ранее, реализация “способности запоминать состояния” определяется поддерживаемыми языком программирования парадигмами программирования.&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/mind_blowing.gif&quot; alt=&quot;Взрыв Мозга&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;center&gt;Поддерживаемые языком программирования парадигмы программирования — Чего-чего? &lt;/center&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Не волнуйтесь, мы разберемся.&lt;/p&gt;

&lt;h4 id=&quot;парадигма-программирования&quot;&gt;Парадигма программирования&lt;/h4&gt;

&lt;p&gt;Парадигмой программирования, грубо говоря, называется определённый подход к программной разработке. Правильно говоря — это не менее чем &lt;strong&gt;настоящее&lt;/strong&gt; научное открытие, строго выверенная математическая теории, которая на практике в том или ином образе воплащается в сложных программных системах как &lt;em&gt;языки программированя&lt;/em&gt;. Это не значит что язык программирования конструируется на базе одной парадигмы, напротив — многие современные языки являются мультипарадигмальными, из чего следует вывод что это &lt;em&gt;ну очень сложные математические модели&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Хорошая новость в том, что если что-то придумали одни люди, мы можем в этом разобраться, пусть даже приложив усилия!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Так вот, эта математическая модель выражается как &lt;em&gt;семантика языка программирования&lt;/em&gt;, которая передает смысл конструкций (и инструкций) в конкретном языке программирования.&lt;/p&gt;

&lt;p&gt;Подробное изучение парадигм программирования явно выходит за рамки этого поста и моих текущих знаний, но в будущем парадигмы будут подробнее изучаться на соответсвующих курсах, до которых я надеюсь добраться.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Способ реализации разобранного нами ранее &lt;em&gt;именованного состояния&lt;/em&gt; является одной из двух ключевых характеристик парадигм программирования. Вторая характеристика — характерность или не характерность &lt;strong&gt;недетерминизма&lt;/strong&gt;.&lt;/p&gt;

&lt;h4 id=&quot;недетерминизм&quot;&gt;Недетерминизм&lt;/h4&gt;

&lt;p&gt;В привычном представлении новичка-программиста, особенно самоучки, привычная императивная программа выполняется последовательно и выдает от вызова к вызову с одними и теми-же аргументами один и тот-же результат. Такое поведение назвыается &lt;strong&gt;детерминированным&lt;/strong&gt;. Иными словами, если программа детерминирована, мы можем по её коду однозначно определить какой результат будет на выходе. Никаких сюрпризов.&lt;/p&gt;

&lt;p&gt;Недетерминизм, как несложно предположить, является противоположной ситуацией, когда вызывая программу, даже с одними и теми же входными данными, мы можем наблюдать разный результат из раза в раз. Такой недетерминизм называется &lt;em&gt;явным&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Но как такое получается? Программа может выдавать неожиданные результаты, если она описана в системе (парадигме) программирования, в которой соединяются уже изученные нами “именованные состояния” и &lt;strong&gt;&lt;em&gt;параллельные&lt;/em&gt;&lt;/strong&gt; вычисления.&lt;/p&gt;

&lt;h3 id=&quot;параллелизм&quot;&gt;Параллелизм&lt;/h3&gt;

&lt;p&gt;Наконец мы подобрались к параллелизму! Сперва нам нужно строго определять о чем идет речь. В русском языке часто используется одно и то же слово для фактически разных концепции.&lt;/p&gt;

&lt;p&gt;Во-первых, есть parallelism — аппаратная концепция. Это про “одновременное” выполнение процессорных инструкций на нескольких ядрах, etc.&lt;/p&gt;

&lt;p&gt;Во-вторых, concurrency — чисто программная концепция, которая нас интересует в первую очередь в рамках изучамых тем. Я далее буду использовать слово параллелизм, и по дефолту иметь в виду concurrency. В случае если речь вдруг зайдет про “процессорный параллелизм” на это будет явное указание.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Вернемся к связи недетерминизма с параллельными вычислениями и именованными состояниями. В теме программного параллелизма есть две разные концепции:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Процесс&lt;/li&gt;
  &lt;li&gt;и Thread (нить).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вспоминая свое начальное обучение на администратора баз данных, одно из самых интересных и ярких впечатлений у меня было вызвано простым, и чертовским понятным определением разницы этих двух терминов из записи одой из лекций Дмитрия Кетова об устройстве Линукса. Дословно не помню, но суть такая:&lt;/p&gt;

&lt;p&gt;“Процесс — вычисления работающие в &lt;strong&gt;изолированной&lt;/strong&gt; модели памяти. Нити — работают в модели &lt;strong&gt;общей&lt;/strong&gt; памяти.”&lt;/p&gt;

&lt;p&gt;Иными словами, более научными и известными нам, Нити — это параллельные “процессы” которые могу иметь\имеют доступ к одним и тем же &lt;em&gt;именованным состояниям&lt;/em&gt; (модель “общей” памяти).&lt;/p&gt;

&lt;p&gt;Теперь должно стать понятно откуда берутся “неожиданные”, недетерминированные результаты работы программы. Если в программе используются параллельные потоки (нити), которые работают с одними и теми-же переменными, мы &lt;strong&gt;вообще&lt;/strong&gt; не можем знать в каком порядке эти нити буду запущены, изменят (перезапишут) значения переменной и завершатся. В таких условиях работы возникает race condition, по русски — “состояние гонки”. Смысл этого термина в том, что “победителем” гонки будет нить, которая последней запишет в переменную результат своей работы. Отсюда и берутся уже упомянутый мной выше &lt;em&gt;явный недетерминизим&lt;/em&gt;, мы видим его в непосредственном результате работы программы.&lt;/p&gt;

&lt;p&gt;Хотя существуют ситуации, в которых недетерминизм приемлем или даже необходим (является целевым, ожидаемым результатом работы), чаще всего мы хотим чтобы наши программы были детерминированы (надежны и стабильны), даже применяя параллельные вычисления, в общем случае для ускорения работы программы.&lt;/p&gt;

&lt;p&gt;Такой результат может быть достигнут только благодаря правильному проектированию программного кода, &lt;strong&gt;нельзя&lt;/strong&gt; использовать параллельные вычисления и именованные состояния вместе бездумно, это приведет уже не просто к недетерминированному результату, а к настощему хаосу.&lt;/p&gt;

&lt;p&gt;В случае когда нам всё таки нужно совмещать эти концепции, &lt;strong&gt;мы должны&lt;/strong&gt; делать это в строго ограниченной, изолированной части кода (в программном модуле), и код этот должен быть “грамотным” и выразительным.&lt;/p&gt;

&lt;p&gt;Разумеется, в программной инженерии разработаны подходы к реализации совмещения переменных и concurrency. Давайте рассмотрим один из них.&lt;/p&gt;

&lt;h3 id=&quot;атомарность&quot;&gt;Атомарность&lt;/h3&gt;

&lt;p&gt;Один из способов решить проблему race condition — использование атомарных операций.&lt;/p&gt;

&lt;p&gt;Сначала вернемся к “состоянию гонки”, и разберем его чуть подробнее. Представьте толкучку. Именно это и происходит когда параллльные нити пытаются работать с одними и теми же участками памяти. Кто успел — тот и съел. Потоки вычислений пытаются выполнить похожие действия и мешают друг другу.&lt;/p&gt;

&lt;p&gt;Способ борьбы с этой ситуаций называется thread-safe, или “&lt;em&gt;безопасность потока&lt;/em&gt;”. В язык программирования внедряются специальные инструкции, доступные разработчику для использования, которые позволяют объявить некоторые операции &lt;em&gt;атомарными&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;На практике это выглядит как &lt;em&gt;блокирование доступа к общей ячейке памяти&lt;/em&gt; для других нитей, во время работы &lt;em&gt;“активной”&lt;/em&gt; нити (та, которая “повесила” блокировку). Блокировка снимается когда активная нить завершила все необходимые операции с заблокированной ячейкой памяти.&lt;/p&gt;

&lt;p&gt;Важный момент заключается в том, что хотя благодаря атомарности мы и изолируем на время работы одной нити используемые ресурсы от других нитей, сами нити всё ещё могут, и запускаются в &lt;strong&gt;непредсказуемом&lt;/strong&gt; порядке. То есть получается, что хотя thread-safe и является мощным инструментом-концепций для устранения race condition, он не &lt;em&gt;избавляет нас от недеретминизма&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Избавиться от недеретминизма при параллельных вычислениях можно, опять же, только правильным проектированием программы, когда мы логически разделяем по нитям вычисления так, что они хоть и работают параллельно и с общими переменными — результат становится детерминированным.&lt;/p&gt;

&lt;h3 id=&quot;железная-параллельность&quot;&gt;Железная параллельность&lt;/h3&gt;

&lt;p&gt;Хочется вкратце рассмотреть параллельность на уровне железа, работу многороцессорных систем.&lt;/p&gt;

&lt;p&gt;В общем и целом нужно понимать, что сначала именованные состояния попадают в ячейки оперативной памяти, и следом копируются по системной шине в &lt;em&gt;процессорные кэши&lt;/em&gt;. Так как процессорных ядер у нас может быть несколько, параллельно работающие инструкции на разных ядрах могут стягивать в свой &lt;em&gt;локальный&lt;/em&gt; кэш значения из памяти и по своему обрабатывать. В результате может получиться такая ситуация, когда в оперативной памяти у нас “изначальное” значение, а в локальных кэшах процессорных ядер свои копии, да ещё и разные.&lt;/p&gt;

&lt;p&gt;Разумеется на практике существует решений этой проблемы, иначе как бы эта параллельность вообще работала? Мы точно не хотим иметь такой “race condition” на уровне железа, когда в операвную память будут возвращаться разные результаты работы из независимых (параллельно работающих) ядер.&lt;/p&gt;

&lt;p&gt;Единство значений в локальных кэшах проццессорных ядер, для обеспечения корретной работы системы в целом, достигается благодаря так называемым &lt;em&gt;протоколам когерентности&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Когерентность кэша (cache coherence) — &lt;em&gt;это свойство кэшей, которое подразумевает консистентность (целостность) значений, которые записываются в локальные кэши каждого из процессорных ядер.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Обеспечивается эта консистеность наличием у &lt;strong&gt;каждой&lt;/strong&gt; ячейки кэша специальных флагов, от значений которых зависит как состояние, хранимое в этой ячейке, соотносится с состояниями в ячейка кэша других ядер &lt;strong&gt;имеющих такой же адрес&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Например, когда состояние определенной ячейки меняется каким-либо образом, по внутренней сети процессорной системы происходит рассылка специльных сообщений (очень-очень быстро!).&lt;/p&gt;

&lt;p&gt;На данный момент разработано много &lt;em&gt;протоколов когерентности&lt;/em&gt;, которые отличаются алгоритмами работы и количеством состояний ячеек (флажков). Большая часть протоколов основаны на протоколе MESI (футболист тут не при чем!).&lt;/p&gt;

&lt;h4 id=&quot;протокол-когерентности-mesi&quot;&gt;Протокол когерентности MESI&lt;/h4&gt;

&lt;p&gt;Важно подчеркнуть то, что данные между ячейками оперативной памяти и ячейками процессорного кэша передаются блоками фиксированных размеров, которые называют &lt;strong&gt;линиями кэша&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;В схеме работы протокола MESI каждая линия кэша может находиться в одном из четырех состояний (те самые флаги):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Модифицированная линия (modified). Этим флагом одновременно может быть помечена только &lt;em&gt;одна&lt;/em&gt; линия в &lt;em&gt;одном&lt;/em&gt; локальном кэше. Очевидно из названия — флаг обозначает, что линия была как-то изменена, &lt;strong&gt;но до оперативной памяти изменения ещё не доехали&lt;/strong&gt;. Ядро, к которому непосредственно относится эта линия может &lt;em&gt;без рассылки&lt;/em&gt; уведомлений по внутреннй сети продолжать читать из ячейки и записывать в неё.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Эксклюзивная линия (exclusive). Так же как и модифицированная линия, эксклюзивная может находиться одновременно только в одном локальном кэше. Отличие в том, что данные в этой линии &lt;em&gt;идентичны&lt;/em&gt; данным в соответствующей ячейке оперативной памяти. Чтение и запись в этой линии происходит без уведомлений, но после изменения данных линия помечается как &lt;em&gt;модифицированная&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Разделямая линия (shared). Мы добрались до параллельности. Такая линия &lt;em&gt;может&lt;/em&gt; содержаться одновременно в разных локальных кэшах, но запросы на изменение &lt;strong&gt;всегда&lt;/strong&gt; отправляются в общую процессорную шину, это приводит к тому, что все кэши других линий с таким же адресом отмечаются специальным флагом как &lt;em&gt;недействительные&lt;/em&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Недействительная линия (invalid). Попытка чтения из кэша недействительной линии проваливается (cache miss). Chace miss приводит к тому, что “свежие” данные должны быть прочитаны из оперативной памяти. Этим флагом помечаются либо пустые линии, либо содержащие устаревшие значения.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;На практике работа процессорных кэшей, их внутреннее взаимодействиее и взаимодействие с памятью выглядит намного сложнее. Тему “железного” параллелизма мне захотелось затронуть, так как она является частью одного из вопросов в заключительном тесте по текущему курсу, и в качестве дополнительного акцента на разнице между concurrency и parallelism. Хочется верить что пост получился читаемым. Всех благ!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><summary type="html">Научный взгляд на программирование. Concurrency, atomicity и кое что ещё.</summary></entry><entry xml:lang="ru"><title type="html">Git в массы!</title><link href="http://localhost:4000/2022/01/26/about_git.html" rel="alternate" type="text/html" title="Git в массы!" /><published>2022-01-26T00:00:00+03:00</published><updated>2022-01-26T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/26/about_git</id><content type="html" xml:base="http://localhost:4000/2022/01/26/about_git.html">&lt;p&gt;Идея написать этот пост возникла у меня после того, как я вспомнил случай, когда один &lt;strong&gt;опытный&lt;/strong&gt; DBA на полном 
серьезе у меня спросил — &lt;em&gt;“А что такое гит?”&lt;/em&gt; 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;В это может быть сложно поверить, но разговор из подзаголовка я действительно пережил. Не смотря на то что парень давно работает админом баз данных он имел крайне смутное представление о гите, вроде &lt;em&gt;“ну я понимаю что там есть гитхаб и вот это всё, код там лежит, а что это, как и зачем — не знаю”&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Git — это программная система, которая управляет версиями файлов. Всё.
Инструмент был разработан Линусом Торвальдсом, кто не в курсе (есть такие?), это умный фин, что разработал ядро Linux. После того как Линус релизнул ядро в open source очень быстро и очень много людей подключились к разработке и доработке ядра. То есть &lt;em&gt;много людей захотели одновременно работать с одной и той же кодовой базой, с одним проектом&lt;/em&gt;. В таких условиях было чрезвычайно сложно отслеживать изменения, проверять каждую правку кода на предмет ошибок, нужно было в отдельных местах хранить стабильные версии, и много других проблем.&lt;/p&gt;

&lt;p&gt;Все эти проблемы решает Git.&lt;/p&gt;

&lt;p&gt;Исходный код любой программы ничто иное, как просто текстовые файлы. Git ведет своего рода “базу данных” этих файлов, каждое их изменение, при том с возможностью откатывать эти изменения назад, и… если надо — вперёд! Back in the future, Марти, мы ничего не протеряли (если правильно и со знанием дела польовались git’ом.)&lt;/p&gt;

&lt;p&gt;И самая главная мысль в том, что это могут быть &lt;em&gt;не обязательно&lt;/em&gt; текстовые файлы, а любые файлы вообще.&lt;/p&gt;

&lt;h3 id=&quot;как-это-работает&quot;&gt;Как это работает?&lt;/h3&gt;

&lt;p&gt;Вам нужно установить git, инициализировать &lt;em&gt;репозиторий&lt;/em&gt; и начать работать. Это может быть консольная утилита, или графический редактор с поддержкой гита, или какой-то специальный софт с графическим интерфейсом, которого уже наразрабатывали достаточно. Git на самом деле сложная штука, её придумал умный человек для умных людей, но для базового использования большей части преимуществ лезть глубоко в дебри не обязательно.&lt;/p&gt;

&lt;p&gt;Верхнеуровнево гит работает примерно так.
У вас есть некоторое пространство для хранения файлов. Директория, или, если хотите — папка. В ней вы иницилизируете git репозиторий, говоря гиту &lt;em&gt;отслеживать все изменения&lt;/em&gt; файлов в этой директории, и каких именно файлов. Гит будет следить за любыми изменениями и удалениями файлов. Вы можете исключить какие-то файлы из отслеживания, создать новые, etc. В нужный вам момент вы можете &lt;em&gt;зафиксировать&lt;/em&gt; изменения, это называется commit. Вы можете создать новую &lt;em&gt;ветку&lt;/em&gt;, скопировав существующую (все происходит в рамках того же рпозитория!), наизменять в ней что угодно, вернуться к предыдущей ветке, на состояние момента времени, последние из которых вы зафиксировали. Ветки можно сливать, перезаписывая все изменения из одной ветки поверх другой.&lt;/p&gt;

&lt;p&gt;Репозитории могут быть локальными, могут быть удаленными (origin) и храниться на вашем личном сервере git или в таких сервисах как github или gitlab. Репозитории с серверов вы можете клонировать себе локально на любой девайс где установлен git с помощью одноименной команды git clone.&lt;/p&gt;

&lt;p&gt;Важно то, что все файлы и ветки хранятся в одной директории. Если вы переключаетесь между ветками, гит автоматически скрывает от вас одни файлы, и показывает другие, из ветки на которую вы переключились в данный момент.&lt;/p&gt;

&lt;p&gt;В сети огромное количество гайдов по гиту всех уровней, from zero to hero, что называется.&lt;/p&gt;

&lt;h3 id=&quot;как-я-могу-это-использовать&quot;&gt;Как я могу это использовать?&lt;/h3&gt;

&lt;p&gt;Не смотря на то, что гит в первую очередь служит для версионного контроля программного кода в качестве инструмента для удобства совместной разработки множеством людей, гит может быть полезным не только для программистов. Как я сказал в самом начале — гит следит за изменениями любых файлов, а значит потенциальная сфера его применения ограничена лишь вашими требованиями и фантазией.&lt;/p&gt;

&lt;p&gt;Например вы пишете книгу или дипломную работу. Или вы писатель, копирайтер. Вы можете организовать свою работу в гите, если есть необходимость, постоянная или потенциальная, возвращаться к старым версиям своих документов. Например вы можете разбить свою работу по главам, каждая глава будет отдельным текстовым файлом, которые вы постепенно будете дорабатывать, продумывать, все изменения будут сохранены в гите и вы всегда сможете к ним вернуться, через день или через год.&lt;/p&gt;

&lt;p&gt;Или вы дизайнер, или диджитал художник. Или 3D моделированием занимаетесь. Можно сохранять прогрессы в своей работе делая коммиты, создавать новые версии одной картины или макета, переключаться между ними, etc. Думаю вы уловили мысль.&lt;/p&gt;

&lt;p&gt;Свой сервер или приватный github\gitlab репозиторий (или много репозиториев) может служить вам беспланым облачным хранилищем, через которое вы можете синхронизировать состояния своих проектов на разных устройствах. В конце концов вы можете подключить к работе других писателей, художников, что бы вы там вместе не делали, и спользовать гит на полую катушку так, как он был (и для чего был) задуман.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><summary type="html">Идея написать этот пост возникла у меня после того, как я вспомнил случай, когда один опытный DBA на полном серьезе у меня спросил — “А что такое гит?”</summary></entry><entry xml:lang="ru"><title type="html">Лупоглазый суслик Go.</title><link href="http://localhost:4000/2022/01/23/go_language.html" rel="alternate" type="text/html" title="Лупоглазый суслик Go." /><published>2022-01-23T00:00:00+03:00</published><updated>2022-01-23T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/23/go_language</id><content type="html" xml:base="http://localhost:4000/2022/01/23/go_language.html">&lt;p&gt;Заметка о первом знакомстве.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;зачем-я-начал-учить-go&quot;&gt;Зачем я начал учить Go&lt;/h2&gt;

&lt;p&gt;Совсем недавно я начал знакомиться с базовым синтаксисом и особенностями языка программирования Go. До этого всё моё изучение программирования проходило в рамках Python, он же и был основным инструментом в написании мелких скриптов. Работу программистом я так и не нашел, но вполне реактивно перешел в DevOps из DBA осенью прошлого года. Мне очень нравится текущая работа, как позиция, так и конкретно компания, но кодить нравится — хоть убейте! Поэтому недолго поразмыслив я решил учить Go, и вот почему.&lt;/p&gt;

&lt;p&gt;Начнем с того что  Go достаточно молодой язык, который разработан в Google и появился в открытом доступе в 2009, не то чтобы это плюс, просто привожу факт. На данный момент Go действительно &lt;strong&gt;широко&lt;/strong&gt; используется в DevOps. Docker, Kubernetes, Prometheus, Grafana и многие другие инструменты написаны на Go. Изучение Go открывает мне потенциальные возможности разрабатывать свои инструменты, может даже принять участие в open source (хочется верить).&lt;/p&gt;

&lt;p&gt;Кроме того что Go хорошо подружился с DevOps-чертовщиной, я давно поглядываю в сторону Си, и вообще сиподобных языков, строгой типизации и вот этого всего. Слышал что Go называют “Си на стероидах”, но мне почему-то это кажется не совсем корректным, по крайней мере на данный момент. Мне рано судить о плюсах и минусах Go, потому что я только начинаю свое знакомство, в частности прошел официальный &lt;a href=&quot;https://go.dev/tour/list&quot;&gt;тур по Go&lt;/a&gt;, по мере свободного времени читаю документацию, и начинаю смотреть курс на coursera.&lt;/p&gt;

&lt;p&gt;Ничего феноменально сложного я пока не заметил, но в разделах о поинтерах и интерфейсах пришлось напрячь мозги. Скажу честно, интерфейсы в Go, по крайней мере как они описываются в туториале, не до конца остались понятными. Хотя саму концепцию интерфейсов я вроде бы понимаю. Вероятно мои затруднения вызваны в целом малым опытом разработки, а может и тем что в Go интерфейсы в структурах данных реализуются &lt;em&gt;имплицитно&lt;/em&gt; то есть &lt;em&gt;неявно&lt;/em&gt;. И хотя это заявляется как сильная сторона Go, меня пока терзают смутные сомнения. Обязательно отпишусь на эту тему, как только наберусь достаточно опыта в разработке на Go и его понимания.&lt;/p&gt;

&lt;p&gt;Кроме “Сишности” в Go мне нравится его простота. Это достаточно компактный язык, при этом из коробки есть практически всё что нужно. В Go &lt;strong&gt;нет&lt;/strong&gt; ООП, ну точнее оно &lt;em&gt;как бы есть&lt;/em&gt;, объясняю. Объектно ориентированная парадигма в некотором виде применяется в Go, но достаточно слабо. В Go можно создавать абстрактные стрктуры данных, вроде классов, но классом это тут не называется, это просто &lt;em&gt;struct&lt;/em&gt;. Мы можем описывать интерфейсы и методы связанные с этими структурами, но в Go &lt;strong&gt;нет наследования&lt;/strong&gt; (и это хорошо, потому что повторяющийся код это потенциальный источник ошибок), нет конструкторов, и нет дженериков! То есть на Go не пишут фабрики и вот это всё, код остатется простым. Учитывая этот факт и достаточно выразительный синтаксис, даже не смотря на местами ужасающую неясность и корявость кода (отвратительный нейминг, например), который сообщество разработчиков Go по какой то причине не стесняется повсеместно пушить — код остается воспринимаемым. Не знаю насколько корректно оправдывать халатность комьюнити по отношению к ясности разрабатываемого кода молодостью языка, но мне эта “фишка” не нравится. Ну да ладно, главное им не подражать :) Возможно со временем Go обзаведется какими то общепринятыми правилами стилистики кода, вроде PEP8 у Python.&lt;/p&gt;

&lt;p&gt;Go компилируемый язык, и говорят что компилируется он быстро! Можно поспорить на тему и сказать, что это не является особым преимуществом для доставки приложения, так как широко распространились контейнеры в которых вам и интерпритатор, и библиотки воткнуть можно, но компилируемость позволяет не только избавиться от сторонних библиотек в составе образа (копируем бинарь и всё!), а так же и снизить его (образа\контейнера) итоговый размер — пишут, что в последних версих Go хорошо оптимизировали размер итогового бинаря.&lt;/p&gt;

&lt;p&gt;Вообще Go это достаточно амбициозная попытка взять самое лучшее у популярных языков программирования (сильные стороны применения некоторых парадигм программирования) например Java и C++, и сделать Go способным выражать то же самое, но “более простым языком”.&lt;/p&gt;

&lt;p&gt;Go уверенно набирает популярность, но имхо, пока рано судить о том что ждет язык в будущем. Сообщество разработчиков очень консервативно и долго рассматривает реквесты и предложния, многие из которых просто оставляя без внимания. Например погуглите как долго в Go требовали и пропихивали дженерик типы. (спойлер — их всё ещё нет, но &lt;em&gt;может быть&lt;/em&gt; будут в 1.18beta).&lt;/p&gt;

&lt;p&gt;Мне нравится этот микс в Go: с одной стороны есть стогая типизация, компилятор, с другой — сборщик мусора и синтаксический сахар для объявления переменных, который сам определит тип (работает только внутри функций, или вернее — &lt;em&gt;вложенных блоков кода&lt;/em&gt;). Имхо, типы всё таки стоит определять явно. А ещё: поинтеры и очень крутая и простая реализация парралельного программирования — горутины и каналы. Думаю что это это темы для отдельного, более подробного поста :)&lt;/p&gt;

&lt;p&gt;Я не призываю вас бежать и учить Go, но призываю учить программирование! Конкретно в моем случае Go несомненно принесет лишь пользу после долгой дружбы с Python, карьерные возможности и в целом в развитии как специалиста. И как я уже говорил на счет Си, наконец то я дорвался до Си-подобного языка! Рано или поздно я обязательно доберусь до низкоуровнего программирования и поковыряюсь в ядрышках. Если вы спросите зачем мне это нужно, то отвечу цитируя Джеффа Дантеманна из “Assembly Language Step–by–Step” — &lt;em&gt;because I want to know how it works&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Увидимся в следующих постах про Go, которые наверняка ещё будут.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Go" /><summary type="html">Заметка о первом знакомстве.</summary></entry><entry xml:lang="ru"><title type="html">Давай я погуглю за тебя</title><link href="http://localhost:4000/2022/01/23/how_to_google.html" rel="alternate" type="text/html" title="Давай я погуглю за тебя" /><published>2022-01-23T00:00:00+03:00</published><updated>2022-01-23T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/23/how_to_google</id><content type="html" xml:base="http://localhost:4000/2022/01/23/how_to_google.html">&lt;p&gt;Да пребудет с вами сила поиска в Google! Или как избавить своего тимлида от 80% глупых вопросов. Слышали что нибудь о так называемых google dorks? Нет? Добро пожаловать под кат!&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Один из самых главных инструментов любого айтишника, разумеется, после мозга — это правильное использование поисковых систем интернета.
Воспользусь правом автора и буду рассматривать только Google.&lt;/p&gt;

&lt;h3 id=&quot;элементарные-запросы&quot;&gt;Элементарные запросы&lt;/h3&gt;

&lt;p&gt;Начнем с азов. Современный гугл достаточно умный, вы можете задать даже коряво сформированный запрос и плюс-минус получите удовлетворительный ответ на первой странице. Если вы хотите найти фразу &lt;em&gt;именно в том виде&lt;/em&gt; в котором задаете её в поисковик — просто заключите её в двойные кавычки. Кроме того можно включить “обязательность” присутствия одного или нескольких слов в поиске, для этого, как и в прошлый раз, заключите требуемую часть запроса в кавычки.&lt;/p&gt;

&lt;p&gt;Исключить одно или несколько слов из выдачи можно просто используя знак минуса перед ними без пробела.&lt;/p&gt;

&lt;p&gt;В поисковых запросах Гугла можно использовать стандартные логические операции: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;.&lt;br /&gt;
Можно указать в любом месте запрос символ &lt;strong&gt;*&lt;/strong&gt;, Гугл будет интерпетировать это точно так же как в обычном регулярном выражении — подставлять любое количество недостающих слов, удовлетворяющих оставшиеся части запроса на место символа звездочки. Ограничить удаленность двух слов, или частей запроса друг от друга можно с помощью оператора &lt;strong&gt;AROUND()&lt;/strong&gt;, передав ему в качестве аргумента колличество слов допустимых в промежутке. Например:&lt;/p&gt;

&lt;h3 id=&quot;level-up&quot;&gt;Level Up&lt;/h3&gt;

&lt;p&gt;Есть список специальных операторов поиска. К примеру, чтобы искать информацию исключительно на конкретном сайте вы можете определить его используя оператор &lt;strong&gt;site:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/site_google_operator.png&quot; alt=&quot;search medium for postgres replication&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Оператор &lt;strong&gt;related:&lt;/strong&gt; служит для поиска &lt;em&gt;других&lt;/em&gt; сайтов, похожих на указанный.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/related_google_operator.png&quot; alt=&quot;search other social networks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Более того, в Гугле можно сразу искать файлы конкретного расширения. Скажем, вы в поисках новых знаний о программировани. Примените оператор &lt;strong&gt;file:&lt;/strong&gt; с указанием расширения, например, pdf.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/file_google_operator.png&quot; alt=&quot;search for pdf books&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Дай человеку рыбу и он будет сыт один день… Оставшийся список оператор вы можете найти сами.&lt;/p&gt;

&lt;h3 id=&quot;google-dorks&quot;&gt;Google dorks&lt;/h3&gt;

&lt;p&gt;Фишка в том что поисковые операторы можно группировать практически в любом порядке и количестве. А теперь проявите фантазию. Допустим вам нужно найти что-то весьма специфическое. Например случайно утекшие в сеть пароли, забытые документы и прочее. А чё, так можно? Можно.&lt;/p&gt;

&lt;p&gt;Google Dorks или Google Dork Queries — это специально сформированный запрос для выявления дыр в безопасности. Такими запросами пользуются как нетсталкеры, так и настоящие злоумышленники. Они могут искать, например, потенциально уязвимые паттерны url ссылок с помощью оператора &lt;strong&gt;inurl:&lt;/strong&gt;, которые при должной сноровке могут, и часто являются, векторами атак.&lt;/p&gt;

&lt;p&gt;Для общего развития и формирования понимания потенциальной мощности поиска в Google, рекомендую ознакомиться с базой дорков собирамой исследователями информационной безопасности на сайте сообщества Offensive Security &lt;a href=&quot;https://www.exploit-db.com/google-hacking-database&quot;&gt;exploit-db.com&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Помните слова Дяди Бена, имейте совесть, уважайте свои и чужие персональные данные. Если что, карма вас обязательно настигнет!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><category term="Информационная_безопасность" /><summary type="html">Да пребудет с вами сила поиска в Google! Или как избавить своего тимлида от 80% глупых вопросов. Слышали что нибудь о так называемых google dorks? Нет? Добро пожаловать под кат!</summary></entry><entry xml:lang="ru"><title type="html">Сложность и эффективность алгоритмов.</title><link href="http://localhost:4000/2022/01/22/algorithms_complexity.html" rel="alternate" type="text/html" title="Сложность и эффективность алгоритмов." /><published>2022-01-22T00:00:00+03:00</published><updated>2022-01-22T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/22/algorithms_complexity</id><content type="html" xml:base="http://localhost:4000/2022/01/22/algorithms_complexity.html">&lt;p&gt;Как правильно думать о программе, что такое временная сложность и это самое “О большое”. Давайте разбираться.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Недавно я сделал перевод важной статьи про &lt;a href=&quot;/2022/01/15/programming_interview_algorithm.html&quot;&gt;Алгоритм прохождения интервью по программированию&lt;/a&gt;. Это сложная тема, особенно если вы никогда до этого не изучали структуры данных, ничего не слышали про временную сложность и не занимались оценкой эффективности или не эффективности программного кода.&lt;/p&gt;

&lt;h2 id=&quot;а-как-думать&quot;&gt;А как думать?&lt;/h2&gt;

&lt;p&gt;Начну с того что не зависимо от особенностей каждого человека, если мы физически и психически здоровы то “понимание” какой-то темы у нас складывается примерно одинково. Возьмем, например, телевизор. Человек растет и развивается, видит как его родители нажимают на кнопки, из телевизора показывают картинки, в его мозгу формируются некоторые связи приводящие к пониманию зависимости действий над объектом, и к каким результатам эти действия приведут. Но если человек никогда не интересовался как работает телевизор, из каких компонентов он состоит то он не сможет объяснить что это на самом деле такое, как работе, как это создать с нуля или починить. Это нормально. Инженер или работник завода на котором собирают телевизоры или его компоненты знают порядком больше, в виду обладания &lt;em&gt;большим опытом&lt;/em&gt; в непосредственной области, соответствующим обучением, etc. Надо ли говорить как телевизор будет воспринимать пещерный человек, или коренной житель глубокой тропической деревни, где иногда до сих пор практикуют каннибализм?&lt;/p&gt;

&lt;p&gt;С программированием всё обстоит так-же. Информационные технологии и программирование — дети науки и математики, развивашихся лучшими умами человечества за последние столетия.
Само собой это сложная тема, и нахрапом её не взять.&lt;/p&gt;

&lt;p&gt;Когда мы программисты-самоучки, мы можем достаточно быстро выучить современный высокоуровневый и выразительный язык программирования, например Python, методы его стандартной библиотеки, и интуитивно начать собирать в голове образ того чего мы хотим добиться от программы, смутно представлять как она работает. Мы, ещё раз, &lt;em&gt;интуитивно&lt;/em&gt; понимаем что такое переменная, что такое лист или массив. Ну есть там какие-то данные, мы их туда записали, можем сделать клац-клац &lt;strong&gt;sorted(my_very_spetial_list)&lt;/strong&gt; и знаем чего ожидать. Несмотря на то, что таким же образом можно изучить ряд технологий, фреймворков и довольно успешно выполнять простые прикладные задачи, это представление неверно, контрпродуктивно и ничем хорошим не заканчивается, например как только мы попытаемся разработать хоть сколько нибудь сложную систему.&lt;/p&gt;

&lt;p&gt;Поэтому единственный правильный способ думать о программе — это думать научно, и так же подходить к изучению программирования. Напрягаем извилины и идём дальше.&lt;/p&gt;

&lt;h2 id=&quot;алгоритм&quot;&gt;Алгоритм&lt;/h2&gt;

&lt;p&gt;Что такое программирование вообще? Ну, в первую очередь, скажете вы — это написание какой-то программы, которая что-то внутри делает и выдает интересующий нас результат, и будете в общем-то правы. Приемлемо. А что такое программа? Ни больше ни меньше, программа, в самом простом её представлении и правильном понимании — это &lt;em&gt;Алгоритм&lt;/em&gt; достижения требуемого результата. Утрированный пример алгоритма, который я неоднократно встречал во всевозможных книжках начального уровня, это список ваших последовательных дел на завтра:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Проснуться&lt;/li&gt;
  &lt;li&gt;Потянуться&lt;/li&gt;
  &lt;li&gt;Надеть носки&lt;/li&gt;
  &lt;li&gt;Поехать на работу (или дойти до компьютра и начать рабоать :) )&lt;/li&gt;
  &lt;li&gt;Прерваться на обед&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;При том каждый из пунктов тоже на самом деле является алгоритмом некоторых последовательных (а может и параллельных) действий, так что в примере выше я скоре описываю &lt;em&gt;список алгоритмов&lt;/em&gt;.
Так и есть. В любой даже маленькой программе практически всегда есть &lt;em&gt;n&lt;/em&gt; число алгоритмов — вызовы разных функций, каждая из которых что-то вычисляет.
А если вычисляет — значит алгоритм. Кажется я вас начинаю запутывать, но думаю идея ясна.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Алгоритмом мы называем пошаговое руководство “компьютеру” что-то нам посчитать (вычислить). Вычисления могут быть очень простыми, а могут быть и крайне сложными. Правильный способ думать о программе не как о волшебном коде, а как о вполне строгом, &lt;strong&gt;математическом&lt;/strong&gt; описании решения задачи.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Вычислительное железо, как и любой другой объект физического мира подчиняется строгим законам. Сила притяжения (по крайней мере на нашей планете) не даст вам прыгнуть кузнечиком в окно второго этажа. Вычислительные ресурсы (центральный процессор, оперативная память, etc) просто так не обработают по щелчку пальцев огромное количество данных — на это потребуется &lt;strong&gt;время&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;К какому бы крутому суперкомпьютеру у вас вдруг не оказался доступ, его мощность играет &lt;em&gt;намного меньшее значение&lt;/em&gt; для производительности программы, чем &lt;em&gt;правильно подобранный алгоритм&lt;/em&gt;. Именно о правильном подборе алгоритма и идет речь в переведенной мною статье, со ссылки на которую начинается этот пост.&lt;/p&gt;

&lt;p&gt;Итак, алгоритм — это вычисление или преобразование &lt;em&gt;входных&lt;/em&gt; данных в интересующие нас &lt;em&gt;выходные&lt;/em&gt; данные. Вы любите ждать? Маловероятно. Проще всего эффективность алгоритма понять как отношение времени, за которое мы получим результат. Чем быстрее — тем лучше.&lt;/p&gt;

&lt;h2 id=&quot;асимптотическая-сложность&quot;&gt;Асимптотическая сложность&lt;/h2&gt;

&lt;p&gt;Так что же влияет на скорость работы алгоритма? Как сказанно выше, в первую очередь это правильность самого алгоритма. А точнее — оправданность его использования в &lt;em&gt;конкретных обстоятельствах&lt;/em&gt;. Под конкретным обстоятельствами я имею в виду контекст решаемой нами задачи. В контексте задачи скорость, с которой алгоритм будет вычислять решение, зависит от &lt;em&gt;объема (количества) входных данных&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Научно (математически) сложность алгоритмов оценивается с помощью так называемого &lt;em&gt;асимптотического анализа&lt;/em&gt;. Итак, мы рассматриваем сложность алгоритма посредством анализа &lt;em&gt;зависимости времени и вычислительных ресурсов&lt;/em&gt;, которые потребуются алгоритму в процессе его работы.&lt;/p&gt;

&lt;p&gt;На практике всё это выражается как математическая функция, которая позволяет понять &lt;em&gt;насколько быстро&lt;/em&gt; будет увеличиваться время работы алгоритма, в зависимости от увеличения обрабатываемого объема данных. Иными словами, под &lt;em&gt;асимптотикой&lt;/em&gt; мы понимаем &lt;em&gt;характер&lt;/em&gt; с которым изменяется функция в течении &lt;em&gt;времени&lt;/em&gt;, когда её аргумент (количество обрабатываемых данных) &lt;em&gt;стремится&lt;/em&gt; к какой-то точке. Только в асимптотическом анализе сложности &lt;em&gt;компьютерых алгоритмов&lt;/em&gt; за эту точку принимается бесконечность. Простите меня за то что я несколько раз повторяю одно и то же, но это важно понять:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Мы оцениваем скорость работы алгоритма в сравнительном &lt;strong&gt;количестве операций&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;так-что-там-за-о&quot;&gt;Так что там за О?&lt;/h3&gt;

&lt;p&gt;Наиболее часто для оценки роста используются следующие &lt;a href=&quot;https://en.wikipedia.org/wiki/Mathematical_notation&quot;&gt;нотации&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Ο (О-большое) – верхняя или “наихудшая” оценка сложности. Входные данные подаются самым “неудобным” для алгоритма способом;&lt;/li&gt;
  &lt;li&gt;o (o-малое) – средняя оценка, данные подаются случайным образом;&lt;/li&gt;
  &lt;li&gt;Ω (Омега) – нижняя оценка, идеальная ситуация для достижения максимальной скорости алгоритма;&lt;/li&gt;
  &lt;li&gt;Θ (Тета) – нижняя и верхняя, точная оценка роста временной функции.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Все эти нотации используются мощными человеческими умами в теоретической Computer Science, нам же полезнее всего будет рассмотреть фундаментальные меры сложности, использумые повсеместно, которые выражаются через O-большое.&lt;/p&gt;

&lt;h4 id=&quot;разбираемся-подробнее&quot;&gt;Разбираемся подробнее&lt;/h4&gt;

&lt;p&gt;Возьмем &lt;em&gt;n&lt;/em&gt; за величину подаваемого объема данных. Тогда верхнюю оценку сложности алгоритма можно записать как &lt;strong&gt;O(f(n))&lt;/strong&gt;. Почему нас интересует именно верхняя или “наихудшая” оценка? Потому что с практической точки зрения нам важно понять этот &lt;em&gt;наихудший вариант развития событий&lt;/em&gt; при котором алгоритму будет скормлено &lt;em&gt;большое количество данных&lt;/em&gt;. Если он будет эффективен в этих условиях, то разумеется будет эффективен и в более “благоприятных”.&lt;/p&gt;

&lt;p&gt;Самые простые для понимания обозначения сложности это &lt;strong&gt;O(1)&lt;/strong&gt; и &lt;strong&gt;O(n)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(1)&lt;/strong&gt; выражает сложность, при которой для выполнения алгоритму потребуется &lt;em&gt;константа&lt;/em&gt; времени. Например взятие элемента из массива по его индексу. Мы точно знаем где элемент находится и просто идём туда. &lt;em&gt;Такие операции не зависят от количества обрабатываемых данных.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;O(n)&lt;/strong&gt; линейно зависит от количества входных данных. В худшем случае такому линейному алгоритму придется проводить какие-то операции с каждым элементом данных. Это, например, обход массива, обход связанного списка или расчет его длинны. Чтобы понять лучше приведу утрированный пример. Представим что задача состоит в том, чтобы определенному сущетву (алгоритм) нужно выпить некоторое (n) количество воды. Смоделируем ситуацию, в которой воду пьёт не человек, а волшебный троглодит, у которого не желудок, а бездонная черная дыра (n стремится к бесконечности). Пить воду он может только последовательно, глоток за глотком, поэтому алгоритм выпивания воды будет иметь линейную сложность O(n) — чем больше воды мы дадим троглодиту на испитие, тем дольше он будет её хлебать.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Классическим вариантом логарифимической сложности &lt;strong&gt;O(log n)&lt;/strong&gt;, где за основание логарифма обычно берется 2, является бинарный (двоичный поиск). Чем больше входных данных — тем медленнее растет время выполнения алгоритма (тем меньше его сложность). Самый простой и затертый до дыр пример для представления работы двоичного поиска — попытка найти номер телефона нужного вам человека по индексированному справочнику (Аббоненты упорядочены по алфавиту). Вы можете искать по порядку, запись за записью, страница за страницей. Согласитесь, очевидно что это может занять много времени. Сложность такого поиска можно выразить предыдущей формулой O(n). Представьте что вы в ищите человека не в своей записной книжке, а в справочнике всех аббоненов Москвы, например. Похоже что листать его последовательно (линейно) плохая идея.&lt;/p&gt;

&lt;p&gt;Намного быстрее, зная что справочник упорядочен, открыть его примерно в том месте, где мы ожидаем найти аббонента. Например мы ищем Фёдора Корнельчука (все совпадения случайны!). Зная алфавит русского языка может показаться что буква К обязательно будет находиться в первой половине справочника, но это не так, мы не знаем сколько фамилий на А, Б, и так далее. Может случиться так, что фамилии на К находится во второй половине сравочника. Алгоритм Двоичный поиска работает так — мы открываем справочник (массив) посередине и смотрим куда попали, если нам нужно в левую половину (на откртой странице фамилии на букву, следующую за К в алфавитом порядке), мы отбрасываем правую часть и открываем оставшуюся часть &lt;em&gt;снова посередине&lt;/em&gt;. И так до тех пор пока не найдем Корнельчука.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Сложность алгоритмов сортировки часто выражается как &lt;strong&gt;O(n log n)&lt;/strong&gt;. Время выполнения таких алгоритмов растет быстрее, чем O(n). Можно представить как комбинацию O(log n) и O(n).&lt;/p&gt;

&lt;p&gt;Далее по интенсивности роста идут квадратичные зависимости, например &lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/strong&gt;. Время выполнения таких алгоритмов растет очень быстро при увеличении объема входных данных (экспоненциально!). Например, два цикла, когда один вложен в другой, каждый из которых работает за O(n). Практически в любом случае это &lt;strong&gt;очень плохая мера&lt;/strong&gt;, которую вообще не стоит определять в своих алгоритмах.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Разбор алгоритмов сортировки и разных структур данных выходит за рамки этого поста. В будущем я планирую несколько постов в которых мы разберем базовые структуры данных и попытаемся оценить их сложность. Надеюсь что теперь стало понятнее о чем шла речь в статье-алгоритме Майкла.&lt;/p&gt;

&lt;p&gt;До новых встреч!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Алгоритмы" /><category term="ComputerScience" /><summary type="html">Как правильно думать о программе, что такое временная сложность и это самое “О большое”. Давайте разбираться.</summary></entry><entry xml:lang="ru"><title type="html">Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!</title><link href="http://localhost:4000/2022/01/16/why_zettelkasen.html" rel="alternate" type="text/html" title="Zettelkasten. Что это, и почему вам нужно начать вести его прямо сейчас!" /><published>2022-01-16T00:00:00+03:00</published><updated>2022-01-16T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/16/why_zettelkasen</id><content type="html" xml:base="http://localhost:4000/2022/01/16/why_zettelkasen.html">&lt;p&gt;Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. 
Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h4 id=&quot;при-чём-тут-комод&quot;&gt;При чём тут комод?&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9B%D1%83%D0%BC%D0%B0%D0%BD,_%D0%9D%D0%B8%D0%BA%D0%BB%D0%B0%D1%81&quot;&gt;Никлас Луман&lt;/a&gt; — &lt;em&gt;чрезвычайно&lt;/em&gt; продуктивный немецкий социолог. За 40 лет труда он написал более 70 книг и 400 статей на &lt;strong&gt;разные&lt;/strong&gt; темы: социология, биология, математика и др. При этом, книги Лумана совсем не водянистые романы в мягком переплете. Его работы стали настоящей классикой, а сам Луман считается чуть ли не самым важным социологом прошлого века.&lt;/p&gt;

&lt;p&gt;Секрет его продуктивности — тот самый &lt;em&gt;комод&lt;/em&gt;. Никлас создал и постоянно поддерживал свой Zettelkasten как огромную картотеку заметок и идей, а сам же он говорил, что &lt;em&gt;ничего сам не придумывает&lt;/em&gt;, и большая часть работы происходит в Zettelksaten.&lt;/p&gt;

&lt;h4 id=&quot;дело-не-в-мебели&quot;&gt;Дело не в мебели.&lt;/h4&gt;

&lt;p&gt;На самом деле комод с ящиками не при чём. Просто в то время не было более удобного способа ведения картотеки. Zettelkasten — это метод ведения записей. И в своей сути он предельно прост:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Каждая заметка, в идеальном случае, должна быть &lt;em&gt;атомарна&lt;/em&gt;, то есть освещать какую то конкретную мысль и объект “сам в себе”. Заметка не должна превращаться в подробное эссе или статью.&lt;/li&gt;
  &lt;li&gt;Заметки могут иметь тэги, объединяться в “папки” или условные группы, но это &lt;strong&gt;не главное&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;Самое главное, и гениально простое — заметка &lt;em&gt;должна ссылаться&lt;/em&gt; на другую заметку, или на несколько заметок.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Таким образом Zettelkasten — это метод организации &lt;em&gt;сети идей&lt;/em&gt;, связанных друг с другом по смыслу. Новые заметки не нарушают структуру, а лишь укрепляют и развивают её. Примерно так же работет человеческий мозг — чем больше нейронных связий вы наращиваете, тем умнее становитесь.&lt;/p&gt;

&lt;p&gt;Метод ведения записей Лумана опередил появление гиперссылок интерата, а работает, по сути именно так.&lt;/p&gt;

&lt;h3 id=&quot;и-зачем-мне-это&quot;&gt;И зачем мне это?&lt;/h3&gt;
&lt;h4 id=&quot;помощник-в-учебе&quot;&gt;Помощник в учебе&lt;/h4&gt;
&lt;p&gt;Zetellkasten отличный инструмент, который может помочь вам в широком спектре задач. Например в учебе. Мы можем читать книги или статьи с целью изучения, и даже перечитывая их несколько раз вдумчево, материал попадет лишь в нашу краткосрочную память. Другое дело, нелюбимое многими — конспектирование. Ведя конспект вы напрягаете заметно больше отделов мозга, в этом процессе учавствует моторика, вы как то жонглируете информацией, сокращаете, etc. Можно пойти ещё дальше (внимание, лайфхак!). Если английский язык не ваш родной, вы не говорите и не пишите на нем, но способны читать и понимать, пусть даже с помощью переводчика — &lt;em&gt;пишите конспекты на русском.&lt;/em&gt; Я так учил документацию Oracle DB, что в конечном итоге привело к лучшему пониманию этой СУБД, и СУБД технологий вообще, чем у других ребят со стажировки, которые пытались учиться по книгам переведенным на русский, и\или не так усердно вели конспекты. Но большую часть материала &lt;em&gt;я всё равно забыл&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ведение сети заметок в Zettelkasten &lt;em&gt;намного&lt;/em&gt; выигрывает у обычного конспектирования. Если бы я тогда знал про этот метод, вел конспект и строил Zettelkasten из ключевых смыслов по всем изучаемым темам, в нем бы сейчас была вся архитектура СУБД, к которой я мог бы вернуться в любой момент, “пробежаться” по ссылкам и очень быстро освежить материал в памяти.&lt;/p&gt;

&lt;h4 id=&quot;отстойник-и-лучший-собеседник-запасные-мозги&quot;&gt;Отстойник и лучший собеседник, запасные мозги&lt;/h4&gt;

&lt;p&gt;Луман часто называл свою картотеку собеседником, второй памятью, жвачкой, и иногда отстойником.&lt;/p&gt;

&lt;p&gt;Со второй памятью всё понятно, фиксирование информации — это главная цель любых записей которые мы ведем.
Zettelkasten как отостойник идей — отличное описание. Во-первых, при внесении новых заметок вы не обязательно должны сразу их линковать с другими, если такая связь естественно не приходит на ум сразу. Главное позже возвращаться к этим “сиротам” и вплетать их в общую сеть созданием связей. Во-вторых, сам по себе Zettelkasten, как уже было сказано, со временем растет и становится умнее, свое содержимое он как бы “настаивает”. Это особенно актуально если вы напоняете Zettelkasten не только как банк изучаемых данных, но и активно вносите туда &lt;strong&gt;свои&lt;/strong&gt; мысли, идеи.&lt;/p&gt;

&lt;p&gt;Каждый раз возвращаясь к Zettelkasten и погуляв по ссылкам вы не только освежите топики в памяти, но и с большой вероятностью ваш мозг сгенерирует новые, “настоявшиеся” идеи. Чем не собеседник?&lt;/p&gt;

&lt;h4 id=&quot;современный-комод&quot;&gt;Современный комод&lt;/h4&gt;

&lt;p&gt;Хорошая новость в том, что нам не надо покупать комод с ящиками, хотя если вам очень хочется, я не стану вас переубеждать :)
Вы можете вполне успешно вести классический Zettelkasten, но нужно ли?
Гораздо проще и продуктивнее воспользоваться современными технологиями. Zettelkasten можно завести используя любой текстовый редактор, собрать себе в докере собственную wiki на локалхосте, или скачать какой-нибудь Zettelkasten софт. Вариантов навалом.&lt;/p&gt;

&lt;p&gt;Я пользуюсь &lt;a href=&quot;https://obsidian.md/&quot;&gt;obsidian&lt;/a&gt; — он мультиплатформерный, имеет вполне отзывчивое комьюнити и бесплатную версию, которой более чем достаточно. Платная подписка позволяет вам завести некий аккаунт и синхронизировать заметки между устройствами, я с трудом понимаю зачем это нужно, кроме способа оказать финаносвую поддержку и выразить благодарность разработчикам. Или можно решить вопрос синхронизации своего кибер-комода банальным репозиторием на гитхабе.&lt;/p&gt;

&lt;p&gt;Преимущество obsidan в том, что заметки в нем полностью поддерживают markdown, есть множество плагинов, как официальных так и от сообщества, а вишинка на торте - граф вашего Zettelkasten. Это очень удобно и наглядно. В данный момент мой выглядит так:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zettelkasten.png&quot; alt=&quot;&amp;lt;img class=&amp;quot;image image--xl&amp;quot; src=&amp;quot;/images/zettelkasten.png&amp;quot;/&amp;gt;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Всегда можно зайти в граф, поблуждать по нему, дописать новое в заметки, добавить новые ссылки, укрепив сеть смысловых связей, etc.&lt;/p&gt;

&lt;p&gt;При том что я заполняю его чуть менее месяца. А теперь представьте что будет через пол года? Через год? Даже если вносить в день как минимум одну новую заметку.
Часто, используя Zettelkasten в процессе обучения одну запись добавить просто невозможно, ведь нам нужно следовать правилу атомарности, а изучаемая тема редко когда содержить лишь одну концепцию. Я так-же использую два плагина для obsidian: быстрая кнопка для создания новой заметки с префиксом из текущей даты, и вторая — открыть рандомную заметку.&lt;/p&gt;

&lt;h4 id=&quot;резюме&quot;&gt;Резюме&lt;/h4&gt;

&lt;p&gt;В данный момент мой процесс обучения стал намного устойчивее и яснее. Ведение конспектов по изучаемому материалу, блога и формирование Zettelkasten сильно дополняют и укрепляют друг друга. Смотрите что происходит у вас в голове, и если зацепилась действительно стоящая мысль (вам хотя бы на секунду показалось что она интересна) — незамедлительно запишите куда угодно! Я испольую ежедневник, который всегда под рукой, или личные сообщения самому себе в мессенджерах. Потом вы всегда сможете перенести эти заметки либо в полноценную статью блога (я так написал, например &lt;a href=&quot;/2022/01/15/my_interviews_experience.html&quot;&gt;эту&lt;/a&gt;), или во временную заметку-сиротку в Zettelkasten, которая рано или поздно обязательно обзаведется родственными связями.&lt;/p&gt;

&lt;p&gt;Во всей этой затее главное выработать привычку и достичь постоянства. Такой Zettelkasten — натуральное продолжение вашего мозга. Киберпанк уже давно тут.&lt;/p&gt;

&lt;p&gt;Начните прямо сейчас!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Инструменты" /><summary type="html">Один хороший программист, бывший участник команды разработки TON в прошлом году навел меня на такую вешь как Zettelkasten. Zettelkasten (читатся, примерно Цэттелькастэн) с немецкого на английский переводится как slip-box, а на русском это что-то вроде комода с выдвижными ящиками. Ну знаете, как в детективных сериалах, такая тумба в которой лежит куча папок, досье, etc.</summary></entry><entry xml:lang="ru"><title type="html">Мой лайфхак для прохождения интервью.</title><link href="http://localhost:4000/2022/01/15/my_interviews_experience.html" rel="alternate" type="text/html" title="Мой лайфхак для прохождения интервью." /><published>2022-01-15T00:00:00+03:00</published><updated>2022-01-15T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/15/my_interviews_experience</id><content type="html" xml:base="http://localhost:4000/2022/01/15/my_interviews_experience.html">&lt;p&gt;Поговорим о том как подговиться к собеседованию и что нужно держать в голове :)
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;В сети часто пишут и говорят о так называмых hard и coft скилах. Если кто не в курсе, hard - это вполне конкретные компетенции какндидата как специалиста: знание языков программирования, технологических стеков, etc. В общем это всё то, что вы обычно видите в разделе вакансий &lt;em&gt;требумые навыки&lt;/em&gt;. С soft скилами всё ещё проще.
По большому счёту софт скилы - &lt;em&gt;это просто ваши социальные навыки&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;С первым всё понятно - мы должны изучать компетенции и совершенствоваться в своем поле. Касаемо hard скилов, лучшей практой подготовки к любому собеседованию или аттестации будет ведение некоторой документации, подтверждающей ваш опыт как технического специалиста – тематический блог, правильно оформленный гитхаб с проектами и трекером изучаемых тем. Это тема для отдельного разговора.&lt;/p&gt;

&lt;p&gt;Я же хочу поговорить, скорее, о soft скиллах. На основании своего опыта я осознал почти беспройгрышный вариант как вести себя на техническом собеседовании (или аттестации).&lt;/p&gt;

&lt;p&gt;Во-первых, не нужно бояться, никто вас убивать не будет. Самое худшее что может случиться - вам деликатно откажут или не перезвонят, пообещав это сделать. В хорошем случае - вам скажут в чем вы ошибаетесь и что нужно подтянуть. По хорошему это именно то что вам нужно самим &lt;strong&gt;всегда&lt;/strong&gt; уточнять. Любое собесдование не казнь, а крайне полезный опыт.&lt;/p&gt;

&lt;h3 id=&quot;микро-инсайт&quot;&gt;Микро-инсайт&lt;/h3&gt;
&lt;p&gt;А теперь о том, что мне действительно каждый раз помогало:
Перехватывайте инициативу на вашем техническом собеседовании!&lt;/p&gt;

&lt;p&gt;Я не говорю о том, что вам нужно отклоняться от темы вопроса, или вдаваться в рассуждения на абстрактные темами. Не надо умничать! Это  приведет к лишним вопросам и вы сами себя зароете. Будьте бдительны, и задавайте ВСТРЕЧНЫЕ вопросы в &lt;em&gt;обсуждамом контексте&lt;/em&gt;!&lt;/p&gt;

&lt;p&gt;Ваше собеседование должно быть беседой. Каздый раз делая так я чувствовал позитивную реакцию, получался увлеченный диалог технических специалистов. Если вы действительно имеете какой-то опыт и показываете что “горите глазами” - вам врядли смогут отказать. По крайней мере вы получите отличный фидбэк.&lt;/p&gt;

&lt;p&gt;Если вы уверены что не просто забыли, а вообще не знаете о чем вас спрашивают - не теряйтесь и не стесняйтесь об этом прямо сказать.&lt;/p&gt;

&lt;p&gt;Главное сохранять баланс. Не забывайте что собеседуют всё таки вас.
Когда мне отвечают на встречные вопросы, и я слышу что-то новое и интересное, я никогда не стесняюсь и прошу интервьювера подождать 5 секунд, беру ручку и записываю пометку в блокнот максимально кратко - концепцию, название технологии, etc. Будьте искренни. В противно случае что вы тут вообще делаете? Это же касается вопросов, ответы на которые вы не знаете. Я всегда в таких случая прошу вкратце пояснить о чем речь, и запысываю ответ.&lt;/p&gt;

&lt;p&gt;Хорошо, если вы потом вернетесь к этим записям и изучите список :)
Если нет, то как минимум интервьювер увидит что вы по настояему увлечены процесом изучения новых технологий.&lt;/p&gt;

&lt;p&gt;Правда если вы попали на максимально консервативное, “бирюкратическое” собеседование, то всё выше упомянутое скорее всего не сработает. Тем не менее это тоже является хорошим опытом. Вообще проходить технические собеседования полезно, даже если вам нравится текущее место работы и не планируете его менять. Часто принимая участие этих мероприятиях вы остаетесь в курсе требований рынка, проверяете свои знания и актуализируете их.
В общем одни плюсы.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html">Поговорим о том как подговиться к собеседованию и что нужно держать в голове :)</summary></entry><entry xml:lang="ru"><title type="html">Алгоритм прохождения интервью по программированию.</title><link href="http://localhost:4000/2022/01/15/programming_interview_algorithm.html" rel="alternate" type="text/html" title="Алгоритм прохождения интервью по программированию." /><published>2022-01-15T00:00:00+03:00</published><updated>2022-01-15T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/15/programming_interview_algorithm</id><content type="html" xml:base="http://localhost:4000/2022/01/15/programming_interview_algorithm.html">&lt;p&gt;Достаточно вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью по программированию.&lt;/p&gt;

&lt;!--more--&gt;
&lt;p&gt;Оригинал статьи можете прочитать в его личном блоге по &lt;a href=&quot;https://malisper.me/an-algorithm-for-passing-programming-interviews/&quot;&gt;этой ссылке.&lt;/a&gt;
Приступим.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;За последние несколько лет я проходи интервью в дюжине (или около того) компаний и решил ~50 уникальных алгоритимических задач.
Мне часто давали обратную связь, в которой говорилось, что я отлично справился с предлагаемыми алгоритимическими задачами.
В этом посте я собираюсь поделиться тем, как именно я подхожу к решению этих задач.&lt;/p&gt;

&lt;h2 id=&quot;мыслительный-процесс&quot;&gt;Мыслительный процесс&lt;/h2&gt;

&lt;p&gt;Основной принцип, который я использую, заключается в том что каждая задача, предлагаемая к решению на собеседовании, &lt;em&gt;может быть решена&lt;/em&gt;.
На интервью вас не станут просить доказать Великую теорему Ферма. Если вам дадут какую-то неразрешимую задачу, похоже что у вас не будет особых шансов её решить.&lt;/p&gt;

&lt;p&gt;По моему опыту, примерно в 80% случаев алгоритмические задачи сводятся к фундаментальным структурам данных и алгоритмам. Структуры данных, которые я встречаю чаще всего:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево поиска&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Что касаемо алгоритмов:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Скорее всего от вас не будут требовать реализовать бинарный поиск или алгоритм сортировки, но вы &lt;em&gt;должны знать&lt;/em&gt;, что они существуют.)&lt;/p&gt;

&lt;p&gt;Кроме того, есть две дополнительные техники программирования, с которыми вы должны быть знакомы:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;алгоритм-решения&quot;&gt;Алгоритм решения&lt;/h2&gt;

&lt;p&gt;Алгоритм решения задачи выглядит так:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Как только вы получили алгоритмическую задачу, уточните требования к реализации (условия, runtime) которым должно соответствовать ваше решение. Скорее всего интервьвер ответит на этот вопрос.&lt;/li&gt;
  &lt;li&gt;Вычеркните из списка возможных структуры данных и алгоритмы которые очевидно не имеют отношения к рассматриваемой задаче. Это избавит вас от большей части списка, и вы, как правило, останетесь с 2-3 структурами данных и алгоритмами.
    &lt;ul&gt;
      &lt;li&gt;Вы можете не рассматривать слишком медленные структуры данных. Если вам необходимо решить задачу за O(1), то невомозможно использовать бинарное дерево в своем решении, так как бинарное дерево всегда будет выполнять не менее, чем за O(log n) времени.&lt;/li&gt;
      &lt;li&gt;Так же вы можете избавиться от алгоритмов, если их невозможно применить в задаче. Например, если в задаче нет графа, вы знаете, что поиск в глубину вам точно не подойдет.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Рассмотрите варианты использования оставшихся структур данных. Какие из них имеют отношения к поставленной задаче? Решением станет подходящая комбинация, вам остается её только собрать воедино.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Давайте рассмотрим среды выполнения, основные структуры данных и алгоритмы. Затем мы разберем несколько примеров, чтобы убедиться насколько прост данных подход.&lt;/p&gt;

&lt;h3 id=&quot;требования-и-сценарии&quot;&gt;&lt;em&gt;Требования и сценарии&lt;/em&gt;&lt;/h3&gt;

&lt;h4 id=&quot;хэш-таблицы&quot;&gt;Хэш-таблицы.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - поиск, вставка и удаление за O(1)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Когда вам нужно лишь находить и сохранять объекты.&lt;/li&gt;
  &lt;li&gt;Когда вам нужно разделить список объектов на группы, по некотрому свойству (это то, что делает GROUP BY в SQL)&lt;/li&gt;
  &lt;li&gt;Нужно посчитать колиечество отличных элементов из списка.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;связанные-списки&quot;&gt;Связанные списки.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - вставка нового узла, поиск и удаление узлов из головы, хвоста, или из узла на который уже есть указатель.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:
Основные сценарии применения связанных списков витают вокруг факта, что связанные списки поддерживают относительный порядок своих элементов. В интервью по программированию связанные списки, в основном, используются как реализация стека или очереди.&lt;/p&gt;

&lt;h4 id=&quot;двоичные-деревья&quot;&gt;Двоичные деревья.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - вставка, поиск и удалние за O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:
Двоичные деревья используются, когда вам нужно хранить данные в отсортированном порядке. Позволяют быстро находить количество элементов, попадающих в конкретый диапазон, или самый &lt;em&gt;высокий&lt;/em&gt; элемент в дереве.&lt;/p&gt;

&lt;h4 id=&quot;двоичный-поиск&quot;&gt;Двоичный поиск.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Вам нужно найти число в массиве, ближайшее к другому числу.&lt;/li&gt;
  &lt;li&gt;Вам нужно найти наименьше число в отсортированном массиве, которое больше чем другое число.&lt;/li&gt;
  &lt;li&gt;Вам нужно найти наибольшее число в отсортированном массиве, которое меньше другого числа.&lt;/li&gt;
  &lt;li&gt;Если по какой-то причине в своем решении вы не можете использовать хэш-таблицу, вы можете с помощью двоичного поиска проверить, находится ли элемент в отсортированном массиве.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;поиск-в-глубину&quot;&gt;Поиск в глубину.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Требуется обойти весь граф.&lt;/li&gt;
  &lt;li&gt;Требуется найти конкретный элемент в графе.&lt;/li&gt;
  &lt;li&gt;Нужно найти &lt;a href=&quot;https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B3%D1%80%D0%B0%D1%84%D0%B0&quot;&gt;компоненту графа&lt;/a&gt; (состоящий из наибольшего количества узлов подграф)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;сортировка&quot;&gt;Сортировка.&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Требования к реализации - O(n log n)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Сценарии применения:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Может использоваться в случае, когда вам нужно обработать элементы в требуемом порядке. Сначала сортируем в этом порядке, затем итерируемся по элементам.&lt;/li&gt;
  &lt;li&gt;Может использоваться для соритровки массива, к которому потом будет применяться двоичный поиск.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;динамическое-прогрммирование-и-рекурсии&quot;&gt;Динамическое прогрммирование и рекурсии.&lt;/h4&gt;

&lt;p&gt;Динамическое программирование и рекурсия отличаются тем, что являются общими методами решения алгоритмических задач, а не конкретными алгоритмами.
Это означает что у них нет конкретных сценариев применения или требуемого &lt;a href=&quot;https://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5&quot;&gt;асимптотического поведения&lt;/a&gt;. 
Хорошая новость в том, что после небольшой практики становится достаточно просто распознавать задачи, которые можно решить с помощью динамического программирования или рекурсии. Я рекомендую попрактиковаться в подобных задачах, чтобы вы &lt;em&gt;могли почувствовать&lt;/em&gt; эти методы. Полное объяснение динамического программирования и рекурсии выходит за рамки данного поста.&lt;/p&gt;

&lt;h3 id=&quot;примеры&quot;&gt;Примеры&lt;/h3&gt;

&lt;p&gt;Теперь давайте посмотрим на несколько разных алгоритмических задач с интервью, и как они могут быть решены с помощью алгоритма решения.&lt;/p&gt;

&lt;h4 id=&quot;задача-1-написать-рейт-лимитер&quot;&gt;Задача #1: Написать рейт-лимитер&lt;/h4&gt;

&lt;p&gt;Эту задачу я встречал несколько раз на интервью в разных компаниях.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Вам нужно написать функцию, которая может быть вызвана не более N раз за одну минуту. Например, она может быть вызвана лишь 10 раз в минуту.
Если функция вызывается более N раз, она должна генерировать исключение. Ожидается что функция будет работать за O(1).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Посмотрите на список алгоритмов и структур данных, которые мы можем использовать, и попытайтесь понять какие из них помогут в решении данной задачи. Затем попробуйте понять как вы можете их применить в решении. Попробуйте самостоятельно, прежде чем смотреть ответ.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Сперва исключим алгоритмы и структуры данных, которые явно не подходят.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Двоичное дерево&lt;/del&gt; — слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; — слишком медленно, и в задаче нет графа для использования этого алгоритма.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — тоже слишком медленно, в задаче нет отсортированного массива.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — снова слишком медленно. В задаче нет элементов для сортировки.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — нет способов применить динамическое программирование в решении.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — нет сособов применить рекурсию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Не вычеркнули только хэш-таблицы и связанные списки. Если мы вернемся и рассмотрим сценарии использования хэш-таблиц, то не найдем способа применить эту структуру данных в решении задачи. Нам не нужно быстро искать разные объекты, и не нужно разбивать на подгруппы списки объектов. Значит хэш-таблицы тоже можно вычеркнуть из списка.&lt;/p&gt;

&lt;p&gt;Таким образом, осталась только одна структура данных v связанные списки. Глядя на сценарии применения видим реализацию стека или очереди. Можем ли мы использовать какой то из этих вариантов для отслеживания колличества вызовов функции за последюю минуту? Да! Мы можем создать очередь, в которую будет входить одна запись за каждый вызов функции в течении последней минуты. Каждый раз, когда функция вызывается, мы удаляем из очереди все записи, которые были сделанны более минуты назад. Если очередь по прежнему имеет длинну больше N — генерируется исключение. В противном случае мы добавляем новую запись в очередь с меткой текущего времени (время вызова). Отслеживая длинну очереди с помощью переменной счётчика, которую мы можем определять за O(1), функция так же будет иметь ожидаемую производительность O(1).&lt;/p&gt;

&lt;h4 id=&quot;задача-2-анаграммы&quot;&gt;Задача #2: Анаграммы&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;На вход поаается список слов, из которого нужно составить список слов, которые являются анаграммами как минимум одного другого слова во входном списке. Два слова являются анаграммами друг друга, в случае если буквы в одном слове можно поменять местами так, чтобы получилось второе. Программа должна выполняться за O(n), если все слова одной длинны&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Снова попытатейтсь обдумать задачу самостоятельно, прежде чем читать решение. Вот уже знакомый нам список структур данных и алгоритмов:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение-1&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Начнем отбрасывать элементы из списка, которые не помогут в решении проблемы:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Двоичное дерево&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; —Тут нет графа.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — Тут нет отсортированного массива.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — Нет способа применить динамическое программирование.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — Нет способа применить рекурсию.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;У нас остались хэш-таблицы и связанные списки. Связанные списки, похоже, не пригодятся в решении этой задачи, так как стэк или очередь не выглядят эффективно. Получается что остается использовать хэш-таблицу.&lt;/p&gt;

&lt;p&gt;Единственный вариант использования хэш-таблицы, который кажется здесь уместным, — это возможность разделить список объектов на группы по некоторому признаку. В этом случае, если бы у нас был способ разделить список на отдельные группы, в которые бы входили слова анаграммы друг друга, это помогло бы решить задачу. Выглядит как план:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Разделим входной список слов на группы по признаку “анаграммности” друг друга.&lt;/li&gt;
  &lt;li&gt;Соединим вместе группы, в которых больше одного слова. В результате мы получим требуемый список слов, в котором каждое слово будет являться анаграммой как минимум одного другого слова из входного списка.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Единственное, что нам осталось решить. это найти какое-то свойство, которое мы можем использовать для группирования анаграмм. Нам нужно определить функцию &lt;em&gt;f&lt;/em&gt;, результат выполнения которой как &lt;em&gt;f(x)&lt;/em&gt; и  &lt;em&gt;f(y)&lt;/em&gt; будет одинаков, если x и y являются анаграммами друг друга.&lt;/p&gt;

&lt;p&gt;Для этой цели мы можем использовать две разные функции:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Отсортируем символы в словах по алфавиту. Мы знаем, что все анаграммы состоят из одних и тех же буква. Таким образом мы получим одну и ту же строку для любой пары слов-анаграмм.&lt;/li&gt;
  &lt;li&gt;Составим словарь из количества вхождений каждой буквы в каждом слове. Это решенее сложнее, так как придётся каким то образом использовать в качестве ключа в хэш-таблице. В некоторых языках программирования есть способ это сделать, в других нет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Теперь, когда мы нашли способ сгруппировать слова анаграммы друг друга, мы можем собрать все размышления вместе и решить задачу.&lt;/p&gt;

&lt;p&gt;Давайте попробуем рассмотреть ещё одну задачу.&lt;/p&gt;

&lt;h4 id=&quot;задача-3-k-sorted-частичная-сортировка&quot;&gt;Задача #3: K-sorted (частичная сортировка)&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;Есть массив объектов, который частично отсортирован, и его нужно “досортировать”. Каждый элемент массива находится на расстоянии, не более чем k от своего фактического места. Требования к сложности реализации алгоритма отсутствуют.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Как и ранее, вот список алгоритмов и структур данных:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;Поиск в глубину&lt;/li&gt;
  &lt;li&gt;Бинарный поиск&lt;/li&gt;
  &lt;li&gt;Алгоритмы сортировки&lt;/li&gt;
  &lt;li&gt;Динамическое программирование&lt;/li&gt;
  &lt;li&gt;Рекурсия&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;решение-2&quot;&gt;Решение&lt;/h4&gt;

&lt;p&gt;Сначала, давайте подумаем, можем ли мы что то предположить о сложности и времени выполнения алгоритма. В самом лучшем случае мы можем достичь O(n), посколько именно столько времени потребуется на итерирование по списку. Мы также можем выполнить обычную сортировку за O(n log n). Давайте определим, можно ли сделать лучше, чем O(n log n).&lt;/p&gt;

&lt;p&gt;Как нам достичь скорости в O(n)? Ну, если k=n, то сложность задачи становится такой же, как сортировка списка, поэтому невозможно постоянно попадать в O(n). Но может быть всё ещё можно решить задачу быстрее, чем за O(n log n). Теперь давайте посмотрим, какие структуры данных и алгоритмы из нашего перечня помогут в решении:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Хэш-таблицы&lt;/li&gt;
  &lt;li&gt;Связанные списки&lt;/li&gt;
  &lt;li&gt;Двоичное дерево&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Поиск в глубину&lt;/del&gt; — Нет графа.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Бинарный поиск&lt;/del&gt; — Массив не отсортирован.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Алгоритмы сортировки&lt;/del&gt; — Слишком медленно.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Динамическое программирование&lt;/del&gt; — Не подходит для решения задачи.&lt;/li&gt;
  &lt;li&gt;&lt;del&gt;Рекурсия&lt;/del&gt; — Не подходит для решения задачи.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Из оставшихся структур данных, единственная, которая имеет отношение к возможному решению — это двоичное дерево. К такому выводу мы приходим потому что только двоичное дерево единственная структура данных из списка, имееющая отношение к сортировке элементов. Если немного подумать о том, как можно применить двоичное дерево для решения, ответ станет ясен. Мы можем построить двоичное дерево из &lt;em&gt;последних k элементов&lt;/em&gt;. Мы раз за разом удаляем наименьший элемент из бинарного дерева, и добавляем в него следующий из входного массива. Полный алгоритм решения выглядит следующим образом:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Построить двоичное дерево из первых k элементов входного массива.&lt;/li&gt;
  &lt;li&gt;Перебрать оставшуюся часть массива. На каждой итерации удаляем наименьший элемент из двоичного дерева и добавляем его в результирующий массив. Затем добавляем &lt;em&gt;текущий&lt;/em&gt; элемент из входного массива в двоичное дерево.&lt;/li&gt;
  &lt;li&gt;Как только мы дойдем до конца входного массива, один за одним удаляем наименьший элемент из двоичного дерева, пока дерево не опустеет.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Анализируя сложность этого решения делаем вывод, что время выполнения составит O(n log k). Возможно ли сделать лучше? Интуитивно кажется, что тут добиться более быстрого алгоритма не получится. 
Какой алгоритм может быть эффективнее, между O(n) и O(n log k), особенно из тех, что вам удастся придумать во время интервьюирования? Дале приводится неформальное доказательство того, что вы не можете решить задачу быстре, чем O(n log k). Учитывая то, что придумать алгоритм быстрее задача не из лёгких, от вас не будут ожидать этого на интервью. Если доказательство вам не интересно, можете его пропустить.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Предположим, у вас уже есть алгоритм, который работает быстрее, чем O(n log k). Мы можем использовать его, чтобы пытаться придумать алгоритм сортировки, который быстрее O(n log n), что невозможно. Допустим, у вас есть n/k различных списков, кажрый длинной в k, причем элементы каждого списка строго больше, чем элементы предыдущего. Если вы объедините все списки вместе, запустите для них k-сортировку, а затем разделите каждые k элементов на отдельные списки, вы отсортируете n/k списков менее, чем за время O(n log k). В свою очередь это означает, что в среднем вы сортируете каждый список менее чем за O(n/(n/k) log k) = O(k log k), что невозможно. Поэтому ни один алгоритм k-сортировки не будет работать быстрее, чем O(n log k).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Это озачает что выше мы нашли оптимальное решение поставленной задачи.&lt;/p&gt;

&lt;p&gt;Надеюсь, на данный момент я убедил вас, что алгоритм решения алгоритмических задач, описываемый в этом посте — эффективный метод. Обратите внимание, что он эффективен не только при решении задач на собеседованиях, но и для решения алгоритмических задач, с которыми вы можете столкнуться в реальном мире. Вы можете использовать его, чтобы проверить, есть ли у задачи решение, состоящие из основных структур данных из нашего списка.&lt;/p&gt;

&lt;p&gt;Если вы хотите узнать о других способах решения задач, я настоятельно рекомендую книгу &lt;a href=&quot;https://www.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069111966X&quot;&gt;How to solve it&lt;/a&gt;. Эта книга охватывает множество различных подходов к решению любой задачи. How to solve it оказала огромное влияние на то, как я подхожу к любой задаче в настоящее время.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;На этом текст оригинальной статьи подходит к концу. По мере вычитывания и укрепления собственного понимания, с большой долей вероятности, в мой перевод будут вноситься улучшающие изменения.
Это статья достаточно сложная. Если вам не понятно что такое O(n) и так далее, и вы не знакомы с алгоритмами и структурами данных, о которых идет речь — не беспокойтесь! Я планирую написать цикл небольших постов на эти темы. Благодарю за уделённое время и надеюсь что превод окажется вам полезным!&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Перевод" /><category term="Программирование" /><category term="Алгоритмы" /><category term="ComputerScience" /><summary type="html">Достаточно вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью по программированию.</summary></entry><entry xml:lang="ru"><title type="html">О чём этот блог?</title><link href="http://localhost:4000/2022/01/10/about_blog.html" rel="alternate" type="text/html" title="О чём этот блог?" /><published>2022-01-10T00:00:00+03:00</published><updated>2022-01-10T00:00:00+03:00</updated><id>http://localhost:4000/2022/01/10/about_blog</id><content type="html" xml:base="http://localhost:4000/2022/01/10/about_blog.html">&lt;p&gt;Приветствую. Мысль начать вести свой блог я развивал около полугода. Сперва, идея заключалась в написании статей ради систематизирования своих знаний и мыслей. Я пробовал собрать нечто на Django и Vue, что-то получилось, но в итоге так и не ушло в &lt;em&gt;production&lt;/em&gt;. Я не был доволен результатом, так как это была всего лишь копипаста с какой то статьи “для чайников”. 
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;Впрочем не хватало и мотивации, зато работы и бытовых трудностей - навалом. Сейчас быт стало ещё гуще и напряжённее, но счасливее, благодаря унарному инкременту счётчика кол-ва членов моей семьи. А мотивации вести блог насыпали знатно. За сына я благодарю свою любимую супругу, а за мотивацию - Сергея Игоревича Бобровского, у которого я учусь программированию уже чуть более года. В виду этих обстоятельств - я более чем доволен GitHub Pages на Jekyll.&lt;/p&gt;

&lt;p&gt;Обо мне вы можете прочитать &lt;a href=&quot;/about.html&quot;&gt;здесь&lt;/a&gt;. Вернёмся к блогу.&lt;/p&gt;

&lt;p&gt;Планируется, что основной контент статей будет заключаться в описании изучаемых мной технологий, нюансов программирования и инсайтов, на которые я надеюсь. Трек обучения и лог вы можете найти в моём &lt;a href=&quot;https://github.com/NaNameUz3r/My-Learning-Tracker&quot;&gt;гитхабе&lt;/a&gt;. Оставляю за собой право на глупость и ламерство, за что прошу отнестись с пониманием. Я открыт для любой конструктивной &lt;del&gt;и не очень&lt;/del&gt; критике, всегда рад обратной связи.&lt;/p&gt;

&lt;h3 id=&quot;почему-такое-название&quot;&gt;Почему такое название?&lt;/h3&gt;

&lt;p&gt;А почему топор? Потому что &lt;em&gt;врубаемся&lt;/em&gt;. Если вы на волне хайпа стереотипизируете Хакер == Кибер-преступник, право ваше, “рыночек” &lt;del&gt;вас&lt;/del&gt; порешал. Я исповедую другое понимание, Хакерство как вдохновенный настрой ума разобраться в той или иной теме, ведущее к мастерству в исследуемой области. Сантехник, который с закрытыми глазами и оторванной рукой починит вам трубы с помощью подручных материалов, которые вам бы и в голову не пришло использовать, да ещё быстро и качественно это сделает - Хакер.&lt;/p&gt;

&lt;p&gt;Скрипт кидди, который не может отсортировать массив без стандартных библиотек ЯП, но при этом успешно разводит народ, эксплуатируя когнитивные баги человеческого мозга - банальный мошенник и преступник, какие были всегда испокон веков.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Я не хакер&lt;/strong&gt;, но wannabe. Мне нравятся информационные технологии. Я вообще плох в математике, и в контексте данного блога преследую лишь две следующие, взаимодополняемые в бесконечном цикле, цели:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Врубиться в программирование&lt;/li&gt;
  &lt;li&gt;Поделиться нарубленным&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Надеюсь вы, как говорится, get the point.&lt;/p&gt;</content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Размышления" /><summary type="html">Приветствую. Мысль начать вести свой блог я развивал около полугода. Сперва, идея заключалась в написании статей ради систематизирования своих знаний и мыслей. Я пробовал собрать нечто на Django и Vue, что-то получилось, но в итоге так и не ушло в production. Я не был доволен результатом, так как это была всего лишь копипаста с какой то статьи “для чайников”.</summary></entry></feed>