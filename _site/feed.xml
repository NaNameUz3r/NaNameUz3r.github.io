<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ru"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="ru" /><updated>2022-06-27T22:55:33+03:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Wannahack.in</title><subtitle>Врубаемся в программирование
</subtitle><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><entry xml:lang="ru"><title type="html">Передача параметров, коллекции и инварианты</title><link href="http://localhost:4000/2022/06/26/hack_in_imperative_3.html" rel="alternate" type="text/html" title="Передача параметров, коллекции и инварианты" /><published>2022-06-26T00:00:00+03:00</published><updated>2022-06-26T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/26/hack_in_imperative_3</id><content type="html" xml:base="http://localhost:4000/2022/06/26/hack_in_imperative_3.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 3.
<!--more--> 
<a href="/2022/06/06/hack_in_imperative_2.html">Читать предыдущую часть.</a></p>

<p>Сегодня продолжим ровно с того момента на котором остановились. А остановились мы комбинациях аспектов АТД.</p>

<h3 id="защищённый-декларативный-распакованный">Защищённый, декларативный, распакованный</h3>

<p>Защищенный декларативный распакованный АТД, и собственно сам способ его <em>защиты</em> мы разбирали в заключительной части постов про Декларативную модель. Идея там заключалась в истользовании функций оберки и развертки (wrap/unwrap) с ключем, который знают только “авторизованные” нами части программы.</p>

<p>Если взять АТД стек, то все его методы по сути работают через эти функции. Метод создания нового стека автоматически будет возвращать “заврапленный” стек, проверка верхнего элемента в стеке и стека на пустотность обладают нужным ключем и внутри автоматически выполняют unwrap. Ну и заталкивание с выталкиванием элементов тоже модифицируют результирующий стек сначала Unwrap’нув внутренности, и за’Wrap’ив новый список (стек). Мы помним что это декларативная модель, и по этому по сути после каждой такой операции мы получаем новую сущность.</p>

<h3 id="защищённый-декларативный-запакованный">Защищённый, декларативный, запакованный</h3>

<p>Напоминаю что <em>запакованный</em> АТД, это такой у которого данные хранятся вместе с операциями над ними.</p>

<p>Реализовать это в рамках декларативной модели можно <em>спрятав стек внутри самих операций</em> через лексическое замыкание. В таком случае стек от операций просто нельзя никак отделить. В таком случае синтаксис становится похожим на знакомый ООП:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>stack_1 = create_stack()
stack_1.is_empty()
stack_2 = stack_1.pop_out(X)
</code></pre></div></div>

<p>И так далее. Каждый метод возвращает новый стек не изменяя текущий. Wrap/Unwrap тут не нужны, потому что реализация <em>запакована</em> — результатом мы получаем “объект”, а не какой-то определенный стек, внутрь которого никак нельзя заглянуть.</p>

<p>Декларативной модели придерживаемся? Да. 
Явное состояние для безопасности подобного АТД нужно? Нет, не нужно! Нам хватает техники программирования высшего порядка.</p>

<h3 id="защищенные-stateful-реализации">Защищенные stateful реализации</h3>

<p>Запакованный вариант это по сути классическое ООП c АТД. У нас есть объект в котором во внутреннем поле содержится структура данных, например опять связанный список, если мы продолжаем в качестве примера использовать стек. Это внутреннее поле инкапсулировано, а у объекта есть методы для доступа и изменения этого поля.</p>

<p>Распакованный вариант редко применяется в ООП и ФП. Такой вариант не требует программирования высшего порядка. Здесь все операции АТД требуют в качестве одного параметра стек. Они не создают новых объектов и работают (модицируют) только с этим аргументом. Wrap тут используется при создании нового стека, а все остальные операции получают доступ к внутренностям через Unwrap.</p>

<h1 id="передача-параметров">Передача параметров</h1>

<p>Разобравшись с понятием явного состояния теперь нам нужно уделить внимание способам передачи параметров.</p>

<h2 id="call-by-reference">Call by reference</h2>

<p>Передача по ссылке — это когда процедуре передается <em>идентификатор</em> какой то сущности языка. После этого процедура может эту сущность свободно использовать в вычислениях в своем теле, обращаясь к сущности по переданному в параметрах идентификаторе. Это примитивный, но повсеместно используемый механизм в различных вычислительнях моделях, <em>фактически для всех сущностей языков программирования</em>.</p>

<p>Тем не менее императивные яп достаточно часто под передачей по ссылке имеют в виду что-то другое. Например они предполагают что идентификатор хранится в ячейке локальной для рассматриваемой процедуры. Короче, то что параметр функции является локальной переменной для этой функции. Строго говоря, такое поведение формально является <em>передачей по значению</em>, так как ссылка-идентификатор рассматривается как значение.</p>

<h2 id="call-by-variable">Call by variable</h2>

<p>Передача через переменную это особая версия передачи по ссылке. Идентификатор <em>ячейки</em> передаем в процедуру, и внутри процедуры этот идентификатор становится синонимом имени-параметра ячейки. В отличие от обычной передачи по ссылке в качестве параметра используется не оригинальный идентификатор ячейки, а <em>алиас</em>. При том этот алиас не является локальной переменной внутри функции (куда копируется ссылка), а представляет собой по сути синтаксический сахар.</p>

<h2 id="call-by-value">Call by value</h2>

<p>Передача по значению — значение передается в процедуру в ячейку-параметр, которая является локальной для этой процедуры. Реализация может быть либо через копирование значения целиком, либо через передачу лишь ссылки. Это неважно, потому что формально процедура не может никаким образом изменять внешние по отношению к себе значения (за пределами своего скоупа), даже если эти значения передаются по ссылке.</p>

<h2 id="call-by-value-result">Call by value-result</h2>

<p>Передача по значению-результату — это версия передачи через переменную, которая используется для <em>возвращения значения через параметр</em>. При вызове процедуры содержимое мутабельной ячейки помещается в другую, локальную для процедуры мутабельную переменную. Над этой переменной проиходят описанные вычисления, результат которых (при завершении процедуры) из локальной переменной перемещается обратно в изначальную ячейку.</p>

<h2 id="call-by-name">Call by name</h2>

<p>Передача по имени — это такой общий случай, когда для всех аргументов создаются отдельные процедурные значения. Называют их <strong>thunk</strong>, или преобразователь (или переходник…). Этот преобразователь вычисляется каждый раз когда в вычислениях запрашивается соответствующий аргумент, и возвращает имя ячейки — адрес нужной мутабельной переменной. Вообще thunk это <em>функция</em>, и в случае когда аргментами являются индексы цикла возможны сложные ситуации из за многократного перевычисления индексов.</p>

<h2 id="call-by-need">Call by need</h2>

<p>Передача по необходимости — это версия передачи по имени, в которой процедурное значение вычисляется единожды. Аргумент процедуры вычисляется тогда, когда запрашивается результат, после чего он сохраняется в замыкании (локальная переменная). При следующих обращениях к процедуре в качестве аргумента будет использоваться уже вычисленное значение из замыкания.</p>

<h1 id="stateful-коллекции">Stateful коллекции</h1>

<p>Коллекция является важной разновидностью АТД. Коллекции группируют вместе набор значений в единую сущность-контейнер. У коллекций есть две важные характеристики:</p>

<ul>
  <li>Поддержка индексации;</li>
  <li>Хранение фиксированного или переменного количества значений.</li>
</ul>

<h2 id="индексированные-коллекции">Индексированные коллекции</h2>

<p>Индексированные коллекции в декларативной модели — кортежи и записи. А их stateful версии — это массивы и словари.</p>

<p><strong>Массив</strong> — это коллекция конкретных значений которым однозначно соответствует ряд целых чисел (индексы). Область определения, или домен массива — это набор последовательных целых чисел от нижней до верхней границ массива. Домен массива задается при его объявлении <em>и не может быть изменен после этого</em>. Наиболее часто нижней границей является ноль, иногда с единицы (например в языках Julia, Fortran, R, и др.). Изредка допускаются отрицательные значения.</p>

<p>Доступ к эллементам массива и их изменение выполняются за константное O(1) время.</p>

<p><strong>Словарь</strong> — это коллекция из простых констант (имена, целые числа, атомы) однозначно соответствующих конкретным значениям. Домен словаря может спокойно изменяться в процессе его использования. Каждый элемент словаря представляет собой пару ключ-значение. Менять ключи в существующем элементе нельзя.</p>

<p>Доступ и изменение тут тоже выполняется за O(1), чаще всего это реализуется посредством хэш-таблиц.</p>

<p>Словари и записи очень похожи. Оба типа раскладывают простые константные ключи в соответствующие значения. Основное их отличие в том, что записи — stateless, а словари — stateful. У записей может быть фиксированный, неизменяемый набор ключей-значений, а в словарях их можно произвольно менять.</p>

<hr />

<p>Хотя кортежи, записи, массивы и словари обеспечивают доступ к эллементам за константное время, в остальном их продуктивность отличается.</p>

<p><em>Кортежи</em> самые ограниченные, но зато работают очень быстро и требуют мало памяти по сравнению с остальными типами индексирумых коллекций. Содержимое кортежей не может меняться, значения в них хранятся последовательно. Доступ по индексу, всегда лежащему в диапазоне от 1 до N — очень прост.</p>

<p><em>Записи</em> заметно более гибки в сравнении с кортежами, потому что в качестве индексов можно использовать любые литералы и числа. Числа-индексы тут не обязаны принадлежать к какому то конкретному диапазону. Значения хранятся последовательно — при создании записи генерируется хэш-таблица, которая преабразует ключи поля записи в его сдвиг в последовательности значений.</p>

<p><em>Массивы</em> допускают ещё большую гибкость и предоставляют возможность менять содержимое значений. Эффективность этого типа всё ещё остается высокой, из за того что значения хранятся последовательно, диапазон индексеов заранее известен и не меняется, а позиции конкретных элементов в памяти вычислятся быстро.</p>

<p><em>Словари</em> — самый общий случай индексированной коллекции. Словари комбинируют в себе возможности записей и массивов. Изначально словарь создается пустым без какого либо явно заданного диапазона индексов. Это наименее эффективная структура данных по времени доступа к эллементам и обновлению содержимого. Словари часто реализуются на динамических хэш-таблицах.</p>

<h2 id="неидексируемые-коллекции">Неидексируемые коллекции</h2>

<p>Есть две самые распространенные неидексируемые коллекции:</p>
<ul>
  <li><em>Потоки</em>;</li>
  <li><em>Списки</em>.</li>
</ul>

<p>Эти оба типа данных по сути хранят в себе линейные последовательности, могут последовательно перебираться от головы до хвоста. Кроме того одновременно над ним таки переборов может происходить любое количество. Хотя есть исключения из этого правила — <em>не всегда может допускаться повторный перебор с нуля</em>, например в потоках ввода-вывода.</p>

<p>Список от потока отличается тем, что список в момент времени имеет фактический хвост. Длина списка фиксирована. А поток это своего рода “незавершенный” список. Хвост потока может быть <em>несвязанной переменной</em>. Получается что поток можно всегда расширить как список. По эффективности использования памяти и по времени работы поток является одной из самых эффективных <strong>расширяемых коллекций</strong>.</p>

<h3 id="расширяемые-коллекции">Расширяемые коллекции</h3>

<p>Поток эффективно расширяется, но вот доступ к его эллементам работает за О(N), если в реализации вообще присутствует возможность доступа к произвольному элементу, а не только последовательный перебор. <em>Словарь</em>, который мы уже рассмотрели, это тоже расширяемая коллекция. Но расширение словаря само по себе уже происходит за неконстантное время.</p>

<p>Ещё один вид расширяемой коллекции это <em>динамический массив</em>. По сути это всё ещё массив, точнее <em>внутренний буфер</em> в котором хранятся элементы динамического массива — обычный массив. Но когда в буфере динамического массива полностью или почти полностью заканчивается место его буфер расширяется. Этот процесс расширения называется <em>релокацией массива</em>.</p>

<p>Существуют две схемы релокации:</p>
<ul>
  <li>Аддитивная;</li>
  <li>Мультипликативная.</li>
</ul>

<p>Аддитивная схема эффективна и применяется когда размер массива не очень большой, и как следствие расходы ресурсов на релокацию малы. Здесь увеличение происходит небольшими и фиксированными кусочками.</p>

<p>Мультипликативная схема релокации в свою очередь работает иначе. В этом случае размер буфера существенно увеличивается — в несколько раз. Эта схема применяется в случае когда размер массива большой, потому что его релоцирование требует много ресурсов. Обычно в этой схеме размер буфера просто удваивается, хотя возможны другие варианты, например — золотое сечение (увеличение буфера в 1.1618 раз)</p>

<p>Вычисления по которым буфер динамического массива сильно зависят от конкретно решаемой задачи.</p>

<p>Амортизационное время расширения динамического массива значительно лучше чем у словарей, при этом у нас сохраняется доступ к произвольным эллементам за O(1).</p>

<h1 id="инвариативные-утверждения">Инвариативные утверждения</h1>

<p>А вот это очень важная штука!</p>

<p>Мы разобрались с тем что появление в вычислительной модели явных состояний может вызывать проблемы. В частности снижается способность рассуждать и программе и вообще её понимать, особенно когда состояния используются бессистемно.</p>

<p>Когда состояние гуляет по всей программе, доступно всем частям, то такое состояние может быть модифицировано где угодно в этой программе. И че делать? Смотреть код от корки до корки, пытаясь проследить в каком месте в какой момент времени что, по идее, должно быть в этом состоянии? Бррр.</p>

<p>Представьте что это не скрипт на 200 строк а программная система на 200 тысяч строк.</p>

<p>Есть отличная джедайская техника, которая позволяет взять stateful-сложность под <em>линейный контроль</em>. Имя ей — “<em>Инвариативные утверждения (invariant assertions)</em>”. Метод применим для программ в которых есть и императивная (с состояниями) и декларативная части.</p>

<p>Декларативные части проверяются логическими выражениями — утверждениями, или assert-проверками.</p>

<p>Техника таких в computer science известка как <em>аксиоматическая семантика</em>, когда семантика всех конструкций языка программирования определяется через набор правил (аксиом). Вообще не сюрприз что это было разработано “святой троицей” —  Флойд, Хоар и Дейкстра в семидесятые годы. Тогда вообще много чего хорошего изобрели :)</p>

<p>В общем, используя метод инвариативных утверждений мы становимся способны рассуждать о каждой части программы независимо от других частей. Тем самым, даже если в системе используются состояния мы сохраняем одну из самых сильных фишек декларативной вычислительной модели: понимание всей системы является линейной суммой понимания подсистем.</p>

<p>Платим кровью — вся программа должна быть строго формально организованна на ассертах.</p>

<p>Ключевая мысль тут это то что система <em>организовывается как иерархия АТД</em>. АТД могут использовать другие АТД для своей реализации. Этот более глубокий подход чем наследование в классическом ООП.</p>

<p>Каждый АТД в подобной системе специфицируется набором инвариативных утверждений.</p>

<p><strong>Инвариант</strong> — это логическое утверждение которым мы четко определяем как связанно внутреннее состояние АТД с его аргументами. Каждая операция абстрактного типа данных <em>заранее предполагает</em> истинность одного инварианта, а по завершению эта операция <em>гарантирует истинность другого инварианта</em>. Эта истинность гарантируется программной реализацией операции.</p>

<h2 id="утверждения">Утверждения</h2>

<p>Инварианты реализуются благодаря такому понятию как asserion — утверждения.</p>

<p>Утверждение — это логическое выражение, которое располагается <em>между двумя инструкциями кода</em>. Это может быть вычисление булевого значения, или утверждения могут содержать переменные и идентификаторы ячеек используемых в коде. Кроме того они могут содержать вообще переменные и <em>кванторы</em> которые не встречаются в языке программирования, и используются только для выражений конретного проверяемого отношения.</p>

<p>Классические кванторы:</p>
<ul>
  <li>Квантор всеобщности “для всех…” — <strong>∀</strong>;</li>
  <li>Квантор существования “существует хотя бы один…” — <strong>∃</strong>.</li>
</ul>

<h2 id="утверждения-частичной-корректности">Утверждения частичной корректности</h2>

<p>Пусть каждая <strong>Oi</strong> операция АТД специфицурется двумя утверждениями <strong>Ai</strong> и <strong>Bi</strong>. Спецификация утверждается, что в случае когда инвариант <strong>Ai</strong> является истинным перед выполнением операции <strong>Oi</strong>, то по завершению <strong>Oi</strong> инваиант <strong>Bi</strong> будет истинным.</p>

<p>Это можно записать как: {Ai} Oi {Bi}, а называться такое утверждение будет <em>утверждением частичной корректности</em>. Частичное оно потому что всё утверждение будет корректным только в том случае, когда Oi завершится нормально (без рейзов исключений и прочих нежелательных ситуаций).</p>

<p><strong>Ai</strong> называется предусловием, а <strong>Bi</strong> — постусловием.</p>

<p>Полная спецификация абстрактного типа данных складывается из утверждений частичной корректности для <em>всех операций</em> этого АТД.</p>

<p>Как доказать корректность реализации самого АТД, даже если он формально описан? Для этого нужно доказать корректность реализации самих (всех) утверждений частичной корректности операций этого АТД. Когда нибудь я доберусь до пруф-чекеров , но пока это “глубокая кроличья нора” :)</p>

<h3 id="нормальный-я-нормальный">Нормальный, я нормальный!</h3>

<p>Утверждения частичной корректности, пусть они описаны для всех операций всех АТД в программе, ничего не гаранитируют нам в плане корректности завершения программы целиком. Они лишь фиксируют истинность тех или иных утверждений когда программа завершилась нормально.</p>

<p><em>Нам нужно доказать что программа вообще завершается.</em></p>

<p>Ненормальные случаи завершения это:</p>
<ol>
  <li>Провалились в бесконечный цикл;</li>
  <li>Вычисления заблокировались, когда dataflow-переменная не связалась со значением. Возникает при ошибках программиста или в ситуацих блокировок;</li>
  <li>Вычисления завершились с исключением.</li>
</ol>

<p>А теперь разберем что нужно делать в каждом из случаев выше.</p>
<ol>
  <li>Всегда когда в программе присутствует использование цикла без ограничения (цикл while или рекурсивные вызовы) есть риск что он никогда не завершится. Для того чтобы убедиться что такой цикл завершится нам достаточно доказать, что условие завершения цикла — это функция, которая неотрицательна и всегда убывает от итерации к итерации. Иными словами — нужно убедиться, что на каждой итерации цикла <em>уменьшается будущее пространство расчета</em>.</li>
  <li>Должно быть доказано то, что все переменные в программе становятся связанными со значениями до начала использования этих переменных. Для каждого использования переменной нужно проследить в обратном порядке все пути обращения к ней, и убедиться что в самом начале все эти пути выходят на связывание со значением.</li>
  <li>Самая частая причина исключений это <em>конфликты типов</em>. Поэтому нужно стараться избегать любых явных и неявных преобразований типов данных, включать по максимуму тайп чекеры на уровне компилятора и среды выполнения.</li>
</ol>

<hr />

<p>Притормозим. Оставшаяся часть курса про programming in large, и я обязательно напишу об этом в следующий или другой раз.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 3.]]></summary></entry><entry xml:lang="ru"><title type="html">Про Маршрутизацию и протоколы L1-L3</title><link href="http://localhost:4000/2022/06/19/TCP_UDP_and_something_else.html" rel="alternate" type="text/html" title="Про Маршрутизацию и протоколы L1-L3" /><published>2022-06-19T00:00:00+03:00</published><updated>2022-06-19T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/19/TCP_UDP_and_something_else</id><content type="html" xml:base="http://localhost:4000/2022/06/19/TCP_UDP_and_something_else.html"><![CDATA[<p>Немного про модель OSI и работу элементарной канальной среды.
<!--more--></p>

<h1 id="м-м-маршрутизация">М-м-маршрутизация!</h1>

<p>Роутеры нужны для маршрутизации трафика между канальными средами. Теоретически мы можем построить только на коммутаторах одну огромную канальную среду. Но из <a href="/2022/06/13/OSI_and_switches.html">прошлого поста</a> мы знаем про юникаст флуд. Представьте себе сколько ARP и MAC кадров будет получать каждый участник сети? Представьте что в такой сети 20 тысяч компьютеров… А если миллион?</p>

<p>Для этого того чтобы избавиться от лишней нагрузки на сеть нужно разделять большую сеть на разумно организованные канальные среды с помощью маршрутизаторов (роутеров).</p>

<p>Если у коммутаторов по умолчанию всё включено и работает “из коробки” — воткнул витые пары и забыл. То с роутером так не работает. Роутер из коробки ничего не знает и с кадрами работает не так как участники обычной канальной среды. Роутеру нужно указывать с каким его портом какая канальная среда живет, какой у этой среды <em>gateway</em>.</p>

<h2 id="что-такое-gateway">Что такое gateway?</h2>

<p>Gateway это адрес шлюза (по сути роутера), который занимается перекладыванием трафика между одной канальной средой и другой. Проще сказать — это адрес интерфейса маршрутизатора, назначенного на ту подсеть (канальную среду) в которой мы находимся. Когда компьютер отправитель трафика “видит” что целевой адрес находится в другой подсети, он “понимает” что в этом случае достучаться по мак адресу не получится, и шлет тогда не канальные кадры, а уже IP пакеты на шлюз. Роутер же в свою очередь получив пакет перенаправлет его на интерфейс соответствующей целевой канальной среды по IP адресу получателя.</p>

<p>Првда в пределах своей канальной среды отправитель шлет эти пакеты на роутер все равно по MAC адресу, только MAC получателя тут не MAC фактического получателя трафика, а физический адрес роутера-шлюза.</p>

<p>Но как отправитель всё это “видит” и “понимает”? Для этого используется <em>маска подсети</em>.</p>

<h2 id="что-такое-маска-подсети">Что такое маска подсети?</h2>

<p>Маска подсети определяет какая часть IP адреса относится к <em>адресу сети</em> а какая к <em>адресам хостов</em>.</p>

<p>Возьмем два одинаковых IP адреса, но с разными масками:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>192.168.15.20/24
192.168.15.20/16
</code></pre></div></div>

<p>В первом случае, при использования 24-ой (255.255.255.0) маски <em>первые три октета</em> относятся к адресу сети а последний к адресу хоста.</p>

<p>Во втором случае у нас маска 16, это значит что первые <em>два</em> октета относятся к адресу сети, а вторая пара к адресу хоста.</p>

<p>Иными словами и более просто — маска подсети указывает отправителю на то <em>сколько октетов адреса получателя нужно сравнивать с октетами <strong>своего</strong> IP адреса</em>, чтобы понять в <em>своей канальной среде</em> этот получатель находится, или нет.</p>

<p>Вернемся к маршрутизатору и рассмотрим простой пример.</p>

<p>Например у отправителя адрес 192.168.0.10 и маска подсети 255.255.255.0, а у получателя 172.20.20.20 и маска <em>такая же</em>. Отправитель согласно своей маске поймет что адрес получателя находится в другой канальной среде (октеты не совпали) и будет искать в своей сети <em>MAC адрес маршрутизатора</em> (основной шлюз, gateway) выполнив широковещательный ARP запрос (если в его таблице ещё нет MAC адреса маршрутизатора).</p>

<p>Получив в ответном ARP кадре от роутера его адрес, компьютер отправитель отправит <em>пакет</em> (не канальный кадр!) на MAC адрес роутера.</p>

<p>Получив пакет на свой MAC адрес роутер видит IP адрес получателя, понимает что нужно перенаправить трафик в другую канальную среду, но для этого ему нужен MAC получателя. Поэтому уже по хорошо известной нам схеме роутер ARP бродкастом будет искать MAC получателя в целевой канальной среде.</p>

<h1 id="ip-адреса">IP адреса</h1>

<p>В отличие от MAC адресов, IPv4 адреса представляются в десятеричной системе исчисления и состоит из четырех <em>октетов</em> разделяемых точками. Каждый октет является числом из 8 бит (1 байт). Компьютеры видят эти числа (да и вообще всё :D) в двоичной системе исчисления.</p>

<p>IP адреса делятся на частные и публичные диапазоны.</p>

<p>Наиболее часто используемые сетевыми инженерами диапазоны частных IP адресов:</p>
<ul>
  <li>10.0.0.0/8 (всё что начинается с 10);</li>
  <li>172.16.0.0/12 (всё что начинается с 172.16.0.0 по 172.31.255.255);</li>
  <li>192.168.0.0.16 (всё что начинается с 192.168.0.0 по 192.168.255.255).</li>
</ul>

<p>Эти IP адреса не маршрутизируются в интернет и используются только в локальных сетях (например в каких нибудь организациях), виртуальных сетях инфраструктур облачных провайдеров и так далее. Имейте в виду что нам никто не запрщает в локальной сети придумать какой угодно адрес, но он всё равно останется частным. Список выше представлен лишь самыми популярными диапазонами. Правда есть несколько исключений! Это специальные зарезервированные адреса которые либо не получится вообще назначить, либо не будут работать (вообще или возможны проблемы):</p>

<ul>
  <li>127.0.0.0-127.255.255.255 — это loopback адреса по которым хост общается сам с собой;</li>
  <li>169.254.0.0-169.254.255.255 — Automatic Private IP Adressing (APIPA), это автоматические адреса генерируемые в винде службой APIPA.</li>
  <li>0.0.0.0 и любые адреса с нуля либо не будут вообще работать, либо система не даст их назначить на устройстве. Такие адреса используются по умолчанию сетевыми устройствами, например когда у них ещё никакой адрес не назначен;</li>
  <li>255.255.255.255 — широковещательный адрес (и любой другой, в зависимости от маски);</li>
  <li>224.0.0.0-247.255.255.255 — мультикаст диапазон;</li>
  <li>248-255.х.х.х — адреса зарезервированные для целей тестирования сетей;</li>
  <li>x.x.x.0 или x.x.0.0 — адреса сетей (в случае “нормальных” масок);</li>
  <li>x.x.x.255 или x.x.255.255 (и тд) — широковещательные адреса сети (в случае “нормальных” масок).</li>
</ul>

<p>Публичные IP адреса напротив — маршрутизируются в интернете, то есть доступны в интернете практически откуда угодно.</p>

<p>Контроль и выдача публичных адресов регулируется целой цепочкой специальных организаций. Если вдруг вам понадобится IP адрес для публичного сервера, вам придется запросить его у своего интернет провайдера, который в свою очередь получает набор таких адресов от LIR, а те от RIR. RIR от IANA. А IANA наконец от ICANN. Благодаря этой цепочке контроля достигается уникальность каждого публичного IP адреса в интернете.</p>

<p>Если ваш потенциальный сервер будет “путешествовать”, вам не хотелось бы терять публичны адрес выданный интернет провайдером. В таком случае можно получить <em>провайдеро независимый IP</em> обратившись в LIR напрямую.</p>

<p>Я не очень хочу тут отвлекаться на описание этих организаций, смело гуглите аббревиатуры.</p>

<p>И ещё раз закрепим — зная маску мы (и в двоичном виде компьютер) можем определить адрес подсети. Например 192.168.15.20/24 будет находится в подсети 192.168.15.0, так как маска у нас 24 (первые три октета). Такой адрес подсети мы не можем назначить на какой-то узел самостоятельно. При такой маске адреса хостов будут находиться в диапазоне 192.168.15.1 по 192.168.15.254.</p>

<p>Но куда делся 255?</p>

<p>192.168.15.255 в нашем случае будет служебным, <em>широковещательным</em> IP адресом, по которому узлы могут отправлять пакеты всем хостам в своем домене.</p>

<h2 id="более-сложные-маски-подсети">Более сложные маски подсети</h2>

<p>Иногда границы подсетей проходят по не таким “ровным” маскам, которые мы уже рассмотрели.</p>

<p>Например мы можем встретить IP адрес с такой маской — 255.255.255.192</p>

<p>Что это такое и что с этим вообще делать?</p>

<p>Сперва нам нужно перевести эту маску в двоичную систему исчисления. Получается 11111111.11111111.11111111.11000000, значит это 26-ая маска. Да, в сокращенном формате маска это просто количество единиц в двоичном представлении. Важно чтобы в маске <em>единицы шли подряд</em>, иначе IP маска просто не будет работать. Компьютер не поймет сколько бит адреса нужно брать для сравнения.</p>

<p>Имеем, например, адрес 192.168.15.87 /26
Мы точно знаем что первые три октета оносятся к сети (маска больше 24). Но что с оставшимся октетом?</p>

<p>Чтобы найти границу подсети нужно перевести IP адрес в двоичный вид. Получаем 11000000.10101000.00001111.01010111
Ну, собственно и всё. Зная что у нас маска 26 мы понимаем что адрес сети будет составлять первые 26 бит. Отсчитываем 26 и отбрасываем всё что осталось: 11000000.10101000.00001111.01 | 010111 -&gt; всё что отбрасываем заменяем нулями и получаем адрес подсети: 11000000.10101000.00001111.01000000. Переведем его в десятичную. Получается 192.168.15.64, а значит адресом первого хоста в этой подсети будет 192.168.15.65.</p>

<p>Чтобы понять каким будет последний адрес в этой канальной серед нам сперва нужно вычислить её широковещательный адрес. Для этого мы снова берем последний октет адреса подсети, но ту часть которую мы отбрасывали и превращали в нули, наоборот — обозначаем единицами. Получаем 11000000.10101000.00001111.01111111, что в десятичной 192.168.15.127</p>

<p>Значит адрес последнего хоста в подсети будет 192.168.15.126, а 192.168.15.128 уже адресом другой подсети.
Итого диапазон адресов хостов получается 192.169.15.65-126</p>

<h1 id="osi-vs-tcpip">OSI vs TCP/IP</h1>

<p>При инкапсуляции изначальные, читаемые человеком данные дополняются заголовками протоколов на каждом уровне. В итоге на физическом уровне весь этот пирог передается в бинарном виде, а получатель начинает декапсулировать пирог обратно отрезая от него на каждом уровне нужные заголовки по пути выполняя преобразования данных возвращая их к изначальному виду.</p>

<p>На транспортном уровне появляется такое понятие как порт. Этот уровень определяет возможность устройствам “понять” какая последовательность бит передаваемых по сети какому приложению адресована.</p>

<p>TCP/IP модель на самом деле то же самое что OSI. В TCP/IP работают все те же самые протоколы, но это более обобщенная форма понимания сетевого взаимподействия. В TCP/IP стеке сетевая модель делится на 4 уровня:</p>
<ul>
  <li>Link уровень, это по сути физический и канальный уровень OSI;</li>
  <li>Internet — тоже самое что уровень Network, то есть сетевой в OSI;</li>
  <li>Transport уровень называется так же;</li>
  <li>А вот последние три уровня модели OSI: Application, Presentation и Session в понимании TCP/IP объединяются в один прикладной уровень (Application).</li>
</ul>

<p>Главное что здесь нужно понять это то что обе модели по факту одно и то же, и представляют собой лишь разное <em>логическое</em> понимание, разное логическое разделение уровней процессов которые происходят при сетевой передаче данных.</p>

<h1 id="заголовок-ethernet-l2-header">Заголовок Ethernet (L2 Header)</h1>

<p>Протокол Ethernet работает на канальном уровне. Заголовок этого протокола называется Ethernet кадром. Он определяет каким образом данные будут передаваться в одной канальной среде.</p>

<p style="text-align: center;"><img src="/images/Ethernet_Frame.jpg" alt="Кадр Ethernet" /></p>

<p>Разберемся с полями заголовка:</p>

<ul>
  <li>
    <p>Преамбула является идентификатором начала передачи кадра. Больший смысл эта часть кадра имела раньше, когда использовалась общая шина. Преамбула была своего рода предупреждающим “криком” для всех остальных участников канальной среды, вроде “Эй! Я сейчас буду кадр слать, помолчите все!”. Короче чтобы занять среду для вещания.</p>
  </li>
  <li>
    <p>Потом идут MAC адреса получателя и следом за ним отправителя, каждый из которых размером в 6 байт. Порядок физических адресов в заголовке обусловлен тем что есть такая технология как Cut-Through. Эта технология поддерживаеся некоторыми свитчами и позволяет не помещать весь получаемый кадр в буфер, а сразу “налету” перекладывать кадр в нужный исходящий буфер. Перекладывать получается быстрее, потому что адрес получателя находится ближе к “голове” кадра, чем оставшаяся часть. Таким образом свитч чисто физически быстрее видит адрес получателя и передает кадры куда надо. “Глупые” свитчи не умеют в Cut-Through и сначала помещают данные в буфер целиком.</p>
  </li>
  <li>
    <p>2-х байтовый заголовок “Тип(длинна)” в наше время содержит информацию о длинне передаваемых данных. Раньше в этом заголовке указывался тип передаваемых данных, что служило маркером для передачи кадров обработчикам соответствующих типов. Поле длинна находится перед данными для того чтобы получатель мог понять в какой момент в кадре закончатся данные и начнется чексумма.</p>
  </li>
  <li>
    <p>Следующее поле самое большое по размеру и содержит данные. Вместе с ними в это поле добавляются значения SNAP/LLC. SNAP — это Subnet Access Protocol, не слишком вдаваясь в подробности, это вложение в поле с данными служит для инкапсуляции, а именно как идентификатор того какому протоколу нужно передавать данные из кадра на уровень выше. <em>Обратите внимание на то, что это поле по умолчанию ограничено размером в 1500 байт.</em> Это ограничение продиктовано тем что необходимо эффективно (точно) вычислять чексумму. Тем не менее этот показатель можно увеличить. Это конфигурируется на сетевых устройствах параметром MTU (Maximum transmission unit). При увеличении MTU мы повышаем скорость работы сети, так как каждый из кадров начинает вмещать в себя больше данных, но важно помнить о том что мы тем самым понижаем эффективность вычисления чексуммы.</p>
  </li>
  <li>
    <p>В самом конце кадра находится чексумма (FCS) — остаток от деления битовой последовательности всего кадра на 2**32 - 1 (за исключением преамбулы). Чексумма нужна для того чтобы получатель мог проверить кадр на целостность (не побилась ли битовая последовательность при передачи по сети).</p>
  </li>
</ul>

<h1 id="заголовок-ip-l3-header">Заголовок IP (L3 Header)</h1>

<p>Переходим к сетевому уровню. На предыдущем уровне мы передавали данные в пределах одной канальной серды и заголовок Ethernet выглядит достаточно просто. Теперь задача усложняется, вступает в полную силу в работу протокол IP, данные теперь нужно как-то маршрутизировать между сетями.</p>

<p style="text-align: center;"><img src="/images/IP_Header.jpg" alt="Кадр Ethernet" /></p>

<p>Разберемся с тем что тут есть.</p>

<ul>
  <li>
    <p>Версия - IPv4 или IPv6.</p>
  </li>
  <li>
    <p>IHL - содержит размер самого заголовка (всё кроме данных). Почему тут есть такое поле а в заголовке предыдущего увроня такого не было? Потому что размеры заголовка IP не фиксированы и могут отличаться от случая к случаю (могут быть Опции).</p>
  </li>
  <li>
    <p>Тип обслуживания используется для различных сетевых механизмов. Например для механизма очередей и других которые могут быть имплементированы в сетевом оборудовании. Например тут может указываться важность пакета, то есть его приоритет, место в очереди буфера сетевого устройства на передачу.</p>
  </li>
  <li>
    <p>Длинна пакета содержит в себе длинну всего пакета (IHL + размер данных).</p>
  </li>
  <li>
    <p>Поля идентификатор, флаги и смещение фрагмента нужны для того чтобы правильно нарезать IP пакеты на канальные кадры. Как мы помним поле Ethernet кадра под данные ограниченно параметром MTU, а IP пакет разумеется может быть больше, намного больше этого значения. Когда IP пакет нарезается на части, в каждом таком кусочке записывается <em>одинаковый</em> идентификатор, который указывает на принадлженость к одному IP пакету. Устанавилвается флаг фрагментированности. А в поле “Смещение” таких кусков-фрагментов указывается сдвиг этого фрагмента относительно первого из них. Можно очень условно назвать это смещение “индексацией” фрагментов, чтобы в результате пакет собирался в правильном порядке, так как фрагменты могут доходить на конечное устройство не по порядку.</p>
  </li>
  <li>
    <p>Время жизни пакета (TTL) нужно для того чтобы избежать появление так называемых “петель маршрутизации” в сетях. Изначально в это поле записывается число 255, и каждый <em>роутер</em> на хопе через себя “отщипывает” от счетчика TTL единицу. Петля маршрутизации между роутерами это такая ситуация когда пакет никак не может прийти к устройству получателю и бегает по кругу в одной и той же цепи роутеров. Роутер при получении пакета с счетчиком TTL равным нулю уничтожает этот пакет.</p>
  </li>
  <li>
    <p>В поле “Протокол” записана информация о том какому выше по уровню протоколу предназначен пакет (Как правило UDP или TCP).</p>
  </li>
  <li>
    <p>Контрольная сумма IP пакета отличается от чексуммы канального кадра тем что она высчитывается только от полей заголовка пакета. То есть в её рассчет не входят сами данные, и как следствие их целостность на этом уровне <em>не проверяется</em>. Целостность данных, как мы уже разобрали, проверяется на канальном уровне — там чексумма вычисляется от всего кадра включая данные.</p>
  </li>
  <li>
    <p>С полями адресов я думаю всё понятно. Когда пакет отправляется с одного компьютера — IP адрес отправителя записывается в соотвеетствующее поле, а на основании IP адреса получателя пакет обрабатывается в зависимости от устройства где пакет “находится” в конкретный момент времени. Роутеры смотрят по адресам получателя куда пакет нужно перенаправить, а получатель проверяет это поле — отправлен ли пакет именно ему, и если да, то какому обработчику его нужно передать (Поле “Протокол”).</p>
  </li>
  <li>
    <p>Поле Опции служит для расширения дефолтного функционала IP заголовка. Используется редко и специфическими устройствами.</p>
  </li>
  <li>
    <p>Смещение нужно для своего рода “балансировки” поля опций. Все поля заголовка IP пакета выровнены по границе 4 Байт (спецификация протокола IP), тогда как Опции не имеют фиксированной длинны и могут “плавать”. Смещение служит для того чтобы Опции можно было подровнять до требуемой границы.</p>
  </li>
  <li>
    <p>Поле Данные содержит передаваемую информационную нагрузку.</p>
  </li>
</ul>

<h2 id="jumbo-frame">Jumbo Frame</h2>

<p>Повторюсь что нужно быть бдительным касаемо MTU. Кадр у которого размер поля данных больше дефолтных 1500 байт называется Jumbo Frame. Здесь есть подводные камни. Когда мы повышаем MTU, во-первых отправитель и получатель должны уметь работать с такими пухлыми кадрами. Короче говоря, MTU должен быть одинаково сконфигурирован на первом и втором устройстве.</p>

<p>Во-вторых, это увеличивает нагрузку на маршрутизатор. Не смотря на то что в пределах канальной среды передача по сети начинает работать быстрее, мы можем столкнуться с проблемами передачи <em>между</em> сетями. Почему? Когда на роутер приходит jumbo frame, он понимает что внутри находится здоровый IP пакет, и в какую среду нужно перенаправлять трафик. Если целевая среда не поддерживает такой MTU роутеру придется вскрывать кадр, вытаскивать из него IP пакет и фрагментировать его.</p>

<h1 id="заголовки-транспортного-уровня-l4-headers">Заголовки транспортного уровня (L4 Headers)</h1>

<p>Теперь давайте рассмотри заголовки UDP и TCP протоколов.</p>

<h2 id="udp-header">UDP Header</h2>

<p>UDP Заголовок предельно прост.</p>

<p style="text-align: center;"><img src="/images/UDP_header.jpg" alt="UDP header" /></p>

<p>UDP занимается только распределнием трафика приложений.</p>

<p>В порт отправителя записывается либо рандомный свободный порт при отправке либо какой то определенный, и нужный порт получателя в соответствующее поле. После получения датаграммы и её обработки в ответной датаграмме значения этих полей меняются местами.</p>

<p>В поле длинна записывается длинна всей датаграммы — заголовок + данные. Контрольная сумма высчитывается тоже от всей датаграммы. UDP не осуществляет контроль доставки, поэтому если чексумма не сходится получатель “молча” отбрасывает битую датаграмму.</p>

<p>Отправлять данные без контроля доставки важно в том случае, когда неприемлимы задержки. Например потоковая передача медиаконтента (аудио, видео).</p>

<h2 id="tcp-header">TCP Header</h2>

<p>А теперь про серьезного парня. TCP не только распределяет трафик, но и выполняет ещё множество других функций. Первая и самая главная из них это контроль доставки пакета. Если у получателя чексумма не сходится при проверке, то протокол ещё раз запрашивает отправку пакеты который был побит.</p>

<p>Контроль доставки нужен когда данные чувствительны к потерям (важен правильный порядок переданных бит данных), например почту, текст и так далее.</p>

<p>Заголовок выглядит так:</p>

<p style="text-align: center;"><img src="/images/TCP_header.jpg" alt="TCP header" /></p>

<p>Ещё одной задачей TCP является сбор фрагментированных пакетов в правильной последовательности.</p>

<p>Далее, TCP в отличие от UDP умеет устанавливать сессии.</p>

<p>С портами, думаю, всё понятно.</p>

<p>Поля Порядковый номер и номер подтвеждения используются по разному, в зависимости от стадии передачи — установлена уже сессия или только устанавливается.</p>

<p>Поле “Длинна заголовка” нужно потому что здесь у заголовка снова (как в IP) есть поле нефиксированной длинны (“Опции”) — даем понять получателю когда заканчивается заголовок и начинаются данные.</p>

<p>“Флаги” используются для установления сессии, а в поле “Зарезервированно” специальные флаги для “протокольных” нужд.</p>

<p>“Размер окна” нужен для осуществления оптимизации контроля доставки. Как вообще работает контроль доставки? Вкратце ― получатель должен на каждый получаеммый TCP пакет отвечать подтверждением того что всё ОК и чексумма “срослась”. Значение размера окна указывает на колличество полученных пакетов, после которых нужно отправлять подтверждение что всё с ними было ОК. После установления сессии подтверждения отправляются на каждые три пакета, если потерь не происходит то размер окна увеличивается. Протокол следит за колличеством успешных и неуспешных отправок и регулирует размер окна в соответствии с колличеством потерь. Чем реже происходят потери — тем больше становится размер окна.</p>

<p>Если вы когда нибудь что-то качали по сети то наверняка видели сначала приерное время окончания загрузки неадекватных размеров, например 2 года. А потом бах, и время всё меньше и меньше становится. Это вот как раз размер окна меняется :)</p>

<p>Чексумма вычисляется от размера всего пакета.</p>

<p>Поле опций у TCP уже интереснее, так как используется чаще, в отличие от редких случаев использования опций в IP пакетах. Это потому что у TCP есть много разных расширений и дополнений которые управляются как раз посредством этого поля.</p>

<p>В данных тут уже то с чем будет работать прикладной протокол выше (HTTP например).</p>

<h2 id="установка-tcp-сессии">Установка TCP сессии</h2>

<p>Рассмотрим в приблизительном порядке что происходит с TCP заголовками при установке сессии:</p>

<ol>
  <li>Изначально клиентом устанавливаются значения портов отправителя (источника) и получателя (назначения).</li>
  <li>Клиент устанавливае рандомное число в поле “Порядковый номер”.</li>
  <li>Отправитель (клиент) устанавливает флаг SYN, который как раз и обозначет попытку установить сессию.</li>
  <li>Сформированный SYN пакет отправляется по сети и попадает к получателю (серверу).</li>
  <li>Получатель в ответном пакете меняет местами порт получателя и отправителя.</li>
  <li>Сервер устанавливает рандомное число в поле Порядковый номер в ответном пакет.</li>
  <li>А В “Номер Подтверждения” ответного пакета сервер записывает значение из поля Порядкового номера полученного от клиента SYN пакета прибавляя к этому числу единицу.</li>
  <li>Так же к флагу SYN в ответном пакете добавляется флаг ACK.</li>
  <li>Клиент получив SYN+ACK пакет опять менят местами порты, перемещает значение из Порядкового номера в Номер подтверждения прибавляя к этому числу единицу. Убирает флаг SYN оставляя флаг ACK и снова отправляет уже такой “ACK пакет” серверу.</li>
  <li>Сессия установилась. Произошел так называемый процесс <em>3-way handshake</em> (SYN -&gt; SYN+ACK -&gt; ACK).</li>
  <li>В установленной сесии идет обмен данными. Когда сессия установилась в поле “Порядковый номер” начинают записываться <em>номера пакетов</em>, а в “Номер подтверждения” записываются номера уже <em>полученных</em> пакетов.</li>
  <li>По завершеню обмена происходит процесс закрытия сессии обменом пакетами: FIN+ACK от клиента к серверу, ответ FIN+ACK обратно клиенту, и последний ACK от клиента о получении FIN+ACK. Если клиент не завершит сессию на сервере она всё равно закроется по таймауту, если ничего не будет прилетать по открытой сессии.</li>
</ol>

<hr />

<p>На сегодня это всё!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сети" /><summary type="html"><![CDATA[Немного про модель OSI и работу элементарной канальной среды.]]></summary></entry><entry xml:lang="ru"><title type="html">Про модель OSI и коммутаторы</title><link href="http://localhost:4000/2022/06/13/OSI_and_switches.html" rel="alternate" type="text/html" title="Про модель OSI и коммутаторы" /><published>2022-06-13T00:00:00+03:00</published><updated>2022-06-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/13/OSI_and_switches</id><content type="html" xml:base="http://localhost:4000/2022/06/13/OSI_and_switches.html"><![CDATA[<p>Немного про модель OSI и работу элементарной канальной среды.
<!--more--></p>

<p>Всем привет! Я наконец дожил до момента когда начал нормально изучать сети! Конечно у меня был курс по сетям в колледже, и это было самое интересное и толкое их того что там вообще преподавалось (помимо основ схемотехники). Но признаюсь честно, во-первых, я тогда не очень сильно был заинтересован в учебе (о чем сильно сожалею), во-вторых, пусть в голову нам вдалбывалось знатно — я многое уже успешно забыл.</p>

<p>Последнее время в своей профессиональной практике я всё более остро ощущал нехватку хороших, фундаментальных знаний о сетевых технология. С одной стороны, в принципе базового понимания “как оно там вообще работает”, (ну то что есть порты и тд :) жидкого знания основных протоколов в большей части задач вроде бы как достаточно, но когда дело доходит до откровенного ступора — лично мне перед самим собой стыдно бэкать и мэкать. Не стыдно бежать за помощью к коллегам, стыдно испытывать <em>нехватку компетенции.</em></p>

<p>Да, коллеги всегда помогут, но нужно же профессионально расти! И ещё один немаложваный фактор — мне до чертиков эта тема интересна!</p>

<p>Сегодня я хочу вкратце написать про модель OSI и немного поговорить про коммутаторы и физические адреса устройств.</p>

<p>Кстати, значальное описание OSI в распечатанном виде имеет толщину в один метр.</p>

<p>Поехали!</p>

<p style="text-align: center;"><img src="/images/wow.png" alt="Эмодзи шокового удивления" /></p>

<h1 id="osi">OSI</h1>

<p>OSI (Open System Intreconnection model) — это эталонная модель стека сетевых протоколов которая состоит из семи <em>логических</em> уровней. Можно сказать что эта модель своего рода “скелет” всех сетевых сущностей. Она определяет протоколы следуя которым эти самые сущности между собой как-то взаимодействуют. Протокол — это “набор правил” <em>интерфейса логического уровня</em>, которыё определяют каким образом программы должны обмениваться данными между собой. Но сегодня мы говорим не о протоколах. Я недавно писал про <a href="/2022/06/01/DNS.html">HTTP</a>, <a href="2022/05/31/FTP.html">FTP</a>, и <a href="/2022/06/01/DNS.html">DNS</a>.</p>

<p>Передача всегда происходит от уровня к уровню, последовательно подключая нужные протоколы на каждом из них.</p>

<p>Как уже было сказанно модель OSI делится на семь уровней:</p>

<p style="text-align: center;"><img src="/images/OSI.jpg" alt="Схема модели OSI" /></p>
<p><em><center>Извините что криво, я правда старался!</center></em></p>

<p>Модель OSI разрабатывалась давненько — в семидесятых годах. Задачей была попытка описать архитектуру и как вообще должны работать сети.</p>

<p>На последнем седьмом уровне передаваемые данные представляются в виде фактических данных (то как мы их воспринимаем), а на первом — бежит по каналам в бинарном виде.</p>

<p>Процесс в котором данные от уровня к уровню конвертируются из читаемых данных в биты называется знакомым нам из программирования словом <em>инкапсуляция</em>. Обратный процесс — <em>декапсуляция</em>. На каждом из уровней информация представляется в виде так называемых PDU (Protocol Data Unit), это такие блоки данных.</p>

<p>Все уровни условно делятся на две группы: уровни среды передачи, и уровни хоста. Уровни с 1 по 3 это уровни среды передачи. Они занимаются непосредственно передачей информации, тогда как остальные уровни хоста (с 4 по 7) используются непосредственно на наших девайсах (десктопы, лаптопы, смартфоны и тд).</p>

<h2 id="физический-уровень-l1">Физический уровень L1</h2>

<p>Уровень отвечает за обмен электрическими или оптическими сигналами по проводам, или радиоволнами по беспроводным сетям (Bluetooth, WiGI, GSM и вот это вот всё) между устройствами. Наши компьютеры вообще ничего не знают про то что такое картинки, какая там фотография изображена, что на нашем смешном мемасике. Компьютеру мемасы понятны только как наборы нулей и единиц (это грустно, я бы поговорил с железякой). Здесь <em>бит</em> является блоком данных (PDU).</p>

<p>Каждый уровень по сути имеет свои PDU, представляемые образом понятным протоколам этого уровня. А иногда и протоколам следующего уровня (например для возможности преобразования).</p>

<p>Работа с “чистыми” данными будет производиться только на уровнях с 5 по 7.</p>

<h2 id="канальный-уровень-l2">Канальный уровень L2</h2>

<p>На этом уровее решается проблема <em>адресации</em> передачи. Канальный уровень инкапсулирует биты в <em>кадры</em> (frame). Кадры формируются с адресами отправителя и получателя, а потом отправляются дальше.</p>

<p>Тут есть условно два “подуровня” — это MAC и LLC. Первый служит для “присвоения” физических адресов железок, а второй занимается проверкой и исправлением данных, а так же управляет их передачей.</p>

<p>На втором уровне OSI работают коммутаторы (сетевая железяка), их задачей является передача сформированныех кадров от одного устройства к другому используя в качестве адресов только физические MAC-адреса. Про комммутаторы и MAC адреса мы поговорим в заключительной части.</p>

<h2 id="сетевой-уровень-l3">Сетевой уровень L3</h2>

<p>Здесь вводится понятие маршрутизации. Маршрутизацией занимаются специальные железяки… маршрутизаторы (роутеры). Роутеры получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута между устройствами.</p>

<p>На сетевом уровне есть протокол ARP (Address Resolution Protocol), благодаря которому MAC-адреса определенным образом преобразуются в 32-битные IP-адреса и наоборот.</p>

<p>Единица данных (PDU) передаваемая с использованием маршрутизации уже называется не кадр а <em>пакет</em>.</p>

<h2 id="транспортный-уровень-l4">Транспортный уровень L4</h2>

<p>Помните мы говорил про уровни среды и уровни хоста? Так вот четвертый уровень это что-то вроде уровня посредника между этими двумя группами. Транспортный уровень управляет передачей пакетов в сети, определяет каким приложениям на уровнях выше предназначаются данные (использование портов). Тут работают такие протоколы как TCP и UDP. TCP контролирует целостность передаваемой (доставленной) информации, а UDP — нет. В TCP <em>устанавливается соединение</em> пакеты данных делятся на сегменты, успешность и целостность доставки каждого пакета некоторым образом “проверяется”. Отправили, подождали подтверждения что все дошло ОК, не дошло - отправили ещё раз. В UDP — отправил куда сказали и забыл, плевать если какая то датаграмма (в этом протоколе пакеты делятся на датаграммы а не на сегменты) потерялась или дошла битой. Чуть подробнее про эти протоколы мы поговорим в следующий раз.</p>

<p>И <em>сегмент</em> и <em>датаграмма</em> это PDU транспортного уровня.</p>

<h2 id="сеансовый-уровень-l5">Сеансовый уровень L5</h2>

<p>Уровень отвечает за поддержку сессии (сенса) связи. Начиная с этого уровня данные оперируются в “чистом” виде. Сеансовый уровень управляет тем как разные приложения взаимодействуют между собой, предоставляет возможность синхронизации задач. Всё это нужно для работы следующего уровня.</p>

<h2 id="уровень-представления-данных-l6">Уровень представления данных L6</h2>

<p>Уровень “конверитрует” данные, которые всё ещё в виде каких то PDU в представление понятное человеку (и компьютеру). Например тут происходит перевод текста из одной кодировки в другую. Видео и изображения тоже обрабатываются на этом уровне. А ещё, если соединение требует шифрования, в бой оно вступает так же на уровне представления данных.</p>

<h2 id="прикладной-уровень-l7">Прикладной уровень L7</h2>

<p>Это уровень приложений (application level). Это тот уровень с которым взаимодействуют конечные пользователи. Короче говоря, задачей протоколов этого уровня является только предоставление возможности пользователю увидеть данные в понятном ему форме (например, HTTP протокол 7 уровня).</p>

<h1 id="зачем-мне-знать-osi-если-везде-tcpip">Зачем мне знать OSI, если везде TCP/IP</h1>

<p>Модель OSI это стандарт (ISO/IEC 7498). Его просто надо знать, потому что не смотря на запятнаную репутацию и критику модель есть и она всё ещё используется.</p>

<p>Репутация… Ну, модель OSI много и оправданно критикуют. Её слишком долго разрабатывали и её обвиняют в том, что модель <em>не совсем отображает действительность</em>. На момент релиза OSI уже широко был распространен стек TCP/IP. Кто знает, если бы с разработкой OSI не затягивали она была бы фактическим, “настоящим” стандартом. Или если бы модель не проектировали в сверхсекретном “закрытом” режиме, тогда как стек TCP/IP изначально была <em>открыт</em>, она была бы принята с более распростертыми руками.</p>

<p>Ещё OSI критикуют из за того что функции уровней распределены между ними неравнозначно, и что вообще одинаковые задачи могут быть решены на <em>разных уровнях</em>. В общем ругают за то что уровней вообще слишком много, сеть можно построить используя только первые 4.</p>

<p>—-</p>

<h1 id="коммутируй-то-коммутируй-это">Коммутируй то! Коммутируй это!</h1>

<p>Я обещал чуть больше рассмотреть канальный уровень. Приступаем!</p>

<h2 id="зачем-в-сетях-нужны-коммутаторы">Зачем в сетях нужны коммутаторы?</h2>

<p>Современные сети построенны на канальном уровне с использованием коммутаторов, которые связывают разные компьютеры между собой. Грубо говоря коммутаторы нужны не только чтобы просто соединить машины, но в первую очередь — чтобы избежать коллизиий присущих такой устаревшей сетевой топологии как “шина”, в которой как раз таки все машины связывали в тупую одним каналом.</p>

<p>Так вот, шина — это когда все компьютеры в сети, грубо говоря, подключены к одному “кабелю”, а коллизия это такой “цифровой” хаос в сети, когда одновременно пытаются общаться больше двух машин по одному каналу. Например коллизия может возникнуть в шине когда в сети есть сервер и N компьютеров, и одновременно два (или больше) клиента попробуют обратиться к одному и тому же серверу.</p>

<h2 id="устройство-коммутатора">Устройство коммутатора</h2>

<p>У сетевого коммутатора (свитча) есть условно два буфера: входящий и исходящий. На самом деле буферы логически делятся на буферы портов.</p>

<p>Когда в сети с коммутатором один из компьютеров отправляет данные другому, эти данные сначала попадают во входящий буфер свитча (коммутатора) по одному из портов. После этого свитч решает на какой иной порт (куда) эти данные нужно перенаправить (используя MAC таблицу, про MAC будет дальше), а точнее <em>на <strong>исходящий</strong> буфер какого порта их нужно перенаправить</em>.</p>

<p>После этого коммутатор ждет когда целевой канал освободится, ведь с сервером могут общаться другие участники сети нему же. Когда это происходит данные из соответствующего буфера свитча отправляются целевому получателю. В одном таком исходящем буфере могут спокойно ждать своей очереди данные от двух и более участников сети (которые хотят достучаться на один и тот же сервер например).</p>

<p>Именно благодаря описанному выше механизму (очереди в буфере) коллизий в сети не происходит.</p>

<p>В старые (но не очень) времена существовали так называемые концентраторы (хабы). Отличались они от свитчей тем что у них не было буферов. Такое устройство по сути являлось всего лишь электрическим повторителем, и никак не уберегало сеть от возникновения коллизий. Вроде бы как устройство, вроде бы как компьютеры к нему подключаются физически разными кабелями, но топология по сути получается “шина”.</p>

<h2 id="домен-коллизии">Домен коллизии</h2>

<p>Домен коллизии — это участок сети на котором есть <em>возможность</em> возникновения коллизии. Очевидно что в случае с шиной домен коллизии распространяется на всю канальную среду, но в случае применения коммутаторов домен коллизии ограничен участком сети от <em>конечного узла до коммутатора</em>.</p>

<p>На этом участке коллизия может возникнуть если узел и коммутатор будут работать в <em>полудуплексном</em> (half-duplex) режиме.</p>

<p>Дуплекс — это такой сопособ связи двух устройств которые могут общаться друг с другом в оба направления. Когда <em>симплекс</em> — только в одном направлении. Устройство которое реализует в себе полный дуплекс способно передавать или принимать данные в любой момент времени, а вот полудуплекс не может делать это одновременно. <em>Полудуплекс</em> это когда в один момент времени устройство может только передавать или получать данные.</p>

<p>Коллизии при half-duplex в участках до коммутара возникают в случае когда передатчик коммутатора и сетевой карты узла начинают одновременно (или почти одновременно) передавать данные в разных режимах (прием/передача), считая что участок сети между ними свободен.</p>

<h1 id="канальная-среда-кадры-и-mac-адреса">Канальная среда, кадры и MAC адреса</h1>

<p>Мы сегодня уже использовали термин <strong>кадр</strong>.</p>

<p>Кадром в сети принято называть <em>единицу информации</em>, которая передается в пределах одной канальной среды.</p>

<p><em>Канальная среда</em> — это небольшой участок локальной сети, устройства в котором объединены одним свичом (или несколькими). В такой сети <em>нет роутера</em>, и еще её называют <em>одним широковещательным доменом</em>.</p>

<p>В пределах одной канальной среды адресация между узлами происходит в первую очередь по <em>MAC адресам</em>, а не по IP. IP здесь работает, но лишь <em>косвенно</em>.</p>

<p>Конечно же узлы в такой сети имеют свои IP адреса, но получатели кадров в ней определяются по MAC адресам.</p>

<p>Это работает благодаря протоколу <strong>ARP</strong> (<a href="https://datatracker.ietf.org/doc/html/rfc826">RFC 826</a>), который служит для сопоставления айпишников и физических адресов устройств (MAC).</p>

<p>Работа протокола организована посредством ведения так называемых ARP-таблиц, которые хранятся в памяти операционных систем на компьютерах. Устройство, которое собирается отправить данные по какому то IP адресу сперва проверяет свою ARP-таблицу на предмет наличия в ней MAC адреса. Если адрес есть — отправляем по нему. Если адреса нет — узел формирует ARP запрос в виде кадра и рассылает его <em>широковещательно</em> (по всей канальной среде). Следовательно, все узлы получают этот запрос, сравнивают в нем IP со своим, и если выявляется соответствие — узел получатель отправлет ответный ARP кадр на адрес отправителя запроса, в котором записан IP и соответствующий MAC.</p>

<p>MAC адреса есть у каждого устройства и вшиваются в постоянную память производителями этих устройств. Они состоят из двух частей по 24 бита каждая:</p>
<ul>
  <li>Уникальный идентификатор OUI, который выдается <a href="https://www.ieee.org/">IEEE</a></li>
  <li>
    <p>Часть которую назначает сам производитель</p>

    <p>Кстати, MAC адрес можно легко изменить\подменить, потому что из постоянного энергонезависимого источника при загрузке ОС он записываться в <em>оперативную память</em>.</p>
  </li>
</ul>

<p>Уникальный MAC каждого устройства называется <em>Unicast</em> адресом, но есть еще <em>широковещательный</em> (broadcast) адрес который одинаково выглядит во всех операционных системах: FF-FF-FF-FF-FF-FF.</p>

<p>Широковещательный адрес позволяет разослать кадр сразу всем участникам канальной среды (“размножается” на свитче).</p>

<p><em>Многоадресные</em> (Multicast) MAC адреса отличаются от широковещатльных тем, что по мультикасту идет рассылка кадров по определенной группе узлов, у которых установленны соответствующие мультикаст-адреса.</p>

<h2 id="unicast-flooding">Unicast Flooding</h2>

<p>У свичей есть специальная таблица MAC адресов, в которой они хранят соответствия своих каналов (портов) с MAC адресами устройств работающих за этим портом. Изначально, когда мы только включаем коммутатор его таблица как правило пуста. Она наполняется следующим образом.</p>

<p>Когда какой-то из компьютеров в канальной среде отправляет другому данные они сперва попадают на свитч. Свитч видит MAC адрес получателя, записывает в свою таблицу адрес <em>отправителя</em> в строку таблицы порта, по которому он получил данные. Но в этот момент коммутатор не знает <em>куда</em> перенаправлять (в буфер какого порта) кадр дальше.</p>

<p>Поэтому он рассылает этот кадр по всем <em>остальным</em> портам! Затем коммутатор смотрит с какой стороны пришел ответ и снова записывает MAC адрес в соотвутствующую строку порта. Таким нехитрым образом свич заполняет свою таблицу.</p>

<p>Процесс наполнения таблицы называется <em>unicast flooding.</em></p>

<hr />

<p>На сегодня это всё. На самом деле в отдельности каждую из тем можно долго-долго рассматривать. Если вы настолько жадны до сетей, то… Почитайте Таненбаума, например!</p>

<p><a href="/2022/06/19/TCP_UDP_and_something_else.html">Читать следующий пост про маршрутизацию и заголовки протоколов L1-L3</a></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сети" /><summary type="html"><![CDATA[Немного про модель OSI и работу элементарной канальной среды.]]></summary></entry><entry xml:lang="ru"><title type="html">Продолжаем исследовать Императивную модель</title><link href="http://localhost:4000/2022/06/13/hack_in_imperative_2.html" rel="alternate" type="text/html" title="Продолжаем исследовать Императивную модель" /><published>2022-06-13T00:00:00+03:00</published><updated>2022-06-13T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/13/hack_in_imperative_2</id><content type="html" xml:base="http://localhost:4000/2022/06/13/hack_in_imperative_2.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 2.
<!--more--> 
<a href="/2022/06/06/hack_in_imperative_1.html">Читать предыдущую часть.</a></p>

<h1 id="компонентно-ориентированное-программирование">Компонентно ориентированное программирование</h1>

<p>Характеристики абстракции, которые мы разбирали в прошлой части, определяют собой <em>Компонентно ориентированное программирование</em>.</p>

<p>Компонент следует понимать как определение части программной системы изнутри и снаружи, иными словами — четкое определение <em>интерфейса</em> 
той части.</p>

<p>Внутренняя составляющая компонента скрыта (инкапсуляция), изнутри доступно только то что определено интерфейсом.</p>

<p>Благодаря композиционности из компоненты могут составляться другие, новые компоненты. Это естественный способ расширения возможностей одного компонента. Для реализации компонента с новым требуемым функционалом мы можем использовать уже существующий компонент или компоненты, которые уже реализует в себе некоторую часть (в существенной степени) этого нового функционала.</p>

<p>Инстанциирование компонентов позволяет создавать их новые экземпляры, которые моментально включаются в рантайм.</p>

<p>На самом деле компонент это ещё одна фундаментальная программистская концепция, признаки которой можно обнаружить во многих, если не во всех, программных концепциях и техниках:</p>

<ul>
  <li><strong>Процедурная абстракция</strong> — это компонент! Почему? Потому что это определение функции с параметрами, а экземпляр, то есть инстанциирование процедурной абстракции — это вызов определенной функции с аргументами;</li>
  <li><strong>Функтор</strong> (разбирали <a href="/2022/03/20/program-design.html">здесь</a>) — это исходный код программного модуля, который компилируется в сам модуль независимо от других компонентов;</li>
  <li><strong>Параллельные компоненты</strong> — программная система состоящая из независимых и взаимодействующих с друг другом элементов может быть представлена нами как граф из одновременно работающих <em>компонентов</em>, которые общаются посредством обмена сообщениями.</li>
</ul>

<h1 id="ооп">ООП</h1>

<p>Объектно-ориентированное программирование это по сути компонентно ориентированное, только с добавлением ещё одной концепции\механики — <strong>наследования</strong>.</p>

<p>Наследование — это такой способ конструирования программной системы, в котором реализация нового функционала основывается на уже существующей.
Такие постепенно развивающиеся компоненты называются <em>классами</em>, а экземпляры классов — <em>объектами</em>.</p>

<p>Возможность повторно использовать код в ООП сильно снижает дублирование кода и его избыточность в системе в целом, это большой и сильный плюс.
Но как известно:</p>

<p style="text-align: center;"><img src="/images/resplonsibiliy.webp" alt="Базз" /></p>
<p><em><center>Прислушайтесь к дяде Бену!</center></em></p>

<p>Почему так? Кажется что возможность каскадно переиспользовать код очень круто, добавляет возможность гибко, практически как угодно жонглировать компонентами и внедрять их друг в друга! Здорово же, да?</p>

<p>На самом деле нет, не очень. Компоненты начинают очень сильно зависеть от компонентов, которые они наследуют. В результате система становится все менее “модульной” и всё более <em>связанной</em>. Такими зависимостями становится очень сложно управлять.</p>

<p>Несмотря на то что большая литературы и учебников по объектно-ориентированному проектированию сфокусированы на правильном использовании наследования, стоит прислушаться к светлым и опытным инсайдерским умам, которые рекомендуют по возможности <strong>использовать композицию а не наследование.</strong> Пусть композиция и менее гибкий подход, тем не менее она проще в использовании. А наследование нужно применять только тогда, когда композиции недостаточно.</p>

<p>Если поступать таким образом, то иерархии в системе будут получаться намного менее глубокими, чем при использовании исключительно наследования. И как следствие, система будет менее связанной и запутанной.</p>

<h1 id="декларативная-модель-с-явным-состоянием">Декларативная модель с явным состоянием</h1>

<p><em>Явно состояние</em> — это пара из двух сущностей ЯП:</p>
<ol>
  <li>Идентичность (identity) — способ именования состояния в программе.</li>
  <li>Текущее содержание состояния — это собственно значение, с которым связано имя состояния.</li>
</ol>

<p>Сюда добавляется ещё операция, которая позволят посредством идентичности состояния получить текущее содержание.</p>

<h2 id="ячейка">Ячейка</h2>

<p>Мы уже говорили про ячейки в прошлый раз. Ячейка — это явное состояние, и <em>базовый тип</em> который мы добавляем в вычислительную модель.</p>

<p>Ячейка состоит из неизменяемого (постоянного) имени и ссылки на объект в хранилище однократных присваиваний.</p>

<p class="info">Напоминаю где можно вспомнить про внутрнее устройство декларативной модели -&gt; <a href="/2022/02/06/hack_in_declarative_model.html">тут</a>.
А если вы до сих пор не понимаете почему мы так много говорим в этом цикле о декларативной модели, хотя сабжем вроде как является императивная — рекомендую сперва прочитать весь цикл отчетов по изучению декларативной модели (начиная со ссылки выше, там будут кросссылки на следующие посты).</p>

<p>Благодаря тому что имя ячейки не допускается изменять все они (ячейки) фактически получаются чистыми абстрактными типами данных. Множество же самих ячеек хранится в некотором мутабельном (изменяемом) хранилище.</p>

<p>В результате вычислительная модель состоит из неизменяемого хранилища однократных присваиваний, которое содержит в себе dataflow-переменные (это такие переменные которые могуть быть связаны только с одним значением), и из второго — изменяемого хранилища, в котором хранятся пары из имен и ссылок (ячейки).</p>

<p>В такой модели существует элементарный язык программирования, который расширяет базовую декларативную модель двумя операциями, которые условно назовем NewCell и Exchange.</p>

<p>У NewCell есть два параметра. Эта операция создает новую ячейку с именем из первого параметра, и с содержимым (ссылкой) во втором:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NewCell C X
</code></pre></div></div>

<p>Операция Exchange уже имеет три параметра:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Exchange C X Y
</code></pre></div></div>

<p>Эта операция связывает X с прежним содержимым ячейки С, и задает этой ячейке новое содержимое, передаваемое в Y.</p>

<p>Для обеспечения большей выразительности в такую модель добавляются ещё две инструкции:</p>

<ul>
  <li>
    <p>Операция @ предоставляет доступ к содержимому ячейки С:</p>

    <p>X = @C</p>
  </li>
  <li>
    <p>Операция := присваивает ячейке C новое значение из Y, и <em>возвращает значение ячейки X</em>:</p>

    <p>C := Y</p>
  </li>
</ul>

<p>Прикол в том, что добавление такой ячейки с лишь двумя операциями хватает чтобы построить <strong>все</strong> концепции, которые может предоставить понятие <em>состояния</em>.</p>

<p class="info">Все сложные концепции абстрактных типов данных можно построить с помощью декларативной модели дополненной ячейками.</p>

<h1 id="связь-с-декларативным-программированием">Связь с декларативным программированием</h1>

<p>Строго говоря, “императивная” stateful-программа не может считаться декларативной. Потому что её выполнение несколько раз с одними и теми же входными данными может давайть разные результаты, в зависимости от внутреннего состояния.</p>

<p>Однако, stateful-программы можно писать таким образом, чтобы они <em>удовлетворяли определению декларативной операции</em>. Чтобы они <strong>вели себя декларативно</strong>.</p>

<p>Мы разбирали пару декларативных функций <a href="hack_in_declarative_model_6.html">здесь</a></p>

<p>Любую из них можно взять и переписать в императивном “стиле”, изменив внутреннюю декларативную рекурсивную реализацию например на простой перебор циклом, который будет записывать в результирущий список каждый подходящий по функции-предикату элемент. Результирующий список это явное состояние (локальная переменная) внутри реализации вычислений.</p>

<p>Таким образом интерфейс самой функции оберки filter остается неизменным, и её пользователю вообще неизвестно какая там внутри реализация, а сам filter ведет себя всё ещё декларативно.</p>

<h2 id="мемоизация">Мемоизация</h2>

<p>Ещё одна полезная техника в разрезе декларативной модели с использованием состояний — <em>мемоизация</em>. Это такой финт, когда функция запоминает результаты её предыдущих вызовов (например очень тяжелых вычислений), что позволяет при повторных вызовах такой функции использовать эти результаты сразу же. В такой функции внутри состояние реализуется в замыкании, но внешне ей поведение формально остается декларативным.</p>

<h1 id="sharing-состояний">Sharing состояний</h1>

<p>Один из важных нюансов, который нужно строго формализировать при работе с состояниями это понятие <em>равенства ячеек</em>.</p>

<p>Нужно понять, можно ли считать что две ячейки равны, когда равно их <em>содержание</em>, или если два идентификатора (X и Y) ссылаются на одну и ту же ячейку?</p>

<p>Такие случаи “равенств” называют sharing или aliasing, что по сути является совместным использованием некоторого содержания ячейками, которые являются <em>алиасами</em>.</p>

<p>Когда мы изменим содержимое ячейки X это автоматически приводит и к изменению содержимого ячейки Y, ведь физически <em>их содержимое одно и то же</em>.</p>

<p>В ООП это называется <em>передача объектов по ссылке</em>.</p>

<p>Формальное понимание программы, в которой есть много алиасов у ячейки заметно усложняется. Эта проблема решается с помощью <em>инкапсуляции состояния</em> следующим образом:</p>

<p class="info">Вся логика работы с состоянием выделяется в отдельную и четко определенную часть программы, которая гарантирует что состояние оттуда не сможет выбраться. Поэтому абстрактные типы данных идеальный способ для использования явных состояний, потому что они инкапсулируются в АТД, скрываясь за набором определенных высокоуровневых операций.</p>

<h1 id="атд-и-способы-их-организации">АТД и способы их организации</h1>

<p>В <a href="hack_in_declarative_model_6.html">последнем посте</a> из цикла изучения Декларативной модели мы уже знакомились с АТД и способами их защиты. Сейчас пришла пора добавить к этой джедайской технике понятие состояния.</p>

<p>Абстрактные типы данных с одной и той же функциональностью могут быть по разному реализованы внутри. В эволюции АТД есть ещё две “перпендикулярных оси” — <em>состояние</em> и <em>бандлинг</em>. Вметсе с защищенностью эти три аспекта составляют восемь способов организации АТД, а зависимости от применения или не применения каждого из них.</p>

<p>Давайте рассмотрим эту тему чуть более подробно.</p>

<h2 id="открытость-и-защищённость">Открытость и защищённость</h2>

<p><em>Открытый абстрактный тип данных</em> — это АТД, внутренее представление которого видно везе в программе. Реализация такого типа может быть размазана по коду, а разные его части расширяться независимо друг от друга. Такая реализация может быть полезна разве что в небольших проектах, когда выразительность важнее чем безопасность. Только не используйте это как оправдание лени писать безопасный код.</p>

<p><em>Защищенный абстрактный тип данных</em> — это АТД реализация которого недоступна остальным частям программы, и его реализация сосредоточена в одном модуле. Как я уже упоминал, способ защиты АТД мы рассматривали в последнем посте о Декларативной модели.</p>

<p>АТД может быть “частично безопасным”, когда права на чтение внутренней реализации выдаются другим частям программы некоторым контролируемым образом (wrap, unwrap).</p>

<h2 id="состояние-в-атд">Состояние в АТД</h2>

<p><strong>Stateless-АТД</strong> создаются в рамках декларативной вычислительной модели. Нужно создавать новые экземпляры АТД, так как модифицировать их запрещено. Такой подход приводит к увеличению количества экземпляров АТД в программе, из за чего ими может становиться трудно управлять. Сам код программы становится менее модульным, потому что мы помним — это <em>декларативная модель</em>, и как следствие экхемпляры должны передаваться по конвейеру вычислений даже через части программы, которые в этом АТД не нуждаются.</p>

<p><strong>Statefull-АТД</strong>, очевидно, использует внутри себя явные состояния. А значит его экземпляры могут изменяться во времени. В такой реализации нельзя быть уверенным какое значение инкапсулировано внутри экземпляра АТД, не обладая полной историей вызовов процедур с момента создания экземпляра. Здесь так же существует только один экземпляр, в отличие от декларативных АТД. Кроме того, зачастую этот экземпляр вообще не надо передавать внутрь функции как параметр, потому что доступ к нему может быть организован через лексическое замыкание.</p>

<p>Этот подход позволяет сделать программу более выразительной и лаконичной, а так же, возможно, более модульной, потому что нам не нужно “связывать” экземляр АТД с частями системы которым он не нужен.</p>

<h2 id="бандлинг">Бандлинг</h2>

<p>Бандлинг (запаковка) — это когда данные хранятся <em>вместе с операциями</em>.</p>

<p><strong>Распакованный АТД</strong> — это АТД, у которого можно отделить данные от операций. При этом распакованный АТД <em>может быть безопасным</em>. Достигается это путем создания каждого экземпляра АТД вместе с некоторым “ключем”, который представляет собой разрешение на доступ к внутренним данным экземпляра, и на измнение, если АТД обладает состоянием. Все операции такого АТД “знают” ключ, в отличе от остальной части программы. Как правило ключ — это неизменяемая константа.</p>

<hr />

<p>В реальном мире из восьми комбинаций вышеупомянутых аспектов АТД используются эти варианты:</p>

<ul>
  <li>“Открытый, декларативный, распакованный” — Такой подход реализуется в языке Prolog, и некоторых других.</li>
  <li>“Защищенный, декларативный, запакованный” — Добавляются абстракции для реализации декларативного стиля.</li>
  <li>“Защищенный, декларативный, распакованный” — Объектно-ориентированное расширение декларативного стиля.</li>
  <li>“Защищенный, stateful, запакованный” — Это классичское объектно ориентированное программирование, например Java.</li>
  <li>“Защищенный, stateful, распакованный” — “Распакованный” ООП.</li>
</ul>

<p>Эти комбинации перечислены в порядке усложнения их реализации.</p>

<p>Пример первого пункта рассматривался в последнем посте о декларативной модели (реализация стека).</p>

<hr />

<p>На сегодня всё. Пожалуйста не забывайте отдыхать!
<a href="/2022/06/26/hack_in_imperative_3.html">Читать продолжение</a></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 2.]]></summary></entry><entry xml:lang="ru"><title type="html">Нам нужны явные состояния. Нужны же?…</title><link href="http://localhost:4000/2022/06/06/hack_in_imperative_1.html" rel="alternate" type="text/html" title="Нам нужны явные состояния. Нужны же?…" /><published>2022-06-06T00:00:00+03:00</published><updated>2022-06-06T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/06/hack_in_imperative_1</id><content type="html" xml:base="http://localhost:4000/2022/06/06/hack_in_imperative_1.html"><![CDATA[<p>Врубаемся в Императивную модель. Часть 1.
<!--more--></p>

<p>Всем привет! Я приступил к очередному курсу в skillsmart.ru 
На этот раз темой курса является изучение Императивной модели программирования, как расширения фундаментальной Декларативной модели.</p>

<p>Вы что нибудь помните про декларативную модель, и про состояния?
Мы разбирали эти и другие связанные темы некоторое время назад на соответствуещм курсе. Почитать про это вы можете в моих постах-отчетах, начиная с <a href="/2022/02/06/hack_in_declarative_model.html">этого.</a></p>

<p>Но тут мы тоже будем сперва говорить про декларативность, потому что никуда без неё :P</p>

<h1 id="stateful-programming">Stateful programming</h1>

<p>В императивной модели концепция времени понимается уже совсем по другому. Наверное самое главное отличие императивной модели от декларативной заключается именно в этом.</p>

<p>Время тут меняется благодаря введению в модель <em>Явных состояний</em>, которые добавляют программным сущностям возможность <em>долгосрочной памяти</em>.</p>

<p>Иными словами — тут появляются привычные нам “императивные” переменные.</p>

<p>Есть ещё умные слова, которыми достаточно часто отмечают природу состояний в моделях: <strong>stateless</strong> и <strong>stateful</strong> программирование. На самом под первым как правило имеется в виду декларативное, а под вторым — императивное.</p>

<p>Давайте вкратце повторимся.</p>

<p><em>Декларативное программирование</em> — это когда мы описываем <strong>какой результат</strong> нужно получить. Возможно с дополнительным определением “подказок” как его получить :)</p>

<p style="text-align: center;"><img src="/images/declarative_meme.jpeg" alt="Рекурсивные кролики" /></p>

<p><em>Императивное программирование</em> — это когда мы с помощью конкретных команд описываем <strong>как получить результат</strong>.</p>

<p>На самом деле декларативное программированое в какой то степени императивно, потому что всё равно зачастую используются последовательности каких то команд.</p>

<p>Вообще, Декларативная парадигма это в первую очередь математическая модель, а сама “декларативность” проще будет пониматься как <em>относительная степень</em>, в которой эта самая декларативность применяется в языке программирования.</p>

<h1 id="прелести-декларативного-подхода">Прелести декларативного подхода</h1>

<p>Хотя декларативный подход можно, грубо говоря, “спроецировать” на любой программный код, на практике же (в логических или фунциональных программах, например) он теряет большую часть аспекта <em>“что делать”</em>, так как приходится более детально описывать подробности <em>“как делать”</em>.</p>

<p>Тем не менее это не значит что от декларативного программирования можно или нужно как то отказываться, потому что у него есть три существеннных плюшки:</p>

<ol>
  <li>В декларативной модели проще формировать практически все программные абстракции благодаря тому что декларативные операции <strong>композиционны</strong>.</li>
  <li>Декларативные программы просто тестировать, потому что достаточно протестировать одиночныне вызовы команд, когда stateful программу тестировать сложнее из за того что приходится проверять <em>последовательности вызовов</em>.</li>
  <li>Рассуждать о программи в декларативной модели проще, чем при использовании императивного программирования.</li>
</ol>

<h1 id="снова-о-состояниях">Снова о состояниях</h1>

<p>Итак, мы уже выяснили что <em>состояние</em> — это растянутая во времени последовательность значений, в которой содержатся промежуточные результаты нужного вычисления.</p>

<p>Мы помним что в декларативной модели состояние характеризуется как <strong>скрытое</strong>. Такие декларативные, состояния никак <em>явно</em> не поддерживаются со стороны вычислительной модели. Последовательности вычислений могут пониматься и представляться только в сознании программирующего существа, а на уровне кода последовательности просто не существуют.</p>

<p>Явное состояние наоборот — <em>существует</em> на протяжении времени, в более чем одном вызове функции <em>без явного определения этого состояния в аргументах этой функции</em>.</p>

<p>Такое состояние реализуется с помощью некоторого “контейнера”, который принято называть <strong>ячейка</strong>. Такая ячейка уже фактически существует в коде, наблюдается, иными словами — <em>не только в сознании программирующего существа.</em></p>

<h1 id="принцип-абстракции">Принцип абстракции</h1>

<p>По мере роста системы описывать её абстракции в чисто декларативном или функциональном программировании становится всё сложнее, потому что сам <em>принцип</em> абстракции не очень хорошо поддерживается этими парадигмами. Причиной этой сложности является как раз природа состояний — мы не можем вкладывать <em>новую</em> информацию в компоненты программы или функции (инкапсулировать их внутри).</p>

<p>Для того чтобы система могла хорошо поддерживать принцип абстракции она должна обладать следующими характеристиками:</p>

<ul>
  <li><strong>Инкапсуляция</strong> — это возможность скрывать внутренние части самой системы;</li>
  <li><strong>Композиционность</strong> — это про возможность комбинирования частей системы в целях полуения новых частей;</li>
  <li><strong>Инстанциирование</strong> (invocation) — возможность создавать много конкретных экземпляров компонена на основе его единого определения.</li>
</ul>

<p>Если вы знаете хотя бы немного про ООП (объектно ориентированное программирование), то наверняка уловили сейчас знакомые концепции. Но мы говорим сейчас совсем не про “высокии материи” ООП, и используем более фундаментальные и универсальные принципы программирования для определения и понимания этих концепций.</p>

<p>Например <em>замыкани</em> обеспечивают инкапсуляцию, а инстанциирование достигается посредством программирования высшего порядка.</p>

<p><strong>Важной</strong> особенность характеристик перечисленных выше является то, что их набор <strong>не требует использования концпеции состояния</strong>.</p>

<p>На самом деле инкапсуляция вообще противоположна состоянию, и её можно применять в декларативном программировании. Состояния же могут обходиться без икапсуляции, к примеру — с помощью создания <em>глобальных переменных</em>.</p>

<p>Пришла пора поговорить о cons, а то всё про pros да про pros :)</p>

<p>Добавления концепции состояния к декларативному программированию резко и в разы усложняет понимание самой программы, становится не так просто рассуждать о ней.</p>

<p>Во-первых мы можем столкнуться с <strong>побочными эффектами</strong> у функций, которые теперь могут менять состояния что не видны во всей остальной программе.</p>

<p>Именно по этой причине явное состояние нужно обязательно <strong>применять в тесной связи с инкапсуляцией</strong>, благодаря чему появляется возможность проектировать stateful-системы корректно. Тут появляется понитие <strong>инварианта</strong>, который всегда выглядит “снаружи” правильно.</p>

<p>Это возвращает нам возможность рассуждать о подсистемах формально, считая что поведение этой подсистемы не зависит от окружающей среды, тем самым частично возвращая нас в плане рассуждений к декларативному программированию. Тем не менее, одно только введение инвариантов всё ещё не делает программирование с использованием состояний таким же простым и понятным как декларативное.</p>

<p>Потому что инвариант <em>всего лишь определяет что компонент не ведет себя некорректно</em>, и никак не гарантируется то, что он помогает в продвижении к решению итоговой задачи.</p>

<p>Из всего это следует очень важное правило:</p>

<p class="info">Сложные системы нужно проектировать так, чтобы как можно больше количество компонентов этой системы было описано в декларативной парадигме.</p>

<p>Состояния <strong>должны</strong> быть сконцентрированны в единичных компонентах. Нельзя растягивать состояния по несколькоим компонентам.</p>

<hr />

<p><a href="/2022/06/13/hack_in_imperative_2.html">Читать продолжение</a></p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Императивная_модель" /><summary type="html"><![CDATA[Врубаемся в Императивную модель. Часть 1.]]></summary></entry><entry xml:lang="ru"><title type="html">F# Напоследок</title><link href="http://localhost:4000/2022/06/03/last_about_f.html" rel="alternate" type="text/html" title="F# Напоследок" /><published>2022-06-03T00:00:00+03:00</published><updated>2022-06-03T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/03/last_about_f</id><content type="html" xml:base="http://localhost:4000/2022/06/03/last_about_f.html"><![CDATA[<p>Послесловие о функциональном программировании на F#
<!--more--></p>

<p>Привет! Совсем недавно я завершил базовый курс по функциональному программированию на F# в <a href="http://skillsmart.ru/">skillsmart.ru</a>.
Хочу написать ещё немного об этом опыте, в продолжение <a href="/2022/04/17/more_about_f.html">предыдущего поста</a></p>

<p>Рассмотрим несколько фишек и типов F#</p>

<h1 id="определение-типа-и-записи">Определение типа и записи</h1>

<p>В F#, как и в большинстве языков программирования можно определять свои типы, делается это с помощью ключевого токена “type”.</p>

<p>Есть так же такой тип как Запись (record), который фактически является кортежем, но его элементы идентифицируются ключами-метками (названиями), а не порядковой позицией. Это напоминает словарь в Python.</p>

<p>Сперва нам нужно определить структуру записи как тип.
Например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type = Weapon { fullauto : bool; load_amount: int; fire_rate: float32 }
</code></pre></div></div>

<p>Затем мы можем определить “экземпляр” записи:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47 = { fullauto = true; load_amount = 30; fire_rate = 100.54 }
</code></pre></div></div>

<p>Не нужно как-то дополнительно указывать что ak47 это запись типа Weapon — компилятор F# сам поймет на основании идентификаторов используемых полей.</p>

<p>Мы можем обращаться к каждому отдельному полю записи, чтобы получить её значение используя точечную нотацию:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak47_firerate = ak47.fire_rate
</code></pre></div></div>

<p>Записи можно целиком сравнивать, если типы данных значений полей совпадают. Такое сравнение происходит в лексикографическом порядке.</p>

<h1 id="размеченное-объединение">Размеченное объединение</h1>

<p>Это тип данный, в котором мы задаем множество некоторых идентификаторов. Соответственно размеченное объединение может принимать только тип из своего “списка”. Синтаксис напоминает сопоставление с образцом — используем пайп:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47
  | m249_saw
  | colt_anaconda
</code></pre></div></div>

<p>На полную катушку оторваться тут можно уже фактически используя паттернматчинг фишку:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Weapon = 
  | ak47 -&gt; "автомат"
  | m249_saw -&gt; "пулемет"
  | colt_anaconda -&gt; "револьвер"

let full_auto = function
  | ak47 | m249_saw -&gt; true
  | _ -&gt; false
</code></pre></div></div>

<h2 id="конструктор-значений">Конструктор значений</h2>

<p>Мы так же можем обозначить тип данных для каждого элемента-тега размеченного объединения:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Сaliber =
  | Pistol of float32
  | Machine_gun of float32
  | Cannon of int
</code></pre></div></div>

<p>В таком случае тег связанные с типом является фактически функцией, которыю называются конструкторами значений.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let ak_caliber = Machine_gun 7.62
let bfgun_caliber = Cannon 666
</code></pre></div></div>

<h1 id="частичные-функции">Частичные функции</h1>

<p>Это такая функция, которая только на <em>подмножистве значений аргументов</em>.</p>

<p>Есть специальный тип <strong>option</strong>, у которого может быть только два значения:</p>
<ul>
  <li>None: тут всё понятно;</li>
  <li>Some: это <em>полиморфный</em> конструктор значений, который прнимает <em>любые</em> типы.</li>
</ul>

<p>В F# есть три случая, в которых функция может быть неопределенной:</p>
<ol>
  <li>Вычисления в функции не завершаются — упала в бесконечную рекурсию и тд.</li>
  <li>Вычисления завершились с рейзом исключения.</li>
  <li>Вычисления возвращают вышеупомянутый тип option.</li>
</ol>

<p>Простой пример:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let div x y = if y = 0 then None else Some(x / y)
let r = div 2 0 
</code></pre></div></div>

<p>Тогда:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>printfn "%s" (string r) 
</code></pre></div></div>

<p>не выведет ничего. Но если значение есть, мы можем достать его из Some с помощью Option.get:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let r = div 4 2 
printfn "%d" (Option.get r)
</code></pre></div></div>

<h1 id="списки-в-f">Списки в F#</h1>

<p>Списки отличаются от кортежей тем, что они являются цепочками значений <em>одного</em> типа.</p>

<p>В F# списки заключаются в квадратные скобки, а элементы перечисляются через точку с запятой.</p>

<p>В типе списков можно увидеть ключевое слово list, которое является <em>конструктором типа</em>.
У списка:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ ("hello", "world"); ("hello", "friend") ]
</code></pre></div></div>

<p>Тип будет:</p>

<p>(string * string) list</p>

<p>Добавить элемент в голову списка можно специальным оператором — “::”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"hello" :: ["w"; "o"; "r"; "l"; "d"] = ["hello"; "w"; "o"; "r"; "l"; "d"]
</code></pre></div></div>

<p>Список из целых значений с единичным шагом можно выражать зачениями диапазона используя две точки, например:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 10 ]
</code></pre></div></div>

<p>Шаг можно изменить, указав его между первым и последним значеним так же — через две точки</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ 1 .. 3 .. 12 ]
</code></pre></div></div>

<p>Сцепить вместе два списка можно с помощью инфиксного оператора @:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ "h"; "e"] @ [ "l"; "l"; "o"]
</code></pre></div></div>

<h1 id="множества">Множества</h1>

<p>Множеством называется неупорядоченный набор элементов одного типа, <em>среди которых нет повторяющихся</em>, то есть одинаковых.</p>

<p>Список преобразовать во множество можно с помощью функции Set.ofList, и обратно — Set.toList.</p>

<p>Добавить и убрать элемент — Set.add <элемент>, Set.remove <элемент></элемент></элемент></p>

<p>Проверить что элемент есть в списке можно с помощью Set.contains, или проверить на вхождение подмножества — Set.isSuset:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Set.contains "hello" (set ["hello"; "w"; "o"; "r"; "l"; "d"])
Set.isSubset (set ["w"; "o"]) (set ["hello"; "w"; "o"; "r"; "l"; "d"])
</code></pre></div></div>

<p>Объединяются множества через Set.union, а пересечения и различия находятся как Set.intersect и Set.difference соответственно.</p>

<h1 id="хвостовая-рекурсия">Хвостовая рекурсия</h1>

<p>Рекурсию мы уже достаточно хорошо обсуждали во втором посте о Декларативном программированиие -&gt; <a href="/2022/02/12/hack_in_declarative_model_2.html">тык чтобы перечитать</a>.</p>

<p>Давайте рассмотрим живой пример на F#.</p>

<p>Неоптимизированная рекурсивная функция для расчета факториала будет выглядеть так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let rec factorial = function 
 | 1  -&gt; 1
 | x  -&gt; x * factorial(x - 1)
</code></pre></div></div>

<p>Здесь x накапливает результат, но на каждом итерации рекурсии будет происходить вызов функции factorial, и её результаты умножаться на x.</p>

<p>Избавиться от лишних рекурсивных вызовов можно использовав прием с <em>аккумулятором</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let factorial n =
    let rec inner_wrapper x a =
        if x &lt;= 1 then a
        else inner_wrapper (x - 1) (a * x)
    inner_wrapper n 1
</code></pre></div></div>

<p>Здесь рекурсивные вычисления выполняются в другой, вложенной функции inner_wrapper, а её рекурсивный вызов располагается в самом конце, и не входит в какие либо вычисления как в предыдущем примере. Благодаря этому компилятор сможет оптимизировать выполнение без использования стека произвольной рекурсивной глубины.</p>

<h1 id="последовательности-и-ленивые-вычисления">Последовательности и ленивые вычисления</h1>

<p>Ленивые вычисления, это такая математическая модель вычислений в программировании. Как это работает? Например в F# есть <em>Последовательности</em>. Это как раз пример “ленивой структуры”.</p>

<p>Последовательность — это упорядоченная коллекция элементов, значения которых вычисляются <em>лишь в момент обращения к ним.</em></p>

<p>Фишка в том, что последовательность может быть <em>бесконечной</em>. И таковыми их можно представить как раз благодаря “ленивости”, никаких накладных расходов на определение последовательностей нет (не нужно сразу что-то бесконечно вычислять :)</p>

<p>Бесконечная последовательность задаётся дефолтной функцией Seq.initInfinite, и в параметр ей мы передаем другую функции которая будет генерировать последовательные значения.</p>

<p>Такая последовательность будет в себе содержать квадраты целых чисел:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let squares = Seq.initInfinite (fun x -&gt; x * x)
</code></pre></div></div>

<p>Мы можем получить (вычислить) любой по индексу элемент последовательности с помощью функции Seq.item. А ещё последовательности можно кэшировать, чтобы не приходилось при каждом обращении к последоватльности вычислять её значения.</p>

<p>Пример выше можно было бы закэшировать так:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let cached_squares = Seq.cache squares
</code></pre></div></div>

<p>После этого при обращении к n-ному элементу такой последовательности будут вычислять этот и все предыдущие элементы, <em>если они ещё не были вычислен</em>, ну а в противном случае — использовать кэшированные результаты.</p>

<h1 id="резюме">Резюме</h1>

<p>В целом, наверное на этом всё. Мне кажется что не совсем уместо тупо перечислять стандартные функции. Документация F# вполне себе ок, как на английском так и на русском.</p>

<p>И рассматривать (читай спойлерить) задания из курса как в прошый раз я не хочу. Скажу лишь главное — это было круто, и стоило того. Пусть и пришлось поломать голову. Хотя, кмк я больше преувеличиваю и задания были проще чем мне казалось.</p>

<p>По крайней мере после сравнения своего решения и эталонного я так думал практически каждый раз :D</p>

<p>Я никогда особо до этого не трогал лапками функциональные языки, разве что хаскель полтора раза, и скажу честно две вещи:</p>

<ol>
  <li>Мне <strong>очень</strong> понравилось.</li>
  <li>Не знаю когда и что я буду, и буду ли вообще писать на чисто функциональных языках, но кажется что это правда как то меняет точку зрения на программирование в целом. Может мне кажется, но всё таки кажется что не кажется.</li>
</ol>

<p>Я знаю что пишу часто криво, криво рейрачу, но кто бы это не прочитал — идите потрогайте ФП, и посмотрите внимательно в зеркало, ведь там очень красивый и умный человек :)</p>

<p>P.S. 
Если вдруг захотите <del>удариться головой об косяк</del> преисполниться в ФП на F# поищите учебник: “Functional Programming Using F#” Michael R. Hansen</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Программирование" /><category term="Отчеты" /><category term="Функциональное_программирование" /><summary type="html"><![CDATA[Послесловие о функциональном программировании на F#]]></summary></entry><entry xml:lang="ru"><title type="html">Обзор DNS</title><link href="http://localhost:4000/2022/06/01/DNS.html" rel="alternate" type="text/html" title="Обзор DNS" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/DNS</id><content type="html" xml:base="http://localhost:4000/2022/06/01/DNS.html"><![CDATA[<p>Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?</p>

<!--more-->

<p>И Артпанет и наш нынешний интернет на очень примитивном уровне и грубо говоря — телефонна сеть. У каждого участника этой сети есть свой “номер телефона” — IPv4 или IPv6 адрес, по которому к нему можно “дозвониться”, например на какой нибудь порт.</p>

<p>на заре интернета в роли DNS выступал текстовый файлик HOSTS.TXT, который хранился в некотором сетевом информационно центре, и чтобы получить нужный адрес или внести свой в этот центр <strong>нужно было… звонить!</strong>  Чем больше развивалась сеть, тем больше становилось хостов, и поддерживать HOSTS.TXT стало, мягко говоря, неудобно. Тут родился DNS.</p>

<h1 id="что-такое-dns">Что такое DNS</h1>

<p>Domain Name System — это такая распределенная система, которая “превращает” доменные имена в IP адреса, которые клиент использует для получения нужных ему ресурсов с целевого сервера. Ну там, страничку в браузере загрузить :)</p>

<p>Служит вся эта история в первую очередь для нашего человеческого удобства.</p>

<h1 id="dns-сервер">DNS сервер</h1>

<p>Грубо говоря, DNS сервер это такой сервер, который хранит у себя подобие записной книги контактов в вашем телефоне — своего рода база данны, в которой записаны публичные IP адреса и связанные с ними <em>доменные имена</em>.</p>

<p>Как только IP адрес найден и передан клиенту, этот самый клиент может устанавливать нужные ему соединения, например с ближайшим CDN (content delivery network) сервером, на котором закеширован искомый ресурс или с “исходным”, как говорится origin сервером.</p>

<h1 id="как-устроен-dns">Как устроен DNS</h1>

<p>В обычным DNS запросе URL адрес, введенный пользователем должен пройти через четыре сервера, чтобы получить клиент получил нужный адрес.</p>

<p>Все эти четыре сервера работают вместе таким образом:</p>

<ul>
  <li>
    <p>DNS Recursor: его ещё называют “преобразователем DNS”. Этот сервер получает DNS запрос от клиента, а потом связывается с другими DNS сервера, чтобы они помогли ему найти верный адрес. На этом этапе преобразователь сам действует как клиент — он создает один или несколько DNS запросов, которые отправляются дальше.</p>
  </li>
  <li>
    <p>Root nameservers: это <em>коренные серверы имен</em>. Коревой сервер назначен на определенную <em>корневую</em> DNS зону интернета. Задачей такого сервера является обработка полученных DNS запросов, отвечая на которые корневой сервер формирует список <em>Авторитетных серверов имен <strong>верхнего уровня (TLD)</strong></em>, которые <em>вероятно могут</em> знать искомый в запросе адрес.</p>

    <p>Уровень домена определяется количеством точек в доменном имени. например blablabla.com будет доменом верхнего уровня, тогда как blabla.killme.com — второго, и так далее.</p>
  </li>
  <li>
    <p>TLD nameservers: или Top Level Domain Nameservers связаны с доменами верхнего уровня, и обычно эти серверы идут после коренных. Для простоты их можно представлять как ответвления от коренных серверов. На них содержится информация о доменах следующего уровня <em>конкретных DNS зон</em>.</p>
  </li>
  <li>
    <p>Authoritative nameservers: это те сервера, которые уже наконец дают какой то реальный ответ на изначальный DNS запрос. Есть два ипа таких серверов: главный сервер, и вторчный. Главный хранит <em>исходные</em> копие записей своей зоны, а вторичный (один или несколько) являются репликами главного, которые служат для распределния нагрузки и страховым вариантом в случае сбоя главнго сервера. Эти сервера так же хранят ресурсные DNS записи (А, АААА, CNAME, MX, TXT, и так далее)</p>
  </li>
</ul>

<h1 id="кэширование-dns">Кэширование DNS</h1>

<p>Кэширование результатов DNS запросов может происходить на уровне операционной системы или браузера. Это необходимо для оптимизации, ускорения обработки запросов. Зачем искать адрес, который мы итак уже знаем?</p>

<h2 id="рекурсивные-сервера">Рекурсивные сервера</h2>

<p>Мы уже выяснили, что авторитативные серверы хранят настоящие DNS записи, тогда как <em>рекурсивные</em> серверы выступают в роли посредников, которые находятся между авторитативным сервером и конечным клиентом. Чтобы найти нужную запись (нужный сервер имен) рекурсивные серверы посредством DNS запросов “рекурсивно” проходят по дереву DNS серверов, чтобы наконец добраться до своей цели.</p>

<p>Рекурсивные серверы хранят у себя в кеше результаты своих “путешествий”, чтобы каждый раз не искать по новой. Время такого кеширования определяется хозяином домена с помощью параметра TTL (time to live).</p>

<h1 id="ещё-раз-как-как-это-работает">Ещё раз… как как это работает?</h1>

<p>Если всё ещё непонятно, давайте быстро разберем базовый случай.</p>

<ol>
  <li>Вбиваем адрес сайта в браузер.</li>
  <li>Браузер проверяет кэш. Если адреса есть — начинает работать с ресурсом используя этот адрес. Если адреса нет идем дальше.</li>
  <li>Бразуер отправляет запрос к DNS-резолверу. Резолвер это такая служба в операционной сети. Если в кэше у резолвера нашелся нужный адрес — возвращаем его браузеру для работы, если адреса нет:</li>
  <li>DNS-резолвер отправляет запрос DNS-резолверу вашего интернет провайдера, или резолверу Google (8.8.8.8, 4.4.4.4), или на худой конец в CloudFlare (1.1.1.1). Резолвер снова проверяет свой кэш на предмет запроса. Если и тут адреса нет:</li>
  <li>DNS-резолвер провайдера отправляет запросы коренным DNS серверам (кому слать резолвер понимает по домену верхнего уровня). Корневые серверы проверяют есть ли у них информация о домене верхнего уровня из полученного запроса. Если такая информация найдена, коренной сервер возвращает резолверу адрес TLD сервера. Если нет — возвращает ошибку, потому что запрощенной зоны просто не существует.</li>
  <li>Резовер, получив адрес TLD сервера отправляет к нему запрос, и TLD сервер проверяет у себя информацию о домене второго уровня из запроса. Если такой домен у него есть, значит домен существует и зарегистрирован. Тогда TLD сервер вернет адрес авторитативного сервера.</li>
  <li>Получив адрес авторитативного сервера резолвер отправляет ему запрос. Авторитативный сервер проверяет свою базу данных, и если нужный домен в ней есть — возвращает его IP адресс, который записан в А записи этого домена.</li>
  <li>Наконец, когда нужный адрес найдер и получен резолвером, последний записывает этот адрес в свой кэш и передает его в резовер нашей операционной системы, который оттуда попадает в браузер (и оседает в кэш соответственно).</li>
</ol>

<p>Всё это работает быстро, в первую очередь благодаря кэшированию на многих уровнях DNS системы.</p>

<h1 id="дайте-потрогать">Дайте потрогать!</h1>

<p>Посмотреть глазами как это работает можно с помощью утилиты dig, которая есть и на линуксе и на, простите, макоси. Если вы заядный виндузятник можете воспользоваться NSLOOKUP, но лучше поставьте Linux :D</p>

<p>Трейснуть dns с помощью dig можно командой:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    gid +trace &lt;интересующий_домен&gt;
</code></pre></div></div>

<p>Если dig у вас по какой то причине не установлен, нужно установить dnsutils или bind-utils для debian и redhat семейств соответственно.</p>

<p>Если вы всё таки решили сидеть на винде, и читаете это до сих пор, а NSLOOKUP вдруг неожиданно оказался не очень информативной штукой, вы можете воспользоваться любым онлайн инструментов для трейса DNS.</p>

<h1 id="резюме">Резюме</h1>

<p>Как видите в DNS ничего страшного и сложного нет, и работает эта штука предельно понятно. Я не говорю тут про имплементацию самих серверов, это наверное совсем отдельная тема :D</p>

<p>По традиции для владеющих английским языком, и жадных до знаний приведу для затравки пару RFC по теме: <a href="https://datatracker.ietf.org/doc/html/rfc1035">RFC 1035</a> с основой спецификацией, и <a href="https://datatracker.ietf.org/doc/html/rfc1912">RFC 1912</a> уже на тему “Common DNS Operational and Configuration Errors”.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Краткий обзор на DNS или как дозвониться в библиотеку, бабуля?]]></summary></entry><entry xml:lang="ru"><title type="html">Почтовые протоколы</title><link href="http://localhost:4000/2022/06/01/mail_protocols.html" rel="alternate" type="text/html" title="Почтовые протоколы" /><published>2022-06-01T00:00:00+03:00</published><updated>2022-06-01T00:00:00+03:00</updated><id>http://localhost:4000/2022/06/01/mail_protocols</id><content type="html" xml:base="http://localhost:4000/2022/06/01/mail_protocols.html"><![CDATA[<p>Немного о том как письма в интернете ходят.</p>

<!--more-->

<p>Привет! В этому посте я предлагаю немного ознакомиться с почтовыми протоколами. Какие бывают? Попробуем понять чем они отличаются. В нашем прицеле сегодня POP3, SMTP, ESMTP и IMAP.</p>

<h1 id="pop3">POP3</h1>
<p>Протокл POP3 (Post Office Protocol) — это ещё один <del>старый</del> стандартный сетевой протокол используемый локальными почтовыми клиентами для получения писем с почтового сервера по TCP/IP соединению. Первая версия протола появилась в 1984 году (<a href="https://datatracker.ietf.org/doc/html/rfc918">RFC 918</a>), а актуальная версия, как не сложно догадаться — третья!</p>

<p>Кому интересно: Вторая версия протокола описана в <a href="https://datatracker.ietf.org/doc/html/rfc937">RFC 937</a> в 85 году, третья в <a href="https://datatracker.ietf.org/doc/html/rfc1081">RFC 1081</a> в 1988. В течении следующих 10 лет протокол несколько раз прееопредялялся, и последняя актуальная версия была описана в 1996 году в <a href="https://www.ietf.org/rfc/rfc1939.txt">RFC 1939</a>.</p>

<p>Протокол до сих пор очень распространен, и одной из главных причин этому — простота его конфигурации.</p>

<h2 id="как-работает-pop3">Как работает POP3</h2>
<p>Серверы электронной почты, размещенные например у интернет провайдеров, так же часто используют POP3 для получения и харнения писем, предназначенных для их подписчиков. Периодически эти самые подписчики используют клиенты для проверки своих ящиков на удаленных почтовых серверах, и загружают письма предназначенные им.</p>

<p>Обычно, когда письмо загруженно клиентом, оно удаляется с почтового сервера. Некоторые почтовые клиенты позволяют менять это поведения, копируя письмо на локальный хост и не удаляя его с сервера в течении определенного времени.</p>

<p>Как правило клиенты используют 110 порт для подключения к POP3 серверу. Существует так же версия поддерижвающая шифрование — POP3S. Работает с TLS или SSL обычно на порту 995.</p>

<p>Преимущества POP3:</p>
<ul>
  <li>Так как почта загружается на компьютер пользователя её можно читать в оффлайне;</li>
  <li>Аттачменты можно открывать быстро, по той же причине — они уже скачаны;</li>
  <li>Нужно меньше дискового пространства на сервере, так как письма хранятся у клиента;</li>
  <li>Широко распространен, легко настроить.</li>
</ul>

<p>Минусы:</p>
<ul>
  <li>Если почты много пользователю может потребоваться выделять для её хранения слишком много дискового пространства;</li>
  <li>Всю почту можно утратить если медным тазом накроется диск, или ещё хуже — если в почте были конфиденциальные данные и ваш компьютер украли…</li>
  <li>Нет настроек сортировки писем, вся почта летит в одну директорию;</li>
  <li>Если в используемом клиенте нет возможности копировать письмо с сервера (только выкачивать с удалением), то приедтся пользоваться почтой только с одного устройства;</li>
  <li>Письма можно скачивать только целиком, вместе с аттачами.</li>
</ul>

<h1 id="imap">IMAP</h1>

<p>Inernet Message Access Protocol — ещё один почтовый протокол для получения писем с почтового сервера. Аналог POP. Точно так же работает в клиент-серверной архитектуре. Всё поверх того же TCP/IP, используя по дефолту 143 порт для незащищенного соединения, и 993 для шифрованного.</p>

<p>Первая версия задокументирована в <a href="https://datatracker.ietf.org/doc/html/rfc1064">RFC 1064</a> в июле 1988, обновлена в <a href="https://datatracker.ietf.org/doc/html/rfc1176">RFC 1176</a> в августе 1990, IMAP3 появился в феврале 1991, описан в <a href="https://datatracker.ietf.org/doc/html/rfc1203">RFC 1203</a>.</p>

<p>IMAP3, кстати, никто так и не использовал, все продолжали работать с IMAP2.</p>

<p>После этого было ещё одно изменение — внедрение поддержки MIME в расширении названном IMAPbis.</p>

<p>Наконец, современный IMAP4 впервые был описан в двух публикациях: <a href="https://datatracker.ietf.org/doc/html/rfc1730">RFC 1730</a>, которая содержит спецификацию протокола, и <a href="https://datatracker.ietf.org/doc/html/rfc1731">RFC 1731</a> — с описанием механизма аутентификации в IMAP4.</p>

<h2 id="фичи-imap">Фичи IMAP</h2>

<p>Протокол был разработан специально для обеспечения максимально гибкого спобоса доступа пользователя к своему ящику. IMAP может работать в любом из трех режимов: онлайн, оффлайн или автономно (disconnected).</p>

<p>IMAP предоставляет следующие возможности:</p>
<ul>
  <li>Доступ и получение почты с удаленного сервера (практически как в POP);</li>
  <li>Установка флага прочитанных сообщений;</li>
  <li>Управление несколькими почтовыми ящиками, перекидывание писем из одиного в другой, организация ящиков в категории, создавать иерархии из директорий для писем;</li>
  <li>Возможность загружать часть сообщения. Например без мультимедиа содержимого;</li>
  <li>Организация почты на сервере в соответствии с требованиями. Можно удалять или переименовывать свой ящик на сервере (в POP так нельзя);</li>
  <li>Можно искать письма по ключевым словам;</li>
  <li>Проверка заголовка письма, перед его загрузкой.</li>
</ul>

<p>Преимущества IMAP:</p>
<ul>
  <li>Вся почта хранится на сервере, доступна с любого устройства-клиента;</li>
  <li>Письма не загружаются все сразу на локальный компьютера как в POP, и соответственно нет таких требований к дисковому пространству.</li>
  <li>Письма хранятся в условной безопасности на сервере, риски утечек и утраты почты меньше по сравнению с POP.</li>
  <li>Благодаря возможности частичной загрузки почтой можно пользоваться даже при плохом соединении, загружая только тело письма без тяжелых аттачей.</li>
</ul>

<p>Минусы IMAP:</p>
<ul>
  <li>Вся почта на сервере, так что без интернета не получится загружать и новые и уже полученные письма, которые были кэшированы более двух недель назад;</li>
  <li>В случае компрометации ящика злоумышленниками всё его содержимое станет им доступно. В сравнении с POP это “палка о двух концах”, но проблемы информационой безопасности корреспонденции выходят за рамки этого обзора.</li>
</ul>

<h1 id="smtp">SMTP</h1>

<p>SMTP (Simple Mail Transfer Protocol) ещё один сетевой протокол старичок, представленный в 1982 году в <a href="https://datatracker.ietf.org/doc/html/rfc821">RFC 821</a>.</p>

<p>Преследует две задачи: проверка правильности конфигурации системы, авторизация на отправку письма для конкретного устройства, и собственно сама отправка исходящего письма на указанный адрес с подтверждением успешной доставки.</p>

<p>Кстати, если письмо доставить не удалось — отправитель получит алерт.</p>

<p>SMTP может работать практически с любыми протоколами транспортного уровня (TCP, UDP и тд). По умолчанию работет на двух портах: 25 служит для передачи почты между почтовыми серверами, и 587, по которому почта передается от клиента на сервер.
Поддерживает SSL шифрование (задействуется дополительно 465-ый порт).</p>

<h2 id="формат-письма-в-smtp">Формат письма в SMTP</h2>

<p>Почтовое сообщение в SMTP состоит из “конверта”, заголовка и тела письма. 
Формат заголовка и тела подробно описан в <a href="https://datatracker.ietf.org/doc/html/rfc2822">RFC 2822</a>.</p>

<p>Конверт, грубо говоря, это такая абстракция для передачи сообщений между клиентом и сервером. На самом деле они общаются в привычном клиент-серверном формате запросов и ответов.</p>

<h2 id="запросы-и-ответы-smtp">Запросы и ответы SMTP</h2>

<p>Самые часто используемые запросы (команды):</p>
<ul>
  <li>Helo: служит для установки соединения, и выполняется только когда клиент укзаывает свой домен и почтовый адрес;</li>
  <li>Mail: задает адрес отправителя;</li>
  <li>RCTP: задает адрес получателя. Если получателей несколько, то они указываются каждый в отдельной RCTP команде;</li>
  <li>DATA: сигнал серверу о конце “конверта”, после чего идет само письмо;</li>
  <li>QUIT: разрыв соединения после окончания письма.</li>
</ul>

<p>Ответы SMTP состоят из кода и текста ответного сообщения. По коду можно понять если что то пошло не так. В человекочитаемом сообщении же будет указано что произошло в ходе отправки или получения письма.</p>

<p>Коды начинаются с 2, 3 и 5. В первом случае всё прошло хорошо, во втором — письмо отправилось, но нужны дополнительные данные. А пятерка это алерт, что то сломалось и надо разбираться.</p>

<h2 id="описание-работы">Описание работы</h2>

<p>Представим частный случай, в котором уже установлен и сконфигурирован SMTP север, и мы хотим отправить письмо:</p>
<ol>
  <li>Пишем письмо, указываем адрес отправителя, после чего происходит соединение с SMTP клиентом провайдера, например Gmail.</li>
  <li>Происходит передача почтовых адресов отправителя и получателя, тема письма и содержимое на сервер.</li>
  <li>SMTP система начинает искать SMTP сервер получателя.</li>
  <li>Если целевой сервер не будет найден, наш попытается ещё несколько раз это сделать. Если все попытки проваялся мы получим алерт о том что письмо не будет доставлено.</li>
  <li>Если всё хорошо и целевой сервер нашелся, то далее в работу вступают другие почтовые протоколы — POP3 или IMAP.</li>
</ol>

<h2 id="прекратить-спам">Прекратить спам!</h2>

<p>В 1995 году в качестве меры по борьбе с безудержным почтовым спамом появилось расширения SMTP протокола — ESMTP, которое добавлет дополнительные команды для защиты серверов и повышения пропускной способности. Например ESMTP привнес:</p>

<ul>
  <li>Аутентификацию отправителя;</li>
  <li>SSL-шифрование почты;</li>
  <li>Возможность аттачить мультимедиа файлы к письмам;</li>
  <li>Возможность ограничить размер писем в соответствии со спецификациями сервера;</li>
  <li>Одновременно слать письма нескольким адресатам;</li>
  <li>Стандартизацию алертов о невозможности доставки.</li>
</ul>

<p>Разумеется сейчас везде используется ESMTP, по понятным причинам.</p>

<h1 id="резюме">Резюме</h1>

<p>Так что же выбрать, IMAP или POP? Мы вкратце рассмотрели оба протокола, и с первого взгляда кажется что IMAP намного лучше. В этом есть доля истины. В принципе, единственным серьезныем отличием является сопосб хранения писем. В POP3 мы качаем все письма себе, и <em>возможно</em> в случае каких то сверхсекретных писем можно выбрать POP3, обмазав его всевозможным шифрованием, начиная от шифрования соединения, заканчивая шифрованием диска с письмами. Но это очень спорный момент, ведь с другой стороны практически все, если не все, почтовые провайдеры поддерживают двухфакторную аутентификцаию, которую сложно обойти… Сложно же, да? :D</p>

<p>Закончим на сегодня, пока я не ударился в шифропанковский параноидальный бред. Будьте здоровы!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Немного о том как письма в интернете ходят.]]></summary></entry><entry xml:lang="ru"><title type="html">FTP протокол</title><link href="http://localhost:4000/2022/05/31/FTP.html" rel="alternate" type="text/html" title="FTP протокол" /><published>2022-05-31T00:00:00+03:00</published><updated>2022-05-31T00:00:00+03:00</updated><id>http://localhost:4000/2022/05/31/FTP</id><content type="html" xml:base="http://localhost:4000/2022/05/31/FTP.html"><![CDATA[<p>Если вы ищете быстрый и простой способ отправлять и получать файлы с друзьями, семьей или коллегами по работе, возможно вам следует знать о FTP.</p>

<!--more-->

<h1 id="что-это-такое">Что это такое</h1>

<p>FTP — это аббревиатура от File Transfer Protocol. Этот сетевой протокол существует с 1980-х годов и до сих пор остается одним из наиболее часто используемых способов передачи файлов.</p>

<p>Название говорит само за себя — протокол служит для передачи файлов поверх TCP/IP, и в этой модели считается протоколом прикладного уровня.</p>

<p>В транзакциях FTP компьютер конечного пользователя принято называють “локальным хостом”, а второй — удаленный компьютер является сервером. Разумеется, между ними должно быть сетевое соединение, и у каждого участника соответвущий софт (FTP сервер на сервере, и какой-то FTP клиент у пользователя).</p>

<p>Не смотря на то что передача файлов по сети может осуществляться с помощью HTTP протокола, с которым мы уже знакомились <a href="/2022/05/22/HTTP.html">тут</a>, к сожалению или к счастью FTP, как уже сказанно выше — до сих пор широко распространён.</p>

<h1 id="как-это-работает">Как это работает</h1>

<p>FTP — это клиент-серверный протокол, который использует <em>два канала</em> связи: один, так называемый “командный канал”, который служит для управления “общением” участников транзакции, и второй — для самой передачи данных.</p>

<p>FTP сервер может быть анонимным — это когда логиниться в него не надо, и работать с ним может фактически кто угодно. Своего рода помойка…) 
А может быть не анонимным и требовать авторизации.</p>

<p>Сеансы FTP работают в двух режимах: активном или пассивном.</p>

<p>В Активном режиме, после того как клиент инициализировал сеанск через запрос по командному каналу, сервер создает обратное соединение с клиентом и начинается передача данных.</p>

<p>В Пассивном режиме сервер использует командный канал для отправки клиенту информации, необходимой для открытия канала данных. Иными словами, в этом режиме клиент инициализирует передачу файлов, а не сервер. Такой режим хорошо работает, когда соединению “препядствуют” всякие фаерволлы, прокси и тд.</p>

<p>Пользователи могут работать с FTP сервером через интерфейсы командной строки из консоли, используя какие нибудь GUI приложения, или просто веб-браузер.</p>

<h1 id="зачем-он-нужен-если-есть-http">Зачем он нужен, если есть HTTP</h1>

<p>FTP — это старый добрый стандарт. Он очень прост и понятен в использовании. Мы можем передавать данные по HTTP, или пересылать их… по электронной почте X_X, но этим вариантам не хватает ясности, простоты и быстроты настройки, которые мы получаем используя FTP.</p>

<p>Этот протокол можно применять в простых и сложных сценариях, таких как доставка или получения необходимых данных на\с сервера, резервное копирование данных на другой сервер, репликация данных. Можно навелосипедить практически любой сценарий :D</p>

<h1 id="типы-ftp">Типы FTP</h1>
<p>Есть несколько видов имплементации протокола. Рассмотрим их вкратце.</p>

<p><strong>Anonymous FTP</strong></p>

<p>Самый простой вариант и небезопасный вариант. Сервер торчит в сеть и раздает данные в незашифрованном (как правило) формате и не требует никакой аутентификации и авторизации. Обычно это какая то слабо регулируемая общедоступное файловая помойка.</p>

<p><strong>Password-protected FTP</strong></p>

<p>То же самое что предыдущий вариант, только чуть безопаснее. Потребуется логин и пароль. Шифрования обычно тут тоже отсутствует.</p>

<p><strong>FTPS</strong></p>

<p>S — значит Secure. Данные шифрутся TLS.</p>

<p><strong>SFTP</strong></p>

<p>Технически, это не FTP протокол, но работает точно так же. SFTP это дитя SSH протокола, который обычно (сервер) работает на 22 порту. Наверное это самый безопасный вариант. Про SSH поговорим в другой раз. Вренемся к FTP.</p>

<h1 id="история-и-безопасность">История и Безопасность</h1>

<p>Давайте честно. Это старинная штука. Изначально FTP проткол определили в <a href="https://datatracker.ietf.org/doc/html/rfc114">RFC 114</a>, написанной Абхаё Бхушан (тогда ещё студент MIT) 16 апреля 71 года!! А это, на минуточку, раньше чем TCP и IP! Тогда ещё не было интернета, каким мы его знаем сейчас, а был ARPANET. Собственно в этой RFC и описывается идея предачи файлов в арпанете.</p>

<p>В последствии FTP разумеется переопределяли по мере эволюции интернета. 
Дружба с TCP/IP описана в <a href="https://datatracker.ietf.org/doc/html/rfc765">RFC 765</a> в 1980 году Джоном Постелом (АйТи Университет Калифорнии), пять лет спустя в <a href="https://www.ietf.org/rfc/rfc959.txt">RFC 959</a> добавили новые возможности управления протоколом, попытались обезопасить протокол только в 1997 году в <a href="https://datatracker.ietf.org/doc/html/rfc2228">RFC 2228</a>, и ещё через два года завезли поддержку IPv6 в  <a href="https://datatracker.ietf.org/doc/html/rfc2428">RFC 2428</a>.</p>

<p>По дефолту FTP вообще не шифруте трафик, и сниффить пакеты может кто угодно посередине. Это никуда не годится, собственно так и появились варианты FTPS и FTPES с поддержкой, соответственно, неявного и явного TLS соединения.</p>

<p>Но не смотря на все улучшения и попытки внедрить безопасность, протокол FPT всё ещё уязвим к брутфорс атакам на креды пользователей и к DOS.</p>

<h1 id="недостатки-ftp">Недостатки FTP</h1>

<p>На самом деле протокол использует два порта. 21 для командного канала и 20 для передачи данных. А ещё этот активный и пассивный режимы… Протокол сложно “резать” на сетевом экране. HTTP в этом моменте намного проще.</p>

<p>Понятие кодировки отсутствует. Если кодировки сервера и клиента отличаются, то скачав файл(ы) и имена и содержимое придется перекодировать. В HTTP такой проблемы нет, так как имеем метаданный в заголовках, где указан и тип файла, и кодировка передачи.</p>

<p>Отсутствие шифрования по умолчанию. Пусть оно и есть в модификациях, но как думаете, сколько на сервере администраторов которые ставят первый попавшийся под руку сервер и не заморачиваются по безопасности…?</p>

<h1 id="резюме">Резюме</h1>
<p>Но не смотря на всё это… Оно ещё живое, и умирать похоже не планирует.
Лично я FTP не использую, а при необходимости реализовать передачу данных смотрел бы в сторону других решений. По моему “умолчанию”, это это был бы на вскидку какой нибудь rsync по ssh или тупо scp.</p>

<p>Но знать про FTP и уметь им пользоваться нужно! Только, пожалуйста, настраивайте хотя бы FTPS сервера…)</p>

<p>Миру мир! Будьте здоровы!</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Если вы ищете быстрый и простой способ отправлять и получать файлы с друзьями, семьей или коллегами по работе, возможно вам следует знать о FTP.]]></summary></entry><entry xml:lang="ru"><title type="html">HTTP протокол</title><link href="http://localhost:4000/2022/05/22/HTTP.html" rel="alternate" type="text/html" title="HTTP протокол" /><published>2022-05-22T00:00:00+03:00</published><updated>2022-05-22T00:00:00+03:00</updated><id>http://localhost:4000/2022/05/22/HTTP</id><content type="html" xml:base="http://localhost:4000/2022/05/22/HTTP.html"><![CDATA[<p>Небольшой разбор повсеместно используемого протокола.</p>

<!--more-->

<h2 id="интро">Интро</h2>

<p>Всем привет! В далекой далекой галлактике однажды гумноиды придумали компьютеры, а потом придумали их вместе связывать. Задачка была не из легких, и много подумав гуманоиды разработали спецификацию — концептуальную сетевую модель, или стандарт, посредством которого компьютеры общаются между собой (к этой истории мы вернемся в другой раз).</p>

<p>А потом подумали ещё, поняли что слишком много выдумали, и отразили идеи в более прикладном и жизнеспособном виде.</p>

<p>Модели OSI и TCP/IP не являются темой этого поста. Сегодня я предлагаю разобрать нечто с их “дальнего конца”, наиболее близкого к нам — один из протоколов прикладного уровня, а именно HTTP.</p>

<h2 id="в-начале-был-текст">В начале был текст</h2>

<p>А потом появился <em>Гипертекст</em>. В нашей тусовке этим термином назвали текст размеченный с помощью собственно HTML.</p>

<p>За аббревиатурой HTML стоит —  HyperText Markup Language, переводить надеюсь не надо :)</p>

<p>Все замечательные (и не очень) странички которые вы видите в своих браузерах серфя интернет размечены HTML. Но понятно что соверменные системы не ограничиваются обменом текстовыми документами, за всем этим стоит какой то бекенд, логика, и прочие прелести.</p>

<p>Как происходит обмен данными между вашим компьютером, и другим, далеким-далеким сервером?</p>

<p>С помощью протокола HTTP!</p>

<p>Изначально задачей протокола являлось как раз получение текстовых страничек, но времена меняются, с 1990 года воды утекло много и сейчас по HTTP можно передавать практически всё, вплоть до потокового видео и аудио.</p>

<h3 id="чего-там-внутри-то">Чего там внутри-то</h3>

<p>Клиент-серверная архитектура, это такая “модель” взаимодествия вычислительных систем, в которой задачи распределяются некоторым образом между клиентам и серверами. Клиенты — это, например, опять-же ваш браузер или приложенька, а сервер — это некоторая сущность которая выполняет хотелки клиента.</p>

<p>Почему я говорю сущность? Потому что клиент и сервер это не какие то особенные железяки, а просто <em>софт</em> работающий друг с другом по сети. И общий язык этот софт находит как раз благодаря спецификациям сетевых протоколов.</p>

<p>В HTTP всё крутится вокруг <em>запросов</em> и <em>ответов</em>. Это предельно просто. Клиент Вася попросил (сделал запрос) Сервер Петю почистить картошку, на что от Пети следует какая-то реакция, в зависимости от обстоятельств.</p>

<p>Реакция Пети — это ответ. И их с Васей вазимодействие регламентировано протоколом (на самом деле не одним).</p>

<p>Сеть устроена сложно, и между Петей и Васей может, и обычно присутствует, множество роутеров, прокси-серверов, и прочей чертовщины о которой мы будем говорить позже.</p>

<p class="info">Это кстати небольшой спойлер! Я скоро начну достаточно плотно изучать сети, и обо всем буду писать в блог!</p>

<h3 id="хочу-банан">Хочу банан!</h3>

<p>Целью любого запроса всегда является какой-то <em>ресурс</em>. Как мы уже выяснили выше, по HTTP может передаваться что угодно. Более умным языком это можно выразить как то, что протокол HTTP никак не ограничивает <em>ресурсы</em> которые могут запрашиваться и передаваться, а лишь определяет <em>интерфейс</em> для взаимодействия с ресурсами.</p>

<p>Каждый ресурс, хотелка клиента, должна иметь какой-то идентификатор. Этим идентификатором является <em>URI</em> — Uniform Resource Identifier. URI — это по сути символьная строка. Здесь тоже есть много интересных (или не очень) подробностей, но по сути URI это всем нам привычный URL (Uniform Resource Locator) — то что часто называют “ссылкой”, и представяется в браузере в адресной строке как как-то последовательность разделенная слэшами.</p>

<p>Ну, короче, это адрес ресурса!</p>

<h3 id="структура-сообщений">Структура сообщений</h3>

<p>Начнем с запросов.</p>

<p>В структуру запросов входят следующие метаданные:</p>

<ul>
  <li>HTTP-метод: этот элемент декларирует хотелку клиента. Есть несколько методов запроса, но чаще всего клиент хочет либо что-то получить <strong>GET</strong>, либо передать какие-то значения — <strong>POST</strong>;</li>
  <li>Адрес ресурса: URL, который мы уже разобрали;</li>
  <li>Версия протокола;</li>
  <li>Заголовки (Headrs): могут быть, а могут не быть. <del>Вот в чем вопрос.</del> Задача заголовка — передать дополнительную информацию серверу, которая может ему понадобиться для корректной обработки запроса;</li>
  <li>Тело запроса: это нужно в первую очередь для POST запрсов, чтобы передать то, что клиент собственно хочет передать.</li>
</ul>

<p>Ответы же состоят из:</p>
<ul>
  <li>Версии протокола;</li>
  <li>Кода состояния: есть список кодов, которые говорят об успешности или не успешности операции, и могут подсказать или достаточно четко дать понять что пошло не так. Например знакомый 404 — ресурс не найден, или 200 — который вы никогда не замечаете, потому что 200 это ОК.</li>
</ul>

<h2 id="краткий-обзор-отличий-версий">Краткий обзор отличий версий</h2>

<p>В 2015 году на смену HTTP/1.1 пришел HTTP/2 который родился как результат обмозговывания путей оптимизации скорости обработки запросов, в первую очередь при работе с мобильными клиентами и аудио\видео форматами.</p>

<p>Основным отличием является то, что HTTP/1.1 сообщения передает втупую плейнтекстом, тогда как HTTP/2 кодирует их в двоичный формат, благодаря чему открывается возможность использовать другую модель доставки сообщений. Семантика “внутри” осталась прежней.</p>

<p>Для чего кодировать в двоичный формат? Это позволяет разбить сообщения на более мелкие пакеты, которые ещё называют кадрами. А ещё это позволяет использовать <em>одно</em> TCP соединение, вместо нескольких.</p>

<p>Несколько соединений HTTP/1.1 приходится устанавливать для того чтобы обходить блокировку HOL.</p>

<p>Блокировка Head-of-line — это такая фигня, когда очередь из пакетов задерживается первым поступающим пакетом. Так получается когда несколько запросов оправляются на один и тот же ресурс. Пакеты просто не могут проходить друг через друга.</p>

<p>Ну вот, а в HTTP/2 есть один поток, и сами сообщения закодированны. Каждый кадр имеет идентификацию принадлежности к пакету, поэтому ничего не путается. Сервер у себя спокойно принимает сообщения, собирает их обратно. И хотя устанавливается одно TCP соединения, сообщения могут спокойно долетать до сервера параллельно друг другу.</p>

<p>А ещё HTTP/2 сжимает заголовки. Сами данные, можно сжимать и в HTTP/1.1, но не заголовки. И хотя заголовок очень мал, но если клиент или клиенты шлют огромное кол-во запросов — это может стать проблемой. Как видим, HTTP/2 решает её довольно изящно.</p>

<p>Другие отличия HTTP/2 потребуют углубиться в сетевую модель, вернемся к этому может быть в другой раз :)</p>

<h3 id="что-там-про-поток">Что там про поток?</h3>

<p>Клиент-серверное взаимодествие выглядит как-то так:</p>

<ol>
  <li>Открываем TCP соединение. Одно или несколько. Разумеется, уже открытое соединение может использоваться и переиспользоваться далее, не нужно открывать новое соединение для каждого запроса.</li>
  <li>Отправляем сообщение (или сообщения).</li>
  <li>Читаем ответ сервера.</li>
  <li>Закрываем соединение или используем его снова.</li>
</ol>

<p>Ну, тут собственно больше говорить не о чем :)</p>

<h2 id="ещё-немного">Ещё немного</h2>

<h3 id="печеньки">Печеньки!</h3>
<p>Можно устанавливать <em>сессии</em>. Это достигается путем использования кукисов! Зачем нужны куки?</p>

<p>Прикол в том, что HTTP — это протокол <em>без состояния</em>. Это значит что каждый запрос независим, никак не связан с предыдущим. Мы это уже хорошо рассмотрели — всё общение построенно на парах запрос-ответ.</p>

<p>Но ведь… Состояния нужны! Мы не хотим каждый раз логиниться, и не хотим чтобы при обновлении страницы пропала вся наша бережно скирдованная корзина товаров в интернет магазине :)</p>

<p>Тут и выходят на сцену печеньки-кукисы.</p>

<p>Куки — это такой хитрый фрагмент данных, который сервер отправляет клиенту, и клиент у себя его сохраняет. Потом клиент эту куку шлет серверу в составе других HTTP запросов. Так Петя понимает, что хочет Вася, а что хочет Саша, и что Вася есть Вася, а не Катя.</p>

<p class="info">Хотя мне очень хочется тут распылиться на тему безопасности, но скажу лишь то, что куку легко украсть и подменить, если поток данных между клиентом и сервером не зашифрован. TLS — отдельная тема к которой мы <em>обязательно</em> вернемся в другой раз.</p>

<h3 id="аутентификация">Аутентификация</h3>

<p>HTTP может без всяких других штук предоставлять средства базовой аутентификации, но это не очень безопасно, и обычно специальные сессии устанавливаются с помощью куки.</p>

<h3 id="кеш">Кеш!</h3>

<p>Сервер может с помощью специальных заголовков заставлять промежуточные прокси сервера кешировать какие-то данные, и как долго их надо сохранять.
Клиент в свою очередь может схожим образом “просить” прокси игнорировать кеш, и передавать запрос на требуемые ресурсы далее.</p>

<h2 id="резюме">Резюме</h2>

<p>Мы завершаем краткий обзор протокола HTTP. Краткий, потому что там есть <em>много чего ещё</em>: можно очень долго перечислять все коды ответов, углубиться в то, как происходит сжатие, кеширование. Что такое REST, какие используются кодировк и так далее.</p>

<p>Если вам интересно умудриться то первымы местами, куда стоит обратиться, это RFC документы, в частности под номером <strong>7231</strong> и MDN доку.</p>]]></content><author><name>Иван Закутний</name><email>zakutnii.ivan@gmail.com</email></author><category term="Сеть" /><summary type="html"><![CDATA[Небольшой разбор повсеместно используемого протокола.]]></summary></entry></feed>