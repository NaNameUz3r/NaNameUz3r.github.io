---
title: "Декларативное программирование и рекурсия."
tags: "Программирование Отчеты Декларативная_модель"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-02-20"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/declarative_model_2.png
---

Врубаемся в Декларативную модель — Часть 2. 
<!--more-->

Здравствуйте! Мы продолжаем изучать декларативную вычислительную модель. На этой неделе я добрался до более практичных тем, и начну рассказывать вам о том, как собственно устроено программирование в декларативном "стиле".

[В прошлый раз](/2022/02/06/hack_in_declarative_model.html) мы разобрали декларативную модель с теоретической точки зрения, и в общих чертах должны хорошо понимать её внутреннее устройство.

## Польза декларативной модели
#### Детерминированный "конструктор"
Одна из главных крутостей декларативного программирования заключается в том, что декларативные программы **композиционны**. Это значит, что программа состоит из некоторых *компонентов*, каждый из которых, благодаря заложенным в вычислительной модели принципам, является строго и ясно ограниченной частью программы. 

В декларативной программе каждый компонент всегда хорошо различим, у него есть определенные входы и выходы. При этом компонент не обязательно является "малым" фрагментом кода, функций или процедурой. Процедура лишь частный вид компонента, и в более "сложном" компоненте могут быть определены другие, сохраняя всю декларативную ясность и мощь. 

Композиционность достигается благодаря свойственным декларативной модели качествам. Напоминаю, мы не используем "динамические переменные", не храним внутренние состояния процедур\функций, не передаем их куда-то вовне. Получается что компоненты, "сущности сами в себе", или по русски — независимые сущности. Выход из одной декларативной операции становится входом для другой, сайд-эффекты, фактически — невозможны. 

Благодаря этому качеству в декларативной модели мы можем разрабатывать сложные и *надежные* системы.

#### Ясно, понятно

Вторая сила декларативного программирования вытекает и связана с первой — декларативные программы достаточно просты для понимания. Мы можем легко рассуждать о них сквозь призму, например, логического анализа. Чтобы понять программу в целом, нам нужно лишь понять все её компоненты. 

---

Исходя из этого мы можем предположить, что можно забить на все остальные вычислительные модели, хорошо разобраться в декларативной, и все программы описывать только в ней. Жаль что это невозможно. Если бы все было так просто, то другие модели бы просто не появились. Дело в том, что задачи бывают разные, и для их решения подходят разные парадигмы. 

Но хорошая новость в том, что на уровне разработки (написания) кода отдельных функций или модулей (ещё это называется *programming-in-small*), декларативный стиль применять можно **всегда!**.

На самом деле так **нужно** поступать. Это залог хорошего продукта не только в виде отдельных программных модулей, но и качественной программной системы в целом (*programming-in-large*). 

Компоненты не должны иметь лишних связей, потому что это приводит к запутыванию и усложнению системы. В такой ситуации мы не можем говорить о композиционности или понятности. Как разобраться в отдельной части, если она явным образом зависит от кучи других? А те, в свою очередь, от кучи других? А если не явным? Брррр.

Другие вычислительные модели, свойством которых является тесная связь многих компонентов, *нужно использовать изолировано и в ограниченном количестве модулей*. Мы пытаемся, как-бы, "компонизировать" части системы со сложными связями, чтобы сами эти части становились **декларативными компонентами**. 

Вот вам новая мантра:

Я делаю как можно больше компонентов системы декларативными.
{:.info} 

Говорят, если повторять её каждый раз когда садишься программировать, и применять на практике — станешь хорошим инженером.

## Рекурсия

Как много будоражащего ум в этом слове (пока не разобраться :) ). 
Помню в детстве я сидел в парикмахерской, и места там были напротив друг друга у противоположных стен, и зеркала соответственно. Слово рекурсия я тогда не знал, но залип *глубоко* и надолго. 

В программировании рекурсией называют "прием", когда в теле функции вызывается эта же функция. На самом деле рекурсия может применяться по разному, самый простой и частный случай это *прямая* или простая рекурсия, когда функцию явно вызывает "саму себя". Ещё рекурсии бывают *косвенные* или — *непрямые*. Это более хитрый способ, когда, например, функция А, вызывает функцию В, которая в свою очередь снова вызывает функцию А, и так далее.

Если рекурсивный вызов в теле функции является последним оператором, то в этом случае такую рекурсию называют *хвостовой*. 

*Глубина* рекурсии определяется количеством рекурсивных вызовов. Как это работает? Ну, в общем, есть такая структура данных **стек**. Наивно-абстрактно мы сейчас можем представить её как некоторую "вертикальную стопку" записей. Мы можем складывать туда записи одна за другой, и извлекать в обратном порядке, то есть забирать "верхние" записи поочередно. 

Например, возьмем рекурсивную функцию А и изначально пустой стек. В вызове А0 что-то происходит, этот вызов с его "окружением" помещается в виде записи в стек, и в процессе выполнения происходит рекурсивный вызов А1. Ситуация повторяется, А1 помещается в стек следом за А0, вызывается А2, и так далее.

На самом деле это может происходить бесконечно, до тех пор пока не кончится память и стек не будет переполнен (stack overflow). Во избежание подобного в рекурсивных функциях определяют конечное условие, в случае удовлетворения которого функция должна что-то вернуть, а не снова провалиться в дальнейшую рекурсию. 

Это ещё называется "базовым случаем" — условие в рекурсивной функции, при котором не происходит рекурсивный вызов и функция завершая, как правило вернув какое-то значение. Соответственно, если проверка базового случая не проходит, функция выполняется дальше в "рекурсивный случай". 

Возвращаясь к примеру выше, представим что в вызове А4 это конечное условие было удовлетворено. В результате мы имеем стек, условно, такого вида А0 -> А1 -> А2 - A3 -> A4. Стрелки в данном случае отображают последовательность рекурсивных вызовов. Получается, что результат работы А4 вернется в А3, оттуда в А2, А1, и наконец в изначальный вызов А0 (который в общем тоже имеет какой-то выход, в данном случае это не важно).

Если вы смотрели мультик Гравити Фолз, то должны помнить что там была такая бездонная яма, в которую что не упади, обязательно рано или поздно вылетит назад. Можно представить рекурсивные вызовы и стек таким образом, для запоминания. 

{:refdef: style="text-align: center;"}
![Стэн в яме](/images/botomless_pit.gif)
{: refdef}
*<center>Дядюшка Стен ждет конечного условия, или пока стек переполнится. </center>*


Очевидно что бездумное использование рекурсии может накладывать существенные расходы памяти.

### Что происходит?

Иван, при чем тут рекурсия? Этот пост про программирование в декларативной модели был. Ага! Я не отошел от темы. 

Сейчас мы уже знаем всё что нужно, чтобы применять "декларативщину" на практике. Подытожим. 

Для соблюдения декларативной модели нам нужно, во-первых, использовать переменные исключительно для однократного присваивания. Во-вторых, использовать простые (арифметические) операции над исконно декларативными типами данных — списками и записями. В-третьих, комбинировать декларативные операции, получая декларативные операции в результате (компонуем по полной!).

Так а что с этим всем делать? Комбинировать компоненты декларативной программы по правилам **программирования высшего порядка**! Звучит серьезно, правда?

Программирование высшего порядка, это когда в модели функции могут получать в качестве аргументов другие функции (как параметры), и *возвращать их в качестве результата*. 

Догадались, нет? 

Технически корректной реализацией декларативной программы будет её описание как **чистых рекурсивных функций** организованных согласно **программированию высшего порядка**.

Помните, в самом начале первой части мы говорили о том, что декларативная модель, это когда мы описываем "что должно получиться в итоге", а как этого результата достигать? Вот это как раз и реализуется по канону высшего порядка, рассмотрим совсем простой псевдокод.


    function ИтерацияВычислений(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо):
        if ФункцияПроверкиРезультата(ОбрабатываемыеДанные) == True:
            Возвращаем ОбрабатываемыеДанные
        env

        ОбрабатываемыеДанные = ФункцияВычисляющаяЧтоТо(ОбрабатываемыеДанные)
        return ИтерацияВычислений(ОбрабатываемыеДанные, ФункцияПроверкиРезультата, ФункцияВычисляющаяЧтоТо)
    end


Разберем по порядку. Всё вместе называется **абстракцией управления**. Это как раз пример программирования высшего порядка.
У нас есть функция которая вызывается рекурсивно — *ИтерацияВычислений*. В данном примере я назвал её так, потому что **итеративные вычисления** это *частный случай рекурсии.*

*ФункцияПроверкиРезультата*, в данном случае, это как раз то, с помощью чего определяется то самое условие "что должно получиться в итоге". 

Ну а *ФункцияВычисляющаяЧтоТо*, это рабочая лошадка, производящая фактические преобразования исходного значения "*ОбрабатываемыеДанные*"

Всё это мы можем обернуть в ещё одну функцию, в которую аргументом будут передавать лишь ОбрабатываемыеДанные, которые нужно преобразовать способом, скрытым внутри реализации. В результате мы получаем компонент, который может использоваться в проекте. В прошлой части я писал о *лингвистических абстракциях*. Подобный компонент, если он должен часто использоваться в проекте, может быть представлен как раз в виде такой абстракции.

Учитывая правило, о котором мы уже говорили — использование простых арифметических операций, глубокий стек рекурсивных вызовов формироваться не будет. Во-первых, потому что мы имеем четко определенное конечное состояние, которое проверяется "ФункциейПроверкиРезультатов". Во-вторых, такие простые вычисления хорошо оптимизируются компиляторами.

## Резюме

Если декларативная модель — это исток всех остальных моделей, их сердцевина. То сердцевина самой декларативной модели — рекурсивные вычисления! Это чрезвычайно мощный инструмент с огромным потенциалом. Кроличья нора *очень глубока*, но ослепительно проста и прекрасна. 

В следующий раз мы разберемся в том, что списки, на самом деле **рекурсивный тип данных!** и продолжим гнаться за декларативным белым кроликом.

Будьте здоровы.

{:refdef: style="text-align: center;"}
![Рекурсивные кролики](/images/white_rabbits.gif)
{: refdef}

[Читать следующую часть](/2022/02/20/hack_in_declarative_model_3.html)