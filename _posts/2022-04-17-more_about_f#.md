---
title: "Ещё немного про F#"
tags: "Программирование Отчеты Функциональное_программирование"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-04-18"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/more_fsharp.jpg
---

Продолжаем врубаться в функциональное программирование. Пусть и туго :)
<!--more--> 

Всех и повсюду приветствую! Я продолжаю заниматься по ФП курсу, и (имхо!) пришла пора написать ещё немного про фишки F# (и, наверное, вообще ФП языков ML семейства) и порефлексировать. 

## Перегрузка

Перегрузка, это такая реализованная в языке "полиморфная" штука, когда при обращениях к функциям или операторам, которые *имеют несколько реализаций для разных типов данных* компилятор ведет себя по разному. Сами эти реализации и есть "перегрузки". 

В F# система типов ведет себя следующим образом:
- Когда компилятору "понятно" в контексте обращения, что за тип используется — символ оператора интерпретируется как функция для этого типа;
- В противном случае используется *перегруженный* оператор для *подходящего* типа по умолчанию.

Звучит сложно, но на самом деле тут всё просто. Если какой-то оператор можно применить к целым числам (int), ну значит int и будет считаться *типом по умолчанию*. 

Например у функции:
    
    let addition (x,y) = x + y 

по умолчанию тип будет int -> int. Но что если мы хотим, и заранее знаем, что будем вычислять числа с плавающей точкой? 
Явно указать тип *аргумента* в F# можно так:

    let addition (x: float, y: float) = x + x

Указать явно тип результата функции:
    
    let addition (x, y) : float = x + x

И, наконец, можно указать явно *тип выражения*, вычисляемого функцией:
    
    let addition (x, y) = x + x : float

## Нонфиксная запись

Любые инфиксные операторы можно записать нонфиксной записью. Ну, короче, не 1 + 1, а (+) 1 1.

Просто берем оператор в скобки, и следом перечисляем аргументы. Можно представить это как функцию:

    let mul3 = (*)3

Где вызов mul3 2 будет равняться 6. Просто? Просто!

Ну и по сути вызов нонфиксного оператора, который на вход получает один аргумент — функция (хотя тут вообще всё функция, но давайте сохранять трезвость рассудка).

Применение функции работает через *левую ассоциацию*:

    printfn "%b" ((*) 3 2 = ((*)3) 2) // будет true!

Ну как там, с трезвостью?

## Композиция и каррирование

Так, это уже серьезные спеллы, первый из которых должен быть нам уже знаком (как минимум интуитивно). 

### Композиция

По-простому — это подход, подразумевающий вызов одних функций в качестве аргументов других. Я уже писал про high-order и вот это всё.
По-сложному, математически — композиция двух функций x и y (x o g) будет обозначать:

    (x o y)(x) = x(y(x)) 

И есть x(a) = a + 5, и y(b) = b * 2, тогда

    (x o y)(b) = x(y(b)) = x(b * 2) = b * 2 + 5


{:refdef: style="text-align: center;"}
![Взрыв Мозга](/images/mind_blowing.gif)
{: refdef}
*<center>Узнали? Согласны?</center>*

Отставить горячку!

В F# вся эта магия реализуется *инфиксным* оператором << или >> у которых оба параметра — функции.

    let x = fun a -> a + 5
    let y = fun b -> b * 2
    let chtoproishodit = x << y

    printfn "%d" (chtoproishodit 5) // посчитает: 5 * 2 + 5 = 15

    let ostanovitespojaluista = ((fun y -> y * 20) << (fun x -> x - 1)) 2 // посчитает: 2 - 1 * 20 = 20 

Всё просто же? Как сказано выше, можно передавать функции в другом порядке с помощью >>

    let vseyasno = x >> y // vseyasno 3 = y ( x(3) ) = y ( 8 ) = 16  

### Каррирование

Или — *частичное применение функций*. 

Это когда мы передаем функции *неполное число аргументов*, и в результате получаем... что? функцию! 

Как уже говорилось в предыдущем посте по теме, все функции в F# имеют **только один аргумент**, когда мы кортежем передаем несколько аргументов, это по сути (формально) работает как применение функций одного аргумента ко всем аргументам из списка поочередно. 

Вот такая каррированая функция f a будет ждать на вход один параметр b:

    let f x = fun b -> b * x 
    let mul5 = f 5

Понятно, что вызвав mul5 2 получится 10. В F# допускается ещё более краткая запись без fun:

    let f x b = b * x 

Работать будет точно так же.

## Нужно больше операторов!

Тут можно делать свои операторы, а не только функции (сейчас какой-то душный человек вспомнит что оператор тоже функция и пойдет поедет. Я ― помню).

Для определение своих *инфиксных* операторов нам доступны следующие символы: 

    ! % & * + - . / < = > ? @ ^ | ~

А для *префиксных* такие последовательности:

    + - +. -. & && % %% ~ ~~ ~~~ ~~~~

Объявление таких операторов нужно делать через скобочную нотацию: (оператор) для инфиксных, и (~оператор), соответственно для префиксных.

## Операторы применения функций

Есть два таких оператора: "\|>" и "<\|", они отправляют значение вправо или влево. 

Выражение x \|> y и выражение y <\| x будут означать одно и то же — "y x".

Но важный момент в том, что ассоциация этих операторов **левая**:

    10 |> 2 |> (+) 

приведет к ошибке, когда:

    10 |> (2 |> (+)) 

сработает.

## Ещё раз про кортежи

Итак, мы знаем что с помощью кортежей мы можем схитрить и передать в функцию больше одного аргумента. 

Кортежи могут объединять в себе значения разных типов, это ок. И это потенциально очень мощный инструмент. Рассмотрим несколько фишек.

### Фишки первого уровня

Значения типов в кортежах перевариваются в F# как объекты первого класса. Мы можем использовать их в выражениях, и получать как результат других выражений. 

Можно использовать в качестве элемента кортежа уже связанное ранее значение:

    let a = (10, "hello")
    let b = (a, 100.500)

Последний кортеж получится типа: ((int * string) * float)

Вычисляются кортежи по порядку слева-направо, и кортежи можно сравнивать, но только если совпадают значения типов их элементов (в том же порядке):

    (5 = 2, "hello", 1 + 1) = (false, "hello", 2) // правда!
    (5 = 2, "hello", 1 + 1) = ("friend", (10.5, 18)) // парень, не дури, типы не совпали.

"Легальное" сравнение (когда с типами всё ок), происходит в лексикографическом порядке:

    (29, 14, 100) > 11, 0, 101 // не правда!

### Кортеж как шаблон

Мы можем сделать кортеж состоящий только из идентификаторов:
    let (x, y) = (10, 200) // x = 10, y = 200

С помощью чего потенциально можем сопоставлять идентификаторы и значения.

Помните паттерн матчинг? Тут можно так же использовать идентификатор "_" для сопоставления с любыми значениями:

    let (_, y) = (1, 2) // y = 2

### Превращение в овцу

Это про полиморфизм, кто не понял :) 

Пример полиморфной функции с кортежем — функция swap:

    let swap (x, y) = (y, x)

Она меняет значения внутри кортежа местами, и типы её параметров полиморфны, то есть определяются другими типами.

Полиморфный тип, это такой тип, операции над которым могут нормально применяться к другим типам.

В F# полиморфным типом выступает базовый тип .NET System.Object, таким образом тип функции swap будет:

    System.Object  * System.Object -> System.Object * System.Object

## Рефлексия

Спойлер Алерт!!! Если вы занимаетесь по курсам Сергея Игоревича Бобровского, и не прошли ещё курс по F# — имейте совесть и смелость решить задачки сами. В частности далее будет спойлер к задаче по кастомным операторам 23.4.1. 
{:.error}



{:refdef: style="text-align: center;"}
![Котямба](/images/serious_cat.jpg)
{: refdef}
*<center>Я серьезно.</center>*


Задачка следующая:

  В фэнтези-РПГ принята следующая денежная система: в одном золотом 20 серебряных, а в одном серебряном 12 медяков. Суммы в такой системе задаются тройками целых чисел (золотые, серебряные, медяки), например (1, 0, 128) или (32, 23, 5).

  Реализуйте инфиксный оператор .+. , который складывает деньги, представленные в виде троек, и инфиксный оператор .-. , который вычитает деньги. Результат приводите к формату, когда количество медяков не превышает 11, а количество серебряных не превышает 19.


Посмотрите какую хрень я накодил в первый (ладно, во второй) раз:


    let (.+.) x y =
        let (g1, s1, c1) = x
        let (g2, s2, c2) = y
        
        let total_wallet = (g1 + g2, s1 + s2, c1 + c2)
        
        let rec count_coppers = function
        | (g, s, c) when c <= 11 -> (g, s, c)
        | (g, s, c) -> count_coppers (g, s + 1, c - 12)

        let rec count_silvers = function
        | (g, s, c) when s <= 19 -> (g, s, c)
        | (g, s, c) -> count_silvers (g + 1, s - 20, c)

        let copper_converted = count_coppers total_wallet
        let converted_wallet = count_silvers copper_converted
        converted_wallet
    

    let (.-.) x y = 

        let (more, less) = 
            if x < y then
                (y, x)
            else
                (x, y)

        let (g1, s1, c1) = more
        let (g2, s2, c2) = less

        let rec count_coppers = function
        | (g, s, c) when c <= 11 -> (g, s, c)
        | (g, s, c) -> count_coppers (g, s + 1, c - 12)

        let rec count_silvers = function
        | (g, s, c) when s <= 19 -> (g, s, c)
        | (g, s, c) -> count_silvers (g + 1, s - 20, c)

        let bigger_copper_converted = count_coppers more
        let bigger_converted_wallet = count_silvers bigger_copper_converted
        
        let smaller_copper_converted = count_coppers less
        let smaller_converted_wallet = count_silvers smaller_copper_converted

        let (bigger_g, bigger_s, bigger_c) = bigger_converted_wallet
        let (smaller_g, smaller_s, smaller_c) = smaller_converted_wallet
        (bigger_g - smaller_g, bigger_s - smaller_s, bigger_c - smaller_c)


Ну, справедливости ради, оно работает и прошло тесты. Но это какая то жесть. Пусть я и попытался применять рекурсию, здесь налицо недопонимание принципов хорошего, ясного программирования. И вообще халатность. Например в реализации оператора .-. не кажется ли вам что DRY не пахнет?

Эталонное решение выглядит следующим образом:

    let rec iter = function
    | (a, b, c) when c > 11 -> iter (a, b + (c / 12), c % 12)
    | (a, b, c) when b > 19 -> iter (a + (b / 20), b % 20, c)
    | (a, b, c) when c < 0 && b > 0 -> iter (a, b - 1, c + 12)
    | (a, b, c) when b < 0 && a > 0 -> iter (a - 1, b + 20, c)
    | (a, b, c) when c < 0 && a > 0 -> iter (a - 1, b + 19, c + 12)
    | (a, b, c) -> (a, b, c)

    let (.+.) (a, b, c) (x, y, z) = iter (a + x, b + y, c + z)
    let (.-.) (a, b, c) (x, y, z) = iter (a - x, b - y, c - z)


Ради той же справедливости попытаюсь оправдаться, что в первом своем нерабочем решении я использовал деление с остатком, но там была какая то императивная дичь с условными операторами, и компилятор ругался матом. Почему я не додумался забабахать рекурсивный паттерн матчинг... Хороший вопрос. Просто посмотрите на эту красоту, насколько это более ясно и коротко может быть выражено в коде. Паттерн матчинг воистину крутая штука!

Век живи — век учись. А дурнем и помрешь!

Слава Алонзо Черчу! Миру Мир! Я пошел. 