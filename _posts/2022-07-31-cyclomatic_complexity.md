---
title: "Снижение цикломатической сложности программной системы"
tags: "Программирование Проектирование"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-07-30"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/cyclomatic_complexity.jpg
---

Небольшая заметка о ЦС в разрезе проектного мышления.
<!--more-->

# Цикломатическая сложность

Привет! Цикломатическая сложность — это одна из самых важных характеристик, или метрик простоты кода, которая отражает степень сложности понимания этого кода (запутанность).

ЦС измеряется числом независимых путей в коде, где каждый путь — это последовательность операторов, по которой можно пробежать до "конца" работы программы.

Например, если цикломатическая сложность для некоторой функции равна 10-15, это по сути означает, что эта функция может отрабатывать 10-15 *разными способами*! Как следствие, нужно 10-15 тестов для того чтобы полностью покрыть работу такой функции. Скорее всего функция с таким показателем ЦС достаточно слабо выражена, имете в теле несколько вложенных условий и прочие непотребства.

Очень ограниченная функция в "вырожденном" стиле, не несущая в себе сложной алогоритмической логики, цикломатическая сложность которой равняеется единице — это другая крайность. На таких функциях врядли удастся "далеко уехать".

Тем не менее формальное правило, следование которому порождает правильный слить программирования выглядит примерно так — следует *стремиться к цикломатической сложности равной 1 нужно тем больше, чем дальше мы уходим в **проектирование** и бизнес-логику от "алгоритмического программирования"*.

# Правила снижения ЦС

Приемы снижения ЦС:

1. Никаких операторов switch/case.
2. Никаких циклов (while, for и тд).
3. Никаких Null/None/nil и тд.


{:refdef: style="text-align: center;"}
![Взрыв Мозга](/images/hard.png)
{: refdef}

Мы, кажется, напали на проблемку. Как это вообще реализовывать на практике? Попробуем разобраться далее.

Ну ок, условные операторы и for можно заменить единообразно циклом while. Но while тоже запрещён... Да ещё и на null проверять нельзя ничего. А как программировать то вообще?

Просвященные-бородатые мудрецы CS говорят рассматривать задачу по сниженю цикломатической сложности в рамках другого, более широкого принципа — **Open-Closed Principle**, или принципа открытости-закрытости.

Этот принцип можно выразить в следующей форме:

*Модуль считается открытым, если его можно продолжать расширять*.
{:.info}
*Модуль считается закрытым, когда он выкачен в прод, и им можно **только пользоваться***.
{:.info}

Код можно оценивать по шкале "абсолютной открытости / закрытости" — чем выше ЦС, тем более код закрыт для развития и сопровождения.

Так, что там с правилами...

Зачастую от нагромождней if можно избавиться прямо на уровне синтаксиса языка программирования.

Например от штук вроде:

    if <condition>
        return true
    else
        return false

В большинстве яп, если не во всех, подобная конструкция легко меняется на

    return <condition>

А ещё говорят, математически доказано что безусловно точно вообще и всегда можно программировать не используя else.

## ad-hoc полиморфизм

Первое качественное решение для движения по направлению к открытости кода — это *ad-hoc полиморфизм*.

Полиморфизм обычно делится на три направления.

**Полиморфизм подтипов** — определяется единый интерфейс для разных типов, с различной реализацией. То есть автоматически выбирается нужная версия "интерфейсного метода" в зависимости от типа объекта в иерархии наследования.

**ad-hoc полиморфизм** — это когда мы определяем полиморфные методы с единым именем, которые действуют по разному, но в рамках одного типа. У классов имеется несколько методов с одинаковыми названиями, но с разными списками параметров. "Нужный" метод выбирается в зависимости от переданного списка аргументов.

**Параметрический полиморфизм** — это когда в языках с динамической типизацией одна и та же функция может нормально, универсально работать с параметрами любых типов.

Итак, если у нас имеется метод в котором есть условие, по которому выполняется вообще разный код, то будет очень полезно посмотреть в сторону применения ad-hoc полиморфизма:
выносим каждую ветку условия в отдельный метод у каждого из которых будет одно и то же имя. Каждый такой отдельный метод будет вызываться для каждого варианта со своей реализацией и уникальным набором параметров, который у оригинального метода избыточен, т.е охватывает все варианты работы в зависимости от условий, но при этом реально используется вообще не все аргументы. Такой подход приведет к снижению ЦС.

## Multiple dispatch

В различных ООП языках multiple dispatch поддерживается в минимальном виде как ad-hoc полиморфизм. Про multiple dispatch мы немного говорили [тут](/2022/07/05/hack_in_OOP_1.html).

В классе допускается определять сколько угодно функций с одинаковыми именами и одинаковым кол-вом параметров, которые будут отличаться типами параметров и, возможно, типом возвращаемого значения.

В контексте снижения ЦС тут будут полезны дженерики: можно явно параметризировать функции типами, как и в случае с полиморфными функциями.

# Давайте попроще, а?

Ладно, вот более мягкая версия "стилистических правил" для снижения цикломатической сложности:

1. Не используем esle и цепочки else if.
2. Не используем if вложенные в if, и циклы, вложенные в if.
3. if внутри цикла можно использовать только один, и только для прерывания работы (break, continue), выхода из функции или генерирования исключения.

Следуя этим правилам мы получаем практически линейную последовательность инструкций, и ЦС может достигать значений от 4 до 6. Если внутри условия возникает сложная логика — выносим её в отдельный метод/функцию.

Здесь важно придерживаться ещё одного правила:

Между аргументами функции и телом условия (код внутри if) должно быть соответствия **один к одному**. В каждом условии обрабатываем только один аргумент, а не несколько.
{:.info}
