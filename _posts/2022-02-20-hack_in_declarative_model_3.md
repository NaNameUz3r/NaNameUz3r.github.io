---
title: "Список списков, итеративные вычисления и прочие муми-тролли"
tags: "Программирование Отчеты"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-02-12"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/declarative_3.jpg
---

Врубаемся в Декларативную модель — Часть 3. 
<!--more--> 

### Here we go again
Здравствуйте! Это очередной пост-отчёт по мотивам материала из курса [школы Сергея Бобровского](https://skillsmart.ru/) – Как понять в программировании всё. Изучаем декларативную вычислительную модель.

В прошлый раз мы остановились на том, что закрепили рекурсивные вычисления как ядро декларативной модели.

Рекурсия как программистский трюк не ограничивается "самовызовом" (прочитали как самовывоз, признайтесь?) функций — *рекурсивными могут быть и типы данных*. Базовый пример рекурсивного типа данных — список. 

Почему список на самом деле рекурсивная структура? Потому что он определяется *в терминах более короткой версии себя самого*.

Вернемся немного назад. В первом посте из этого цикла мы вкратце рассмотрели базовые типы данных декларативной модели.
Напоминаю, запись — это вот прямо основа основ. У неё есть идентификатор имя и *"список"*, а лучше сказать набор или "последовательность" пар "ключ-значение". 

Так вот, конкретно тип данных список — это множество произвольных значений, которые друг с другом как то связанны.
В частном случае этот тип так и называют — связанный список. 

Как правило этими "произвольными" значениями в связанном списке являются элементарные типы данных, например строки или числа. Но это не обязательно, в каком нибудь монструозном ООП мы можем на базе списка "впихнуть" в эти "кусочки" какие угодно данные, если это будет целесообразно или эффективно (а будет не всегда). 

Части списка связанны некоторым образом с другими, и всё вместе ("элементарный кусок данных" и связь-указатель на другой) называется *узел*.

В примитивном случае узлы связываются друг с другом последовательно (в одну сторону), как паровозик.

Вернемся к фундаментальным материям :)

В декларативной модели список определяется *рекурсивно*. Считается, что либо список пустой (nil или, если хотите, None), либо *есть какое-то значение связанное со списком*. 

Как это работает совсем по простому: Представим что изначально инициализировали список X. Его значение будет nil — пустой список. Если в список добавится, например, "узел" содержащий строку "shrek", то тогда список X будет равен "shrek" *связанный со списком nil*!

Короче говоря, "последний" элемент в списке всегда будет "указывать" на "пустой список".

Такое представление в декларативной модели позволяет использовать списки для очень лаконичных (выразительных) и мощных рекурсивных вычислений.

В рекурсивных функциях, работающих со списками, *базовым случаем* будет проверка небольшого списка, пустого или состоящего из 1-2 значений. Рекурсивным случаем (работаем с большим списком) будет вычисление результатов *более мелких списков*. 

Например, "декларативная" рекурсивная функция вычисляющая длину списка на Python будет выглядеть как-то так:

 
    def list_length(some_list):
        if some_list == []
            return 0
        
        list_head = some_list[0]
        list_tail = some_list[1:]

        return 1 + list_length(list_tail)


Надеюсь что у вас сейчас случилось небольшое рекурсивное сатори — "Ух ты ж сколько можно то намутить с этим списком!" 

{:refdef: style="text-align: center;"}
![Подождите!](/images/hold_on.gif)
{: refdef}

Это всё ещё рекурсивная функция, мы в прошлый уже говорили про проблему с переполнением стека. Кроме того, рекурсивные функции со списками, при их необдуманном определении, вполне могут оказываться крайней не эффективными — O(n*n) или ещё хуже.

Для решения этих проблем есть техника, при которой рекурсивные функции превращаются в функции с *итеративной формой вычисления* с **линейной** эффективностью!

### Итерируй то

Ранее мы говорили про итеративные вычисления как о частном случае рекурсии. Разберемся чуть глубже.

Во-первых стек. Почему он вообще формируется при рекурсивном вызове? Обратите внимание на пример функции вычисления длинны списка, а именно на хвостовой return в конце. Раз за разом при рекурсивном вызове окружение экземпляра функции должно сохраняться в стеке, потому что прибавление единицы происходит **после** этого заключительного return. 

В нашем примере это всё происходит лишь для того, чтобы потом в обратном порядке "размотать" стек и просуммировать единцы. Кажется избыточным.

Чем отличается итеративное вычисление от обычной рекурсии?

Схема итеративных вычислений — это *последовательность **трансформации состояний***. Как это работает?

Ну, по сути, мы добавляем некоторый счетчик в аргумент рекурсивной функции, и делаем так чтобы увеличение этого счетчика *происходило **до** рекурсивного вызова*. 

Рекурсивная-итеративная функция вычисления длины списка будет выглядеть так:

    def iter_list_length(i, some_list):
        if some_list == []:
            return 0
        
        return iter_list_length(i+1, some_list[1:])

Обратите ещё раз внимание на счетчик *i*. Мы увеличиваем его в аргументах рекурсивного вызова, **до** самого вызова. Благодаря этому мы "замыкаем" окружение функции и состояние каждого экземпляра не требуется сохранять в отдельных записях в стеке. 

Ничего не мешает скрыть такую функции за функцией-абстракцией, которая будет принимать только list, а внутри вызывать inter_list_length(0, list).

### Итерируй это

Видите как связана "рекурсивность функции" с "рекурсивностью типа", который она обрабатывает?

Это **важная фишка**. 

Мы уверенно можем сказать, что *рекурсивная структура функции зависит от рекурсивной структуры определения обрабатываемого типа данных*.

Мы потенциально можем нагородить какой угодно рекурсивный тип, но это не есть хорошо. Эта свобода в программировании часто приводит к написанию очень неэффективных, не грамотных алгоритмов. 

Само по себе определение какого-то типа данных в языке программирования *описательно*. Это значит, что такое определение является всего лишь набором логических утверждений о множестве значений, который данный тип может принять. Такие определения не являются полноценными проверками допустимостей значений, а зачастую (например какой нибудь абстрактный тип) их вообще проверить нельзя.

В декларативной модели даже базовые типы могут быть не проверенны компилятором. Поэтому нам **важно** предельно осознанно понимать что мы кодим, и использовать изначально свойственные декларативной модели типы данных.

Список это very handy! Надо лишь включить думалку, и включить так, чтобы избежать неэффективных реализаций алгоритмов.

Вернемся к нашему определению взаимосвязи рекурсивности типа с рекурсивностью функции.

Сперва нам необходимо *правильно определить рекурсивный тип*, прежде чем писать для него функцию. Что это значит?

Например, у нас есть некий композитный список, элементы которого тоже могут быть списками, и нам надо посчитать количество всех значений, включая значений во вложенных списках.

Нам нужно понять, или *определить* тип "вложенный список". 

Мы помним что "список" — это либо пустой [], либо некоторый "элемент" связанный с [].

В таком случае "вложенный список" будет определяться как — либо пустой [], либо "вложенный список" связанный с "вложенным списком", либо как "элемент" связанный с "вложенным списком". Ничего не понятно?

Короче говоря, у нас в любом порядке и в "ширину" и в "глубину" элементы могут быть либо "простыми" элементами-значениями, либо списками, в которых в любом порядке и в "глубину" и в "ширину" элементы могут быть либо "простыми" элементами-значениями, либо списками, в которых...


{:refdef: style="text-align: center;"}
![Рекурсия](/images/recursion_1.gif)
{: refdef}
*<center>Неотложка уже выехала.</center>*

Так, давайте не будем пороть горячку! Это проще чем кажется.

Вложенный список, с которым может быть связан вложенный список, все ещё "обычный" список, который может быть пустым (то есь может "не быть"! Ом!) Мы с этого и начали определение.

Тогда функция, основанная на таком типе будет иметь структуру:

    def length_1(some_list):
        if some_list == []:
            return 0
        
        list_head = some_list[0]
        list_tail = some_list[1:]

        if type(some_list) is list:
            return length_1(list_head) + length_1(list_tail)
        
        return 1 + length_1(list_tail)
 
---

А если структура типа будет другой? Функция будет иметь *другую* логику. К примеру у нас есть тип подобный предыдущему, но нам не важно количество элементов во вложенных списках, и мы хотим лишь посчитать элементы на "верхнем" уровне. Не важно — является этот элемент списком или нет.

Поймите, речь идет о *логическом* определении типа.

В таком случае тип "вложенный список 2" мы будем определять как — либо пустой [], либо "вложенный список 2" связанный со "вложенным списком 2", либо как *элемент "верхнего" уровня*.

Ключевое отличие с прошлым примером в том, что тогда "вложенный список" всегда считался списком, а на этот раз он может считаться как простой элемент.

Функция:

    def length_2(some_list):
        if some_list == []:
            return 0
        
        list_head = some_list[0]
        list_tail = some_list[1:]

        if list_tail == []:
            return 1
        
        return length_2(list_head) + length_2(list_tail)

Ключевой момент тут это проверка list_tail == [], суть которого в том, что если рекурсия добралась до случая, когда хвост элемента является пустым списком мы возвращаем единицу, как бы "забивая" на то, что "проваливались" во вложенный список.

---

Эти простые примеры приводятся как пример для понимания способа которым мы должны мыслить о рекурсивных вычислениях в декларативной модели. Почему нам всегда важно понимать логику алгоритма, и учитывать структуру рекурсивного типа, с которым работаем.

Декларативная модель дает нам мощный и изящный инструмент — *минималистичность*, которым можно и нужно пользоваться при разработке алгоритмов (если это возможно). Декларативная модель удобна и исключает множество потенциальных ошибок, если мы четко определяем типы и понимаем что делаем.

### Аккумуляторы!

На этом моменте мы уже выяснили как писать рекурсивные функции, делать из них итеративные и как корректно определять и применять рекурсивные типы данных. Так а зачем тогда рекурсивные функции? *А не зачем*.

В боевой разработке с использованием декларативной модели функции *сразу пишут итеративными*! Мы разобрали эти тонкости сугубо в целях понимания и изучения.

Давайте повторим для закрепления. Вся фишка итеративных вычислений в *передаче значения* все "глубже" в рекурсию. Мы никогда не возвращаемся обратно с помощью return. 

{:refdef: style="text-align: center;"}
![Базз](/images/buzz.gif)
{: refdef}
*<center>Ну или пока память не кончится :D</center>*

Отставить шуточки! Как это работает?

Возьмем состояние, которое передаем в функцию как S. Возьмем это состояние и расширим двумя аргументами, S1 и Sn.

Такой финт называется — *аккумулятор*.

Мы берем этот аккумулятор и передаем его в **процедуру** (не функцию!). В первом посте мы говорили о том, что декларативная процедура работает в своих параметрах с указателями на ещё *не инициализированные* декларативные переменные. Иными словами, результат работы процедуры возвращается через эти параметры *по ссылке*.

В аккумуляторе: S1 является входным состоянием, а Sn — выходным, то есть результатом. Внутри такой процедуры происходит её рекурсивный вызов выполняющий последовательные преобразования Si в Si+1 (итеративные, тысяча чертей!!!)

Псевдокод:

    procedure(S, S1, Sn):
    если вычисления S не требуются:
        Sn = S1
    иначе:
        ## начинается блок рекурсивных вызовов
        procedure1(S1, S2)
        procedure2(S2, S3)
        ...
        procedureN(Sn-1, Sn)

Выход каждой procedureI является входом procedureI+1

Как уже объяснялось, отличие от рекурсивной функции в том, что нам не надо сохранять в стеке все промежуточные состояния-вызовы, так как значения передаются по ссылке. А "базовым случаем-ограничением" рекурсии, может быть указание границы обработанных элементов в исходной структуре S.

Когда мы в этом посте разбирали итеративные вычисления на примере функции iter_length:

    iter_list_length(i, some_list):
        if some_list == []:
            return 0
        
        return iter_list_length(i+1, some_list[1:])

Мы практически использовали *схему с аккумулятором*, передавая текущую длину в следующий вызов *по ссылке*.

---

Фактически в наши дни такая схема с аккумуляторами считается устаревшей, и их чрезмерное использование лишь затруднит программирование. 

Схема с аккумуляторами имеет право на жизнь, когда получается ограничиться минимальным количеством аккумуляторов (1-2). 

Тем не менее, пользу от знания таких фундаментальных приемов невозможно переоценить в контексте прокачки нашей аналитической и программистской машинки мозга.

И вот ещё повторим — хотя в итеративных вычислениях мы не проваливаемся в стек "в глубину", память потенциально может кончиться ещё как! Мы "разматываем" состояние "в ширину".

Спасибо за внимание.


    