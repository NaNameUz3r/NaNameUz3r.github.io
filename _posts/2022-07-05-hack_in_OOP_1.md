---
title: "А что есть добавить... Наследование?"
tags: "Программирование Отчеты ООП"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-07-06"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/oop1.jpg
---

Врубаемся в модель ООП. Часть 1.
<!--more--> 

# Просто добавь Наследование

Объектно-ориентированное программирование наверное не совсем корректно определять как жестко отдельную вычислительную модель. По той причине, что по сути ООП — это императивная вычислительная модель плюс *наследование*. 

Можно сказать ещё, что ООП — это *программирование с инкапсуляцией, наследованием и явным состоянием*. Работа с состояниями здесь ведется активно, в виде мутабельных переменных.

В современных языках программирование инкапсуляция, наследование и явные состояния поддерживаются абстракцией под названием *класс*. Но если разбираться то эта абстракция на самом деле не обязательна — ООП'мы можно писать почти на любом яп. 

Широкое распространение объектно-ориентированного программирования внесло два значимых вклада в программирование как таковое:

1. Стало понятно что *инкапсуляция нужна*, а программы получаются удобными и более эффективными с точки зрения продуктивности работы с ними огранизовывать в виде *коллекций абстрактных типов данных*. [Помним](/2022/06/13/hack_in_imperative_2.html), что АТД в ООП — Защищённые, stateful, запакованные. Это значит что каждый модуль или объект имеет свой ключ-секрет, известный только ему. 
2. Абстрактные типы данных оказалось важным *выстраивать постепенно*, через использование наследования для того чтобы избежать повторений кусков кода.

# Наследование

Итак, когда у нас есть АТД с реализацией описанной выше, выходит так что программу можно построить как иерархию — одни АТД, зависящие от других АТД. Это идея *компонентно ориентированного программирования*, но ООП развивает ещё чуть дальше, полагаясь на то, что *компоненты зачастую имеют много общего*. 

Разберем небольшой пример. Допустим, что в нашей программе мы хотим использовать последовательности. Но есть много способов реализации разных АТД, которые будут обладать этим свойством последовательности. В одном случае мы хотим чтобы такие АТД вели себя как очереди, в другом — как стеки, и так далее.

В каждом из этих случаев все последовательности поддерживают основное (общее) свойство — их элементы линейно-упорядочены.

Очевидно, что если каждый из этих АТД описывать отдельно, то в их описании будет дублироваться некоторая часть кода.

Это именна та проблема, которую ООП решает введением концепции наследования. Определяя один АТД как наследник других он практически имеет ту же функциональность, с потенциальной возможностью вносить в эту функциональность какие то изменения или расширять её. При этом нужно лишь указать различия между этим АТД и его родителем. 

Эта механика постепенного относительно родителя определения абстрактных типов данных называется *"класс"*.

---

Наследование — *это **техника** программирования*. И она вносит большое различие в ОПП по отношению к другим видам программирования с использованием состояния. Как уже было сказано, вычислительная модель на которой стоит ООП это всё та же stateful-модель. 

ООП по сути просто обеспечивает синтаксическую поддержку наследования через добавление концпеций классов в виде лингвистической абстракции.
{:.info} 

Сам по себе базовый компонентный подход намного проще в плане построения систем. Каждый компонент группирует в себе набор сущностей, и логически рассматривает их как одно целое с точки зрения зависимостей между ними.

Наследование же, хотя и имеет некоторые проблемы, обладает большим потенциалом. При использовании наследования каждая абстракция может быть реализована лишь один раз, и все реализации остаются независимыми. Изменения одной реализации не требует изменять другие. Обратная сторона (те самые проблемы) — это распределение реализации АТД в разных частях программы. Здесь реализация АТД может быть собрана в одном месте лишь в небольших проектах. В крупных системах же АТД, как правило, будут включать в себя через композицию или наследование другие АТД, которые моугут находиться далеко в коде. Насолим ещё — подключаемые реализации могут существовать вообще в виде только скомпилированного кода, лишая нас доступа к исходнику.

Раньше думали что наследование позволит решить проблему повторного использования кода целиком, упростит создание библиотек, которые можно будет массово распространять для переиспользования. Но это не сработало. Наследование как метод повторого использования сильно проиграло и уступило место компонентам, фреймворкам и шаблонам проектирования.

Тем не менее наследование остается полезным, но лишь в пределах *одной системы* или тесно связанного семейства программ, занимая достойное место рядом с программированием высшего порядка в качестве одной из самых важных техник структурирования программ. 

## Объекты и классы

**Объект** — это программная сущность, которая *инкапсулирует состояние*. Доступ к инкапсулированному состоянию извне может быть получен только контролируемым способом через использование методов. Методы являются доступными извне процедурами, которые имеют непосредственный доступ к состоянию внутри объекта. Инкапсулированные состояния можно изменять только через вызовы соответствующего метода, что гарантирует ситуацию когда состояние объекта всегда удовлетворительно по некоторому инварианту. 

**Класс** — это программная сущность, которая определяет *объект* постепенным способом, кусок за куском. Объект как экземпляр класса *определяется* в свою очередь "родительскими" классами, от которых он наследуется, и тем, чем он отличается от *прямых* предков. Большинство современных яп поддерживают концепцию классов как лингвистическую абстракцию через синтаксическую инструкцию class.

# Классы как полноценные АТД

Итак, зарубим себе, что **класс — есть лингвистическая абстракция** языка программирования, определяемая с помощью ключевого слова-токена class.

В идеальном случае классы в яп считаются **значениями первого класса** ([тык](/2022/02/27/hack_in_declarative_model_4.html)). Как минимум класс в коде определяется так же просто как функция. Класс содержит в себе **атрибуты** — внутренние переменные, и **методы** для работы с атрибутами. 

Работа с атрибутами, хоть по сути и представлена теми же операциями (считать значение, поменять значение) что и работа с обычными переменными, имеет **отдельный синтаксис**. 

Всё это — минимум необходимый для добавление в язык программирования объектной парадигмы. Хотя концепция класса в stateful-модели может быть реализована без расширения синтаксиса языка. В большинстве императивных языков есть такая концепция как *модуль*, который представляет из себя некоторый интерфейс из набора функций, что обращаются к "внутренним" переменным в реализации модуля. Эти переменные обычно не видны за пределами модуля.

Идем дальше. Класс — это структура данных, которая **задает** внутреннее состояние *объекта* через атрибуты, и поведение объекта через методы, а так же наследуемые классы и несколько дополнительных свойств и операций.

Универсальное определение будет звучать так:

Класс — это структура данных, которая описывает абстрактный тип данных и предоставляет его полную или частичную реализацию.
{:.info} 

На основании класса может быть создано любое количество объектов — экземпляров класса. **Отправкой сообщения объекту** называют любое обращение к объекту, например вызовы методов. Такие обращения, точно так же как и обращения к функциям — синхронны, т.е. считаются завершенными только когда метод польностью закончил свою работу.

## Члены класса

Есть три вида членов класса, из которых классы состоят:

1. Атрибуты. Это *ячейка*, которая содержит "часть" состояния экземпляра класса. Так же атрибуты ещё называют полями или переменными класса. Тип атрибута может быть любым допустимым в яп. В классической модели ООП атрибуты польностью скрыты внутри класса и никак недоступны извне, но свободно наследуются классами потомками. 
2. Методы. Это процедуры, привязанные к контексту *конкретного экземпляра класса* и имеющие доступ к атрибутам этого класса (объекта). Метод может иметь список параметров как обычная функция.
3. Свойства. Задают либо специфическое поведение *экземпляра класса*, либо специфическую характеристику *самого класса*. Например, свойством может задаваться блокировка объекта (любой метод может выполняться только одним потоком, доступ других потоков к методам этого же объекта блокируется), или запрет на расширение класса *потомками*. Специальные свойства могут допускаться и для конкретных методов или атрибутов.

## Ещё про атрибуты

Атрибуты класса кроме того делятся на способы их инициализации:

1. Атрибут может быть инициализирован через привязку к конкретному объекту. Обычено в яп это выглядит как привязка через префиксы self или this. 
2. Атрибут может быть инициализирован с привязкой к *самому классу*. В таком случае значение атрибута во всех объектах этого класса будет одинаковым. Это так называемые *статические атрибуты класса*.
3. Бренд — это некоторый набор классов, которые связаны друг с другом каким-то способом *кроме наследования*. Атрибуту бренда может быть присвоено общее для всех классов участников бренда через инициализацию одной и той же переменной класса. Пример — дружественные классы в С++.

# Методы и сообщения первого класса (порядка)

Сообщения — это *записи*, тогда как методы — паттерны выполняющие разбор этих записей. Когда объект получает сообщение, то для его обработки автоматически подбирается метод подходящий по всем параметрам.

В языке программирования Julia этот механизм реализован и называется **Multiple Dispatch**. 

Выбор соответствующего метода может происходить и в момент компиляции программы в языках со статической типизацией, и во время работы программы в языках с динамической типизацией.
У такого обработчика может быть как фиксированное так и гибкое число параметров, когда к фиксированному списку параметров добавляется "...", обозначающее заранее неизвестный список параметров произвольной длинны. 

Метод может иметь специальное свойство "otherwise", которое является флагом обозначающим, что в случае если никакой другой метод не подойдет для обработки сообщения его "перехватит" этот otherwise-метод. Этот метод имеет один параметр в который передается необработанное сообщение. Такой механизм реализует концепцию делегатов, что своего рода альтернатива наследованию и интерфейсам.

Описываемая тут концепция класса предлагает удобный синтаксис для *определения АТД с инкапсулированным состоянием и множеством операций* — классический ООП. Очень желательно в дополнении к этому синтаксису наличие поддержки "классов как значений", чтобы сохранялись все преимущества процедурных значений. Классы здесь композиционны и могут быть вложенны в другие классы, совместимы с процедурными значениями — процедуры могут быть вложенны в классы, а классы в процедуры. Беда в том, что в поплуярных языках программирования обычно такая гибкость отсутствует.

# Классы как инкрементальные АТД

ООП, благодаря наследованию, позволяет определять класс постепенно через расширение уже существующих классов. 

Недостаточно лишь отметить какие классы расширяются. Для правильного определения АТД нужно больше концепций. Разбираемая нами модель включает в себя три набора таких концепций:

1. Наследование, которое определяет какие уже сущетсвующие классы расширяются.
2. Управление доступом к методам классов — как будет организован доступ к конкретным методам в новом классе и в классах выше по иерархии.
3. Управление инкапсуляцией — определяет сопосб огранизации доступа к атрибутам и методам класса из остальной части программы (за пределами класса).

Если сюда в довесок добавить поддержку сообщений первого класса (реализуем делегатов) — получаем уникальный способ *инкрементального определения АТД*.

---

Наследование допускается как *единичное* — у класса не может быть больше одного родителя, так и *множественное*, и определяет как существующие атрибуты и методы будут доступны в новом классе.

Схема наследования применима и к атрибутам с методами! Это называется — **связь через перезапись (overriding relation)**. Метод в классе А перезаписывает любой метод с таким же именем и списком параметров определенных типов во всех находящихся выше по иерархии от класса (суперклассы А).

Иерархия классов представляет собой направленный граф с текущим узлом как корнем. Ребра направлены от нищестоящих классов к вышестоящим. Существует два требования корректности такой иерархии:

1. Отношение наследования должно быть **направленным и ациклическим**.
2. После удаления всех переопределенных методов **каждый оставшийся метод должен иметь уникальную сигнатуру** (имя и список параметров) и быть определенным только в одном классе в иерархии.


## Статическое и динамическое связывание

Когда метод выполняется "внутри" объекта зачастую приходится вызывать другой метод этого же объекта. Такой вызов можно считать *рекурсивным* относительно объекта в целом, потому что объект как бы *"вызывает" сам себя*. Если в такой ситуации допускается наследование ситуация усложняется. 

Обычное наследование подразумевает определение нового АТД, расширяющего уже существующий АТД. Для корректной реализации этой схемы потребуется два способа поддержки рекурсивных вызовов — статическое и динамическое связывание.

Из за полиморфизма на этапе компиляции может не быть возможным точно определить объект какого класса хранится в той или иной переменной. 

Динамическое связывание, когда метод связывается с конкретным классом, подразумевает, что определение нужного метода в иерархии наследования *выполняется непосредственно в момент обращения объекта к имени метода во время работы работы программы*. Этот подход не позволяет вызывать уже существующие родительские методы когда родительский АТД мы расширили новыми возможностями. 

Статическое связывание в свою очередь подразумевает что класс, в котором находится вызываемый метод, можно определить *в момент компиляции*. Например с помощью синтаксических подсказок о имени класса через приведение типов.

## Упавление инкапсуляцией

Принцип управление инкапсуляцией заключается в ограничении доступа к атрибутам и методам класса в соответствии с архитектруными требованиями системы. Каждый член класса уточняется его областью видимости.

Область видимости — это часть программного кода из (в) которой виден атрибут или метод. К ним можно получить доступ по их именам. Как правило область видимости статически определяется структурой программы. Хотя она и может определяться динамически, на практике такой подход почти никогда не применяют.

Языка программирования обычно определяют область видимости *по умолчанию* для каждого члена класса в момент определения последнего. Эта дефолтная облась видимости может быть изменена через использование специальных ключевых слов, таких как public, private и protected. Важно понимать, что разные яп используют эти слова для определения разных областей видимости.

### Универсальная схема видимости членов класса

Фундаментальные схемы видимости — private и public.

Private — член класса виден только внутри объекта.
Public — виден где угодно.
Protected — виден только внутри объекта, но так же и доступен в классах-потомках.

Хорошая схема, это когда атрибуты по умолчанию приватны, а методы — публичны.

Подход с приватными и публичными членами естественен когда классы используются для конструирования АТД.

Класс — это "инкремент". *АТД существует сам по себе*, у него свои атрибуты и методы. Класс, который конструирует АТД в программе, представляет АТД как инкрементальную модификацию *своих суперклассов*. 

Атрибуты АТД приватны — их не видно за пределами АТД, так как АТД формально задается *только своими методами*.

Методы определяют внешний интерфейс АТД, а это значит что они должны быть видны всем сущностям, которым этот АТД может быть необходим. Следственно видимость методов публична.

## Конструирование иных видимостей

Техники управления инкапсуляцией в коде программы основаны на двух концепциях: *лексической видимости* и *использовании имен*.

Приватная и публичная схемы видимости легко реализуются с помощью этих концепций. Но с их помощью можно выражать и другие, более сложные политики.

Основная техника заключается в организации такой схемы, когда **заголовки методов могут быть именами *как значениями***, а не просто жестко заданными атомами. Имя здесь — это иммутабельная константа, и единственный способ узнать его — получить ссылку на него. Из чего следует, что программа может передавать ссылку на имя контролируемым способом только в те свои области где это имя должно быть видно.

Выходит что атомы не являются безопасными, потому что если третья сторона, узнав программное представление атома-заголовка легко сможет вызвать сам метод.

Но многие современные языки поддерживают только атомы в качестве имен, и по этой причине в них добавлены эти специальные инструкции, вроде protected и private, чтобы явно ограничивать видимость.

# Альтернативы наследованию

Наследование часто бывает сложным для правильного использования и требует выского скила от программиста, потому что подразумевает тесную связь между классом-предком и его расширениями потомками. Поэтому иногда лучше использовать более свободные подходы:

1. Переадресацию
2. и Делегирование.

Оба подхода определяются на уровне объекта — в случае, если объект А не принимает сообщение Х, то оно прозрачно передаются другому объекту B.

Эти подходы отличаются в способах, которыми они обрабатывают self\this.

**При переадресации объекты А и В работают со своими собственными *оригинальными* self**.

**При делегировании есть только одна сущность А, и обращение к self внутри B *подразумевает self из А***.

Короче, делегирование как и наследование подразумавают какой то общий self, а переадресация — не подразумевает общего self.

Делегирование является мощным механизмом структурирования системы динамически через *конструирование иерархии **объектов**, а не классов*. По сути эффект получаем как у наследования, но есть два важных отличия:

- Иерархия строится между объектами, а не между классами;
- Из чего следует, что иерархия может быть изменена в любой момент работы программы.

В цепочке делегирования self всегда остается self'ом исходного объекта, из чего следует что состояние "текущего" объекта, т.е. его атрибуты — будут состоянием и исходного объекта. Получается что другие объекты в цепочке делегирования *играют роль классов* — **только их методы важны при делегировании, а не значения атрибутов**.

# Рефлексия

Система будет считаться рефлексивной, *когда она может проверять части своего состояния прямо в момент работы*. Рефлексия может быть чисто интроспективной (только читаем состояние), или интрузивной (и читаем, и можем писать). Рефлексия может выполняться как на высоком так и на низком уровне абстрации.

Пример рефлексии на высоком уровне — возможность рассматривать элементы в стеке как *замыкания*. Такой пример можно объяснить в терминах абстрактной машины.
Рефлексия на низком уровне — это способность обращаться к оперативной памяти программы напрямую, как к массиву целых чисел. Не сущетсвует простого способа вырзить такую рефлексию в абстрактной машине :)

# Мета-объектные протоколы

Благодаря крайне широкому потенциалу ООП предоставляет огромное поле для экспериментов. Наприме, система может позволять рефлексивное изучение или даже *изменение* иерархии наследования во время работы программы! Или вот ещё — можно изменять работу самих объектов на базовом уровне, например, работу наследования (то как происходит поиск методов в иерархии классов), или механизм вызова методов.

Определение того как именно объектная система будет функционировать на таких базовых уровнях называется **мета-объектным протоколом**. Эти протоколы используются в различных целях: для отладки, конфигурирования, разделения концепций (прозрачно добавить шифрование, изменить формат вызова метода и тд). 

Общая схема мета-объектных протоклов представляет собой "оборачивание" методов дополнительным кодом для перехвата каждого вызова метода, например в целях выполнения определенной операции перед этим вызовом или после его завершения, изменения аргументов вызова, и так далее. 

Первоначально мета-объектные протоколы были изобретены в рамках объектной системы Common Lisp Object System (CLOS) и остаются до сих пор бурной областью исследования ООП.


