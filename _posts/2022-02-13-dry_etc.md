---
title: "Бери и DRY, и так далее"
tags: "Программирование Инструменты Размышления"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-02-13"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/dry_etc.jpg
---

Рассматриваем пару универсальных принципов разработки.
<!--more-->

### Лучше сухо, чем мокро!

Аббревиатура принципа DRY расшифровывается как Don't repeat yourself, что недвусмысленно переводится как "Не повторяйся". Само сокращение является словом dry — сухой, и нарушение принципа окрестили как WET (мокрый) — Write everything twice (Пиши всё дважды) или We enjoy typing (Нам нравится печатать).

Разумеется уровень влажности тут вообще не при чем :)

Вероятно вы уже встречали упоминание DRY. О нем часто говорят в бесплатных и платных уроках программирования, но как правило речь только в контексте написания кода (programming-in-small). 

На самом деле этому универсальному принципу можно, и обязательно нужно, следовать на всех уровнях проектирования системы.

# Я никогда не повторяюсь 
### Неповторим внутри

Как я уже сказал, чаще всего DRY преподносят как правило, при котором мы не должны повторно использовать (копировать) код, в разные части программы. Это лишь малая доля. Фишка в том, что DRY применим к любой сущности в системе, на любом уровне абстракции.

*Если что-то где-то определено, оно должно быть определено только в этом месте.*

А что касаемо кода, то бывают случаи когда дублирование *оправдано*. Например есть две высокоуровневые функции (методы), которые производят *похожие* вычисления, но в разном контексте, и служат разным целям (всякие проверки истинности, etc).

### Неповторим снаружи

В проектировании (programming-in-large) DRY работает аналогично. Во-первых, если есть какой-то конкретный модуль, то его спецификация должна быть единообразной и находиться в одном месте. 

Это значит, что нельзя просто копировать этот модуль, немного его изменять и встраивать в систему. Тогда в будущем при доработке, в случае изменений одного такого "модуля-клона", нам придется менять то же самое и во втором. А если копий три, четыре...? Вы точно думаете что сможете вспомнить о них всех, я не говорю уже о совершенно очевидном неудобстве такой архитектуры. Это полный зашквар, не надо так делать.

Во-вторых, программные интерфейсы (api) тоже должны быть единообразными, следовать спецификации. Представьте что "внутри" модули используют по разному описанные вызовы. Внешние вызовы тоже накостыляли по другому. Чувствуете аромат? Так пахнет горящая точка опоры, когда система рухнет из за того что мы поменяли один интерфейс, или *забыли* поменять один из них, в соответствии с новыми требованиями.

Во избежание этого можно использовать, например OpenAPI, или что-то в таком духе. Если мы разрабатываем собственный API, он должен быть корректно задокументирован и доступен **в одном месте** (например в конкретном репозитории команды разработки).

## Что, и тут тоже?

Мы плавно подошли к документации. Многие разработчики не любят документировать проекты, и это **плохо**. А если и ведут документацию то относятся очень халатно. Ctrl-c, Ctrl-v, Тяп ляп, и так сойдет!

*Документация тоже должна следовать принципу DRY*. 

На уровне комментариев кода (это ведь тоже документация), пример WET-поведения — зачем-то описывать подробными комментариями чуть ли не каждую функцию в коде. Ясный код должен говорить сам за себя и быть понятен читающему его программисту (например вам самим завтра или через неделю). 

Так зачем повторяться? Разве что код выглядит запутанным и совершенно непонятным? Если так, то это отдельная проблема и нужно решать её в первую очередь.

На уровне документирования проекта — мы должны структурировать документы понятно, излагать информацию последовательно и, простите за тавтологию — *информативно*. Документация это не удобный случай поупражняться в графомании. 

На самом деле писать код и писать текст по сути одно и то же, разве нет? 

Мы можем подойти к этой задаче почти так же, как к разработке программы. Декомпозируйте её! Если вы хорошо понимаете документируемый проект то это не вызовет проблем. Каждый модуль, согласно DRY, описывается в одном разделе документации, API в другом, и так далее.

# Легко поменять

Ещё один очень важный принцип, залог, хорошего проектирования — **ETC**, или Easier to change!

Мы все люди, и нам свойственно ошибаться в своих решениях. Разумеется и в разработке программных систем. Поэтому очень важно создавая что-то новое, или внося изменения в уже существующие части, всегда задаваться вопросом — "А будет ли в будущем это *легко изменить*?"

Подумайте, будет ли легко вносить изменения в проект, в котором строго следуют "сухому закону" DRY? (Я пытаюсь шутить, извините!)

Разумеется будет!

Этому принципу осознанности ETC нужно следовать даже (особенно!) в самых малых частях разработки, вплоть до написания функции из нескольких строк кода. Будет ли она легко заменимой, исправляемой? Ясно ли она описана? 

---

Верно утверждать что принцип DRY является логическим продолжением ETC. Вообще *любой* подход хорошего проектирования исходит из ETC. Например, использование понятных имен переменных и функций непосредственно упрощает дальнейшее сопровождение кода. 

А если мы будем как можно больше компонентов делать [декларативными](/2022/02/12/hack_in_declarative_model_2.html), это поможет? Да! Архитектура будет менее запутанной, с меньшей *связностью*, и следственно более удобной в сопровождении.

Куда не глянь, если что-то сделано хорошо, это сделано осознанными в ETC инженерами!

Можно уйти в словоблудие и сказать, что оба эти принципа применимы не только как ценности проектирования программных систем, и исходят из более "фундаментальных" личностных качеств.

Но я оставлю это вам как пищу для размышления.

