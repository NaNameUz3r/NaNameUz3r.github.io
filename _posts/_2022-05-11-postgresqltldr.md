---
title: "TL;DR про PostgreSQL"
tags: "Технологии"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-05-11"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/git_and_cicd.jpg
---

Здоровенная шпоргалка по основам (и не только) СУБД PostgreSQL
<!--more--> 

Статья рассчитана на то, что читатель знает что такое СУБД и зачем она нужна, умеет хоть как то в линукс, а так же навык погуглить чтобы углубиться.

    Главный источник данных — https://postgrespro.ru/education/courses

    Документация и несколько статей, авторы которых на меня, думаю, не обидятся. В случае если у вас появится желание углубиться в DBA ушу школы слона, прежде чем хаотично гуглить — **настоятельно рекомендую** все курсы PgPro — там есть записи лекций, виртуальные машины с учебными средами и практические задания. 

Поехали.

# Базовый инструментарий.

## Установка и управление сервером

Постгресс — это opensource. И это круто. Вы можете легко собрать его из исходников с кучей разных параметров. А можете установить из готовых пакетов. Собирая из исходников советую почитать документацию (и вообще читать документацию дело хорошее), дабы разобраться во всех возможностях предоставляемых этим способом установки. Что касаемо пакетов — установка быстрая, но не такая гибкая. Дефолтная директория обитания бинарей постгресса при установке пакета может разниться от дистрибутива к дистрибутиву.

После установки нужно инициализировать кластер утилитой initdb (или используя убунтовую софтину обвязку вокруг бинарей постгресса — pg_ctlcluster). Убедитесь что у пользователя под которым работает postgresql имеет rw права на инициализируемую директорию.

Чтобы запустить сервер используем pg_ctl (если собирали из сорцов) или стартуем демона (ставили из пакета или собрали с демоном). С помощью pg_ctl можно произвести инициализацию нового кластера, остановку, перенаправление логов и другое (см. доку).

В целом, скажу вам честно — за весь мой опыт работы я ни разу не видел собранный из сорцов постгресс на прод, или не прод серверах, как правило все пользуются пакетами, и в целом понятно почему. Но хотя бы разок я вам рекомендую собрать постгресс, это в целом полезный практический опыт для любого админа.

## Использование psql

psql — это терминальный морда-клиент для работы с PostgreSQL. Если вы когда нибудь работали с оракловым sql*plus то вас ждёт масса приятных ощущений, ибо psql — сделан людьми для людей. Psql позволяет интерактивно отправлять запросы или метакоманды администрирования, передавать их в виде скриптов или прямо в аргументе (ключ -c) при подключении. Внутри есть куча шорткатов по обраному слешу, и... автодополнение не только метакоманд, но имен табличек (как правило автодополнение будет у вас из коробки, если ставили пакет, можно накрутить самому собирая из сорцов).

## Конфигурирование

Основной способ установки параметров в главном конфиг файле — postgresql.conf.

В дополенение к нему есть ещё один — postgresql.auto.conf. Если первый файл конфигурируется вручную, то второй изменяется автоматически когда мы задаем параметры используя ALTER SYSTEM. Автоконф считывается после «главного» конфиг файла, следовательно параметры в автоконфе переопределяют те, что указаны в первом.

Помимо ALTER SYSTEM есть ещё ALTER DATABASE и ALTER ROLE, это так, для затравки:

- Первая позволяет переопределить глобальные параметры на уровне базы данных;
- Вторая — для конкретного пользователя как глобальные, так и локальные параметры бд.

Изнутри psql можно посмотреть значение любого параметра командой SHOW. Командой SET можно изменить параметры на уровне сеанса.

Конечно вам никто не мешает руками править автоконф, но не надо так делать, пожалуйста. Хорошим тоном будет удалять из автоконфа что-то, а не дописывать руками, и держать все *основные* параметры в основном конфигурационном файле кластера.

Кстати, посмотреть с какими параметрами запущен кластер можно в psql, подключишись под суперпользователем жмите — SHOW <Имя параметра> \gx.

\gx в конце вместо ; служит для более читабельного, расширенного вывода. Пользутейсь на здоровье!

А ещё есть такая системная таблица pg_settings, обязательно погуглите :)

# Архитектура

## Общее устройство PostgreSQL

    **Клиент-сервер** вам о чём нибудь говорит? Если нет, то сначала перечитайте шапку, а потом гугол. 

#### Транзакция #### 

Это некоторая логически неделимая часть работы с данными в базе, сохраняющая *согласованность* данных.

От транзакций ожидают выполнения четырех свойств (ACID):

- atomicity — транзакция либо выполняется полностью, либо не выполняется вообще. Для этого начало транзакции отмечается командой BEGIN, а конец — либо COMMIT (фиксация изменений), либо
ROLLBACK (отмена изменений).
- consistency — транзакция начинается в согласованном состоянии и, завершаясь, также сохраняет согласованность.
- isolation — другие транзакции, выполняющиеся одновременно с данной, не должны оказывать на нее влияние.
- durability: после того, как данные зафиксированы, они не должны потеряться даже в случае сбоя.

Что вообще такое согласованность данных? Было бы славно, если бы с базой работал в один момент времени только один клиент, а все остальные ждали в очереди. Ну, к нашему счастью СУБД работают не так. Пусть блокировки и существуют (об этом дальше), одновременно с данными в базе практически всегда работает много "клинтов", и вышеперечисленные "кислотные" требования к транзакциям мы применяем потому что хотим чтобы данные в базе были истинными, "история" изменений поддерживалась правильным образом, и никто никому не мешал. Как это устроенно... Ну, довольно сложно. Разбираемся дальше!

#### Выполнение запроса. 

Запрос передается от клиента серверу в виде текста. Текст парсится в базе — выполняется синтаксический разбор (складываются ли буквы в слова, а слова в команды) и семантический разбор (есть ли в базе данных таблицы и другие объекты, на которые запрос ссылается по имени). Метаданные с которыми сравниваются результаты парсинга хранятся в системном каталоге в самой же бд.

Успешно разобранный запрос передается планировщику, который *разрабатывает* план выполнения. Например он «решает» надо ли использовать индексы. Для нормальноый работы планировщику нужна статистика размера таблиц и распределения данных.

Если один и тот же запрос (с точностью до параметров) выполняется несколько раз то PostgreSQL позволяет подготовить запрос (на деле лишь его оператор) командой PREPARE — что позволяет нам заранее распарсить такой "запрос" и записать в кеш базы его синтаксическое дерево. Подготовленный оператор можно потом дергать EXECUTE'ом, которому можно передавать парметры в аргументах. При каждом EXECUTE по подготовленному оператору будет планироваться фактический запрос (с переданными параметрами) и соответственно выполняться.

Там где то дальше будет ещё по этой теме.

## Изоляция и многоверсионность (коротко)

Это о том чтобы транзакции могли работать в системе одновременно, не получалось каши, данные оставались *консистентными* и всё было в порядке. Как постгресс обеспечивает такую параллельную работу? Благодаря многоверсионности. СУБД хранит **разные версии строк**, которые *нужны* каким-то транзакциям. 

Есть ещё такое понятие — снимок данных (по нашему - снапшот). Это согласованный срез состояния данных на определенный момент времени. 

Снапшот определяется номером транзакции который фиксирует начальный момент времени этого среза. 

Кроме номера транзакции, снапшот содержит в себе *список активных транзакций* на момент снятия снимка (срез). Этот список нужен для того, чтобы *рассматривать изменения **только** тех транзакций, которые были **закомичены до** создания снимка*. 

Таким образом в «зону видимости» не попадают изменения от транзакций которые начались **ДО среза, но ещё не закоммитились**, и все остальное транзакции — те что появились после снятия этой точки во времени.


{:refdef: style="text-align: center;"}
![Взрыв Мозга](/images/mind_blowing.gif)
{: refdef}
<center>А вы думали что ваш select olol from trololo это пальцем в носу ковыряться, да? ( ͡° ͜ʖ ͡°) </center>

Параллельная работа транзакций обеспечивается блокировками, а так же есть разные уровни изоляции. Более подробно эта тема будет рассмотрена далее.

Ну вообще ниче сложного тут тащемта нет, атомарность довольно фундаментальная программно-инженерная техника для борьбы с race condition'ами. Я немного писал об этом, например [здесь](/2022/01/30/hack_in_codding_1.html) 


## Базы данных и схемы.

Когда мы инициализируем новый кластер создаются три базы данных. Две из них — это темплейты.

Ах да, я же совсем забыл вам сказать про этот жаргон слоновый. В общем у постгрессологов кластером называется *экземпляр* запущенной СУБД Постгресс, а не отказоустойчивый "кластер" с репликацией и вот этим вот всем. Ортодоксальные админы строго придерживаются этого термина, но часто забывают его разьяснить :)
Так вот, а *базой данных* называют собственно базу которую мы можем создать внутри кластера CREATE DATABASE и вот это вот всё. Теперь понятно почему кластер? Кластер баз данных, едрить его!

Так вот, дефолтные темплейт базы:

- template1 — дефолтно используется для создания новых бд. Можно в этот шаблон установить какие то расширения, чтобы в новых базах они появлялись сразу при создании.
- template0 — этот темплейт не нужно (правда, не надо!) изменять. Всегда хорошо иметь девственно чистый шаблон, на случай если мы загадили template1, или раскатываемся из бекапа. Впрочем по умолчанию его изменить (скорее всего) не получится, там есть флаг защиты от дурочка, который смелый дурачок может всегда снять :)
- Третья дефолтная база это — postgres. Она используется по умолчанию для подключения пользователя postgres. Эта база не обязательная, но не рекомендуется её сносить, так как много утилит предполагает её наличие.

Если надо, можно создавать свои кастомные базы-шаблоны и использовать для дальнешего выпекания из них других баз.

#### Схема

Это пространство имен для логической организации объектов в базе. Схема и пользователь это разные сущности, вам тут не оракл, ясно?

Путь поиска (search path) — это последовательность схем (можно настраиваеть) в которой бд пытается найти объекты из запроса. Помните там было про семантический парсинг? Вот если в search path не будет схем, в которых предполагается активность, то ничего у вас не распарсится. За исключением случая когда  вы будете писать *полные* имена обьектов через точку — <имя схемы>.<ваша чудесная таблицйа>.

Дефолтная схема — public. Если ~~мы ленивая свинья которая ничего не понимает в реляционной модели и правильной организации данных~~ ничего не менять в дефолтной конфигруации все объекты будут создаваться в этом самом паблике. 

Схема совпадающая с именем пользователя по умолчанию включена в путь поиска, *но не существует*. Если создать такую схему то объекты, создаваемые пользователем будут помещаться в неё, а не в паблик.

Есть специальные схемы, например pg_catalog. Не сложно догадаться что она служит пространством для объектов этого самого каталога. Метаданные и тд, ну вы поняли.

Схемы типа pg_temp_N автоматически создаются для временных таблиц. Если pg_temp **нет в пути поиска** — автоматически такие схемы подразумеваются самыми первыми в пути поиска. А нафига? В общем и вкратце — временные таблицы создаются во время обработки всяких тяжелых запросов, например с кучей сортировок (другие мы писать не умеем, правда?). Если в work_mem буферы вся эта история не влезает, то постгресс временно создает таблицы для хранения результатов сортировки, чтобы потом вернуть итоговый выхлоп запроса. Собственно поэтому автоматически эти схемы и подразумеваются в начале пути поиска. 

По окончанию сеанса который требовал создания временных объектов — они дропаются, а сама временная схема сохраняется для использования в других сеансах.

## Системный каталог

Это такая хранилка — набор таблиц и представлений (вьюшки, view. гугли юный падаван, говорю же КРАТКАЯ шпора ( ͡° ͜ʖ ͡°)  содержащих в себе описание всех объектов СУБД, а так же метаданные кластера. 

Живет в уже упомянутой схеме pg_catalog. Есть ещё одна "системная" схема (привет от стандарда SQL) — information_schema. 

В psql предоставлен набор команд-алиасов (шорткаты, короче) для удобной работы с системным каталогом. Начинаются с обратного слеша, например: \l, \du, \dt и другие. 

    Все таблицы и представления из системного каталога начинаются с префикса pg.

Есть специальный тип данных — **OID** (object identifier), который используется как primary key в таблицах системного каталога.

Есть другие специальные reg-типы, которые на деле лишь абстрактные типы над OID, используются в некоторых таблицах системного каталога и позволяют переводить текстовое имя объекта в OID и обратно.

## Табличные пространства

Служат для организации **физического** хранения данных. 

При инициализации нового кластера создаётся два табличных пространства — pg_default и pg_global. Одно пространство может использоваться разными базами данных в кластере, и каждая база, в свою очередь, может хранить данные в разных пространствах.

В pg_global хранятся объекты системного каталога (общие для всего кластера).

По сути — табличное пространство в PostgreSQL это просто симлинка на каталог в котором хранятся датафайлы. Симлинки хранятся в $PGDATA/pg_tblspc/.

## Низкий уровень организации данных

Опускаемся под землю. Если вы всё ещё читаете это — вы стойкий малый и кланяюсь вам, о красноглазый собрат! Тут интересный, прелый воздух, в этих пещерах! Вперед!

Каждому объкту в базах данных PostgreSQL, хранящему данные (таблицы, индексы, последовательности, материализованные представления), соответствуют несколько слоев (forks). 

    Каждый слой содержит определённый вид данных.

Вначале слой содержит один-единственный файл. Имя файла состоит из числового идентификатора, к которому может быть добавлено окончание, соответсвующее имени слоя. Такой датафайл постопернно растет, и когда его размер доходит до 1 Гб, создается следующий файл *того же слоя*. Называются сегменты. Порядковый номер сегмента добавляется в конец имени файла. Ну, короче, прелый воздух, говорю же.

    Ограничение в 1ГБ возникло в целях поддержки различных файловых систем, некоторые из которых не умеют работать с файлами большого размера. Вот так вот.

Файлы в свою очередь разделены на страницы (то что датаблоки у нас называется). 

*Независимо* от того, к какому слою принадлежат файлы, они используются буферным менеджером примерно одинаково. Страницы сначала считываются с диска в буферный, а там с ними уже работают бэкенд процессы PostgreSQL, после чего страницы обратно на диск, когда чекпоинт там, тырым пырым. 

    И про буфер, и про чекпоинт дальше есть!

#### Типы слоев.

- Основной слой — это собственно данные: сюда складываются версии строк таблиц или строки индексов. Существует слой для всех объектов.
- Слой fsm (free space map) — карта свободного пространства, на которой отмечается наличие пустого места внутри страниц. Используется при insert'ах новых версий строк, чтобы быстро найти подходящую страницу, в которую влезут добавляемые данные. Если таких страниц нет, ну, выделяем новые.
- Слой vm (visibility map) — битовая карта видимости. Вот это очень интересная штука! Тут отмечаются те страницы, *которые содержат только актуальные версии строк, видимые во всех снапшотах*! На этом же слое маркируются страницы, которые давно не изменялись и успели полностью очиститься от неактуальных версий строк. Карта видимости применяется для оптимизации очистики и ускорения работы индексов.

    Начиная с 9.6 в этом же слое хранится карта заморозки.

Воу воу, полегче. А что за карта заморозки? Про очистку и заморозку читай дальше! Имейте терпение в конце концов!

## Буфера буферочки, кэш

Размер кэша задаётся параметром shared_buffers. Каждый буфер состоит из хэдера и пространства размером под один датаблок-страницу (8 кб).

Что записывается в хэдер:
- адрес страницы на диске (датафайл и номер страницы);
- счётчик обращений к буферу (инкрементируется при каждом обращении);
- признак dirty buffer;

Разберемся совсем вкратце как работает кеш: 

Когда процессу нужна страница, сперва он пытается найти её в кэше обращаясь к специальной хэш-таблице, в которой в качестве ключа хэш-функции служит файл и номер страницы. Если происходит cache hit (страница уже есть в кеше) — процесс вешает защелку на эту страницу в буфере (pinned buffer) и работает с ней. Если страницы в буфере нет, то PostgreSQL считывает её с диска (cache miss).

    Если список свободных буферов не пуст (есть место в буфере), то страница записывается в один из буферов этого "свободного списка" (по сути в область памяти по указателю на свободный буфер. Ну а сам "свободный список" есть список укзателей, но это вы итак уже поняли).

Есть ещё один "внешний" указатель — "указатель свободного буфера". Если "свободный список" не пуст, то всегда этот самый указатель доступен для того чтобы не нужно было снова и снова линейно бегать по списку буферов. Прикиньте! Линейно! O(n) блин! В общем оптимизицая простая и гениальная.

Если свободный буфер есть — хватаем память по указателю на элемент списка указателей на свободную память в буфере :D ыыы. Если в "свободном списке" остались элементы "внешний" указатель перемешается на следующий такой элемент. А ссылка-указатель на загруженную в буферный кеш страницу из диска записывается в упомянутую выше хэш-табличку буферного кеша. 

Так, ну понятно. А что если нет свободного места в кеше? Напали на проблемку. Рассмотрим её решение.
Начнем с того, что если места нет, надо что то вытеснить из буфера! Определять что надо вытеснять постгресс будет благодаря работе алгоритма **clock-sweep**.

Суть клоксивапа проста — все буферы в кеше последовательно перебираются в цикле, и счетчик обращений (тот что в хедере, помните?) уменьшается на 1. Когда алгоритм встречает счетчик с нулевым значением, происходит проверка "закрепленности" буфера (pinned buffer или не pinned?). Если не pinned, значит никакая тарнзакция с этим буфером сейчас не работает. И счетчик нулевой, потому что давно никто не обращался к этой страничке. Значит нечего её больше делать в оперативной памяти. Если этот буфер **грязный** (dirty, какие то данные были изменены) — он записывается на диск. Но не сразу в датафайлы, конечно же... А в wal журнал. Про валы поговорим чуть дальше.

Есть ещё один нюанс. PostgreSQL работает с диском через интерфейсы операционной системы, поэтому на деле, как правило, происходит **двойное кэширование**. Так что cache-miss не всегда привоит к чтению с диска, так как вполне возможна такая ситуация что странички остались ещё кеше файловой системы, и в кеш постгресса будут выдернуты обратно оттуда. 

## WAL журналы

За этой аббревиатурой, как говорится, стоит "Write ahead log" — классический метод обеспечения согласованности данных, а именно — возможности восстановления этоё самой согласованности в случае сбоя, при котором теряется содержимое оперативки. 

Что пишется в WAL'ы:

- изменения страниц в кэше (грязные буферы, когда до них добрался клок-свип например);
- commit'ы и rollback'и транзакций;
- операции с файлами и каталогами (создание, удаление).

WAL журналы на диск пишет процесс — WAL writer. Я не знаю зачем вам эта информация, правда. Но может быть когда то в htop'е его увидите :)

Короче, по сути WAL это тупо *последовательный* лог изменений данных.

Для идентификации каждой записи в WAL'ах используется значение  специального типа данных pg_lsn (LSN — log sequence number) — 64 битное число, обозначающее смещение до конкретной записи от начала конкретного журнала.

Физически журналы хранятся в $PGDATA/pg_wal. Каждый файл имеет размер 16 Мб. В оперативной памяти для журналов есть **свой** буферный кэш, размер которого задаётся параметром wal_buffers. По умолчанию выделяется 1/32 часть буферного кэша. Кэш устроен по типу буферного кольца (добавляем в голову — пишем на диск с хвоста).

В случае сбоя при следующем старте кластера происходит накатка с контрольной точки (чекпоинта) изменений из WAL логов. Ну, "катятся" они по сути в заного сформированный на рестарте буфер.

## Контрольная точка — CHECKPOINT.

Фоновый процесс checkpointer периодически сбрасывает все грязные буферы на диск, *но не вытесняет их из кэша*. После завершения записи в датафайлы фиксируется чекпоинт, и все WAL's, что были записанны до совершения чекпоинта становятся **не нужны** для восстановления. В общем идея проста. Чекпоинт операция трудоемкая, мы не можем его делать очень часто. Но мы если база грохнется между чекпоинтами, нам **очень не хочется** потерять данные — поэтому и пишем WAL'ы, и поэтому же удаляем их, когда очередной чекпоинт произошел успешно.

Буферный кэш может быть очень большим, поэтому в целях оптимизации в процессе чекпоинта сбрасывается не все сразу. Предварительно грязные буферы помечаются флагами, и после постепенно записываются на диск. Процесс checkpointer создает очередной wal журнал по окончанию своей работы в котором, собственно есть инфа о последнем чекпоинте, и дополнительно пишет указатель на этот WAL в специальный файл $PGDATA/global/pg_control.

При запуске после сбоя процесс startup видит отличный статус от "shut down" в файле pg_control и инициирует восстановление с последней контрольной точки. После завершения восстановления фиксируется новый чекпоинт. Справедливости ради, когда мы в нормальном режиме складываем базу, по сути происходит тот же чекпоинт, но в pg_control записывается shut down, вместо указателя на wal.

Частота записи контрольных точек определяется параметром checkpoint_timeout.

В дополнение к checkpointer есть процесс фоновой записи — background writer, который гуляет по буферу и записывает на диск грязные не закрепленные буферы с нулевым usage счетчиком. Служит как дополнительная оптимизация чекпоинтера, чтобы последнему нужно было поменьше писать на диск.

# Управление доступом.

## Роли и атрибуты.

Роль — пользователь СУБД. Может включать в себя другие роли (быть групповой ролью). Определяется на уровне кластера.

    Псевдороль public неявно включает в себя все остальные роли. 

Атрибуты — определяют особенности роли, её свойства и права (не связанные с правами доступа к объектам).

## Привилегии.

Определяют права доступа роли к объектам БД. Большинство привелегий определено для таблиц, некоторые из них можно определить на уровне столбцов.

В целом доступ роли к объекту определяется привилегиями. Можно выделить три категории ролей:

1. Суперпользователи могут делать все, godmode — для них проверки разграничения доступа не выполняются.
2. Владелец объекта сразу получает полный набор привилегий для своих объектjd. В принципе, эти привилегии можно отозвать, но владелец объекта обладает обладает неотъемлимыми правами, например он может выдавать другим ролям привелегии на свои обьекты, или отзывать их. В том числе себе и у себя :)
3. Все остальные роли имеют доступ к объекту только в рамках выданных им привилегий.

При выдаче ролям привелигий можно передавать параметр WITH GRANT OPTION, позволяя этой роли передавать эту конкретную привелегию дальше дургим ролям.

Роль может получать привилегии на доступы к объектам не только напрямую но и от групповых ролей, в которые она входит (атрибут INHERIT). Это касается псевдороли public, в которую неявно входят все роли.


По умолчанию "роль" public получает ряд привилегий (то есть, их наследуют все остальные роли):

- подключение и создание временных таблиц для всех баз данных;
- использование схемы public и создание в ней объектов;
- использование схем pg_catalog и information_schema;
- выполнение всех функций.

    Не выдывайте public роль бездумно, даже если вам так советуют на стакофервлоу. Особенно если вам так советуют на стаковерфлоу!

Привелегии по умолчанию определяются с помощью ALTER DEFAULT PRIVILEGES.

