---
title: "Продолжаем исследовать Императивную модель"
tags: "Программирование Отчеты Императивная_модель"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-06-13"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/imper2.jpg
---

Врубаемся в Императивную модель. Часть 2.
<!--more--> 
[Читать предыдущую часть.](/2022/06/06/hack_in_imperative_1.html)


# Компонентно ориентированное программирование

Характеристики абстракции, которые мы разбирали в прошлой части, определяют собой *Компонентно ориентированное программирование*.

Компонент следует понимать как определение части программной системы изнутри и снаружи, иными словами — четкое определение *интерфейса* 
той части.

Внутренняя составляющая компонента скрыта (инкапсуляция), изнутри доступно только то что определено интерфейсом.

Благодаря композиционности из компоненты могут составляться другие, новые компоненты. Это естественный способ расширения возможностей одного компонента. Для реализации компонента с новым требуемым функционалом мы можем использовать уже существующий компонент или компоненты, которые уже реализует в себе некоторую часть (в существенной степени) этого нового функционала.

Инстанциирование компонентов позволяет создавать их новые экземпляры, которые моментально включаются в рантайм.

На самом деле компонент это ещё одна фундаментальная программистская концепция, признаки которой можно обнаружить во многих, если не во всех, программных концепциях и техниках:

- **Процедурная абстракция** — это компонент! Почему? Потому что это определение функции с параметрами, а экземпляр, то есть инстанциирование процедурной абстракции — это вызов определенной функции с аргументами;
- **Функтор** (разбирали [здесь](/2022/03/20/program-design.html)) — это исходный код программного модуля, который компилируется в сам модуль независимо от других компонентов;
- **Параллельные компоненты** — программная система состоящая из независимых и взаимодействующих с друг другом элементов может быть представлена нами как граф из одновременно работающих *компонентов*, которые общаются посредством обмена сообщениями.

# ООП

Объектно-ориентированное программирование это по сути компонентно ориентированное, только с добавлением ещё одной концепции\механики — **наследования**.

Наследование — это такой способ конструирования программной системы, в котором реализация нового функционала основывается на уже существующей.
Такие постепенно развивающиеся компоненты называются *классами*, а экземпляры классов — *объектами*.

Возможность повторно использовать код в ООП сильно снижает дублирование кода и его избыточность в системе в целом, это большой и сильный плюс.
Но как известно:

{:refdef: style="text-align: center;"}
![Базз](/images/resplonsibiliy.webp)
{: refdef}
*<center>Прислушайтесь к дяде Бену!</center>*

Почему так? Кажется что возможность каскадно переиспользовать код очень круто, добавляет возможность гибко, практически как угодно жонглировать компонентами и внедрять их друг в друга! Здорово же, да? 

На самом деле нет, не очень. Компоненты начинают очень сильно зависеть от компонентов, которые они наследуют. В результате система становится все менее "модульной" и всё более *связанной*. Такими зависимостями становится очень сложно управлять. 

Несмотря на то что большая литературы и учебников по объектно-ориентированному проектированию сфокусированы на правильном использовании наследования, стоит прислушаться к светлым и опытным инсайдерским умам, которые рекомендуют по возможности **использовать композицию а не наследование.** Пусть композиция и менее гибкий подход, тем не менее она проще в использовании. А наследование нужно применять только тогда, когда композиции недостаточно.

Если поступать таким образом, то иерархии в системе будут получаться намного менее глубокими, чем при использовании исключительно наследования. И как следствие, система будет менее связанной и запутанной.

# Декларативная модель с явным состоянием

*Явно состояние* — это пара из двух сущностей ЯП:
1. Идентичность (identity) — способ именования состояния в программе.
2. Текущее содержание состояния — это собственно значение, с которым связано имя состояния.

Сюда добавляется ещё операция, которая позволят посредством идентичности состояния получить текущее содержание.

## Ячейка

Мы уже говорили про ячейки в прошлый раз. Ячейка — это явное состояние, и *базовый тип* который мы добавляем в вычислительную модель.

Ячейка состоит из неизменяемого (постоянного) имени и ссылки на объект в хранилище однократных присваиваний.

Напоминаю где можно вспомнить про внутрнее устройство декларативной модели -> [тут](/2022/02/06/hack_in_declarative_model.html).
А если вы до сих пор не понимаете почему мы так много говорим в этом цикле о декларативной модели, хотя сабжем вроде как является императивная — рекомендую сперва прочитать весь цикл отчетов по изучению декларативной модели (начиная со ссылки выше, там будут кросссылки на следующие посты).
{:.info}

Благодаря тому что имя ячейки не допускается изменять все они (ячейки) фактически получаются чистыми абстрактными типами данных. Множество же самих ячеек хранится в некотором мутабельном (изменяемом) хранилище.

В результате вычислительная модель состоит из неизменяемого хранилища однократных присваиваний, которое содержит в себе dataflow-переменные (это такие переменные которые могуть быть связаны только с одним значением), и из второго — изменяемого хранилища, в котором хранятся пары из имен и ссылок (ячейки). 

В такой модели существует элементарный язык программирования, который расширяет базовую декларативную модель двумя операциями, которые условно назовем NewCell и Exchange.

У NewCell есть два параметра. Эта операция создает новую ячейку с именем из первого параметра, и с содержимым (ссылкой) во втором:

    NewCell C X

Операция Exchange уже имеет три параметра:

    Exchange C X Y

Эта операция связывает X с прежним содержимым ячейки С, и задает этой ячейке новое содержимое, передаваемое в Y.

Для обеспечения большей выразительности в такую модель добавляются ещё две инструкции:

- Операция @ предоставляет доступ к содержимому ячейки С:

    X = @C

- Операция := присваивает ячейке C новое значение из Y, и *возвращает значение ячейки X*:

    C := Y

Прикол в том, что добавление такой ячейки с лишь двумя операциями хватает чтобы построить **все** концепции, которые может предоставить понятие *состояния*.

Все сложные концепции абстрактных типов данных можно построить с помощью декларативной модели дополненной ячейками.
{:.info}

# Связь с декларативным программированием

Строго говоря, "императивная" stateful-программа не может считаться декларативной. Потому что её выполнение несколько раз с одними и теми же входными данными может давайть разные результаты, в зависимости от внутреннего состояния. 

Однако, stateful-программы можно писать таким образом, чтобы они *удовлетворяли определению декларативной операции*. Чтобы они **вели себя декларативно**.

Мы разбирали пару декларативных функций [здесь](hack_in_declarative_model_6.html)

Любую из них можно взять и переписать в императивном "стиле", изменив внутреннюю декларативную рекурсивную реализацию например на простой перебор циклом, который будет записывать в результирущий список каждый подходящий по функции-предикату элемент. Результирующий список это явное состояние (локальная переменная) внутри реализации вычислений. 

Таким образом интерфейс самой функции оберки filter остается неизменным, и её пользователю вообще неизвестно какая там внутри реализация, а сам filter ведет себя всё ещё декларативно.

## Мемоизация

Ещё одна полезная техника в разрезе декларативной модели с использованием состояний — *мемоизация*. Это такой финт, когда функция запоминает результаты её предыдущих вызовов (например очень тяжелых вычислений), что позволяет при повторных вызовах такой функции использовать эти результаты сразу же. В такой функции внутри состояние реализуется в замыкании, но внешне ей поведение формально остается декларативным.

# Sharing состояний

Один из важных нюансов, который нужно строго формализировать при работе с состояниями это понятие *равенства ячеек*.

Нужно понять, можно ли считать что две ячейки равны, когда равно их *содержание*, или если два идентификатора (X и Y) ссылаются на одну и ту же ячейку? 

Такие случаи "равенств" называют sharing или aliasing, что по сути является совместным использованием некоторого содержания ячейками, которые являются *алиасами*. 

Когда мы изменим содержимое ячейки X это автоматически приводит и к изменению содержимого ячейки Y, ведь физически *их содержимое одно и то же*.

В ООП это называется *передача объектов по ссылке*.

Формальное понимание программы, в которой есть много алиасов у ячейки заметно усложняется. Эта проблема решается с помощью *инкапсуляции состояния* следующим образом: 

Вся логика работы с состоянием выделяется в отдельную и четко определенную часть программы, которая гарантирует что состояние оттуда не сможет выбраться. Поэтому абстрактные типы данных идеальный способ для использования явных состояний, потому что они инкапсулируются в АТД, скрываясь за набором определенных высокоуровневых операций.
{:.info}

# АТД и способы их организации

В [последнем посте](hack_in_declarative_model_6.html) из цикла изучения Декларативной модели мы уже знакомились с АТД и способами их защиты. Сейчас пришла пора добавить к этой джедайской технике понятие состояния.

Абстрактные типы данных с одной и той же функциональностью могут быть по разному реализованы внутри. В эволюции АТД есть ещё две "перпендикулярных оси" — *состояние* и *бандлинг*. Вметсе с защищенностью эти три аспекта составляют восемь способов организации АТД, а зависимости от применения или не применения каждого из них. 

Давайте рассмотрим эту тему чуть более подробно.

## Открытость и защищённость

*Открытый абстрактный тип данных* — это АТД, внутренее представление которого видно везе в программе. Реализация такого типа может быть размазана по коду, а разные его части расширяться независимо друг от друга. Такая реализация может быть полезна разве что в небольших проектах, когда выразительность важнее чем безопасность. Только не используйте это как оправдание лени писать безопасный код.

*Защищенный абстрактный тип данных* — это АТД реализация которого недоступна остальным частям программы, и его реализация сосредоточена в одном модуле. Как я уже упоминал, способ защиты АТД мы рассматривали в последнем посте о Декларативной модели. 

АТД может быть "частично безопасным", когда права на чтение внутренней реализации выдаются другим частям программы некоторым контролируемым образом (wrap, unwrap).

## Состояние в АТД

**Stateless-АТД** создаются в рамках декларативной вычислительной модели. Нужно создавать новые экземпляры АТД, так как модифицировать их запрещено. Такой подход приводит к увеличению количества экземпляров АТД в программе, из за чего ими может становиться трудно управлять. Сам код программы становится менее модульным, потому что мы помним — это *декларативная модель*, и как следствие экхемпляры должны передаваться по конвейеру вычислений даже через части программы, которые в этом АТД не нуждаются.

**Statefull-АТД**, очевидно, использует внутри себя явные состояния. А значит его экземпляры могут изменяться во времени. В такой реализации нельзя быть уверенным какое значение инкапсулировано внутри экземпляра АТД, не обладая полной историей вызовов процедур с момента создания экземпляра. Здесь так же существует только один экземпляр, в отличие от декларативных АТД. Кроме того, зачастую этот экземпляр вообще не надо передавать внутрь функции как параметр, потому что доступ к нему может быть организован через лексическое замыкание.

Этот подход позволяет сделать программу более выразительной и лаконичной, а так же, возможно, более модульной, потому что нам не нужно "связывать" экземляр АТД с частями системы которым он не нужен.

## Бандлинг

Бандлинг (запаковка) — это когда данные хранятся *вместе с операциями*. 

**Распакованный АТД** — это АТД, у которого можно отделить данные от операций. При этом распакованный АТД *может быть безопасным*. Достигается это путем создания каждого экземпляра АТД вместе с некоторым "ключем", который представляет собой разрешение на доступ к внутренним данным экземпляра, и на измнение, если АТД обладает состоянием. Все операции такого АТД "знают" ключ, в отличе от остальной части программы. Как правило ключ — это неизменяемая константа.

---

В реальном мире из восьми комбинаций вышеупомянутых аспектов АТД используются эти варианты:

- "Открытый, декларативный, распакованный" — Такой подход реализуется в языке Prolog, и некоторых других.
- "Защищенный, декларативный, запакованный" — Добавляются абстракции для реализации декларативного стиля.
- "Защищенный, декларативный, распакованный" — Объектно-ориентированное расширение декларативного стиля.
- "Защищенный, stateful, запакованный" — Это классичское объектно ориентированное программирование, например Java.
- "Защищенный, stateful, распакованный" — "Распакованный" ООП.

Эти комбинации перечислены в порядке усложнения их реализации.

Пример первого пункта рассматривался в последнем посте о декларативной модели (реализация стека).


---

На сегодня всё. Пожалуйста не забывайте отдыхать!
[Читать продолжение](/2022/06/26/hack_in_imperative_3.html)









