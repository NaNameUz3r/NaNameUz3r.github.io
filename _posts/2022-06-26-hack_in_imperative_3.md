---
title: "Передача параметров, коллекции и инварианты"
tags: "Программирование Отчеты Императивная_модель"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-06-26"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/imper3.jpg
---

Врубаемся в Императивную модель. Часть 3.
<!--more--> 
[Читать предыдущую часть.](/2022/06/06/hack_in_imperative_2.html)


Сегодня продолжим ровно с того момента на котором остановились. А остановились мы комбинациях аспектов АТД. 

### Защищённый, декларативный, распакованный

Защищенный декларативный распакованный АТД, и собственно сам способ его *защиты* мы разбирали в заключительной части постов про Декларативную модель. Идея там заключалась в истользовании функций оберки и развертки (wrap/unwrap) с ключем, который знают только "авторизованные" нами части программы.

Если взять АТД стек, то все его методы по сути работают через эти функции. Метод создания нового стека автоматически будет возвращать "заврапленный" стек, проверка верхнего элемента в стеке и стека на пустотность обладают нужным ключем и внутри автоматически выполняют unwrap. Ну и заталкивание с выталкиванием элементов тоже модифицируют результирующий стек сначала Unwrap'нув внутренности, и за'Wrap'ив новый список (стек). Мы помним что это декларативная модель, и по этому по сути после каждой такой операции мы получаем новую сущность.

### Защищённый, декларативный, запакованный

Напоминаю что *запакованный* АТД, это такой у которого данные хранятся вместе с операциями над ними.

Реализовать это в рамках декларативной модели можно *спрятав стек внутри самих операций* через лексическое замыкание. В таком случае стек от операций просто нельзя никак отделить. В таком случае синтаксис становится похожим на знакомый ООП:

    stack_1 = create_stack()
    stack_1.is_empty()
    stack_2 = stack_1.pop_out(X)

И так далее. Каждый метод возвращает новый стек не изменяя текущий. Wrap/Unwrap тут не нужны, потому что реализация *запакована* — результатом мы получаем "объект", а не какой-то определенный стек, внутрь которого никак нельзя заглянуть. 

Декларативной модели придерживаемся? Да. 
Явное состояние для безопасности подобного АТД нужно? Нет, не нужно! Нам хватает техники программирования высшего порядка.

### Защищенные stateful реализации 

Запакованный вариант это по сути классическое ООП c АТД. У нас есть объект в котором во внутреннем поле содержится структура данных, например опять связанный список, если мы продолжаем в качестве примера использовать стек. Это внутреннее поле инкапсулировано, а у объекта есть методы для доступа и изменения этого поля. 

Распакованный вариант редко применяется в ООП и ФП. Такой вариант не требует программирования высшего порядка. Здесь все операции АТД требуют в качестве одного параметра стек. Они не создают новых объектов и работают (модицируют) только с этим аргументом. Wrap тут используется при создании нового стека, а все остальные операции получают доступ к внутренностям через Unwrap. 

# Передача параметров

Разобравшись с понятием явного состояния теперь нам нужно уделить внимание способам передачи параметров. 

## Call by reference

Передача по ссылке — это когда процедуре передается *идентификатор* какой то сущности языка. После этого процедура может эту сущность свободно использовать в вычислениях в своем теле, обращаясь к сущности по переданному в параметрах идентификаторе. Это примитивный, но повсеместно используемый механизм в различных вычислительнях моделях, *фактически для всех сущностей языков программирования*.

Тем не менее императивные яп достаточно часто под передачей по ссылке имеют в виду что-то другое. Например они предполагают что идентификатор хранится в ячейке локальной для рассматриваемой процедуры. Короче, то что параметр функции является локальной переменной для этой функции. Строго говоря, такое поведение формально является *передачей по значению*, так как ссылка-идентификатор рассматривается как значение.

## Call by variable

Передача через переменную это особая версия передачи по ссылке. Идентификатор *ячейки* передаем в процедуру, и внутри процедуры этот идентификатор становится синонимом имени-параметра ячейки. В отличие от обычной передачи по ссылке в качестве параметра используется не оригинальный идентификатор ячейки, а *алиас*. При том этот алиас не является локальной переменной внутри функции (куда копируется ссылка), а представляет собой по сути синтаксический сахар.

## Call by value

Передача по значению — значение передается в процедуру в ячейку-параметр, которая является локальной для этой процедуры. Реализация может быть либо через копирование значения целиком, либо через передачу лишь ссылки. Это неважно, потому что формально процедура не может никаким образом изменять внешние по отношению к себе значения (за пределами своего скоупа), даже если эти значения передаются по ссылке.

## Call by value-result

Передача по значению-результату — это версия передачи через переменную, которая используется для *возвращения значения через параметр*. При вызове процедуры содержимое мутабельной ячейки помещается в другую, локальную для процедуры мутабельную переменную. Над этой переменной проиходят описанные вычисления, результат которых (при завершении процедуры) из локальной переменной перемещается обратно в изначальную ячейку.

## Call by name

Передача по имени — это такой общий случай, когда для всех аргументов создаются отдельные процедурные значения. Называют их **thunk**, или преобразователь (или переходник...). Этот преобразователь вычисляется каждый раз когда в вычислениях запрашивается соответствующий аргумент, и возвращает имя ячейки — адрес нужной мутабельной переменной. Вообще thunk это *функция*, и в случае когда аргментами являются индексы цикла возможны сложные ситуации из за многократного перевычисления индексов.

## Call by need

Передача по необходимости — это версия передачи по имени, в которой процедурное значение вычисляется единожды. Аргумент процедуры вычисляется тогда, когда запрашивается результат, после чего он сохраняется в замыкании (локальная переменная). При следующих обращениях к процедуре в качестве аргумента будет использоваться уже вычисленное значение из замыкания. 

# Stateful коллекции

Коллекция является важной разновидностью АТД. Коллекции группируют вместе набор значений в единую сущность-контейнер. У коллекций есть две важные характеристики:

- Поддержка индексации;
- Хранение фиксированного или переменного количества значений.

## Индексированные коллекции

Индексированные коллекции в декларативной модели — кортежи и записи. А их stateful версии — это массивы и словари.

**Массив** — это коллекция конкретных значений которым однозначно соответствует ряд целых чисел (индексы). Область определения, или домен массива — это набор последовательных целых чисел от нижней до верхней границ массива. Домен массива задается при его объявлении *и не может быть изменен после этого*. Наиболее часто нижней границей является ноль, иногда с единицы (например в языках Julia, Fortran, R, и др.). Изредка допускаются отрицательные значения. 

Доступ к эллементам массива и их изменение выполняются за константное O(1) время.

**Словарь** — это коллекция из простых констант (имена, целые числа, атомы) однозначно соответствующих конкретным значениям. Домен словаря может спокойно изменяться в процессе его использования. Каждый элемент словаря представляет собой пару ключ-значение. Менять ключи в существующем элементе нельзя. 

Доступ и изменение тут тоже выполняется за O(1), чаще всего это реализуется посредством хэш-таблиц. 

Словари и записи очень похожи. Оба типа раскладывают простые константные ключи в соответствующие значения. Основное их отличие в том, что записи — stateless, а словари — stateful. У записей может быть фиксированный, неизменяемый набор ключей-значений, а в словарях их можно произвольно менять.

---

Хотя кортежи, записи, массивы и словари обеспечивают доступ к эллементам за константное время, в остальном их продуктивность отличается.

*Кортежи* самые ограниченные, но зато работают очень быстро и требуют мало памяти по сравнению с остальными типами индексирумых коллекций. Содержимое кортежей не может меняться, значения в них хранятся последовательно. Доступ по индексу, всегда лежащему в диапазоне от 1 до N — очень прост.

*Записи* заметно более гибки в сравнении с кортежами, потому что в качестве индексов можно использовать любые литералы и числа. Числа-индексы тут не обязаны принадлежать к какому то конкретному диапазону. Значения хранятся последовательно — при создании записи генерируется хэш-таблица, которая преабразует ключи поля записи в его сдвиг в последовательности значений.

*Массивы* допускают ещё большую гибкость и предоставляют возможность менять содержимое значений. Эффективность этого типа всё ещё остается высокой, из за того что значения хранятся последовательно, диапазон индексеов заранее известен и не меняется, а позиции конкретных элементов в памяти вычислятся быстро.

*Словари* — самый общий случай индексированной коллекции. Словари комбинируют в себе возможности записей и массивов. Изначально словарь создается пустым без какого либо явно заданного диапазона индексов. Это наименее эффективная структура данных по времени доступа к эллементам и обновлению содержимого. Словари часто реализуются на динамических хэш-таблицах.

## Неидексируемые коллекции

Есть две самые распространенные неидексируемые коллекции:
- *Потоки*;
- *Списки*.

Эти оба типа данных по сути хранят в себе линейные последовательности, могут последовательно перебираться от головы до хвоста. Кроме того одновременно над ним таки переборов может происходить любое количество. Хотя есть исключения из этого правила — *не всегда может допускаться повторный перебор с нуля*, например в потоках ввода-вывода.

Список от потока отличается тем, что список в момент времени имеет фактический хвост. Длина списка фиксирована. А поток это своего рода "незавершенный" список. Хвост потока может быть *несвязанной переменной*. Получается что поток можно всегда расширить как список. По эффективности использования памяти и по времени работы поток является одной из самых эффективных **расширяемых коллекций**.

### Расширяемые коллекции

Поток эффективно расширяется, но вот доступ к его эллементам работает за О(N), если в реализации вообще присутствует возможность доступа к произвольному элементу, а не только последовательный перебор. *Словарь*, который мы уже рассмотрели, это тоже расширяемая коллекция. Но расширение словаря само по себе уже происходит за неконстантное время. 

Ещё один вид расширяемой коллекции это *динамический массив*. По сути это всё ещё массив, точнее *внутренний буфер* в котором хранятся элементы динамического массива — обычный массив. Но когда в буфере динамического массива полностью или почти полностью заканчивается место его буфер расширяется. Этот процесс расширения называется *релокацией массива*. 

Существуют две схемы релокации: 
- Аддитивная;
- Мультипликативная.

Аддитивная схема эффективна и применяется когда размер массива не очень большой, и как следствие расходы ресурсов на релокацию малы. Здесь увеличение происходит небольшими и фиксированными кусочками. 

Мультипликативная схема релокации в свою очередь работает иначе. В этом случае размер буфера существенно увеличивается — в несколько раз. Эта схема применяется в случае когда размер массива большой, потому что его релоцирование требует много ресурсов. Обычно в этой схеме размер буфера просто удваивается, хотя возможны другие варианты, например — золотое сечение (увеличение буфера в 1.1618 раз)

Вычисления по которым буфер динамического массива сильно зависят от конкретно решаемой задачи.

Амортизационное время расширения динамического массива значительно лучше чем у словарей, при этом у нас сохраняется доступ к произвольным эллементам за O(1).

# Инвариативные утверждения

А вот это очень важная штука!

Мы разобрались с тем что появление в вычислительной модели явных состояний может вызывать проблемы. В частности снижается способность рассуждать и программе и вообще её понимать, особенно когда состояния используются бессистемно.

Когда состояние гуляет по всей программе, доступно всем частям, то такое состояние может быть модифицировано где угодно в этой программе. И че делать? Смотреть код от корки до корки, пытаясь проследить в каком месте в какой момент времени что, по идее, должно быть в этом состоянии? Бррр.

Представьте что это не скрипт на 200 строк а программная система на 200 тысяч строк.

Есть отличная джедайская техника, которая позволяет взять stateful-сложность под *линейный контроль*. Имя ей — "*Инвариативные утверждения (invariant assertions)*". Метод применим для программ в которых есть и императивная (с состояниями) и декларативная части. 

Декларативные части проверяются логическими выражениями — утверждениями, или assert-проверками.

Техника таких в computer science известка как *аксиоматическая семантика*, когда семантика всех конструкций языка программирования определяется через набор правил (аксиом). Вообще не сюрприз что это было разработано "святой троицей" —  Флойд, Хоар и Дейкстра в семидесятые годы. Тогда вообще много чего хорошего изобрели :)

В общем, используя метод инвариативных утверждений мы становимся способны рассуждать о каждой части программы независимо от других частей. Тем самым, даже если в системе используются состояния мы сохраняем одну из самых сильных фишек декларативной вычислительной модели: понимание всей системы является линейной суммой понимания подсистем.

Платим кровью — вся программа должна быть строго формально организованна на ассертах.

Ключевая мысль тут это то что система *организовывается как иерархия АТД*. АТД могут использовать другие АТД для своей реализации. Этот более глубокий подход чем наследование в классическом ООП.

Каждый АТД в подобной системе специфицируется набором инвариативных утверждений.

**Инвариант** — это логическое утверждение которым мы четко определяем как связанно внутреннее состояние АТД с его аргументами. Каждая операция абстрактного типа данных *заранее предполагает* истинность одного инварианта, а по завершению эта операция *гарантирует истинность другого инварианта*. Эта истинность гарантируется программной реализацией операции. 

## Утверждения 

Инварианты реализуются благодаря такому понятию как asserion — утверждения.

Утверждение — это логическое выражение, которое располагается *между двумя инструкциями кода*. Это может быть вычисление булевого значения, или утверждения могут содержать переменные и идентификаторы ячеек используемых в коде. Кроме того они могут содержать вообще переменные и *кванторы* которые не встречаются в языке программирования, и используются только для выражений конретного проверяемого отношения. 

Классические кванторы:
- Квантор всеобщности "для всех..." — **∀**;
- Квантор существования "существует хотя бы один..." — **∃**.

## Утверждения частичной корректности

Пусть каждая **Oi** операция АТД специфицурется двумя утверждениями **Ai** и **Bi**. Спецификация утверждается, что в случае когда инвариант **Ai** является истинным перед выполнением операции **Oi**, то по завершению **Oi** инваиант **Bi** будет истинным.

Это можно записать как: {Ai} Oi {Bi}, а называться такое утверждение будет *утверждением частичной корректности*. Частичное оно потому что всё утверждение будет корректным только в том случае, когда Oi завершится нормально (без рейзов исключений и прочих нежелательных ситуаций).

**Ai** называется предусловием, а **Bi** — постусловием. 

Полная спецификация абстрактного типа данных складывается из утверждений частичной корректности для *всех операций* этого АТД.

Как доказать корректность реализации самого АТД, даже если он формально описан? Для этого нужно доказать корректность реализации самих (всех) утверждений частичной корректности операций этого АТД. Когда нибудь я доберусь до пруф-чекеров , но пока это "глубокая кроличья нора" :)

### Нормальный, я нормальный!

Утверждения частичной корректности, пусть они описаны для всех операций всех АТД в программе, ничего не гаранитируют нам в плане корректности завершения программы целиком. Они лишь фиксируют истинность тех или иных утверждений когда программа завершилась нормально.

*Нам нужно доказать что программа вообще завершается.*

Ненормальные случаи завершения это:
1. Провалились в бесконечный цикл;
2. Вычисления заблокировались, когда dataflow-переменная не связалась со значением. Возникает при ошибках программиста или в ситуацих блокировок;
3. Вычисления завершились с исключением.

А теперь разберем что нужно делать в каждом из случаев выше.
1. Всегда когда в программе присутствует использование цикла без ограничения (цикл while или рекурсивные вызовы) есть риск что он никогда не завершится. Для того чтобы убедиться что такой цикл завершится нам достаточно доказать, что условие завершения цикла — это функция, которая неотрицательна и всегда убывает от итерации к итерации. Иными словами — нужно убедиться, что на каждой итерации цикла *уменьшается будущее пространство расчета*.
2. Должно быть доказано то, что все переменные в программе становятся связанными со значениями до начала использования этих переменных. Для каждого использования переменной нужно проследить в обратном порядке все пути обращения к ней, и убедиться что в самом начале все эти пути выходят на связывание со значением.
3. Самая частая причина исключений это *конфликты типов*. Поэтому нужно стараться избегать любых явных и неявных преобразований типов данных, включать по максимуму тайп чекеры на уровне компилятора и среды выполнения.

--- 

Притормозим. Оставшаяся часть курса про programming in large, и я обязательно напишу об этом в следующий или другой раз. 