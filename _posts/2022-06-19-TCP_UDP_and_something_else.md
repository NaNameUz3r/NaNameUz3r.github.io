---
title: "Про Маршрутизацию и протоколы L1-L3"
tags: "Сети"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-06-19"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/networks_1.png
---

Немного про модель OSI и работу элементарной канальной среды.
<!--more--> 

# М-м-маршрутизация!

Роутеры нужны для маршрутизации трафика между канальными средами. Теоретически мы можем построить только на коммутаторах одну огромную канальную среду. Но из [прошлого поста](/2022/06/13/OSI_and_switches.html) мы знаем про юникаст флуд. Представьте себе сколько ARP и MAC кадров будет получать каждый участник сети? Представьте что в такой сети 20 тысяч компьютеров... А если миллион? 

Для этого того чтобы избавиться от лишней нагрузки на сеть нужно разделять большую сеть на разумно организованные канальные среды с помощью маршрутизаторов (роутеров).

Если у коммутаторов по умолчанию всё включено и работает "из коробки" — воткнул витые пары и забыл. То с роутером так не работает. Роутер из коробки ничего не знает и с кадрами работает не так как участники обычной канальной среды. Роутеру нужно указывать с каким его портом какая канальная среда живет, какой у этой среды *gateway*.

## Что такое gateway?

Gateway это адрес шлюза (по сути роутера), который занимается перекладыванием трафика между одной канальной средой и другой. Проще сказать — это адрес интерфейса маршрутизатора, назначенного на ту подсеть (канальную среду) в которой мы находимся. Когда компьютер отправитель трафика "видит" что целевой адрес находится в другой подсети, он "понимает" что в этом случае достучаться по мак адресу не получится, и шлет тогда не канальные кадры, а уже IP пакеты на шлюз. Роутер же в свою очередь получив пакет перенаправлет его на интерфейс соответствующей целевой канальной среды по IP адресу получателя.

Првда в пределах своей канальной среды отправитель шлет эти пакеты на роутер все равно по MAC адресу, только MAC получателя тут не MAC фактического получателя трафика, а физический адрес роутера-шлюза.

Но как отправитель всё это "видит" и "понимает"? Для этого используется *маска подсети*.

## Что такое маска подсети?

Маска подсети определяет какая часть IP адреса относится к *адресу сети* а какая к *адресам хостов*.

Возьмем два одинаковых IP адреса, но с разными масками:

    192.168.15.20/24
    192.168.15.20/16

В первом случае, при использования 24-ой (255.255.255.0) маски *первые три октета* относятся к адресу сети а последний к адресу хоста.

Во втором случае у нас маска 16, это значит что первые *два* октета относятся к адресу сети, а вторая пара к адресу хоста.

Иными словами и более просто — маска подсети указывает отправителю на то *сколько октетов адреса получателя нужно сравнивать с октетами **своего** IP адреса*, чтобы понять в *своей канальной среде* этот получатель находится, или нет. 

Вернемся к маршрутизатору и рассмотрим простой пример.

Например у отправителя адрес 192.168.0.10 и маска подсети 255.255.255.0, а у получателя 172.20.20.20 и маска *такая же*. Отправитель согласно своей маске поймет что адрес получателя находится в другой канальной среде (октеты не совпали) и будет искать в своей сети *MAC адрес маршрутизатора* (основной шлюз, gateway) выполнив широковещательный ARP запрос (если в его таблице ещё нет MAC адреса маршрутизатора).

Получив в ответном ARP кадре от роутера его адрес, компьютер отправитель отправит *пакет* (не канальный кадр!) на MAC адрес роутера. 

Получив пакет на свой MAC адрес роутер видит IP адрес получателя, понимает что нужно перенаправить трафик в другую канальную среду, но для этого ему нужен MAC получателя. Поэтому уже по хорошо известной нам схеме роутер ARP бродкастом будет искать MAC получателя в целевой канальной среде.

# IP адреса

В отличие от MAC адресов, IPv4 адреса представляются в десятеричной системе исчисления и состоит из четырех *октетов* разделяемых точками. Каждый октет является числом из 8 бит (1 байт). Компьютеры видят эти числа (да и вообще всё :D) в двоичной системе исчисления.

IP адреса делятся на частные и публичные диапазоны.

Наиболее часто используемые сетевыми инженерами диапазоны частных IP адресов:
- 10.0.0.0/8 (всё что начинается с 10);
- 172.16.0.0/12 (всё что начинается с 172.16.0.0 по 172.31.255.255);
- 192.168.0.0.16 (всё что начинается с 192.168.0.0 по 192.168.255.255).

Эти IP адреса не маршрутизируются в интернет и используются только в локальных сетях (например в каких нибудь организациях), виртуальных сетях инфраструктур облачных провайдеров и так далее. Имейте в виду что нам никто не запрщает в локальной сети придумать какой угодно адрес, но он всё равно останется частным. Список выше представлен лишь самыми популярными диапазонами. Правда есть несколько исключений! Это специальные зарезервированные адреса которые либо не получится вообще назначить, либо не будут работать (вообще или возможны проблемы):

- 127.0.0.0-127.255.255.255 — это loopback адреса по которым хост общается сам с собой;
- 169.254.0.0-169.254.255.255 — Automatic Private IP Adressing (APIPA), это автоматические адреса генерируемые в винде службой APIPA.  
- 0.0.0.0 и любые адреса с нуля либо не будут вообще работать, либо система не даст их назначить на устройстве. Такие адреса используются по умолчанию сетевыми устройствами, например когда у них ещё никакой адрес не назначен;
- 255.255.255.255 — широковещательный адрес (и любой другой, в зависимости от маски);
- 224.0.0.0-247.255.255.255 — мультикаст диапазон;
- 248-255.х.х.х — адреса зарезервированные для целей тестирования сетей;
- x.x.x.0 или x.x.0.0 — адреса сетей (в случае "нормальных" масок);
- x.x.x.255 или x.x.255.255 (и тд) — широковещательные адреса сети (в случае "нормальных" масок).

Публичные IP адреса напротив — маршрутизируются в интернете, то есть доступны в интернете практически откуда угодно. 

Контроль и выдача публичных адресов регулируется целой цепочкой специальных организаций. Если вдруг вам понадобится IP адрес для публичного сервера, вам придется запросить его у своего интернет провайдера, который в свою очередь получает набор таких адресов от LIR, а те от RIR. RIR от IANA. А IANA наконец от ICANN. Благодаря этой цепочке контроля достигается уникальность каждого публичного IP адреса в интернете.

Если ваш потенциальный сервер будет "путешествовать", вам не хотелось бы терять публичны адрес выданный интернет провайдером. В таком случае можно получить *провайдеро независимый IP* обратившись в LIR напрямую.

Я не очень хочу тут отвлекаться на описание этих организаций, смело гуглите аббревиатуры.

И ещё раз закрепим — зная маску мы (и в двоичном виде компьютер) можем определить адрес подсети. Например 192.168.15.20/24 будет находится в подсети 192.168.15.0, так как маска у нас 24 (первые три октета). Такой адрес подсети мы не можем назначить на какой-то узел самостоятельно. При такой маске адреса хостов будут находиться в диапазоне 192.168.15.1 по 192.168.15.254. 

Но куда делся 255? 

192.168.15.255 в нашем случае будет служебным, *широковещательным* IP адресом, по которому узлы могут отправлять пакеты всем хостам в своем домене.

## Более сложные маски подсети

Иногда границы подсетей проходят по не таким "ровным" маскам, которые мы уже рассмотрели.

Например мы можем встретить IP адрес с такой маской — 255.255.255.192

Что это такое и что с этим вообще делать? 

Сперва нам нужно перевести эту маску в двоичную систему исчисления. Получается 11111111.11111111.11111111.11000000, значит это 26-ая маска. Да, в сокращенном формате маска это просто количество единиц в двоичном представлении. Важно чтобы в маске *единицы шли подряд*, иначе IP маска просто не будет работать. Компьютер не поймет сколько бит адреса нужно брать для сравнения.

Имеем, например, адрес 192.168.15.87 /26
Мы точно знаем что первые три октета оносятся к сети (маска больше 24). Но что с оставшимся октетом? 

Чтобы найти границу подсети нужно перевести IP адрес в двоичный вид. Получаем 11000000.10101000.00001111.01010111
Ну, собственно и всё. Зная что у нас маска 26 мы понимаем что адрес сети будет составлять первые 26 бит. Отсчитываем 26 и отбрасываем всё что осталось: 11000000.10101000.00001111.01 | 010111 -> всё что отбрасываем заменяем нулями и получаем адрес подсети: 11000000.10101000.00001111.01000000. Переведем его в десятичную. Получается 192.168.15.64, а значит адресом первого хоста в этой подсети будет 192.168.15.65.

Чтобы понять каким будет последний адрес в этой канальной серед нам сперва нужно вычислить её широковещательный адрес. Для этого мы снова берем последний октет адреса подсети, но ту часть которую мы отбрасывали и превращали в нули, наоборот — обозначаем единицами. Получаем 11000000.10101000.00001111.01111111, что в десятичной 192.168.15.127

Значит адрес последнего хоста в подсети будет 192.168.15.126, а 192.168.15.128 уже адресом другой подсети.
Итого диапазон адресов хостов получается 192.169.15.65-126

# OSI vs TCP/IP

При инкапсуляции изначальные, читаемые человеком данные дополняются заголовками протоколов на каждом уровне. В итоге на физическом уровне весь этот пирог передается в бинарном виде, а получатель начинает декапсулировать пирог обратно отрезая от него на каждом уровне нужные заголовки по пути выполняя преобразования данных возвращая их к изначальному виду.

На транспортном уровне появляется такое понятие как порт. Этот уровень определяет возможность устройствам "понять" какая последовательность бит передаваемых по сети какому приложению адресована.

TCP/IP модель на самом деле то же самое что OSI. В TCP/IP работают все те же самые протоколы, но это более обобщенная форма понимания сетевого взаимподействия. В TCP/IP стеке сетевая модель делится на 4 уровня:
- Link уровень, это по сути физический и канальный уровень OSI;
- Internet — тоже самое что уровень Network, то есть сетевой в OSI;
- Transport уровень называется так же;
- А вот последние три уровня модели OSI: Application, Presentation и Session в понимании TCP/IP объединяются в один прикладной уровень (Application).

Главное что здесь нужно понять это то что обе модели по факту одно и то же, и представляют собой лишь разное *логическое* понимание, разное логическое разделение уровней процессов которые происходят при сетевой передаче данных. 

# Заголовок Ethernet (L2 Header)

Протокол Ethernet работает на канальном уровне. Заголовок этого протокола называется Ethernet кадром. Он определяет каким образом данные будут передаваться в одной канальной среде. 

{:refdef: style="text-align: center;"}
![Кадр Ethernet](/images/Ethernet_Frame.jpg)
{: refdef}

Разберемся с полями заголовка:

- Преамбула является идентификатором начала передачи кадра. Больший смысл эта часть кадра имела раньше, когда использовалась общая шина. Преамбула была своего рода предупреждающим "криком" для всех остальных участников канальной среды, вроде "Эй! Я сейчас буду кадр слать, помолчите все!". Короче чтобы занять среду для вещания. 

- Потом идут MAC адреса получателя и следом за ним отправителя, каждый из которых размером в 6 байт. Порядок физических адресов в заголовке обусловлен тем что есть такая технология как Cut-Through. Эта технология поддерживаеся некоторыми свитчами и позволяет не помещать весь получаемый кадр в буфер, а сразу "налету" перекладывать кадр в нужный исходящий буфер. Перекладывать получается быстрее, потому что адрес получателя находится ближе к "голове" кадра, чем оставшаяся часть. Таким образом свитч чисто физически быстрее видит адрес получателя и передает кадры куда надо. "Глупые" свитчи не умеют в Cut-Through и сначала помещают данные в буфер целиком. 

- 2-х байтовый заголовок "Тип(длинна)" в наше время содержит информацию о длинне передаваемых данных. Раньше в этом заголовке указывался тип передаваемых данных, что служило маркером для передачи кадров обработчикам соответствующих типов. Поле длинна находится перед данными для того чтобы получатель мог понять в какой момент в кадре закончатся данные и начнется чексумма.

- Следующее поле самое большое по размеру и содержит данные. Вместе с ними в это поле добавляются значения SNAP/LLC. SNAP — это Subnet Access Protocol, не слишком вдаваясь в подробности, это вложение в поле с данными служит для инкапсуляции, а именно как идентификатор того какому протоколу нужно передавать данные из кадра на уровень выше. *Обратите внимание на то, что это поле по умолчанию ограничено размером в 1500 байт.* Это ограничение продиктовано тем что необходимо эффективно (точно) вычислять чексумму. Тем не менее этот показатель можно увеличить. Это конфигурируется на сетевых устройствах параметром MTU (Maximum transmission unit). При увеличении MTU мы повышаем скорость работы сети, так как каждый из кадров начинает вмещать в себя больше данных, но важно помнить о том что мы тем самым понижаем эффективность вычисления чексуммы. 

- В самом конце кадра находится чексумма (FCS) — остаток от деления битовой последовательности всего кадра на 2**32 - 1 (за исключением преамбулы). Чексумма нужна для того чтобы получатель мог проверить кадр на целостность (не побилась ли битовая последовательность при передачи по сети).  

# Заголовок IP (L3 Header)

Переходим к сетевому уровню. На предыдущем уровне мы передавали данные в пределах одной канальной серды и заголовок Ethernet выглядит достаточно просто. Теперь задача усложняется, вступает в полную силу в работу протокол IP, данные теперь нужно как-то маршрутизировать между сетями. 

{:refdef: style="text-align: center;"}
![Кадр Ethernet](/images/IP_Header.jpg)
{: refdef}

Разберемся с тем что тут есть.

- Версия - IPv4 или IPv6.

- IHL - содержит размер самого заголовка (всё кроме данных). Почему тут есть такое поле а в заголовке предыдущего увроня такого не было? Потому что размеры заголовка IP не фиксированы и могут отличаться от случая к случаю (могут быть Опции). 

- Тип обслуживания используется для различных сетевых механизмов. Например для механизма очередей и других которые могут быть имплементированы в сетевом оборудовании. Например тут может указываться важность пакета, то есть его приоритет, место в очереди буфера сетевого устройства на передачу. 

- Длинна пакета содержит в себе длинну всего пакета (IHL + размер данных).

- Поля идентификатор, флаги и смещение фрагмента нужны для того чтобы правильно нарезать IP пакеты на канальные кадры. Как мы помним поле Ethernet кадра под данные ограниченно параметром MTU, а IP пакет разумеется может быть больше, намного больше этого значения. Когда IP пакет нарезается на части, в каждом таком кусочке записывается *одинаковый* идентификатор, который указывает на принадлженость к одному IP пакету. Устанавилвается флаг фрагментированности. А в поле "Смещение" таких кусков-фрагментов указывается сдвиг этого фрагмента относительно первого из них. Можно очень условно назвать это смещение "индексацией" фрагментов, чтобы в результате пакет собирался в правильном порядке, так как фрагменты могут доходить на конечное устройство не по порядку.

- Время жизни пакета (TTL) нужно для того чтобы избежать появление так называемых "петель маршрутизации" в сетях. Изначально в это поле записывается число 255, и каждый *роутер* на хопе через себя "отщипывает" от счетчика TTL единицу. Петля маршрутизации между роутерами это такая ситуация когда пакет никак не может прийти к устройству получателю и бегает по кругу в одной и той же цепи роутеров. Роутер при получении пакета с счетчиком TTL равным нулю уничтожает этот пакет.

- В поле "Протокол" записана информация о том какому выше по уровню протоколу предназначен пакет (Как правило UDP или TCP).

- Контрольная сумма IP пакета отличается от чексуммы канального кадра тем что она высчитывается только от полей заголовка пакета. То есть в её рассчет не входят сами данные, и как следствие их целостность на этом уровне *не проверяется*. Целостность данных, как мы уже разобрали, проверяется на канальном уровне — там чексумма вычисляется от всего кадра включая данные.

- С полями адресов я думаю всё понятно. Когда пакет отправляется с одного компьютера — IP адрес отправителя записывается в соотвеетствующее поле, а на основании IP адреса получателя пакет обрабатывается в зависимости от устройства где пакет "находится" в конкретный момент времени. Роутеры смотрят по адресам получателя куда пакет нужно перенаправить, а получатель проверяет это поле — отправлен ли пакет именно ему, и если да, то какому обработчику его нужно передать (Поле "Протокол").

- Поле Опции служит для расширения дефолтного функционала IP заголовка. Используется редко и специфическими устройствами.

- Смещение нужно для своего рода "балансировки" поля опций. Все поля заголовка IP пакета выровнены по границе 4 Байт (спецификация протокола IP), тогда как Опции не имеют фиксированной длинны и могут "плавать". Смещение служит для того чтобы Опции можно было подровнять до требуемой границы. 

- Поле Данные содержит передаваемую информационную нагрузку.

## Jumbo Frame

Повторюсь что нужно быть бдительным касаемо MTU. Кадр у которого размер поля данных больше дефолтных 1500 байт называется Jumbo Frame. Здесь есть подводные камни. Когда мы повышаем MTU, во-первых отправитель и получатель должны уметь работать с такими пухлыми кадрами. Короче говоря, MTU должен быть одинаково сконфигурирован на первом и втором устройстве. 

Во-вторых, это увеличивает нагрузку на маршрутизатор. Не смотря на то что в пределах канальной среды передача по сети начинает работать быстрее, мы можем столкнуться с проблемами передачи *между* сетями. Почему? Когда на роутер приходит jumbo frame, он понимает что внутри находится здоровый IP пакет, и в какую среду нужно перенаправлять трафик. Если целевая среда не поддерживает такой MTU роутеру придется вскрывать кадр, вытаскивать из него IP пакет и фрагментировать его. 

# Заголовки транспортного уровня (L4 Headers)

Теперь давайте рассмотри заголовки UDP и TCP протоколов.

## UDP Header

UDP Заголовок предельно прост.

{:refdef: style="text-align: center;"}
![UDP header](/images/UDP_header.jpg)
{: refdef}

UDP занимается только распределнием трафика приложений.

В порт отправителя записывается либо рандомный свободный порт при отправке либо какой то определенный, и нужный порт получателя в соответствующее поле. После получения датаграммы и её обработки в ответной датаграмме значения этих полей меняются местами.

В поле длинна записывается длинна всей датаграммы — заголовок + данные. Контрольная сумма высчитывается тоже от всей датаграммы. UDP не осуществляет контроль доставки, поэтому если чексумма не сходится получатель "молча" отбрасывает битую датаграмму.

Отправлять данные без контроля доставки важно в том случае, когда неприемлимы задержки. Например потоковая передача медиаконтента (аудио, видео). 

## TCP Header

А теперь про серьезного парня. TCP не только распределяет трафик, но и выполняет ещё множество других функций. Первая и самая главная из них это контроль доставки пакета. Если у получателя чексумма не сходится при проверке, то протокол ещё раз запрашивает отправку пакеты который был побит.

Контроль доставки нужен когда данные чувствительны к потерям (важен правильный порядок переданных бит данных), например почту, текст и так далее.

Заголовок выглядит так:

{:refdef: style="text-align: center;"}
![TCP header](/images/TCP_header.jpg)
{: refdef}


Ещё одной задачей TCP является сбор фрагментированных пакетов в правильной последовательности.

Далее, TCP в отличие от UDP умеет устанавливать сессии.

С портами, думаю, всё понятно.

Поля Порядковый номер и номер подтвеждения используются по разному, в зависимости от стадии передачи — установлена уже сессия или только устанавливается.

Поле "Длинна заголовка" нужно потому что здесь у заголовка снова (как в IP) есть поле нефиксированной длинны ("Опции") — даем понять получателю когда заканчивается заголовок и начинаются данные. 

"Флаги" используются для установления сессии, а в поле "Зарезервированно" специальные флаги для "протокольных" нужд. 

"Размер окна" нужен для осуществления оптимизации контроля доставки. Как вообще работает контроль доставки? Вкратце ― получатель должен на каждый получаеммый TCP пакет отвечать подтверждением того что всё ОК и чексумма "срослась". Значение размера окна указывает на колличество полученных пакетов, после которых нужно отправлять подтверждение что всё с ними было ОК. После установления сессии подтверждения отправляются на каждые три пакета, если потерь не происходит то размер окна увеличивается. Протокол следит за колличеством успешных и неуспешных отправок и регулирует размер окна в соответствии с колличеством потерь. Чем реже происходят потери — тем больше становится размер окна.

Если вы когда нибудь что-то качали по сети то наверняка видели сначала приерное время окончания загрузки неадекватных размеров, например 2 года. А потом бах, и время всё меньше и меньше становится. Это вот как раз размер окна меняется :)

Чексумма вычисляется от размера всего пакета.

Поле опций у TCP уже интереснее, так как используется чаще, в отличие от редких случаев использования опций в IP пакетах. Это потому что у TCP есть много разных расширений и дополнений которые управляются как раз посредством этого поля.

В данных тут уже то с чем будет работать прикладной протокол выше (HTTP например).

## Установка TCP сессии

Рассмотрим в приблизительном порядке что происходит с TCP заголовками при установке сессии:

1. Изначально клиентом устанавливаются значения портов отправителя (источника) и получателя (назначения).
2. Клиент устанавливае рандомное число в поле "Порядковый номер".
3. Отправитель (клиент) устанавливает флаг SYN, который как раз и обозначет попытку установить сессию.
4. Сформированный SYN пакет отправляется по сети и попадает к получателю (серверу).
5. Получатель в ответном пакете меняет местами порт получателя и отправителя.
6. Сервер устанавливает рандомное число в поле Порядковый номер в ответном пакет.
7. А В "Номер Подтверждения" ответного пакета сервер записывает значение из поля Порядкового номера полученного от клиента SYN пакета прибавляя к этому числу единицу.
8. Так же к флагу SYN в ответном пакете добавляется флаг ACK. 
9. Клиент получив SYN+ACK пакет опять менят местами порты, перемещает значение из Порядкового номера в Номер подтверждения прибавляя к этому числу единицу. Убирает флаг SYN оставляя флаг ACK и снова отправляет уже такой "ACK пакет" серверу.
10. Сессия установилась. Произошел так называемый процесс *3-way handshake* (SYN -> SYN+ACK -> ACK).
11. В установленной сесии идет обмен данными. Когда сессия установилась в поле "Порядковый номер" начинают записываться *номера пакетов*, а в "Номер подтверждения" записываются номера уже *полученных* пакетов.
12. По завершеню обмена происходит процесс закрытия сессии обменом пакетами: FIN+ACK от клиента к серверу, ответ FIN+ACK обратно клиенту, и последний ACK от клиента о получении FIN+ACK. Если клиент не завершит сессию на сервере она всё равно закроется по таймауту, если ничего не будет прилетать по открытой сессии.

---

На сегодня это всё!