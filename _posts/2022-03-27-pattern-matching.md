---
title: "Функциональное программирование, F# и Pattern Matching"
tags: "Программирование Отчеты Функциональное_программирование"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-03-13"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/lambda.jpg
---


<!--more--> 

## Вместо введения

Функциональное программирование как парадигма основывается на концепции функций первого класса, о которой вкратце я уже писал [здесь.](/2022/03/08/hack_in_declarative_model_5.html)

А вообще, функциональное программирование это *частый случай* декларативного подхода. В функциональном программировании тоже нет растянутых во времени состояний (переменных), значения которых хранятся и могут переопределяться когда вздумается. 

Таким образом, функции в ФП понимаются не как какие-то подпрограммы или методы, а скорее *математически*. В программном смысле такие функции можно представить как конвейер, который преобразует входное значение в выходное. Впрочем все это уже нам знакомо из изучения декларативной модели.

Здесь же я хочу подчеркнуть взаимосвязь понимания времени, и именованных состояний. В разных парадигмах программирования время представляется по разному. Мы рассматриваем здесь время как некое абстрактное понятие, которое выражает последовательность именованных значений (именованных состояний, переменных).

Так вот, в функциональном программировании и декларативной модели время непрерывно — значения вычислений как бы перетекают в другие вычисления, до тех пор пока не будет получен итоговый результат. 

## Mr. ~~Gordon Freeman~~ Alonzo Church

Может сложится впечатление, что функциональное программирование это просто некоторая реализация декларативной парадигмы. Но это не так! Функциональное программирование фактически отдельная, самостоятельная парадигма программирования, основанная на математической теории, а точнее — на формальной системе, которую разработал Алонзо Чёрч в ~~далекой-далекой галактике~~ сороковых годах! 

В это систему Чёрч заложил две основные операции:
- Аппликация функции — это про применение (по сути вызов) функции с каким то значением. И хотя в математике итак есть обозначение подобного например как f(a), в лямбда исчислении вся фишка в том что f трактуется не просто как функция, а как *алгоритм* который вычисляет результирующее значение, где a — входное значение.
- Абстракция — если не вдаваться в математическую мудрость, это способ определения выражений. Ну, то есть, это определение того, что там функция f на самом деле внутри вычисляет. Если хотите — определение *алгоритма*.

Кстати, Чёрч был научным руководителем Алана Тьюринга :)

Давайте ещё проще. Лямба-исчисление эта не меньше чем *полноценный* язык программирования, в котором нет *ничего* кроме простых функций — функций от *одного аргумента*.

На практике же, в функциональных языках программирования в функцию можно передавать больше одного аргумента, но делается это с помощью кортежей, то есть с точки зрения математической модели это всё ещё один аргумент, и не важно что внутри него может быть несколько значений.

{:refdef: style="text-align: center;"}
![Neo knows Lambda-calculus](/images/i-know-lambda-calculus.jpg)
{:refdef}


## Ближе к делу

С функциональным программированием я сейчас знакомлюсь в рамках курса по изучению языка F#, который родом из семейства языков MetaLanguage (строгие языки ФП). Это синтаксически минималистичный язык (ещё бы...), но тут есть всё что нужно, чтобы писать полноценные программы: типы, функции, выражения и вычислительные выражения. 

Типизация, разумеется, строгая статическая.  Функции же тут являются таким же базовым типом данных (функции первого класса), а вся программа является единым выражением (выше я уже говорил про "конвейер"). Получается что программа состоит не из операций присваивания и команд, а из *применения функций к аргументам* — аппликаций. 

В F# функции как тип данных определяются типом аргумента, передаваемого этой функции, и типом результирующего значения, которые перечисляются через стрелку "->". 

А сами функции определяются, например, так:

```
  let multiply3 N = N * 3
```

Здесь *multyply3* — идентификатор (имя) функции, а N её единственный аргумент. Получается что тип этой функции будет таким: "int -> int". Имя функции можно не задавать, определив тем самым так называемую *анонимную* функцию, или *лямбда-функцию* с помощью ключевого слова *fun* (a lot of!). Та же самая функция с применением анонимной-функции может быть записана так:

```
  let multiply3 = fun N -> N * 3
```

Видите разницу? Идентификатору multiply3 мы присваиваем результат вычисления анонимной функции, у которой N аргумент, и после стрелки -> выражение, которое эта функция вычисляет.

### Нужно построить Зиккурат

Очевидно, что есть множество случаев, когда мы хотим передать в функцию более одного значения, но аргумент может быть одним. Если вы не рыба, то помните что это мы уже затронули.

Кортежи в F# обозначаются так же как во многих других языках — с помощью круглых скобок. Скажем нам нужна очень сложная функция, которая перемножает три целых числа между собой:

```
  let toughcalc (a, b, c) = 
    let firstmul = a * b
    firstmul * c 
```

Конечно можно было сразу перемножить a * b * c, но в данном примере хочется подчеркнуть то, что результирующем значением функции будет значение *последнего* выражения в её теле. Тип этой функции будет "int * int * int -> int". Да, компилятор нормально понимает когда мы передаем несколько значений через кортеж, и значения типов таких составных аргументов записываются через "*".

Если мы вкорячим последним выражением какой нибудь printfn "helloworld", тип функции станет "int * int * int -> string". Если последним выражением мы поделим результат перемножений на 0.2, тип снова изменится на "int * int * int -> float", и так далее. 

## Имхо — вишенка

Pattern matching — это очень-очень круто! Что же это за колдовство? В общем, мы можем определить в функции некоторый набор вариантов выбора (clause), и жаль что такой финт есть не во всех языках программирования. В императивных языках бывают такие штуки как switch/case, но pattern matching куда круче, и идет дальше. 

Функция, поддерживаются сопоставление с образцом начинается с ключевого слова *function*. Варианты для сопоставления аргумента (или аргументов), перечисляются через символ \|, после которого задается шаблон проверки, и следом за стрелкой ("->") соответствующий шаблону результат. 

Например:

```
  let johnDoe = function
   | "age"   -> "69"
   | "hobby" -> "story telling"
   | "diagnosis" -> "ASPD"
```

Во-первых, тип — string -> string. И как видите, аргумент явно не указан, у него нет имени, нам это и не нужно. Да, так можно :)
Во-вторых, обратите внимание что 69 явно записано в кавычках, дабы быть не int, а string. В противном случае мы получим ошибку компилятора, который будет ругаться что результирующие типы шаблонов не соответствуют друг другу. 

Мы можем указывать универсальный паттерн (если другие условия не сработали), или множество вариантов с помощью or-паттерна (через "\|" друг за другом), выглядит это так:

```
  let johnDoe = function
   | "age" | "vozrast"         -> "69"
   | "hobby" | "che delart"    -> "story telling"
   | "diagnosis" | "bolyachka" -> "ASPD"
   | _                         -> "no data"
```

---

В качестве шаблона мы можем задать некоторый внутренний для функции идентификатор, который автоматически будет связан с проверяемым значением:

```
  let minus1 = function
   | 0 -> 0 
   | n -> n - 1
```

В F# pattern matching поддерживается так-же и как отдельная операция match, которая допускает указывать дополнительные логические условия в вариантах сопоставления после ключевого слова when:

```
  let tendToZero n = match n with
   | 0 -> 0
   | n when n > 0 -> n - 1
   | n when n < 0 -> n + 1
```

### Эпилог

Пока, из того что я выучил в ФП и F#, pattern matching мне показался наиболее интересной киллер фичей. Разумеется тут можно определять рекурсивные функции (надо перед идентификатором функции добавить rec), если логические условия if\then\else\elif и так далее, но всё это привычно и, наверное, писать об этом не очень интересно. 

Сопоставление с образцом есть не во всех языках, но его пытаются завезти. Например в прошлом году его [донесли в пайтон](https://habr.com/ru/company/yandex_praktikum/blog/547902/), но нужен ли он там и использовать ли — решайте сами. 

Миру мир!
