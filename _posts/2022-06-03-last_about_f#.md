---
title: "F# Напоследок"
tags: "Программирование Отчеты Функциональное_программирование"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-06-03"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/sharp_leaf.png
---

Послесловие о функциональном программировании на F#
<!--more--> 

Привет! Совсем недавно я завершил базовый курс по функциональному программированию на F# в [skillsmart.ru](http://skillsmart.ru/).
Хочу написать ещё немного об этом опыте, в продолжение [предыдущего поста](/2022/04/17/more_about_f.html)

Рассмотрим несколько фишек и типов F#

# Определение типа и записи

В F#, как и в большинстве языков программирования можно определять свои типы, делается это с помощью ключевого токена "type".

Есть так же такой тип как Запись (record), который фактически является кортежем, но его элементы идентифицируются ключами-метками (названиями), а не порядковой позицией. Это напоминает словарь в Python.

Сперва нам нужно определить структуру записи как тип.
Например:

    type = Weapon { fullauto : bool; load_amount: int; fire_rate: float32 }

Затем мы можем определить "экземпляр" записи:

    let ak47 = { fullauto = true; load_amount = 30; fire_rate = 100.54 }

Не нужно как-то дополнительно указывать что ak47 это запись типа Weapon — компилятор F# сам поймет на основании идентификаторов используемых полей.

Мы можем обращаться к каждому отдельному полю записи, чтобы получить её значение используя точечную нотацию:

    let ak47_firerate = ak47.fire_rate

Записи можно целиком сравнивать, если типы данных значений полей совпадают. Такое сравнение происходит в лексикографическом порядке.

# Размеченное объединение

Это тип данный, в котором мы задаем множество некоторых идентификаторов. Соответственно размеченное объединение может принимать только тип из своего "списка". Синтаксис напоминает сопоставление с образцом — используем пайп:

    type Weapon = 
      | ak47
      | m249_saw
      | colt_anaconda

На полную катушку оторваться тут можно уже фактически используя паттернматчинг фишку:

    type Weapon = 
      | ak47 -> "автомат"
      | m249_saw -> "пулемет"
      | colt_anaconda -> "револьвер"

    let full_auto = function
      | ak47 | m249_saw -> true
      | _ -> false

## Конструктор значений

Мы так же можем обозначить тип данных для каждого элемента-тега размеченного объединения:

    type Сaliber =
      | Pistol of float32
      | Machine_gun of float32
      | Cannon of int

В таком случае тег связанные с типом является фактически функцией, которыю называются конструкторами значений.

    let ak_caliber = Machine_gun 7.62
    let bfgun_caliber = Cannon 666

# Частичные функции 

Это такая функция, которая только на *подмножистве значений аргументов*.

Есть специальный тип **option**, у которого может быть только два значения:
- None: тут всё понятно;
- Some: это *полиморфный* конструктор значений, который прнимает *любые* типы.

В F# есть три случая, в которых функция может быть неопределенной:
1. Вычисления в функции не завершаются — упала в бесконечную рекурсию и тд.
2. Вычисления завершились с рейзом исключения.
3. Вычисления возвращают вышеупомянутый тип option.

Простой пример:

    let div x y = if y = 0 then None else Some(x / y)
    let r = div 2 0 

Тогда: 

    printfn "%s" (string r) 

не выведет ничего. Но если значение есть, мы можем достать его из Some с помощью Option.get:

    let r = div 4 2 
    printfn "%d" (Option.get r)

# Списки в F#

Списки отличаются от кортежей тем, что они являются цепочками значений *одного* типа.

В F# списки заключаются в квадратные скобки, а элементы перечисляются через точку с запятой.

В типе списков можно увидеть ключевое слово list, которое является *конструктором типа*.
У списка:

    [ ("hello", "world"); ("hello", "friend") ]

Тип будет:

(string * string) list


Добавить элемент в голову списка можно специальным оператором — "::"

    "hello" :: ["w"; "o"; "r"; "l"; "d"] = ["hello"; "w"; "o"; "r"; "l"; "d"]

Список из целых значений с единичным шагом можно выражать зачениями диапазона используя две точки, например:

    [ 1 .. 10 ]

Шаг можно изменить, указав его между первым и последним значеним так же — через две точки

    [ 1 .. 3 .. 12 ]

Сцепить вместе два списка можно с помощью инфиксного оператора @:
 
    [ "h"; "e"] @ [ "l"; "l"; "o"]

# Множества

Множеством называется неупорядоченный набор элементов одного типа, *среди которых нет повторяющихся*, то есть одинаковых.

Список преобразовать во множество можно с помощью функции Set.ofList, и обратно — Set.toList.

Добавить и убрать элемент — Set.add <элемент>, Set.remove <элемент>

Проверить что элемент есть в списке можно с помощью Set.contains, или проверить на вхождение подмножества — Set.isSuset:

    Set.contains "hello" (set ["hello"; "w"; "o"; "r"; "l"; "d"])
    Set.isSubset (set ["w"; "o"]) (set ["hello"; "w"; "o"; "r"; "l"; "d"])

Объединяются множества через Set.union, а пересечения и различия находятся как Set.intersect и Set.difference соответственно.


# Хвостовая рекурсия

Рекурсию мы уже достаточно хорошо обсуждали во втором посте о Декларативном программированиие -> [тык чтобы перечитать](/2022/02/12/hack_in_declarative_model_2.html).

Давайте рассмотрим живой пример на F#.

Неоптимизированная рекурсивная функция для расчета факториала будет выглядеть так:

    let rec factorial = function 
     | 1  -> 1
     | x  -> x * factorial(x - 1)

Здесь x накапливает результат, но на каждом итерации рекурсии будет происходить вызов функции factorial, и её результаты умножаться на x.

Избавиться от лишних рекурсивных вызовов можно использовав прием с *аккумулятором*:

    let factorial n =
        let rec inner_wrapper x a =
            if x <= 1 then a
            else inner_wrapper (x - 1) (a * x)
        inner_wrapper n 1

Здесь рекурсивные вычисления выполняются в другой, вложенной функции inner_wrapper, а её рекурсивный вызов располагается в самом конце, и не входит в какие либо вычисления как в предыдущем примере. Благодаря этому компилятор сможет оптимизировать выполнение без использования стека произвольной рекурсивной глубины.

# Последовательности и ленивые вычисления

Ленивые вычисления, это такая математическая модель вычислений в программировании. Как это работает? Например в F# есть *Последовательности*. Это как раз пример "ленивой структуры". 

Последовательность — это упорядоченная коллекция элементов, значения которых вычисляются *лишь в момент обращения к ним.*

Фишка в том, что последовательность может быть *бесконечной*. И таковыми их можно представить как раз благодаря "ленивости", никаких накладных расходов на определение последовательностей нет (не нужно сразу что-то бесконечно вычислять :)


Бесконечная последовательность задаётся дефолтной функцией Seq.initInfinite, и в параметр ей мы передаем другую функции которая будет генерировать последовательные значения. 

Такая последовательность будет в себе содержать квадраты целых чисел:

    let squares = Seq.initInfinite (fun x -> x * x)

Мы можем получить (вычислить) любой по индексу элемент последовательности с помощью функции Seq.item. А ещё последовательности можно кэшировать, чтобы не приходилось при каждом обращении к последоватльности вычислять её значения. 

Пример выше можно было бы закэшировать так:

    let cached_squares = Seq.cache squares

После этого при обращении к n-ному элементу такой последовательности будут вычислять этот и все предыдущие элементы, *если они ещё не были вычислен*, ну а в противном случае — использовать кэшированные результаты.

# Резюме

В целом, наверное на этом всё. Мне кажется что не совсем уместо тупо перечислять стандартные функции. Документация F# вполне себе ок, как на английском так и на русском. 

И рассматривать (читай спойлерить) задания из курса как в прошый раз я не хочу. Скажу лишь главное — это было круто, и стоило того. Пусть и пришлось поломать голову. Хотя, кмк я больше преувеличиваю и задания были проще чем мне казалось.

По крайней мере после сравнения своего решения и эталонного я так думал практически каждый раз :D 

Я никогда особо до этого не трогал лапками функциональные языки, разве что хаскель полтора раза, и скажу честно две вещи:

1. Мне **очень** понравилось.
2. Не знаю когда и что я буду, и буду ли вообще писать на чисто функциональных языках, но кажется что это правда как то меняет точку зрения на программирование в целом. Может мне кажется, но всё таки кажется что не кажется.

Я знаю что пишу часто криво, криво рейрачу, но кто бы это не прочитал — идите потрогайте ФП, и посмотрите внимательно в зеркало, ведь там очень красивый и умный человек :)

P.S. 
Если вдруг захотите ~~удариться головой об косяк~~ преисполниться в ФП на F# поищите учебник: "Functional Programming Using F#" Michael R. Hansen