---
title: "Предки суслика"
tags: "Программирование Go"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-02-06"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/gopher.jpg
---

Продолжаем знакомиться с Go. Зачем Google разработал новый язык, и чем вдохновлялись разработчики?

<!--more-->

В прошлой заметке о [первом знакомстве с Go](2022/01/23/go_language.html) я очень сжато и сумбурно описал первые впечатления об этом языке программирования.

За минувшую неделю я в увереном темпе прошел первый курс по Go на coursera из [этой](https://www.coursera.org/specializations/google-golang) специализации. Сложность заявлена как intermediate, и это похоже на правду. В четырех модулях были рассмотрены основные концепции языка, синтаксис, структуры данных и core features.

В небольших практических задачах нас знакомят с основными модулями, содержащими методы для работы со строками, вводом-выводом, и json'ами. Дается емкое объяснение того как работает сборщик мусора и указатели. Если вы не полный ноль в программировании то послее этого короткого курса довольно бегло сможете начать работать на Go. Хочу отметить что я уже отсмотрел лекции из первого модуля второго курса — [Functions, Methods, and Interfaces in Go](https://www.coursera.org/learn/golang-functions-methods?specialization=google-golang) и тут уже начинаются более интересные и качественные вещи.

Например, меня отдельно порадовало то, что во тут профессор Ирвин подчеркивает важность нейминга и "чистоты" функций. В первом знакомстве я обмолвился что по неведомой причине в сообществе разработчиков Go всё ещё считается нормой однобуквенный нейминг, и прочая ересь. Это лютая жесть и полный баттхёрт.

Я не преследую цель пересказывать весь первый курс тут, вы можете бесплатно его посмотреть на курсере, пусть и без доступа к задачкам и тестам — не много потеряете. В целом рекомендую как отправную точку в Go, я ничуть не жалею о потраченном времени, и материал подается явно попроще, но ничуть не хуже чем в A tour of Go. Эти материалы отлично дополняют друг друга.

По 2 и 3 курсу я обязательно выберу какую-то тему, которую освящу отдельным постом, например интерфейсы. В этот раз я предлагаю вам чуть больше информации об истоках языка и некоторых концепциях заложенных в нем.

### Люк, я твой отец

Я уже упоминал фразу, что  "Go это Си на стероидах". Называть его может кто угодно и как угодно, но по внутреннему устройству это вообще новый язык, и помимо Си на Go оказали влияние и другие "*родословные*" языков программирования.

Go пытается заимствовать лучшие идеи и парадигмы, при этом его создатели старались достичь максимальной семантической выразительности кода.

От Си язык Go унаследовал:
- Синтаксис выражений;
- Конструкции управления потоком;
- Базовые типы данных (но с некоторым расширением);
- А так же передачу параметров *по значению* и указатели.

Вторым деревом предков являются языки Никлауса Вирта, начиная с самого Паскаля. От следующего потомка паскаля - Modula-2 в Go пришла концепция *пакетов*, от Oberton - использвание одного центрального файла с определением модулей (в Go этот файл называется go.mod). Из чуть более позднего Oberton-2 взята концепция пакетов, импоторов и объявления методов.

Ну всё это мы видели и в других языках программирования :)

А вот самая вишенка, это концепция CSP (communicating sequential processes) из статьи Тони Хоара 1978 года об основах *параллелизма*, которая развивалась в научных языках компании Bell Labs, и в итоге добралась до нашего Go-суслика.

CSP — это скорее не концепция, а формальный язык, которым описываются модели взаимодействия процессов в параллельных программных системах **не имеющих общего состояния**. В этой модели процессы взаимодействуют и синхронизируются между собой с помощью *каналов*. Мне кажется это на порядок более мощная модель чем атомарность, которую я рассматривал вкратце [здесь](/2022/01/30/hack_in_codding_1.html). CSP до сих пор является темой для активного исследования в Computer Science.

### Зачем нам суслик?

Google устал от так называемого *взрыва сложности*. О какой сложности идет речь, в Гугле что, сидят дураки которым сложно программы писать на уже имеющихся языках? Вовсе нет. Здесь имеется в виду такая проблема (при чем вообще не уникальная для Google) как *сложность программной системы*.

Эта сложность характеризуется количеством абстрактных сущностей, которые между собой связаны и как-то взаимодействуют. Всё просто — чем сущностей больше, тем сложнее становится система. А чем сложнее система, тем затруднительнее в ней разобраться и что-то допиливать. Хороший пример сложной системы это СУБД Оракл, погуглите статью на хабре (треш алерт!).

Так вот, Роб Пайк (один из создатлей Go), не без оснований заметил, что сложность *мультипликативна*. Имеется в виду что если мы усложняем одну часть системы, например дорабатываем какие то фичи, etc., то обязательно будут усложняться и другие части.

С течением времени постоянно требуется вносить новые фичи в проект, бизнес требует ~~крови~~ денег, и требует быстро! В итоге мы получаем сложную, вообще не выразительную систему жертвуя простотой кода, хотя в долгосрочной перспективе *именно простота* является ключевым аспектом качественного софта. Простота означает ясность (выразительность), меньше шансов наплодить багов, etc.

Фишка в том, что такая "долгосрочная простота" требует большой работы в самом начале проекта. Необходимо четко сформулировать ключевые аспекты и поддерживать строгую дисциплину во время всего цикла разработки. Благодаря такой дисциплине становится возможным отличать плохие изменения от хороших. На практике же мы часто, и к сожалению, наблюдаем хреняк-хреняк и в продакшен.

Нет строгой спецификации и дисциплины — есть банальный размен *простоты* на мнимое *удобство*, которое в итоге приводит к хаосу и сплошному копанию в легаси и попытке докостылять.

Короче, Google устал, и разрабатывая Go одним из важных факторов стала *культура радикальной простоты*. В прошлый раз я мельком упоминал о том как медленно и неохотно в Go допиливаются новые "фичи", и как слезно сообщество выпрашивало, например, дженерики.

Go выигрывает преимущство во времени в которое он появился. И преимущество это — возможность ретроспективно проанилизировать "опыт" других языков программирования, в чем разрабочики "оторвались по полной".

В Go есть сборщик мусора, мы не мучаемся с памятью. Есть система пакетов, как уже было сказанно. Полноценные функции, замыкаем со спокойной душой. *Лексическая область видимости*. Интерфейс системных вызовов! И иммутабельные строки в UTF-8.

Но при этом, (помните про культуру радикальной простоты?): Нет конструкторов и деструкторов; Нет перегрузки операторов; Нет неявных числовых преобразований; Нет значений параметров по умолчанию. **Нет наследования**, обощенных типов и **исключений**. Нет макросов! Нет аннотаций функий и локальной памяти потока. В общем если вы до этого кодили только на Python, то сперва может будет немного больно, но не так, как на Си, или Си++ :D

Как вы уже могли догадаться, система типов в Go тоже своеобразна. Она боле ограниченна, чем в других языках со сторой типизацией, но при этом *достаточна* для того чтобы избежать большую часть ошибок, на которые мы можем напарываться в языках с динамической типизацией. Мы можем создавать изолированные части кода с "нетипизированным программированием", которые в свою очередь будут включены в более широкую, и более строгую схему типов.

---

Go точно заслуживает вашего внимания, даже если не как основной язык программирования, то как дополнительный инструмент точно.
Совсем не похоже что этот проект отправится на знаменитое кладбище Google.

Этот пост получился таким же обобщенным как и предыдующий, тут нет сниппетов кода, мы не разбирали вглубь особенности и примеры.

Хочу сказать что мне кажется я очень своевременно начал учить Go. Параллельно с курсом "Как понять в програмировании всё", красота простоты Go становится ещё понятнее, как задумка, и как ценность.

---
*Основанно на введении из книги "The Go Programming Language"*
