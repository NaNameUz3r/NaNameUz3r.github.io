---
title: "Связный список, он же Linked List"
tags: "Программирование Структуры_данных"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-07-24"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/linked_list.jpg
---

Врубаемся в Linked List.
<!--more-->

# Вместо введения

Привет! Мы уже много раз говорили про списки как про фундаментальную структуру данных в программировании. Например [в третьем посте о Декларативной модели](/2022/02/27/hack_in_declarative_model_4.html) мы говорили, что в рамках парадигмы список — это рекурсивный тип данных.

Сегодня же я предлагаю вам немного ближе ознакомиться с этой замечательной структурой.

# Что такое связный список

Связный список — это *"классический"* абстрактный тип данных, который представляет собой упорядоченный набор элементарных данных. Элементы связного списка называются **узлами**, и каждый узел связан с другими *некоторым* способом.

Список — это упорядоченная неиндексируемая коллекция, которая может перебираться от головы к хвосту. От массивов списки отличаются тем, что во-первых — они хранятся в памяти *по разному*. Массив, как правило, занимает непрерывную область памяти, которая выделяется при его инициализации.

Если в массиве "кончится место", то мы не сможем просто так его расширить. Для это нам придется найти новую *последовательную* область памяти подходящего размера, аллоцировать новый массив побольше, и скопировать в него все элементы из предыдущего массива. Ну мы сегодня про списки :)

Так вот, узлы списка не обязательно буду храниться в последовательной области памяти, скорее наоборот — узлы будут разбросаны в памяти произвольно. При добавлении нового узла нам не нужно делать ничего кроме как просто добавить его корректно (с учетом всех указателей и граничных ситуаций).

Во-вторых, взяв за начало любой узел списка мы можем достаточно просто вычленить любую необходимую часть. Добавление и удаление эллементов связного списка выполняется очень эффективно.

# Как это устроено

Самый тривиальный связаный список — это односвязный, или *однонаправленный связный список*. В таком списке каждый узел связан со следующим с помощью указателя на этот следующий узел. И так от головы до хвоста. Для реализации такой структуры данных нам нужно всего лишь определить два класса: Узел (Node), у которого будет два поля Value, и указатель на следующий узел Next.

Например, хотя в Go и нет классов и ООП как такового, узел легко определить как Struct:

    type Node struct {
        next  *Node
        value int  // ну или любой другой тип, который вы хотите хранить в узлах.
    }

На самом деле, формально говоря, одного класса Node уже достаточно для того чтобы сформировать список.

Второй класс, собственно список LinkedList является обёрткой для узлов, и по сути играет роль синтаксического сахара.
В этом классе нам нужны два поля — head и tail, который будут указателями на голову и хвост списка соответственно:

    type LinkedList struct {
        head *Node
        tail *Node
    }

Вот и весь скелет однонаправленного списка. Далее, мы можем определить все необходимые для работы методы.
Например, метод для добавления нового узла в хвост списка может выглядеть так:

    func (l *LinkedList) AddInTail(item *Node) {
        if l.head == nil {
            l.head = item
        } else {
            l.tail.next = item
        }

        l.tail = item
    }

Раз за разом добавляя новые узлы в хвост списка, мы сначала либо делаем новый узел "головой" (если список пуст), либо в актуальный хвост записываем указатель на новый узел, и перемещаем на этот же новый узел указатель хвоста в классе\структуре LinkedList.

Мы можем свободно перебирать узлы списка с головы до хвоста, например, чтобы посчитать все узлы:

    func (l *LinkedList) Count() int {
        count := 0
        current_node := l.head
        for {
            if current_node == nil {
                break
            }
            count++
            current_node = current_node.next
        }
        return count
    }

И добавлять узлы куда то в середину, а не только в хвост:

    func (l *LinkedList) Insert(after *Node, add Node) {
        if reflect.DeepEqual(after, l.tail) == true {
            l.AddInTail(add)
        } else {
            add.next = after.next
            after.next = &add
        }

    }

Ну и так далее.

## Двунаправленный список

Двкунаправленный, или двусвязный список — это всё тот же LinkedList, но такой у которого узлы ссылаются не только на следующие, но и на *предыдущий*, для того чтобы можно было бегать в обратную сторону от хвоста к голове.

В такой реализации структуры и метод добавления в хвост реализованные на Go могут выглядеть так:

    type Node struct {
        prev  *Node
        next  *Node
        value int
    }

    type LinkedList2 struct {
        head *Node
        tail *Node
    }

    func (l *LinkedList2) AddInTail(item Node) {
        if l.head == nil {
            l.head = &item
            l.head.next = nil
            l.head.prev = nil
        } else {
            l.tail.next = &item
            item.prev = l.tail
        }

        l.tail = &item
        l.tail.next = nil
    }

Мы платим памятью — нужно выделять дополнительную ячейку для каждого узла (дополнительный указатель prev). Реализация методов тут немного усложняется, потому что при любых модификациях двунаправленного списка нам нужно проверять три ситуации: работу с головой, хвостой, и серединой списка. Мы должны убедиться что указатели после каждой такой операции будут иметь корректные, отражающие новую реальность данные.

Облегчить себе жизнь можно пойти чуть дальше :)

# Лист с двумя дурачками

Чтобы избавиться от ~~головной боли~~ граничных ситуаций упомянутых выше, можно закодить LinkedList с двумя, так называемыми, *dummy* узлами. Это такие фиктивные узлы-пустышки, которые *всегда* будут в связном списке — в голове и хвосте.

Имея эти узлы мы всегда можем быть уверенны в том, что у каждого узла будет и следующий (next) и предыдущий (prev) узлы\указатели, что непосредственно избавляет нас от дополнительных проверок.

Самый простой способ реализовать такой финт — дополнительное булевое поле у Node:

    type Node struct {
        prev  *Node
        next  *Node
        value int
        dummy bool
    }

Список теперь, мы будем создавать при помощи функции-генератора, которая будет добавлять два дурочка:

    type LinkedListDummy struct {
        head *Node
        tail *Node
    }

    func NewList() *LinkedListDummy {
        l := new(LinkedListDummy)
        l.head = &Node{prev: nil, next: nil, value: -1, dummy: true}
        l.tail = &Node{prev: nil, next: nil, value: -1, dummy: true}
        l.head.next = l.tail
        l.tail.prev = l.head

        return l
    }

# Фантазируй дальше

На базе такого простого списка можно реализовать более сложные абстрактные типы, в зависимости от поставленной задачи. Ну, например, можно сделать *кольцевой связный список* на базе как односвязного так и двусвязного списка. В такой реализации хвост будет иметь указатель на голову, а в случае двусвязного кольцевого — ещё и голова на хвост.

В таком циклическом списке мы можем как-то выделить голову, чтобы "отлавливать" по необходимости момент, когда мы обошли весь список и вернулись в начало. Очереди, в том числе двусвязные, тоже реализуются на базе списков. К очередям мы доберемся в другой раз :)
