---
title: "Уровни рассуждения о программных системах"
tags: "Программирование Проектирование"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-07-25"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/3levelsthinking.jpg
---

Три уровня рассуждения, и почему важно знать их и не путать.
<!--more-->

# Ошибочная программа

Как понять что программа ошибочна? Как вообще вывести правильное определение, суждение о том что конкретная программа работает не правильно?

Первое что приходит на ум — программа работает не так как мы ожидали, делает не то что мы хотели. Или она работает правильно в одних обстоятельствах, но в других, например с определенным набором агрументов, эта программа будет некорректной. Мы можем сказать:

**Программа ошибочна, если она была запущена и выдала неверный результат**. На самом деле это достаточно пространные мысли. Давайте попробуем вывести более четкие определения.

Возьмем последний случай — программа работает вроде как исправно, запускается каждый раз с одними параметрами, но в какой то день X всё сломалось, поймали баг! Тогда более верным будет звучать что-то вроде:

**Программа ошибочна, если в каком-то конкретном окружении, наборе входных значений или после определенной череды действий\событий она была запущена и выдала неверный результат**.

Отлично, уже немного лучше. Но мы всё ещё имеем не верный код. По сути мы лишь опредили что программа работает но есть баги. Мы можем верить что такая программа нас никогда не подведет, ведь мы считаем что её всегда будут запускать в одних и тех же условиях и средах. По сути, утверждение о такой программе, что она работает *нормально*, не совсем верно, ведь код имеет уязвимости.
Такая уязвимость рано или поздно приведет к серьезном сбою в будущих версиях программы — кто-то изменить проверку N, или помняет поля в структуре данных, и так далее.

Есть третье определение ошибочности программы, которое кажется не таким очевидным и простым как предыдущие:

**Программа ошибочна, если причина, по которой она должна быть правильной — ошибочна.**

Кажется что это определение больше пародоксальный Дзен коан, но на самом деле оно достаточно строго. Разумеется, все три определения верны, но в зависимости от стадий, времени рассуждения о системе.

Для того чтобы разобраться с ними, и особенно с последним, нам нужно погрузиться чуть глубже в область *формальной верификации кода*.

# Три уровня рассуждения о программной системе

Здесь один из самых важных моментов, который нужно запомнить:

Когда мы рассуждаем о программной системе, мы **всегда** делаем это на **одном из трех уровней**:

1. Runtime, или время выполнения. Этот уровень конкретного выполнения программы в конкретной среде, с конкретными значениями и состояниями. На этом уровне выполняется большая часть отладки кода.

2. Конкретная реализация, исходный код. На этом уровне мы думаем, предполагаем что вообще может сделать текущая реализация программы в некотором окружении и с некоторыми входными данными, которые могут быть *произвольны*. Существует много сценариев работы программы ("поведений"), которые **никогда не могут произойти**. Важно научиться исключать такие сценарии из рассмотрения в процессе разработки, даже если для этого требуется сильно напрячь мозги. Большая часть работы по реализации программы ведется на этом уровне.

3. Дизайн программы, проектирование и логика. Тут рассматривается абстрактная спецификация каждого компонента программы. На уровне проектирорвания мы всегда рассматриваем только те поведения программы, которые определены спецификацией. При этом, предполагая что эти "поведения" в любой момент могут быть заменены другой реализацией с сохранением требований спецификации.

Фишка в том, что многие программы выглядят вполне корректными при их рассмотрении на *втором уровне* — реализация кода рабочая. При этом те же программы, если их рассмотреть на *третьем логическом уровне* могут быть некорректными, так как эти программы реализуют или предполагают такое поведение, *корректность которого вообще никак не гарантируется в будущих версиях*.

Не рассуждая о программе на третьем уровне (не убедившись в корректности её проектного дизайна), а лишь изучив код и зависимости заявлять, что функция корректна — является логической ошибкой, потому что при таком подходе мы вообще не знаем что эта функция конкретно должна делать в рамках всей системы.

## Здесь важно не путаться

Довольно очевидно, что проектирование программной системы осуществляется на уровне логики, *даже если проектировщики не осознают этот момент*, и даже если они вообще не осознают что делают и смешивают в своих рассуждениях все уровни.

Уровни рантайма и реализации тоже можно перепутать, хотя они и достаточно корректны. Например, запуская отладчик и рассматривая стек выполнения программы мы находимся на уровне рантайма.

Когда же мы изучаем код программы и думаем о том как он работает, и какие сценарии могут произойти — мы рассуждаем на уровне конкретной реализации.

Очень важно запомнить то, что существует ещё один уровень, и не путать **что** делает компонент, и **как** компонент это делает.

Мы можем хорошо понять разницу между интерфейсами и реализацией, но гораздо сложнее понять точно и в подробностях то, что *интерфейс определяет **во всей системе***, а не только думать о интерфейсе как о "списке функций".

Видимо проблема в том, что полноценно этот момент можно осознать только при формальной верификации системы, которая описывает свойства и характеристики программы так же корректно как и исходный код. А это же ведь надо думать, прилагать усилия ещё большие чем просто накодить — создать подробное описание и полноценную документацию.

Нельзя смешивать рассуждения о программе на разных уровнях, потому что это может привести к большой путанице как в общении между разными членами команды разработки, так и вообще к путанице в процессе рассуждения о программе.

## Дизайн всему голова

Прежде всего думать как над новым проектом, так и над новой доработкой-фичей нужно на третьем, логическом уровне. В противном случае всё чем мы будем обеспокоены — это отдать в релиз рабочий кусок кода, значит достаточно лишь убедиться в правильности на уровне реализации.

Но нет, это, наверное, monkey codding получается.

Главная цель любого ответственного инженера разработчика — **поставлять, развивать и сопровождать работающую программную систему сейчас и впредь, делать это *качественно* и *продуктивно***.

Логический уровень в первую очередь подразумевает стремление к минимальной связности проектных компонентов, стремление к тому чтобы эти компоненты были максимально модульными. Это особенно важно, если мы планируем создавать разные версии таких компонентов и хотим безболезненно для остальной системы менять их реализации.

В разработке программного обеспечения принятое решение практически нельзя отменить, и эти решения должны поддерживаться до самой смерти проекта. Проект будет жить "вечно" — "вечно" будут и жить принятые решения в процессе его разработки. Хороший пример — ошибка в названии протокола referer внесенная в спецификацию протокола HTTP.

Но ошибка может быть и менее безобидной. Поэтому очень важно упражняться в проектированни программ на уровне формальной спецификации, чтобы обязательно можно было утверждать, а ещё лучше — доказать, что каждый компонент, независимо от остальное программы, корректен сам по себе.

Этот логический уровень "скрыт", потому что не существует в коде и в проекте "физически", но он является **самым важным**, ключевым навыком для любого программиста, который стремится стать настоящим инженером-разработчиком, а не довольствоваться заурядным кодированием.

# Рантайм уровень. Трейсы и состояния

На первом уровне мы работаем с состояниями и трейсами.

**Трейс** — это последовательность событий, которые происходят во время работы программы. Трейсы могут быть как высокоуровнеыми (события запуска микросервиса), так и низкоуровневыми (системные вызовы, или ещё глубже — события планирования выполенения инструкций процессора). Трейсы служат для понимания текущего состояния системы и того что в ней вообще произошло. С точки зрения программиста абстракция трейса выражается в виде логов или отладочных выводов в консоль.

**Состояние** — это набор ячеек памяти с их текущими значениями. Милости прошу в посты из циклов изучения парадигм программирования, за более подобным изучением состояний. Начать можно с [Декларативной модели](/2022/02/06/hack_in_declarative_model.html). С точки зрения программиста абстракция состояний выражется, когда он смотрит на значения переменных в дебаггере.

Любую инструкцию программы которую можно выразить в терминах состояний и трейсов мы считаем относящейся к уровню рантайма.

Выходит так, что формально рассуждать на уровне рантайма можно лишь о конкретных значениях, без количественных критериев.

# Уровень конкретной реализации кода

Здесь мы уже рассуждаем о каждой инструкции именно как о команде на конкретном языке программирования, которая написана в конкретном синтаксисе, и с определенной семантикой. При этом мы полностью уходим от абстракции трейсов и состояний.

Например, подавая разные значения на вход одной и той же функции мы будем получать разные результаты — потоки состояний, трейсы. Вполне очевидно, что даже простая функция может потенциально генерировать бесконечное количество состояний. Тогда, если на уровне рантайма мы стремимся выяснить, возникнет ли в процессе работы некоторого кода ошибка, то на уровне реализации кода мы уже задаемся другим вопросом:

**Возможен ли потенциально такой сценарий выполнения этой функции, этого конкретного куса кода, в результате которого возникнет ошибка?**

Мы пытаемся понять это *не по трейсам*, а по *исходному коду*, без его запуска и тестирования.

Такой метод рассуждения называется **FOL** — First Order Logic (логика первого порядка).

# Уровень спецификации

Итак, это уровень полноценного формального логического рассуждения о системе в целом. Здесь уже применяются спецификации.

Обычно в классической разработке тут подразумевается уровень проектирование системы, но по CS научному спецификации, это о том, что **принципы инкапсуляции и модульности могут быть формально определены лишь в терминах *спецификации* и *формальной логики***.

Есть много сопособов задания спецификаций, один из популярных подходов — *Тройки Хоара*. В [заключительном посте](/2022/06/26/hack_in_imperative_3.html) по изучению исперативной парадигмы я уже немного писал про инварианты.

Вкратце основная мысль Хоара заключается в том чтобы у каждой конструкции императивного языка было *предусловие* и *постусловие* записанное как *логическая формула*. Собственно тройка это — предусловие, конструкция языка, постусловие.

Например, следуя этому методу, на уровне спецификации мы определяем предусловие и постусловие некоторой функции.

Если на втором уровне мы рассуждаем о специфике реализации этой функции — а не может ли случиться следствие X если произойдет событие Y?
То на уровне спецификации эти вопросы обобщаются — в принципе возникнет ли в программе, использующей нашу функции, следствие X?

Этот метод рассуждений называется **HOL** — High-Order logic (логика высших порядков).

Важная особенность спецификаций заключается в том, что через них мы можем здавать свойства системы, которые **невозможно выразить непосредственно в коде**.

Может показаться, что такая формальная система спецификаций избыточна. Зачем нам вообще всем этим заморачиваться, писать какие то формулы с кванторами и так далее, если это никак не помогает нам контролировать конкретную реализацию функции из какой-то стандартной библиотеки, в добавок, если у нас нет ещё и доступа к её исходникам.

Затем, что хоть мы и не можем формально контролировать конкретную реализациб, пользуясь системой спецификаций у нас появляется **логически целостный набор правил, которые нужно проверять и следовать им при написании своего кода**.

Рассуждая заранее на уровне спецификации мы можем выделить все потенциально опасные "места" и возможные питфолы, будем знать что нужно *обязательно проверять*, чтобы наш программа работала корректно и результаты работы её частей соответствали формальной спецификации.

Короче говоря, главная идея третьего уровня — стараться мыслить **концептуально**, как бы в отвлечении от первых двух уровней, и лишь затем переводить выведенные формальные концепции на "физический" уровень средствами языка программирования.

Система спецификаций — это как *идеальнгое* техническое задание, в котором нет никаких противоречий, недосказанностей. Оно логически целое и при его формировании выявляется огромное количество неясных технических нюансов, которые приходится формализировать, сознательно обдумывать, рассуждать о них.

Таким образом, чтобы мы не реализовывали, всегда нужно думать о составляющих систему компонентах через призму *абстрактных интерфейсов* (АТД), спецификаций и инвариантов. Мысленно переводить их в логические формулы.

Такой подход на самом деле работает не только в проектировании, но и в работе с легаси и в тестировании — мы можем заранее покрывать проверками-спецификациями самые мутные участки кода. При этом участок будет становиться менее мутным, как раз в процессе "разработки" этих проверок-спецификаций, потому что мы занимаемся в этот момент **логикой**, а логика — язык проектирования программного обеспечения.