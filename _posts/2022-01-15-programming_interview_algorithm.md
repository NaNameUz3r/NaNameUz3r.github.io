---
title: "Алгоритм прохождения интервью по программированию."
tags: "Перевод Программирование Алгоритмы ComputerScience"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-01-15"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/algorithm_interview.webp
---

Достаточно вольный перевод с английского полезной статьи Майкла Малиса, в которой он делится своим опытом решения алгоритмических задач с интервью по программированию.

<!--more-->
Оригинал статьи можете прочитать в его личном блоге по [этой ссылке.](https://malisper.me/an-algorithm-for-passing-programming-interviews/)
Приступим.

---

За последние несколько лет я проходи интервью в дюжине (или около того) компаний и решил ~50 уникальных алгоритимических задач.
Мне часто давали обратную связь, в которой говорилось, что я отлично справился с предлагаемыми алгоритимическими задачами.
В этом посте я собираюсь поделиться тем, как именно я подхожу к решению этих задач.

## Мыслительный процесс

Основной принцип, который я использую, заключается в том что каждая задача, предлагаемая к решению на собеседовании, *может быть решена*.
На интервью вас не станут просить доказать Великую теорему Ферма. Если вам дадут какую-то неразрешимую задачу, похоже что у вас не будет особых шансов её решить. 

По моему опыту, примерно в 80% случаев алгоритмические задачи сводятся к фундаментальным структурам данных и алгоритмам. Структуры данных, которые я встречаю чаще всего:
- Хэш-таблицы
- Связанные списки
- Двоичное дерево поиска

Что касаемо алгоритмов:
- Поиск в глубину
- Бинарный поиск
- Алгоритмы сортировки

(Скорее всего от вас не будут требовать реализовать бинарный поиск или алгоритм сортировки, но вы *должны знать*, что они существуют.)

Кроме того, есть две дополнительные техники программирования, с которыми вы должны быть знакомы:
- Динамическое программирование
- Рекурсия

## Алгоритм решения

Алгоритм решения задачи выглядит так:
1. Как только вы получили алгоритмическую задачу, уточните требования к реализации (условия, runtime) которым должно соответствовать ваше решение. Скорее всего интервьвер ответит на этот вопрос.
2. Вычеркните из списка возможных структуры данных и алгоритмы которые очевидно не имеют отношения к рассматриваемой задаче. Это избавит вас от большей части списка, и вы, как правило, останетесь с 2-3 структурами данных и алгоритмами.
- Вы можете не рассматривать слишком медленные структуры данных. Если вам необходимо решить задачу за O(1), то невомозможно использовать бинарное дерево в своем решении, так как бинарное дерево всегда будет выполнять не менее, чем за O(log n) времени. 
- Так же вы можете избавиться от алгоритмов, если их невозможно применить в задаче. Например, если в задаче нет графа, вы знаете, что поиск в глубину вам точно не подойдет.
3. Рассмотрите варианты использования оставшихся структур данных. Какие из них имеют отношения к поставленной задаче? Решением станет подходящая комбинация, вам остается её только собрать воедино. 

Давайте рассмотрим среды выполнения, основные структуры данных и алгоритмы. Затем мы разберем несколько примеров, чтобы убедиться насколько прост данных подход.

###  *Требования и сценарии*

#### Хэш-таблицы.
**Требования к реализации - поиск, вставка и удаление за O(1)**

Сценарии применения:
- Когда вам нужно лишь находить и сохранять объекты.
- Когда вам нужно разделить список объектов на группы, по некотрому свойству (это то, что делает GROUP BY в SQL)
- Нужно посчитать колиечество отличных элементов из списка.

#### Связанные списки.
**Требования к реализации - вставка нового узла, поиск и удаление узлов из головы, хвоста, или из узла на который уже есть указатель.**

Сценарии применения:
Основные сценарии применения связанных списков витают вокруг факта, что связанные списки поддерживают относительный порядок своих элементов. В интервью по программированию связанные списки, в основном, используются как реализация стека или очереди.

#### Двоичные деревья.
**Требования к реализации - вставка, поиск и удалние за O(log n)**

Сценарии применения:
Двоичные деревья используются, когда вам нужно хранить данные в отсортированном порядке. Позволяют быстро находить количество элементов, попадающих в конкретый диапазон, или самый *высокий* элемент в дереве.

#### Двоичный поиск.
**Требования к реализации - O(log n)**

Сценарии применения:
- Вам нужно найти число в массиве, ближайшее к другому числу. 
- Вам нужно найти наименьше число в отсортированном массиве, которое больше чем другое число.
- Вам нужно найти наибольшее число в отсортированном массиве, которое меньше другого числа.
- Если по какой-то причине в своем решении вы не можете использовать хэш-таблицу, вы можете с помощью двоичного поиска проверить, находится ли элемент в отсортированном массиве.

#### Поиск в глубину.
**Требования к реализации - O(log n)**

Сценарии применения:
- Требуется обойти весь граф.
- Требуется найти конкретный элемент в графе.
- Нужно найти [компоненту графа](https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%B0_%D1%81%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D0%B3%D1%80%D0%B0%D1%84%D0%B0) (состоящий из наибольшего количества узлов подграф)

#### Сортировка.
**Требования к реализации - O(n log n)**

Сценарии применения:
- Может использоваться в случае, когда вам нужно обработать элементы в требуемом порядке. Сначала сортируем в этом порядке, затем итерируемся по элементам.
- Может использоваться для соритровки массива, к которому потом будет применяться двоичный поиск.

#### Динамическое прогрммирование и рекурсии.

Динамическое программирование и рекурсия отличаются тем, что являются общими методами решения алгоритмических задач, а не конкретными алгоритмами.
Это означает что у них нет конкретных сценариев применения или требуемого [асимптотического поведения](https://ru.wikipedia.org/wiki/%C2%ABO%C2%BB_%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%BE%D0%B5_%D0%B8_%C2%ABo%C2%BB_%D0%BC%D0%B0%D0%BB%D0%BE%D0%B5). 
Хорошая новость в том, что после небольшой практики становится достаточно просто распознавать задачи, которые можно решить с помощью динамического программирования или рекурсии. Я рекомендую попрактиковаться в подобных задачах, чтобы вы *могли почувствовать* эти методы. Полное объяснение динамического программирования и рекурсии выходит за рамки данного поста.

### Примеры

Теперь давайте посмотрим на несколько разных алгоритмических задач с интервью, и как они могут быть решены с помощью алгоритма решения.

#### Задача #1: Написать рейт-лимитер

Эту задачу я встречал несколько раз на интервью в разных компаниях.

*Вам нужно написать функцию, которая может быть вызвана не более N раз за одну минуту. Например, она может быть вызвана лишь 10 раз в минуту.
Если функция вызывается более N раз, она должна генерировать исключение. Ожидается что функция будет работать за O(1).*

Посмотрите на список алгоритмов и структур данных, которые мы можем использовать, и попытайтесь понять какие из них помогут в решении данной задачи. Затем попробуйте понять как вы можете их применить в решении. Попробуйте самостоятельно, прежде чем смотреть ответ.

- Хэш-таблицы
- Связанные списки
- Двоичное дерево
- Поиск в глубину
- Бинарный поиск
- Алгоритмы сортировки
- Динамическое программирование
- Рекурсия

#### Решение

Сперва исключим алгоритмы и структуры данных, которые явно не подходят.

- Хэш-таблицы
- Связанные списки
- ~~Двоичное дерево~~ — слишком медленно.
- ~~Поиск в глубину~~ — слишком медленно, и в задаче нет графа для использования этого алгоритма.
- ~~Бинарный поиск~~ — тоже слишком медленно, в задаче нет отсортированного массива.
- ~~Алгоритмы сортировки~~ — снова слишком медленно. В задаче нет элементов для сортировки.
- ~~Динамическое программирование~~ — нет способов применить динамическое программирование в решении.
- ~~Рекурсия~~ — нет сособов применить рекурсию.

Не вычеркнули только хэш-таблицы и связанные списки. Если мы вернемся и рассмотрим сценарии использования хэш-таблиц, то не найдем способа применить эту структуру данных в решении задачи. Нам не нужно быстро искать разные объекты, и не нужно разбивать на подгруппы списки объектов. Значит хэш-таблицы тоже можно вычеркнуть из списка.

Таким образом, осталась только одна структура данных v связанные списки. Глядя на сценарии применения видим реализацию стека или очереди. Можем ли мы использовать какой то из этих вариантов для отслеживания колличества вызовов функции за последюю минуту? Да! Мы можем создать очередь, в которую будет входить одна запись за каждый вызов функции в течении последней минуты. Каждый раз, когда функция вызывается, мы удаляем из очереди все записи, которые были сделанны более минуты назад. Если очередь по прежнему имеет длинну больше N — генерируется исключение. В противном случае мы добавляем новую запись в очередь с меткой текущего времени (время вызова). Отслеживая длинну очереди с помощью переменной счётчика, которую мы можем определять за O(1), функция так же будет иметь ожидаемую производительность O(1).

#### Задача #2: Анаграммы

*На вход поаается список слов, из которого нужно составить список слов, которые являются анаграммами как минимум одного другого слова во входном списке. Два слова являются анаграммами друг друга, в случае если буквы в одном слове можно поменять местами так, чтобы получилось второе. Программа должна выполняться за O(n), если все слова одной длинны*

Снова попытатейтсь обдумать задачу самостоятельно, прежде чем читать решение. Вот уже знакомый нам список структур данных и алгоритмов:

- Хэш-таблицы
- Связанные списки
- Двоичное дерево
- Поиск в глубину
- Бинарный поиск
- Алгоритмы сортировки
- Динамическое программирование
- Рекурсия

#### Решение

Начнем отбрасывать элементы из списка, которые не помогут в решении проблемы:

- Хэш-таблицы 
- Связанные списки
- ~~Двоичное дерево~~ — Слишком медленно.
- ~~Поиск в глубину~~ —Тут нет графа.
- ~~Бинарный поиск~~ — Тут нет отсортированного массива. 
- ~~Алгоритмы сортировки~~ — Слишком медленно. 
- ~~Динамическое программирование~~ — Нет способа применить динамическое программирование.
- ~~Рекурсия~~ — Нет способа применить рекурсию.

У нас остались хэш-таблицы и связанные списки. Связанные списки, похоже, не пригодятся в решении этой задачи, так как стэк или очередь не выглядят эффективно. Получается что остается использовать хэш-таблицу.

Единственный вариант использования хэш-таблицы, который кажется здесь уместным, — это возможность разделить список объектов на группы по некоторому признаку. В этом случае, если бы у нас был способ разделить список на отдельные группы, в которые бы входили слова анаграммы друг друга, это помогло бы решить задачу. Выглядит как план:

1. Разделим входной список слов на группы по признаку "анаграммности" друг друга.
2. Соединим вместе группы, в которых больше одного слова. В результате мы получим требуемый список слов, в котором каждое слово будет являться анаграммой как минимум одного другого слова из входного списка.

Единственное, что нам осталось решить. это найти какое-то свойство, которое мы можем использовать для группирования анаграмм. Нам нужно определить функцию *f*, результат выполнения которой как *f(x)* и  *f(y)* будет одинаков, если x и y являются анаграммами друг друга.

Для этой цели мы можем использовать две разные функции:
- Отсортируем символы в словах по алфавиту. Мы знаем, что все анаграммы состоят из одних и тех же буква. Таким образом мы получим одну и ту же строку для любой пары слов-анаграмм.
- Составим словарь из количества вхождений каждой буквы в каждом слове. Это решенее сложнее, так как придётся каким то образом использовать в качестве ключа в хэш-таблице. В некоторых языках программирования есть способ это сделать, в других нет.

Теперь, когда мы нашли способ сгруппировать слова анаграммы друг друга, мы можем собрать все размышления вместе и решить задачу.

Давайте попробуем рассмотреть ещё одну задачу. 

#### Задача #3: K-sorted (частичная сортировка)

*Есть массив объектов, который частично отсортирован, и его нужно "досортировать". Каждый элемент массива находится на расстоянии, не более чем k от своего фактического места. Требования к сложности реализации алгоритма отсутствуют.*

Как и ранее, вот список алгоритмов и структур данных:

- Хэш-таблицы
- Связанные списки
- Двоичное дерево
- Поиск в глубину
- Бинарный поиск
- Алгоритмы сортировки
- Динамическое программирование
- Рекурсия

#### Решение

Сначала, давайте подумаем, можем ли мы что то предположить о сложности и времени выполнения алгоритма. В самом лучшем случае мы можем достичь O(n), посколько именно столько времени потребуется на итерирование по списку. Мы также можем выполнить обычную сортировку за O(n log n). Давайте определим, можно ли сделать лучше, чем O(n log n).

Как нам достичь скорости в O(n)? Ну, если k=n, то сложность задачи становится такой же, как сортировка списка, поэтому невозможно постоянно попадать в O(n). Но может быть всё ещё можно решить задачу быстрее, чем за O(n log n). Теперь давайте посмотрим, какие структуры данных и алгоритмы из нашего перечня помогут в решении:

- Хэш-таблицы
- Связанные списки
- Двоичное дерево
- ~~Поиск в глубину~~ — Нет графа.
- ~~Бинарный поиск~~ — Массив не отсортирован.
- ~~Алгоритмы сортировки~~ — Слишком медленно.
- ~~Динамическое программирование~~ — Не подходит для решения задачи.
- ~~Рекурсия~~ — Не подходит для решения задачи.

Из оставшихся структур данных, единственная, которая имеет отношение к возможному решению — это двоичное дерево. К такому выводу мы приходим потому что только двоичное дерево единственная структура данных из списка, имееющая отношение к сортировке элементов. Если немного подумать о том, как можно применить двоичное дерево для решения, ответ станет ясен. Мы можем построить двоичное дерево из *последних k элементов*. Мы раз за разом удаляем наименьший элемент из бинарного дерева, и добавляем в него следующий из входного массива. Полный алгоритм решения выглядит следующим образом:

- Построить двоичное дерево из первых k элементов входного массива.
- Перебрать оставшуюся часть массива. На каждой итерации удаляем наименьший элемент из двоичного дерева и добавляем его в результирующий массив. Затем добавляем *текущий* элемент из входного массива в двоичное дерево.
- Как только мы дойдем до конца входного массива, один за одним удаляем наименьший элемент из двоичного дерева, пока дерево не опустеет.

Анализируя сложность этого решения делаем вывод, что время выполнения составит O(n log k). Возможно ли сделать лучше? Интуитивно кажется, что тут добиться более быстрого алгоритма не получится. 
Какой алгоритм может быть эффективнее, между O(n) и O(n log k), особенно из тех, что вам удастся придумать во время интервьюирования? Дале приводится неформальное доказательство того, что вы не можете решить задачу быстре, чем O(n log k). Учитывая то, что придумать алгоритм быстрее задача не из лёгких, от вас не будут ожидать этого на интервью. Если доказательство вам не интересно, можете его пропустить.

*Предположим, у вас уже есть алгоритм, который работает быстрее, чем O(n log k). Мы можем использовать его, чтобы пытаться придумать алгоритм сортировки, который быстрее O(n log n), что невозможно. Допустим, у вас есть n/k различных списков, кажрый длинной в k, причем элементы каждого списка строго больше, чем элементы предыдущего. Если вы объедините все списки вместе, запустите для них k-сортировку, а затем разделите каждые k элементов на отдельные списки, вы отсортируете n/k списков менее, чем за время O(n log k). В свою очередь это означает, что в среднем вы сортируете каждый список менее чем за O(n/(n/k) log k) = O(k log k), что невозможно. Поэтому ни один алгоритм k-сортировки не будет работать быстрее, чем O(n log k).*

Это озачает что выше мы нашли оптимальное решение поставленной задачи. 

Надеюсь, на данный момент я убедил вас, что алгоритм решения алгоритмических задач, описываемый в этом посте — эффективный метод. Обратите внимание, что он эффективен не только при решении задач на собеседованиях, но и для решения алгоритмических задач, с которыми вы можете столкнуться в реальном мире. Вы можете использовать его, чтобы проверить, есть ли у задачи решение, состоящие из основных структур данных из нашего списка. 

Если вы хотите узнать о других способах решения задач, я настоятельно рекомендую книгу [How to solve it](https://www.amazon.com/How-Solve-Mathematical-Princeton-Science/dp/069111966X). Эта книга охватывает множество различных подходов к решению любой задачи. How to solve it оказала огромное влияние на то, как я подхожу к любой задаче в настоящее время. 

---

На этом текст оригинальной статьи подходит к концу. По мере вычитывания и укрепления собственного понимания, с большой долей вероятности, в мой перевод будут вноситься улучшающие изменения.
Это статья достаточно сложная. Если вам не понятно что такое O(n) и так далее, и вы не знакомы с алгоритмами и структурами данных, о которых идет речь — не беспокойтесь! Я планирую написать цикл небольших постов на эти темы. Благодарю за уделённое время и надеюсь что превод окажется вам полезным!




