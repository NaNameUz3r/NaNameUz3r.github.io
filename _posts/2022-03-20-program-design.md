---
title: "Несколько слов о проектировании"
tags: "Программирование Проектирование"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-03-20"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/program_design.png
---

Как подступиться к правильному созданию программы.
<!--more--> 

### Program Design
Проектирование программы, наверное, самый важный критерий успешности и качественности будущего программного продукта. 
На этапе проектирования нам нужно четко определить саму задачу, и то как мы будем её решать. 

Под "решанием" имеются в виду техники программирования (прадигмы), которые будут применяться, и то как они будут связанны между собой.

Результатом проектирования является высокоуровневая структура, условный *"прототип"* будущей системы. 

Очевидно, что в зависимости от задачи размер и сложность программы может существенно отличаться. Это может быть маленькая программа, написанная одним человеком или здоровенный комплекс, над которым трудится целая команда. В классическом случае первое называют programming in small, а второе — in large.

Более интересным с инженерной точки зрения мне кажется другое определение *programming in small* и *programming in large*, когда подразумевается не количество людей трудящихся над программой, но "фокус" разработки. 

В этом случае, говоря о programming in small подразумевается само кодирование программы, а именно написание стилистически ясного, правильно (чистого) кода, выраженного через [продуктивные алгоритмы](/2022/01/22/algorithms_complexity.html). 

Programming in large, в таком случае, является "фокусом" проектирования, когда программа уже является действительно большой (от нескольких тысяч строк кода, и более). В создании таких сложных программ критически важно подходить к проектированию осознанно и правильно, иначе всё кончится плохо: бизнес потеряет деньги, разработчики — оставшиеся нервные клетки. 

## Базовый подход

Предлагаю вам, в качестве примера, рассмотреть следующую методику проектирования in small, когда программа разрабатывается единолично, и ожидаемый объем кода составит менее десятков тысяч строк.

#### 1. Спецификация
Сперва необходимо обозначить **неформальную спецификацию**. Это то, что часто называют техническим заданием. На практике же нам нужно как можно более точно записать что программа должна делать, а именно:

 - Что программа получает на вход?
 - Что должна выдавать на выходе?
 - Как входные и выходные данные соотносятся друг с другом?

Такая спецификация называется неформальной, потому что мы пишем её на человеческом языке (русском, английском, или на каком вы там ещё умеете).

#### 2. Примеры
Примеры служат для прояснения спецификации, полученной на первом этапе. Будет очень полезно представить что программа делает в определенных, конкретных ситуациях. Лучшего всего это делать в *формате тестов*. Да, сначала пишем тесты для кода, а потом код! Это называется TDD — Test Driven Development, и само по себе огромная тема для отдельного поста.

Наши примеры должны показывать, во-первых, как программа ведет себя граничных условиях. Нужно проверить её самыми неожиданными способами. Никогда не нужно думать что "чего-то может не быть", "моя программа никогда не получит на вход отрицательное значение", и так далее. 

**Assume and check everything!**

Во-вторых, примеры должны собственно отображать базовые сценарии работы программы. Может показаться, что это важнее чем тесты. Нет, не важнее. 

#### 3. Исследование

На этом этапе нам необходимо написать "кирпичики" из которых мы предполагаем строить программу. Этими "кирпичиками" должны быть небольшие и по максимуму автономные операции (низкая связанность). В результате мы получим намного более четкое представление о структуре будущей программы, и сможем определить конкретные методы программирования, уместные для решения поставленных задач. 

#### 4. Структура и реализация

Наконец, мы начинаем формировать саму программу — приблизительно набрасываем операции для расчета входных данных, и способы (методы), которыми эти операции между собой взаимодействуют. После этого пробелы в получившемся наброске заполняются реальным кодом. Важно то, что операции *должны быть простыми* — каждая из них должна делать **одну**, и только одну вещь. 

Это один из самых важных принципов *ясного* программирования, следуя которому мы избегаем потенциально много ошибок, которые могут порождаться, например, сайд-эффектами запутанных функций, которые делают "много чего" внутри. А те ошибки, которые всё таки будут появляться (А они будут!), мы сможем намного быстрее идентифицировать и исправить. 

Для улучшения структуры программы, связанные операции группируются в *модули*.

#### 5. Тестирования и обдумывание

Пришла пора убедиться что ~~оно живое!~~ программа вообще работает. Для этого нужно провести ряд тестов, включая те, что уже были разработаны на этапе 2. Снова и снова гоняем тесты и исправляем ошибки, до тех пор пока программа не заработает так как надо. А надо, чтобы она работала хорошо :)

На этом этапе важно не забывать рассуждать о структуре программы и её сложности. Находя и исправляя ошибки потенциально возможно улучшить структуру программы и переписать плохие алгоритмы (рефакторинг кода). 

---

Все эти этапы взаимодополняющи друг другу. Например, на этапе исследования, или даже написании примеров, мы можем понять что изначальная спецификация не совсем корректна, и изменить/дополнить её. Тестирование и обдумывание, имхо, вообще стоит ультимативно применять как жизненный принцип :)

А если по делу, то тестирование, в принципе, самый важный шаг в programming in small. Существует достаточно много методик тестирования, которые стоит изучить и применять в разработке. Например, уже упомянутое TDD и *модульное тестирование*. Это тема для отдельных постов, поэтому вкратце:

- Модульное тестирование — основная идея unit-тестирования в том, чтобы писать тесты, которые проверяют **наименьшую** составляющую кода (один тест проверяют одну функцию, модуль или класс)
- TDD — Перед тем как писать код, мы пишем тесты для этого кода (например те же самые unit-тесты)! В принципе такие тесты выступают в роли спецификации того, что код *должен делать*. Мощный подход, которые позволяет понимать что мы вообще делаем, программируя части системы.

## Организация программы

В проектировании важно понимать как всё таки правильно организовать программу. Конечно, можно накодить всё как сплошной монолит, в котором по мере роста проекта всё в итоге запутается, и все участники разработки/сопровождения будут ультимативно страдать. Наверняка вы видели такие проекты, не буду показывать пальцами. 

Наиболее адекватный способ борьбы с растущей сложностью системы — декомпозиция программы на так называемые *логические единицы*. Каждая такая единица должна реализовать свой набор операций, которые связанны в одно целое, например через [абстрактные типы данных.](/2022/03/13/hack_in_declarative_model_6.html)

Логическая единица делится на две части: *интерфейс* и *реализацию*. Снаружи логического блока доступен только интерфейс, а реализация "внутри" при этом может меняться безнаказанно. 

Логические единицы часто называют *модулями* или *компонентами* программы.

### Слово дня - Функтор

А теперь немного программистской "научности", продолжая тему организации. 

Спецификацию модуля рассматривают как *отдельную сущность* — это такой "шаблон", который создает новый модуль, примерно так же как класс создает экземпляр объекта в объектно ориентированном программировании. Есть конкретный программистский термин, для обозначения таких спецификаций.

**Функтор** — это функция, которая получает на вход набор модулей, требующихся для создания *нового модуля*, и возвращает этот новый созданный модуль. Правильно говоря, функтор получает на вход *интерфейсы* модулей, и возвращает тоже *интерфейс* нового модуля.  

Функтор состоит из:

- импорта, которым задается перечень требуемых функтору модулей;
- экспорта, определяющего интерфейс "изготавливаемого" модуля;
- реализации, включающая код инициализации самого функтора.

В программной инженерии *программным компонентом* называется некоторый элемент для *независимого развертывания*. Такой компонент для своей установки ничего не требует, кроме перечня стандартных библиотек. Программный компонент не имеет фиксированного внутреннего состояния, иными словами — соответствует (декларативной модели)[/archive.html?tag=Декларативная_модель]

Автономное (standalone) приложение, которое не подразумевает активного взаимодействия с пользователем, например, не имеет графического интерфейса для такого взаимодействия, состоит из главного функтора, который вычисляется на старте приложения, "подтягивает" нужные себе модули, что фактически приводит к вызову других функторов. 

Вычисление или установка главного функтора происходит в три шага:
- Идентификация необходимых для работы модулей;
- Выполнение кода инициализации;
- Загрузка модулей, которые будут нужны непосредственно во время работы программы.

Другие "подфункторы" могут вычисляться в разное время работы программы, как правило в те моменты, когда запрашиваются ресурсы из ещё не вычисленного функтора. Такое поведение называется **динамическим связывание**, которое является полной противоположность **статическому связыванию** — при котором все модули загружаются сразу на старте программы.

Множество установленных (вычисленных) модулей называется **рабочим модульным окружением**. 

---

Любите.