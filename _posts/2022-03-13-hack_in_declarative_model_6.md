---
title: "Программирование, управляемое данными. АТД."
tags: "Программирование Отчеты"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-03-13"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/declarative_6.png
---

Врубаемся в Декларативную модель — Часть 6. 
<!--more--> 

## Data-driven

Часто на практике нужно выполнить какую то операцию над достаточно большой структурой данных, например провести итеративные вычисления, или обойти одну структуру и вычислить другую, на основе "собранных" в обходе данных.

Как правило, чаще всего такие вычисления проводятся над списками, массивами и деревьями. К спискам применяются операции свертки (FoldL\R), которые мы рассмотрели в прошлом посте. Но существуют и другие популярные техники.

### Операция Map

Реализация Map есть почти во всех стандартных библиотеках популярных языков программирования. Эта операция работает со списком, и вычисляет на его основании список такой же длинны, применяя переданную в Map функцию к каждому элементу исходного списка.

С помощью ~~заклинаний~~ программирования высшего порядка, реализовать Map можно как-то так:

    def function Map(some_list, some_func)

        def function iterate_map(new_list, list_remaining, some_func)
            if list_remaining == []:
                return new_list
      

            list_head = list_remaining[0]
            list_tail = list_remaining[1:] 
            return iterate_map(new_list.insert(0, some_func(list_head)), list_tail, some_func)
  

        return iterate_map([], some_list, some_func)

Можем передать в Map простую функцию, типа возведения в квадрат, и передать её вторым аргументов. Напоминаю что здесь, раньше и далее сниппеты описаны в "псевдопайтанокоде". Заварите чай, прочитайте прошлые пару статей, если сходу ничего не понятно, и реализуйте рабочий вариант на своем любимом ЯП :)

### Операция Filter

Filter это ещё одна классическая операция для обработки списков. Она так же принимает вторым аргументом некоторую функцию-предикат, и на выходе отдает список с элементами исходного списка, удовлетворяющими переданный предикат:


    def function Filter(some_list, some_func)

        def function iterate_filter(new_list, list_remaining, some_func)
            if list_remaining == []:
                return new_list

            list_head = list_remaining[0]
            list_tail = list_remaining[1:]

            if some_func(list_head):
                return iterate_filter(new_list.insert(0, list_head), list_tail, some_func)
            else:
                return iterate_filter(new_list, list_tail, some_func)
         
   

        return iterate_filter([], some_list, some_func)

Снова взываю к вашей фантазии, напрягите волшебный интеллект! Предикат можно придумать, практически любой. Например, если список состоит из целых чисел, можем написать простую функцию которая возвращает true если результата делится на 2 без остатка (четный). Или вообще воткнуть предикат в вызов iterate_filter лямбдой. Если вы прожженый питонист, то я уверен что вы хотя бы раз втыкали лямбды в map или filter!!! :trollface:

## Абстрактные типы данных

Абстрактный тип данных — это описание некоторой структуры данных посредством определения операций над этой структурой. И только! Только операций!
Внутренняя реализация, все атрибуты *полностью скрыты* в АТД, или лучше сказать — **эта реализация вообще отсутствует**.

В декларативной парадигме АТД, в первую очередь тип данных — множество значений, с которым связано множество *допустимых* над ними операций. Базовы набор декларативных типов перечислялся в одном [первом посте](/2022/02/06/hack_in_declarative_model.html) из этого цикла. 

Мало типов, скажете вы! Да, хотелось бы определять свои. АТД в нашем распоряжении. 

И ещё раз, что такое *абстрактный* тип данных? Это такой тип, который конкретно определен *множеством операций* над собой, и при этом **полностью** независим от своей реализации. Мы можем всегда быстро и легко поменять эту реализацию не трогая сам абстрактный тип.

### Защищаем АТД

Есть такое чувство, что легкая сменяемость чего либо в программировании может привести к проблемам. Чаще всего так и происходит. В разрезе АТД не всегда будет разумным делать реализацию типа для всех. Во-первых, программа с такой открытой реализаций, то есть *открытая программа* потенциально становится легкой мишенью для злоумышленников.

Под "открытой программой" тут мы понимаем не open source софт, речь вообще не об этом. Представьте программу которая запущена в прод, в ней крутится много данных, в том числе персональных данных клиентов, и в этой программе сама реализация абстрактных типов открыта, и например непосредственно доступна для взаимодействия другим программам через API. В таком случае любая другая программа может быть вредительской и "наворошить дел" в нашем рантайме.

Нам нужно защитить *конкретные* реализации абстрактных типов данных от *неавторизованного* вмешательства. Для этого можно ограничить внутреннюю реализацию, часть кода, которая производит вычисления.

Такое ограничение можно внедрить двумя способами:

1. Четко определяем набор операций и их граничные значения так, чтобы вычисляемое значение вообще не могло выходить за эти границы. Сам набор операций становится ограничением, вычисляя только *стационарные значения*.

2. Другой вариант — *мобильные значение*. Вычисленное значение может покидать границы, а затем вернуться обратно. Пока оно "снаружи", с ним может как-то работать внешний код (другая программа, например, или другой модуль нашей системы). Здесь описывается четкий набор операций, которые по разрешению могут выводить значение, обрабатывать его, и возвращать результат назад.

Такое разрешение называется *авторизацией*. Для получения авторизации операция должна предоставить некоторый "ключ" (токен, называйте как хотите). В декларативной модели этот ключ-авторизацию называется просто "имя".

Для реализации второго метода классическая декларативная модель должна быть расширена. Нам надо придумать как защищать значения, и как защищать *несвязанные* (со значением) декларативные переменные.

Например, мы можем определить операции-обертки, с ключем доступа. Доступ к внутреннему функционалу абстрактного типа становится доступным только тем операциям, которые передают в обертку *правильный* ключ. 

Для начала нам надо определить тип для ключей, например Name, который будет хранить атомарное значение. У этого типа нет никаких операций вывода своего значения на экран, или преобразования в число, строку и тд. Всё что должно быть возможно сделать с Name, это только создавать его новые экземпляры, и сравнивать со значениями других экземпляров Name. 

При этом, операция создания нового ключа должна гарантировать, что результирующее значение будет *уникальным*. Мы тут немного отходим от талмудов декларативности, ведь операция создания нового ключа *не декларативна* — вызывая её каждый раз, мы получаем новый результат. Но тут мы применяем этот подход только для внедрения безопасности абстрактных типов, так что это ок, ведь сами АТД остаются декларативными.

Далее, например у нас есть абстрактный тип данных — стек, который внутри фактически реализован как обычный список, но у нас нет прямого доступа к его (стека) содержимому в виде обычного списка.

Мы можем создать экземпляр стека, создать экземпляр ключа, для этого стека, назвав его как нибудь типа stack_key, и наконец — *реализовать функцию обертку* (доступную "снаружи"), которая на вход получает собственно стек, и ключ. Если ключ правильный — работаем. Если нет — чао-какао.

Ну вы поняли — ни Name, ни метод генерации экземпляров Name, ни сравнения с другими Name извне (другим программам) никак не доступен. Мы разделяем таким образом "внутренние" операции и "внешние". 

Очевидно, что такая схема обезопасивания АТД может применяться в коде часто, поэтому отчего бы её тоже не обернуть в другой слой абстракции?
А как? А с помощью АТД! :trollface:

Мы можем описать две функции "упаковки" и "распаковки" — wrap(), unwrap(), и ключи генерировать скрыто в "конструкторе" АТД.

Операция Wrap получает на вход некоторое значение, возвращает *функцию*, которая требует ключа на вызове, чтобы распаковать скрытое в себе значение.

Unwrap же получает эту функцию, передает ей требуемый ключ, и если ключ правильный то возвращает значение в незащищенном виде. 

Например у нас есть:

    some_list = ["h", "e", "l", "l", "y", "e", "a", "h"]
    
Мы делаем скдыщь:

    secure_list = Wrap(some_list)

Теперь обращаясь как-то к secure_list мы не получаем ничего, None, фигушки, пока не сделаем:

    show_me_what_inside = Unwrap(secure_list)

Важно понимать, что ключи к нас генерируются внутри конструкторов, а сами операции упаковки и запаковки *вызываются внутри других операций абстрактных типов данных*, и за границами АТД они никак не доступны!

Например, обычный, незащищенный абстрактный тип "Stack" может быть определен таким набором операций:

- create_stack() – создает новый экземпляр стека (по сути список);
- push_in(some_stack, some_element) – впихивает элемент some_element в стек some_stack;
- pop_out(some_stack) – выпихивает элемент из стека;
- sneak_peek(some_stack) – получить верхний элемент стека, не выталкивая элемент;
- is_empty(some_stack) – true\false проверка на пустоту стека ~~от самобытия~~.


Такая реализация небезопасна, новый стек будет открыт, ведь это по сути список, читайте и делайте с ним что хотите. Мы можем защитить его рассмотренной упаковкой\распаковкой создав тип SecStack, который будет работать так:

- create_stack() – возвращает Wrap([]) – защищенный пустой список, а не просто список;
- push_in(some_stack, some_element) – делает Unwrap(some_stack) вставляет элемент some_element в стек some_stack, делает Wrap() для нового списка;
- pop_out(some_stack) – делает Unwrap(some_stack) удаляет элемент из стека, делает Wrap() для нового списка;
- sneak_peek(some_stack) – Unwrap(some_list) и отдает верхний элемент извлеченного списка, не выталкивая элемент (исходный список все ещё "заврапен", не переживайте о нем, это же декларативная модель!);
- is_empty(some_stack) – Unwrap(some_list), проверяет пуст или не пуст список.

Теперь надеюсь понятнее важный момент о том, что методы wrap\unwrap скрыты внутри реализации стека. Абсолютно нет никакой возможности получить содержимое извне неавторизованным операциям-методам.

### Защищаем несвязанные переменные

Несвязанные со значениями декларативные переменные можно обезопасить, дополнив декларативную модель операцией read_only. Стоп, а зачем нам вообще защищать эти переменные? Ну как, представьте что какое-то злоумышленное существо или программа, написанная таким существом, получила некоторым образом *ссылку* на несвязанную декларативную переменную. Туда можно записать **что угодно**. 

Так вот, делаем read_only переменные. Мы можем определить такую условную операцию, которая получает имя переменной на вход, а возвращает "образ" значений этой переменной, разрешая только читать его.

Реализуется это с помощью дополнительного хранилища. Операция связывания переменных со значением изменяется таким образом, что прежде чем что-то куда-то привязать проверяет, не находится ли ссылка на переменную в read-only хранилище. Если такая ссылка в хранилище есть — связывание не происходит. 


---

Ну, собственно, на этом мы заканчиваем наше скромное знакомство с Декларативной вычислительной моделью. Я завершил текущий курс. Дальше у нас ещё много, ох как много интересного! Функциональное, императивное, проектирование high-load... Продолжаем взрывать мозг, ура!

