---
title: "Про модель OSI и коммутаторы"
tags: "Сети"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-06-13"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/networks_1.png
---

Немного про модель OSI и работу элементарной канальной среды.
<!--more--> 

Всем привет! Я наконец дожил до момента когда начал нормально изучать сети! Конечно у меня был курс по сетям в колледже, и это было самое интересное и толкое что там вообще преподавалось (помимо основ схемотехники). Но признаюсь честно, во-первых, я тогда не очень сильно был заинтересован в учебе (о чем сильно сожалею), во-вторых, пусть в голову нам вдалбывалось знатно — я многое уже успешно забыл.

Последнее время в своей профессиональной практике я всё более остро ощущал нехватку хороших, фундаментальных знаний о сетевых технология. С одной стороны, в принципе базового понимания "как оно там вообще работает", что есть порты, жидкого осознавания основных протоколов в большей части задач в моей текущей работе достаточно (с натяжкой), но когда дело доходит до откровенного ступора, лично мне перед самим собой стыдно бэкать и мэкать. Не стыдно бежать за помощью к коллегам, стыдно испытывать *нехватку компетенции.*

Да, коллеги всегда помогут, но нужно профессионально расти. И ещё один фактор — мне просто до чертиков это интересно, и я рад наконец выделять на это время.

Сегодня я хочу вкратце написать про модель OSI и немного поговорить про коммутаторы и физические адреса устройств.

Кстати, значальное описание OSI в распечатанном виде имеет толщину в один метр. 

{:refdef: style="text-align: center;"}
![Базз](/images/wow.png)
{: refdef}

# OSI

OSI (Open System Intreconnection model) — это эталонная модель стека сетевых протоколов, которая состоит из семи уровней. Можно сказать что эта модель, некоторый "скелет" всех сетевых сущностей. Она определяет протоколы, следуя которым эти самые сетевые сущности между собой взаимодействуют. Протокол же это своеобразный набор правил *интерфейса логического уровня*, которыё определяет каким образом программы должны обмениваться данными между собой. Но сегодня мы говорим не о протоколах. Я недавно писал про [HTTP](/2022/06/01/DNS.html), [FTP](2022/05/31/FTP.html), и [DNS](/2022/06/01/DNS.html).

Передача всегда происходит от уровня к уровню, последовательно подклчая нужные протоколы на каждом из них. 

Всего, как уже было сказано, модель OSI подразумевает семь уровней:

{:refdef: style="text-align: center;"}
![Базз](/images/OSI.jpg)
{: refdef}
*<center>Извините что криво, я правда старался!</center>*

Модель OSI разрабатывалась давненько — в семидесятых годах. Задачей являлась попытка описать архитектуру и как вообще должны работать сети. 

На последнем седьмом уровне передаваемае данные представляются в виде фактических данных, когда на первом — бежит по каналам в бинарном виде. Процесс в котором данные конвертируются из читаемых данных в биты называется знакомым нам из программирования термином *инкапсуляция*. Обратный процесс — *декапсуляция*. На каждом из уровней информация представляется в PDU (Protocol Data Unit), это такие блоки данных.

Все уровни условно делятся на две группы: уровни среды передачи, и уровни хоста. Уровни с 1 по 3 это как раз уровни среды, они занимаются непосредственно передачей информации, тогда как остальные уровни хоста (с 4 по 7) используются непосредственно на наших девайсах (десктопы, лаптопы, смартфоны и тд)

## Физический уровень L1

Уровень отвечает за обмен электрическими или оптическими сигналами по проводам, или радиоволнами безпроводных сетей (Bluetooth, WiGI, GSM и вот это вот всё) между какими то устройствами. Наши компьютеры вообще ничего не знают про то что такое картинки, какая там фотография изображена или новый смешной мемас. Комьютеру мемасы понятны только как наборы нулей и единиц (это грустно). Здесь бит является блоком данных (PDU).

Каждый уровень имеет свои PDU, представляемые образом понятным протоколам того же уровня, иногда и протоколам следующего уровня, например для возможности преобразования. Работа с "чистыми" данными будет производиться только на уровнях с 5 по 7.

## Канальный уровень L2

На этом уровее решается проблема адресации передачи. Канальный уровень инкапсулирует биты в *кадры* (frame). Кадры формируются с адресами отправителя и получателя, а потом отправляются дальше.

Тут есть условно два "подуровня" — это MAC и LLC. Первый служит для "присвоения" физических адресов железок, а второй занимается проверкой и исправлением данных, а так же управляет их передачей.

На втором уровне OSI работают коммутаторы, их задача — передать сформированные кадры от одного устройства к другому, используя в качестве адресов только физические MAC-адреса. Про комммутаторы и MAC адреса мы поговорим в заключительной части.

## Сетевой уровень L3

Здесь вводится маршрутизация. Маршрутизацией занимаются специальный устройва... маршрутизаторы (роутерами). Роутеры получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута между устройствами.

На сетевом уровне есть протокол ARP (Address Resolution Protocol), благодаря которому MAC-адреса некоторым образом преобразуются в 32-битные IP-адреса и наоборот.

## Транспортный уровень L4

Помните мы говорил про уровни среды и уровни хоста? Так вот четвертый уровень это что-то вроде уровня посредника между этими двумя группами. Транспортный уровень регулирует транспортировкой пакетов в сети. Тут работают такие протоколы передачи как TCP и UDP. TCP контролирует целостность передаваемой (доставленной) информации, а UDP — нет. В TCP *устанавливается соединение* пакеты данных делятся на сегменты, успешность и целостность доставки каждого пакета некоторым образом "проверяется". Отправили, подождали подтверждения что все дошло ОК, не дошло - отправили ещё раз. В UDP — отправил куда сказали и забыл, плевать если какая то датаграмма (в этом протоколе пакеты делятся на датаграммы а не на сегменты) потерялась или дошла битой.

Датаграммы UDP отличаются от сегментов TCP тем что у каждой датаграммы есть заголовки в которых указан адрес получателя данных. И сегмент и датаграмма это PDU транспортного уровня.

## Сеансовый уровень L5

Уровень отвечает за поддержку сесси (сенса) связи. Начиная с этого уровнядДанные оперируются в "чистом" виде. Сеансовый уровень управляет тем как разные приложения взаимодействуют между собой, предоставляет возможность синхронизации задач. Всё это нужно для работы следующего уровня.

## Уровень представления данных L6

Уровень "конверитрует" данные, которые всё ещё в виде каких то PDU в представление понятное человеку (и компьютеру). Например тут происходит перевод текста из одной кодировки в другую. Видео и изображения тоже обрабатываются на этом уровне. А ещё, если соединение требует шифрования, в бой оно вступает так же на уровне представления данных.

## Прикладной уровень L7

Это уровень приложений (application level). Это тот уровень с которым взаимодействуют конечные пользователи, типа GUI всей OSI. Короче говоря, задачей протоколов этого уровня является только предоставление возможности пользователю увидеть данные в понятном ему виде (например, HTTP протокол 7 уровня).

# Зачем мне знать OSI, если везде TCP/IP

Модель OSI это стандарт (ISO/IEC 7498). Его просто надо знать, потому что не смотря на запятнаную репутацию и критику модель есть и она всё ещё используется.

Репутация... Ну, модель OSI много и оправданно критикуют. Её слишком долго разрабатывали и её обвиняют в том, что модель *не совсем отображает действительность*. На момент релиза OSI уже широко был распространен стек TCP/IP. Кто знает, если бы с разработкой OSI не затягивали она была бы фактическим, "настоящим" стандартом. Или если бы модель не проектировали в сверхсекретном "закрытом" режиме, тогда как стек TCP/IP изначально была *открыт*, она была бы принята с более распростертыми руками.  

Ещё OSI критикуют из за того что функции уровней распределены между ними неравнозначно, и что вообще одинаковые задачи могут быть решены на *разных уровнях*. В общем ругают за то что уровней вообще слишком много, сеть можно построить используя только первые 4.

—-

# Коммутируй то! Коммутируй это!

Я обещал чуть больше рассмотреть канальный уровень. Приступаем!

## Зачем в сетях нужны коммутаторы?

Современные сети построенны на канальном уровне с использованием коммутаторов, которые связывают разные компьютеры между собой. Грубо говоря коммутаторы нужны не только чтобы просто соединить машины, но в первую очередь — чтобы избежать коллизиий, присущих такой устаревшей сетевой топологии как "шина", в которой как раз таки все машины связывали в тупую одним каналом.

Так вот, шина — это когда все компьютеры в сети подключены к одному "кабелю", а коллизия это такой "цифровой" хаос в сети, когда одновременно пытаются общаться больше двух машин по одному каналу. Например коллизия может возникнуть в шине когда в сети есть сервер и N компьютеров, и одновременно два (или больше) клиента попробуют обратиться к одному и тому же серверу.

## Устройство коммутатора 

У сетевого коммутатора (свитча) есть условно два буфера: входящий и исходящий. На самом деле буфер логически делится на буферы портов.

Когда в сети с коммутатором один из компьютеров отправляет данные другому, эти данные сначала попадают во входящий буфер свитча (коммутатора) по одному из портов. После этого свитч решает на какой иной порт (куда) эти данные нужно перенаправить (используя MAC таблицу, про MAC будет дальше), а точнее *на **исходящий** буфер какого порта их нужно перенаправить*.

После этого коммутатор ждет когда целевой канал освободится, ведь с сервером могут общаться другие участники сети по этому же каналу. Когда это происходит данные из соответствующего буфера свитча отправляются на сервер. В одном таком исходящем буфере могут спокойно ждать своей очереди исходящие данные от двух и более участников сети (которые хотят достучаться на один и тот же сервер). 

Именно благодаря описанному выше механизму (очереди в буфере) коллизий в сети не происходит. 

В старые (но не очень) времена существовали так называемые концентраторы (хабы). Отличались они от свитчей тем что у них не было буферов. Такое устройство по сути являлось всего лишь  электрическим повторителем, и никак не уберегало сеть от возникновения коллизий. 

## Домен коллизии

Домен коллизии — это участок сети на котором есть *возможность* возникновения коллизии. Очевидно что в случае с топологией шина домен коллизии распространяется условно на всю сеть, но в случае применения коммутаторов он ограничен участком сети от *конечного узла до самого коммутатора*. 

На этом участке коллизия может возникнуть если узел и коммутатор будут работать в *полудуплексном* (half-duplex) режиме.

Дуплекс — это, собственно такой сопосб связи двух устройств которые могут связываться друг с другом в оба направления. Когда *симплекс* — связываться только в одном направлении. Устройство которое реализует в себе полный дуплекс способно передавать или принимать данные в любой момент времени, а вот полудуплекс не может одновременно. Полудуплекс это когда в один момент времени устройство может только передавать или получать данные. 

Коллизии при half-duplex в участках до коммутара возникают, когда передатчик коммутатора и сетевой карты узла начинают одновременно или почти одновременно передавать данные в разных режимах (прием/передача), считая что участок сети между ними свободен. 


---

На сегодня это всё. На самом деле в отдельности каждую из тем можно долго-долго рассматривать. Если вы настолько жадны до сетей, то... Почитайте Таненбаума, например!

