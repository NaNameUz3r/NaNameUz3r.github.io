---
title: "Про модель OSI и коммутаторы"
tags: "Сети"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-06-19"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/networks_1.png
---

Немного про модель OSI и работу элементарной канальной среды.
<!--more--> 

Всем привет! Я наконец дожил до момента когда начал нормально изучать сети! Конечно у меня был курс по сетям в колледже, и это было самое интересное и толкое их того что там вообще преподавалось (помимо основ схемотехники). Но признаюсь честно, во-первых, я тогда не очень сильно был заинтересован в учебе (о чем сильно сожалею), во-вторых, пусть в голову нам вдалбывалось знатно — я многое уже успешно забыл.

Последнее время в своей профессиональной практике я всё более остро ощущал нехватку хороших, фундаментальных знаний о сетевых технология. С одной стороны, в принципе базового понимания "как оно там вообще работает", (ну то что есть порты и тд :) жидкого знания основных протоколов в большей части задач вроде бы как достаточно, но когда дело доходит до откровенного ступора — лично мне перед самим собой стыдно бэкать и мэкать. Не стыдно бежать за помощью к коллегам, стыдно испытывать *нехватку компетенции.*

Да, коллеги всегда помогут, но нужно же профессионально расти! И ещё один немаложваный фактор — мне до чертиков эта тема интересна!

Сегодня я хочу вкратце написать про модель OSI и немного поговорить про коммутаторы и физические адреса устройств.

Кстати, значальное описание OSI в распечатанном виде имеет толщину в один метр. 

Поехали!

{:refdef: style="text-align: center;"}
![Эмодзи шокового удивления](/images/wow.png)
{: refdef}

# OSI

OSI (Open System Intreconnection model) — это эталонная модель стека сетевых протоколов которая состоит из семи *логических* уровней. Можно сказать что эта модель своего рода "скелет" всех сетевых сущностей. Она определяет протоколы следуя которым эти самые сущности между собой как-то взаимодействуют. Протокол — это "набор правил" *интерфейса логического уровня*, которыё определяют каким образом программы должны обмениваться данными между собой. Но сегодня мы говорим не о протоколах. Я недавно писал про [HTTP](/2022/06/01/DNS.html), [FTP](2022/05/31/FTP.html), и [DNS](/2022/06/01/DNS.html).

Передача всегда происходит от уровня к уровню, последовательно подключая нужные протоколы на каждом из них. 

Как уже было сказанно модель OSI делится на семь уровней:

{:refdef: style="text-align: center;"}
![Схема модели OSI](/images/OSI.jpg)
{: refdef}
*<center>Извините что криво, я правда старался!</center>*

Модель OSI разрабатывалась давненько — в семидесятых годах. Задачей была попытка описать архитектуру и как вообще должны работать сети. 

На последнем седьмом уровне передаваемые данные представляются в виде фактических данных (то как мы их воспринимаем), а на первом — бежит по каналам в бинарном виде. 

Процесс в котором данные от уровня к уровню конвертируются из читаемых данных в биты называется знакомым нам из программирования словом *инкапсуляция*. Обратный процесс — *декапсуляция*. На каждом из уровней информация представляется в виде так называемых PDU (Protocol Data Unit), это такие блоки данных.

Все уровни условно делятся на две группы: уровни среды передачи, и уровни хоста. Уровни с 1 по 3 это уровни среды передачи. Они занимаются непосредственно передачей информации, тогда как остальные уровни хоста (с 4 по 7) используются непосредственно на наших девайсах (десктопы, лаптопы, смартфоны и тд).

## Физический уровень L1

Уровень отвечает за обмен электрическими или оптическими сигналами по проводам, или радиоволнами по беспроводным сетям (Bluetooth, WiGI, GSM и вот это вот всё) между устройствами. Наши компьютеры вообще ничего не знают про то что такое картинки, какая там фотография изображена, что на нашем смешном мемасике. Компьютеру мемасы понятны только как наборы нулей и единиц (это грустно, я бы поговорил с железякой). Здесь *бит* является блоком данных (PDU).

Каждый уровень по сути имеет свои PDU, представляемые образом понятным протоколам этого уровня. А иногда и протоколам следующего уровня (например для возможности преобразования). 

Работа с "чистыми" данными будет производиться только на уровнях с 5 по 7.

## Канальный уровень L2

На этом уровее решается проблема *адресации* передачи. Канальный уровень инкапсулирует биты в *кадры* (frame). Кадры формируются с адресами отправителя и получателя, а потом отправляются дальше.

Тут есть условно два "подуровня" — это MAC и LLC. Первый служит для "присвоения" физических адресов железок, а второй занимается проверкой и исправлением данных, а так же управляет их передачей.

На втором уровне OSI работают коммутаторы (сетевая железяка), их задачей является передача сформированныех кадров от одного устройства к другому используя в качестве адресов только физические MAC-адреса. Про комммутаторы и MAC адреса мы поговорим в заключительной части.

## Сетевой уровень L3

Здесь вводится понятие маршрутизации. Маршрутизацией занимаются специальные железяки... маршрутизаторы (роутеры). Роутеры получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута между устройствами.

На сетевом уровне есть протокол ARP (Address Resolution Protocol), благодаря которому MAC-адреса определенным образом преобразуются в 32-битные IP-адреса и наоборот.

Единица данных (PDU) передаваемая с использованием маршрутизации уже называется не кадр а *пакет*.

## Транспортный уровень L4

Помните мы говорил про уровни среды и уровни хоста? Так вот четвертый уровень это что-то вроде уровня посредника между этими двумя группами. Транспортный уровень управляет передачей пакетов в сети, определяет каким приложениям на уровнях выше предназначаются данные (использование портов). Тут работают такие протоколы как TCP и UDP. TCP контролирует целостность передаваемой (доставленной) информации, а UDP — нет. В TCP *устанавливается соединение* пакеты данных делятся на сегменты, успешность и целостность доставки каждого пакета некоторым образом "проверяется". Отправили, подождали подтверждения что все дошло ОК, не дошло - отправили ещё раз. В UDP — отправил куда сказали и забыл, плевать если какая то датаграмма (в этом протоколе пакеты делятся на датаграммы а не на сегменты) потерялась или дошла битой. Чуть подробнее про эти протоколы мы поговорим в следующий раз.

И *сегмент* и *датаграмма* это PDU транспортного уровня.

## Сеансовый уровень L5

Уровень отвечает за поддержку сессии (сенса) связи. Начиная с этого уровня данные оперируются в "чистом" виде. Сеансовый уровень управляет тем как разные приложения взаимодействуют между собой, предоставляет возможность синхронизации задач. Всё это нужно для работы следующего уровня.

## Уровень представления данных L6

Уровень "конверитрует" данные, которые всё ещё в виде каких то PDU в представление понятное человеку (и компьютеру). Например тут происходит перевод текста из одной кодировки в другую. Видео и изображения тоже обрабатываются на этом уровне. А ещё, если соединение требует шифрования, в бой оно вступает так же на уровне представления данных.

## Прикладной уровень L7

Это уровень приложений (application level). Это тот уровень с которым взаимодействуют конечные пользователи. Короче говоря, задачей протоколов этого уровня является только предоставление возможности пользователю увидеть данные в понятном ему форме (например, HTTP протокол 7 уровня).

# Зачем мне знать OSI, если везде TCP/IP

Модель OSI это стандарт (ISO/IEC 7498). Его просто надо знать, потому что не смотря на запятнаную репутацию и критику модель есть и она всё ещё используется.

Репутация... Ну, модель OSI много и оправданно критикуют. Её слишком долго разрабатывали и её обвиняют в том, что модель *не совсем отображает действительность*. На момент релиза OSI уже широко был распространен стек TCP/IP. Кто знает, если бы с разработкой OSI не затягивали она была бы фактическим, "настоящим" стандартом. Или если бы модель не проектировали в сверхсекретном "закрытом" режиме, тогда как стек TCP/IP изначально была *открыт*, она была бы принята с более распростертыми руками.  

Ещё OSI критикуют из за того что функции уровней распределены между ними неравнозначно, и что вообще одинаковые задачи могут быть решены на *разных уровнях*. В общем ругают за то что уровней вообще слишком много, сеть можно построить используя только первые 4.

—-

# Коммутируй то! Коммутируй это!

Я обещал чуть больше рассмотреть канальный уровень. Приступаем!

## Зачем в сетях нужны коммутаторы?

Современные сети построенны на канальном уровне с использованием коммутаторов, которые связывают разные компьютеры между собой. Грубо говоря коммутаторы нужны не только чтобы просто соединить машины, но в первую очередь — чтобы избежать коллизиий присущих такой устаревшей сетевой топологии как "шина", в которой как раз таки все машины связывали в тупую одним каналом.

Так вот, шина — это когда все компьютеры в сети, грубо говоря, подключены к одному "кабелю", а коллизия это такой "цифровой" хаос в сети, когда одновременно пытаются общаться больше двух машин по одному каналу. Например коллизия может возникнуть в шине когда в сети есть сервер и N компьютеров, и одновременно два (или больше) клиента попробуют обратиться к одному и тому же серверу.

## Устройство коммутатора 

У сетевого коммутатора (свитча) есть условно два буфера: входящий и исходящий. На самом деле буферы логически делятся на буферы портов.

Когда в сети с коммутатором один из компьютеров отправляет данные другому, эти данные сначала попадают во входящий буфер свитча (коммутатора) по одному из портов. После этого свитч решает на какой иной порт (куда) эти данные нужно перенаправить (используя MAC таблицу, про MAC будет дальше), а точнее *на **исходящий** буфер какого порта их нужно перенаправить*.

После этого коммутатор ждет когда целевой канал освободится, ведь с сервером могут общаться другие участники сети нему же. Когда это происходит данные из соответствующего буфера свитча отправляются целевому получателю. В одном таком исходящем буфере могут спокойно ждать своей очереди данные от двух и более участников сети (которые хотят достучаться на один и тот же сервер например). 

Именно благодаря описанному выше механизму (очереди в буфере) коллизий в сети не происходит. 

В старые (но не очень) времена существовали так называемые концентраторы (хабы). Отличались они от свитчей тем что у них не было буферов. Такое устройство по сути являлось всего лишь электрическим повторителем, и никак не уберегало сеть от возникновения коллизий. Вроде бы как устройство, вроде бы как компьютеры к нему подключаются физически разными кабелями, но топология по сути получается "шина".

## Домен коллизии

Домен коллизии — это участок сети на котором есть *возможность* возникновения коллизии. Очевидно что в случае с шиной домен коллизии распространяется на всю канальную среду, но в случае применения коммутаторов домен коллизии ограничен участком сети от *конечного узла до коммутатора*. 

На этом участке коллизия может возникнуть если узел и коммутатор будут работать в *полудуплексном* (half-duplex) режиме.

Дуплекс — это такой сопособ связи двух устройств которые могут общаться друг с другом в оба направления. Когда *симплекс* — только в одном направлении. Устройство которое реализует в себе полный дуплекс способно передавать или принимать данные в любой момент времени, а вот полудуплекс не может делать это одновременно. *Полудуплекс* это когда в один момент времени устройство может только передавать или получать данные. 

Коллизии при half-duplex в участках до коммутара возникают в случае когда передатчик коммутатора и сетевой карты узла начинают одновременно (или почти одновременно) передавать данные в разных режимах (прием/передача), считая что участок сети между ними свободен. 

# Канальная среда, кадры и MAC адреса
 
Мы сегодня уже использовали термин **кадр**.

Кадром в сети принято называть *единицу информации*, которая передается в пределах одной канальной среды.  

*Канальная среда* — это небольшой участок локальной сети, устройства в котором объединены одним свичом (или несколькими). В такой сети *нет роутера*, и еще её называют *одним широковещательным доменом*. 

В пределах одной канальной среды адресация между узлами происходит в первую очередь по *MAC адресам*, а не по IP. IP здесь работает, но лишь *косвенно*. 

Конечно же узлы в такой сети имеют свои IP адреса, но получатели кадров в ней определяются по MAC адресам. 

Это работает благодаря протоколу **ARP** ([RFC 826](https://datatracker.ietf.org/doc/html/rfc826)), который служит для сопоставления айпишников и физических адресов устройств (MAC).

Работа протокола организована посредством ведения так называемых ARP-таблиц, которые хранятся в памяти операционных систем на компьютерах. Устройство, которое собирается отправить данные по какому то IP адресу сперва проверяет свою ARP-таблицу на предмет наличия в ней MAC адреса. Если адрес есть — отправляем по нему. Если адреса нет — узел формирует ARP запрос в виде кадра и рассылает его *широковещательно* (по всей канальной среде). Следовательно, все узлы получают этот запрос, сравнивают в нем IP со своим, и если выявляется соответствие — узел получатель отправлет ответный ARP кадр на адрес отправителя запроса, в котором записан IP и соответствующий MAC. 

MAC адреса есть у каждого устройства и вшиваются в постоянную память производителями этих устройств. Они состоят из двух частей по 24 бита каждая:
- Уникальный идентификатор OUI, который выдается [IEEE](https://www.ieee.org/)
- Часть которую назначает сам производитель

    Кстати, MAC адрес можно легко изменить\подменить, потому что из постоянного энергонезависимого источника при загрузке ОС он записываться в *оперативную память*.

Уникальный MAC каждого устройства называется *Unicast* адресом, но есть еще *широковещательный* (broadcast) адрес который одинаково выглядит во всех операционных системах: FF-FF-FF-FF-FF-FF.

Широковещательный адрес позволяет разослать кадр сразу всем участникам канальной среды ("размножается" на свитче).

*Многоадресные* (Multicast) MAC адреса отличаются от широковещатльных тем, что по мультикасту идет рассылка кадров по определенной группе узлов, у которых установленны соответствующие мультикаст-адреса.

## Unicast Flooding

У свичей есть специальная таблица MAC адресов, в которой они хранят соответствия своих каналов (портов) с MAC адресами устройств работающих за этим портом. Изначально, когда мы только включаем коммутатор его таблица как правило пуста. Она наполняется следующим образом.

Когда какой-то из компьютеров в канальной среде отправляет другому данные они сперва попадают на свитч. Свитч видит MAC адрес получателя, записывает в свою таблицу адрес *отправителя* в строку таблицы порта, по которому он получил данные. Но в этот момент коммутатор не знает *куда* перенаправлять (в буфер какого порта) кадр дальше.

Поэтому он рассылает этот кадр по всем *остальным* портам! Затем коммутатор смотрит с какой стороны пришел ответ и снова записывает MAC адрес в соотвутствующую строку порта. Таким нехитрым образом свич заполняет свою таблицу.

Процесс наполнения таблицы называется *unicast flooding.*

---

На сегодня это всё. На самом деле в отдельности каждую из тем можно долго-долго рассматривать. Если вы настолько жадны до сетей, то... Почитайте Таненбаума, например!

[Читать следующий пост про маршрутизацию и заголовки протоколов L1-L3](/2022/06/19/TCP_UDP_and_something_else.html)