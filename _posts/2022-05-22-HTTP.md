---
title: "HTTP протокол"
tags: "Сеть"
lang: ru
show_edit_on_github: false
comment: true
license: false
modify_date: "2022-05-22"
show_subscribe: false
article_header:
  theme: dark
  type: overlay
  align: left
  background_image:
    src: /header_images/http.jpg
---

Небольшой разбор повсеместно используемого протокола.

<!--more--> 

## Интро

Всем привет! В далекой далекой галлактике однажды гумноиды придумали компьютеры, а потом придумали их вместе связывать. Задачка была не из легких, и много подумав гуманоиды разработали спецификацию — концептуальную сетевую модель, или стандарт, посредством которого компьютеры общаются между собой (к этой истории мы вернемся в другой раз).

А потом подумали ещё, поняли что слишком много выдумали, и отразили идеи в более прикладном и жизнеспособном виде. 

Модели OSI и TCP/IP не являются темой этого поста. Сегодня я предлагаю разобрать нечто с их "дальнего конца", наиболее близкого к нам — один из протоколов прикладного уровня, а именно HTTP.

## В начале был текст

А потом появился *Гипертекст*. В нашей тусовке этим термином назвали текст размеченный с помощью собственно HTML.

За аббревиатурой HTML стоит —  HyperText Markup Language, переводить надеюсь не надо :)

Все замечательные (и не очень) странички которые вы видите в своих браузерах серфя интернет размечены HTML. Но понятно что соверменные системы не ограничиваются обменом текстовыми документами, за всем этим стоит какой то бекенд, логика, и прочие прелести.

Как происходит обмен данными между вашим компьютером, и другим, далеким-далеким сервером? 

С помощью протокола HTTP!

Изначально задачей протокола являлось как раз получение текстовых страничек, но времена меняются, с 1990 года воды утекло много и сейчас по HTTP можно передавать практически всё, вплоть до потокового видео и аудио.

### Чего там внутри-то

Клиент-серверная архитектура, это такая "модель" взаимодествия вычислительных систем, в которой задачи распределяются некоторым образом между клиентам и серверами. Клиенты — это, например, опять-же ваш браузер или приложенька, а сервер — это некоторая сущность которая выполняет хотелки клиента.

Почему я говорю сущность? Потому что клиент и сервер это не какие то особенные железяки, а просто *софт* работающий друг с другом по сети. И общий язык этот софт находит как раз благодаря спецификациям сетевых протоколов.

В HTTP всё крутится вокруг *запросов* и *ответов*. Это предельно просто. Клиент Вася попросил (сделал запрос) Сервер Петю почистить картошку, на что от Пети следует какая-то реакция, в зависимости от обстоятельств.

Реакция Пети — это ответ. И их с Васей вазимодействие регламентировано протоколом (на самом деле не одним).

Сеть устроена сложно, и между Петей и Васей может, и обычно присутствует, множество роутеров, прокси-серверов, и прочей чертовщины о которой мы будем говорить позже.

Это кстати небольшой спойлер! Я скоро начну достаточно плотно изучать сети, и обо всем буду писать в блог!
{:.info}

### Хочу банан!

Целью любого запроса всегда является какой-то *ресурс*. Как мы уже выяснили выше, по HTTP может передаваться что угодно. Более умным языком это можно выразить как то, что протокол HTTP никак не ограничивает *ресурсы* которые могут запрашиваться и передаваться, а лишь определяет *интерфейс* для взаимодействия с ресурсами.

Каждый ресурс, хотелка клиента, должна иметь какой-то идентификатор. Этим идентификатором является *URI* — Uniform Resource Identifier. URI — это по сути символьная строка. Здесь тоже есть много интересных (или не очень) подробностей, но по сути URI это всем нам привычный URL (Uniform Resource Locator) — то что часто называют "ссылкой", и представяется в браузере в адресной строке как как-то последовательность разделенная слэшами.

Ну, короче, это адрес ресурса!

### Структура сообщений

Начнем с запросов.

В структуру запросов входят следующие метаданные:

- HTTP-метод: этот элемент декларирует хотелку клиента. Есть несколько методов запроса, но чаще всего клиент хочет либо что-то получить **GET**, либо передать какие-то значения — **POST**;
- Адрес ресурса: URL, который мы уже разобрали;
- Версия протокола;
- Заголовки (Headrs): могут быть, а могут не быть. ~~Вот в чем вопрос.~~ Задача заголовка — передать дополнительную информацию серверу, которая может ему понадобиться для корректной обработки запроса;
- Тело запроса: это нужно в первую очередь для POST запрсов, чтобы передать то, что клиент собственно хочет передать.

Ответы же состоят из:
- Версии протокола;
- Кода состояния: есть список кодов, которые говорят об успешности или не успешности операции, и могут подсказать или достаточно четко дать понять что пошло не так. Например знакомый 404 — ресурс не найден, или 200 — который вы никогда не замечаете, потому что 200 это ОК.

## Краткий обзор отличий версий

В 2015 году на смену HTTP/1.1 пришел HTTP/2 который родился как результат обмозговывания путей оптимизации скорости обработки запросов, в первую очередь при работе с мобильными клиентами и аудио\видео форматами.

Основным отличием является то, что HTTP/1.1 сообщения передает втупую плейнтекстом, тогда как HTTP/2 кодирует их в двоичный формат, благодаря чему открывается возможность использовать другую модель доставки сообщений. Семантика "внутри" осталась прежней.

Для чего кодировать в двоичный формат? Это позволяет разбить сообщения на более мелкие пакеты, которые ещё называют кадрами. А ещё это позволяет использовать *одно* TCP соединение, вместо нескольких.

Несколько соединений HTTP/1.1 приходится устанавливать для того чтобы обходить блокировку HOL. 

Блокировка Head-of-line — это такая фигня, когда очередь из пакетов задерживается первым поступающим пакетом. Так получается когда несколько запросов оправляются на один и тот же ресурс. Пакеты просто не могут проходить друг через друга.

Ну вот, а в HTTP/2 есть один поток, и сами сообщения закодированны. Каждый кадр имеет идентификацию принадлежности к пакету, поэтому ничего не путается. Сервер у себя спокойно принимает сообщения, собирает их обратно. И хотя устанавливается одно TCP соединения, сообщения могут спокойно долетать до сервера параллельно друг другу. 

А ещё HTTP/2 сжимает заголовки. Сами данные, можно сжимать и в HTTP/1.1, но не заголовки. И хотя заголовок очень мал, но если клиент или клиенты шлют огромное кол-во запросов — это может стать проблемой. Как видим, HTTP/2 решает её довольно изящно.

Другие отличия HTTP/2 потребуют углубиться в сетевую модель, вернемся к этому может быть в другой раз :)

### Что там про поток?

Клиент-серверное взаимодествие выглядит как-то так:

1. Открываем TCP соединение. Одно или несколько. Разумеется, уже открытое соединение может использоваться и переиспользоваться далее, не нужно открывать новое соединение для каждого запроса. 
2. Отправляем сообщение (или сообщения).
3. Читаем ответ сервера.
4. Закрываем соединение или используем его снова.

Ну, тут собственно больше говорить не о чем :)

## Ещё немного

### Печеньки!
Можно устанавливать *сессии*. Это достигается путем использования кукисов! Зачем нужны куки?

Прикол в том, что HTTP — это протокол *без состояния*. Это значит что каждый запрос независим, никак не связан с предыдущим. Мы это уже хорошо рассмотрели — всё общение построенно на парах запрос-ответ. 

Но ведь... Состояния нужны! Мы не хотим каждый раз логиниться, и не хотим чтобы при обновлении страницы пропала вся наша бережно скирдованная корзина товаров в интернет магазине :)
 
Тут и выходят на сцену печеньки-кукисы. 

Куки — это такой хитрый фрагмент данных, который сервер отправляет клиенту, и клиент у себя его сохраняет. Потом клиент эту куку шлет серверу в составе других HTTP запросов. Так Петя понимает, что хочет Вася, а что хочет Саша, и что Вася есть Вася, а не Катя. 

Хотя мне очень хочется тут распылиться на тему безопасности, но скажу лишь то, что куку легко украсть и подменить, если поток данных между клиентом и сервером не зашифрован. TLS — отдельная тема к которой мы *обязательно* вернемся в другой раз.
{:.info}

### Аутентификация

HTTP может без всяких других штук предоставлять средства базовой аутентификации, но это не очень безопасно, и обычно специальные сессии устанавливаются с помощью куки.

### Кеш!

Сервер может с помощью специальных заголовков заставлять промежуточные прокси сервера кешировать какие-то данные, и как долго их надо сохранять.
Клиент в свою очередь может схожим образом "просить" прокси игнорировать кеш, и передавать запрос на требуемые ресурсы далее.

## Резюме

Мы завершаем краткий обзор протокола HTTP. Краткий, потому что там есть *много чего ещё*: можно очень долго перечислять все коды ответов, углубиться в то, как происходит сжатие, кеширование. Что такое REST, какие используются кодировк и так далее.

Если вам интересно умудриться то первымы местами, куда стоит обратиться, это RFC документы, в частности под номером **7231** и MDN доку.






